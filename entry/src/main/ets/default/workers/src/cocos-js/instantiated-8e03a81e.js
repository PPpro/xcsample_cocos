System.register([], function (exports, module) {
    'use strict';
    return {
        execute: function () {

            exports({
                A: void 0,
                B: void 0,
                C: void 0,
                E: void 0,
                F: void 0,
                H: void 0,
                I: void 0,
                J: void 0,
                K: void 0,
                L: void 0,
                M: void 0,
                N: void 0,
                O: void 0,
                Q: void 0,
                U: void 0,
                V: void 0,
                W: void 0,
                X: void 0,
                Y: void 0,
                aN: void 0,
                aR: IsPowerOf2,
                aS: FormatSize,
                aT: FormatSurfaceSize,
                aU: GetTypeSize,
                aV: getTypedArrayConstructor,
                b: void 0,
                b$: find,
                bC: Enum,
                bE: _applyDecoratedDescriptor,
                bG: type,
                bS: _initializerDefineProperty,
                bT: assertIsTrue,
                bU: void 0,
                bW: formerlySerializedAs,
                bX: readBuffer,
                bZ: writeBuffer,
                bf: isPropertyPath,
                bg: isCustomPath,
                bo: errorID,
                bp: debug,
                bq: error,
                br: nextPow2,
                bt: void 0,
                bu: void 0,
                by: warnID,
                bz: warn,
                c: void 0,
                c0: mapBuffer,
                c6: void 0,
                c7: clamp01,
                cB: toRadian,
                cG: getWorldTransformUntilRoot,
                cJ: void 0,
                cL: deleteTransform,
                cM: getTransform,
                cN: getWorldMatrix,
                cO: void 0,
                cY: void 0,
                cZ: void 0,
                cc: fastRemoveAt,
                cf: clamp,
                cg: void 0,
                ch: void 0,
                cj: logID,
                cr: void 0,
                cs: void 0,
                cw: property,
                d$: _getClassId,
                d0: toDegree,
                d4: lerp,
                d5: constructLegacyCurveAndConvert,
                d7: void 0,
                d8: repeat,
                dA: absMaxComponent,
                dB: absMax,
                dF: ccenum,
                dR: isValid,
                dT: void 0,
                d_: createMap,
                db: pseudoRandom,
                dd: randomRange,
                de: randomRangeInt,
                df: sign,
                dh: pingPong,
                dm: instantiate,
                dn: cylinder,
                dp: applyDefaultGeometryOptions,
                dq: box,
                dr: plane$1,
                ds: capsule$1,
                dv: void 0,
                dw: void 0,
                dx: void 0,
                dz: absolute,
                e$: v2,
                e1: extname,
                e2: mixin,
                e4: void 0,
                eB: void 0,
                eH: createCommonjsModule,
                eJ: unwrapExports,
                eK: remove,
                eL: Eventify,
                eO: degreesToRadians,
                eP: radiansToDegrees,
                eQ: getError,
                eT: changeBasename,
                ef: void 0,
                eh: clampf,
                ei: addon,
                el: void 0,
                en: void 0,
                ep: void 0,
                eu: contains$1,
                ew: void 0,
                f: void 0,
                f0: v3,
                f1: v4,
                f2: quat,
                f4: mat4,
                f6: size,
                f7: rect,
                f8: color,
                fJ: log,
                fK: assert,
                fL: assertID,
                fM: isDisplayStats,
                fN: setDisplayStats,
                fO: void 0,
                fW: createDefaultPipeline,
                fa: equals,
                fb: approx,
                fc: pseudoRandomRange,
                fd: pseudoRandomRangeInt,
                fe: nextPow2$1,
                ff: inverseLerp,
                fg: enumerableProps,
                fj: BitMask,
                fp: setDefaultLogTimes,
                fq: WorldNode3DToLocalNodeUI,
                fr: WorldNode3DToWorldNodeUI,
                ft: CCClass,
                fu: deserialize,
                fw: getSerializationMetadata,
                g: void 0,
                gA: void 0,
                gB: void 0,
                gC: void 0,
                gE: void 0,
                gn: isPropertyModifier,
                go: isElementModifier,
                gp: isCustomTargetModifier,
                gr: bezier,
                gs: bezierByTime,
                gw: sampleAnimationCurve,
                gx: computeRatioByType,
                gz: getPathFromRoot,
                h: void 0,
                h4: void 0,
                hg: waitForAmmoInstantiation,
                i: void 0,
                j: void 0,
                k: void 0,
                l: void 0,
                m: murmurhash2_32_gc,
                n: void 0,
                o: void 0,
                p: void 0,
                q: void 0,
                r: void 0,
                s: void 0,
                t: void 0,
                u: void 0,
                v: void 0,
                w: void 0,
                x: void 0,
                y: void 0,
                z: void 0
            });

            const WECHAT = exports('bv', false);
            const ALIPAY = false;
            const BAIDU = false;
            const XIAOMI = false;
            const BYTEDANCE = false;
            const OPPO = false;
            const VIVO = false;
            const HUAWEI = false;
            const NATIVE = true;
            const COCOSPLAY = false;
            const EDITOR = exports('bx', false);
            const PREVIEW = false;
            const BUILD = true;
            const TEST = false;
            const DEBUG = true;
            const UI_GPU_DRIVEN = false;
            const DEV = false;
            const RUNTIME_BASED = exports('ez', false);
            const MINIGAME = exports('ex', false);
            const JSB = exports('ey', true);
            const SUPPORT_JIT = true;

            const _global = typeof window === 'undefined' ? global : window;

            const legacyCC = exports('bA', {
              _global
            });
            legacyCC.internal = {};

            {
              _global.CC_BUILD = BUILD;
              _global.CC_TEST = TEST;
              _global.CC_EDITOR = EDITOR;
              _global.CC_PREVIEW = PREVIEW;
              _global.CC_DEV = DEV;
              _global.CC_DEBUG = DEBUG;
              _global.CC_JSB = JSB;
              _global.CC_BYTEDANCE = BYTEDANCE;
              _global.CC_WECHAT = WECHAT;
              _global.CC_ALIPAY = ALIPAY;
              _global.CC_XIAOMI = XIAOMI;
              _global.CC_BAIDU = BAIDU;
              _global.CC_COCOSPLAY = COCOSPLAY;
              _global.CC_HUAWEI = HUAWEI;
              _global.CC_OPPO = OPPO;
              _global.CC_VIVO = VIVO;
              _global.CC_MINIGAME = MINIGAME;
              _global.CC_RUNTIME_BASED = RUNTIME_BASED;
              _global.CC_SUPPORT_JIT = SUPPORT_JIT;
              _global.CC_UI_GPU_DRIVEN = UI_GPU_DRIVEN;
            }

            const engineVersion = exports('cp', '3.5.0');
            _global.CocosEngine = legacyCC.ENGINE_VERSION = engineVersion;
            _global.cc = legacyCC;

            var debugInfos = {
            	"1100": "Expected 'data' dict, but not found. Config file: %s",
            	"1101": "Please load the resource first : %s",
            	"1200": "cocos2d: Director: Error in gettimeofday",
            	"1204": "Running scene should not be null",
            	"1205": "The scene should not be null",
            	"1206": "loadScene: The scene index to load (%s) is out of range.",
            	"1207": "loadScene: Unknown name type to load: '%s'",
            	"1208": "loadScene: Failed to load scene '%s' because '%s' is already being loaded.",
            	"1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
            	"1210": "Failed to preload '%s', %s",
            	"1211": "loadScene: The scene index to load (%s) is out of range.",
            	"1212": "loadScene: Unknown name type to load: '%s'",
            	"1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
            	"1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
            	"1215": "Failed to preload '%s', %s",
            	"1216": "Director.runSceneImmediate: scene is not valid",
            	"1217": "Director._initOnEngineInitialized: renderer root initialization failed",
            	"1218": "Forward render pipeline initialized.",
            	"1219": "Deferred render pipeline initialized. Note that non-transparent materials with no lighting will not be rendered, such as builtin-unlit.",
            	"1220": "Failed to set shading scale, pipelineSceneData is invalid.",
            	"1221": "Setting orientation is not supported yet.",
            	"1300": "%s is not in the model pool and cannot be destroyed by destroyModel.",
            	"1400": "'%s' is deprecated, please use '%s' instead.",
            	"1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
            	"1406": "'%s.%s' is removed",
            	"1408": "'%s' is removed",
            	"1409": "element type is wrong!",
            	"1502": "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
            	"1503": "cc.Scheduler.pauseTarget():target should be non-null",
            	"1504": "cc.Scheduler.resumeTarget():target should be non-null",
            	"1505": "cc.Scheduler.isTargetPaused():target should be non-null",
            	"1506": "warning: you CANNOT change update priority in scheduled function",
            	"1507": "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
            	"1508": "Argument callback must not be empty",
            	"1509": "Argument target must be non-nullptr",
            	"1510": "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
            	"1511": "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
            	"1513": "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
            	"1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
            	"1619": "callback function must be non-null",
            	"1620": "interval must be positive",
            	"1623": "Set '%s' to normal node (not persist root node).",
            	"1624": "Replacing with the same sgNode",
            	"1625": "The replacement sgNode should not contain any child.",
            	"1626": "Should not set alpha via 'color', set 'opacity' please.",
            	"1627": "Not support for asynchronous creating node in SG",
            	"1632": "Node name can not include '/'.",
            	"1633": "Internal error, should not remove unknown node from parent.",
            	"1635": "reorderChild: this child is not in children list.",
            	"1636": "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
            	"1637": "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
            	"1638": "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
            	"1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
            	"1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
            	"1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
            	"1803": "cc._EventListenerAcceleration.checkAvailable():_onAccelerationEvent must be non-nil",
            	"1900": "Invalid parameter.",
            	"2104": "Layer collision. The name of layer (%s) is collided with the name or value of some layer",
            	"2200": "Design resolution not valid",
            	"2201": "should set resolutionPolicy",
            	"2300": "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
            	"2402": "Forward pipeline startup failed!",
            	"3103": "cc.Texture.addImage(): path should be non-null",
            	"3119": "Lazy init texture with image element failed due to image loading failure: %s",
            	"3120": "Loading texture with unsupported type: '%s'. Add '%s' into 'cc.macro.SUPPORT_TEXTURE_FORMATS' please.",
            	"3121": "Can't find a texture format supported by the current platform! Please add a fallback format in the editor.",
            	"3122": "Error Texture in %s.",
            	"3123": "Set same texture %s.",
            	"3300": "Rect width exceeds maximum margin: %s",
            	"3301": "Rect height exceeds maximum margin: %s",
            	"3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
            	"3501": "Invalid listener type!",
            	"3502": "Can't set fixed priority with scene graph based listener.",
            	"3503": "Invalid parameters.",
            	"3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
            	"3505": "The listener has been registered, please don't register it again.",
            	"3506": "Unsupported listener target.",
            	"3507": "Invalid scene graph priority!",
            	"3508": "If program goes here, there should be event in dispatch.",
            	"3509": "_inDispatch should be 1 here.",
            	"3510": "%s's scene graph node not contains in the parent's children",
            	"3511": "event is undefined",
            	"3512": "Event manager only support scene graph priority for ui nodes which contain UIComponent",
            	"3520": "Device Motion Event request permission: %s",
            	"3521": "Device Motion Event request permission failed: %s",
            	"3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
            	"3602": "Unknown editor property '%s' in class '%s'.",
            	"3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
            	"3604": "Can only indicate one type attribute for %s.",
            	"3605": "The default value of %s is not instance of %s.",
            	"3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
            	"3607": "The default value of %s must be an empty string.",
            	"3608": "The type of %s must be CCString, not String.",
            	"3609": "The type of %s must be CCBoolean, not Boolean.",
            	"3610": "The type of %s must be CCFloat or CCInteger, not Number.",
            	"3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
            	"3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
            	"3613": "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
            	"3614": "Should not define constructor for cc.Component %s.",
            	"3615": "Each script can have at most one Component.",
            	"3616": "Should not specify class name %s for Component which defines in project.",
            	"3618": "ctor of '%s' can not be another CCClass",
            	"3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
            	"3625": "[isChildClassOf] superclass should be function type, not",
            	"3626": "Can't remove '%s' because '%s' depends on it.",
            	"3627": "Should not add renderer component (%s) to a Canvas node.",
            	"3628": "Should not add %s to a node which size is already used by its other component.",
            	"3633": "Properties function of '%s' should return an object!",
            	"3634": "Disallow to use '.' in property name",
            	"3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
            	"3639": "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
            	"3640": "'%s': the setter of '%s' is already defined!",
            	"3641": "Can not construct %s because it contains object property.",
            	"3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
            	"3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
            	"3646": "Unknown 'type' parameter of %s.%s：%s",
            	"3647": "The length of range array must be equal or greater than 2",
            	"3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
            	"3652": "Failed to `new %s()` under the hood, %s\nIt is used for getting default values declared in TypeScript in the first place.\nPlease ensure the constructor can be called during the script's initialization.",
            	"3653": "Please do not specifiy \"default\" attribute in decorator of \"%s\" property in \"%s\" class.\nDefault value must be initialized at their declaration:\n\n \n// Before:\n@property({\n  type: cc.SpriteFrame\n  default: null  // <--\n})\nmyProp;\n// After:\n@property({\n  type: cc.SpriteFrame\n})\nmyProp = null;   // <--",
            	"3654": "Please specifiy a default value for \"%s.%s\" property at its declaration:\n\n \n// Before:\n@property(...)\nmyProp;\n// After:\n@property(...)\nmyProp = 0;",
            	"3655": "Can not specifiy \"get\" or \"set\"  attribute in decorator for \"%s\" property in \"%s\" class.\nPlease use:\n\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}",
            	"3659": "Violation error: extending enumerations shall have non-overlaped member names or member values",
            	"3660": "You are explicitly specifying `undefined` type to cc property \"%s\" of cc class \"%s\".\nIs this intended? If not, this may indicate a circular reference.\nFor example:\n\n \n// foo.ts\nimport { _decorator } from 'cc';\nimport { Bar } from './bar';  // Given that './bar' also reference 'foo.ts'.\n                              // When importing './bar', execution of './bar' is hung on to wait execution of 'foo.ts',\n                              // the `Bar` imported here is `undefined` until './bar' finish its execution.\n                              // It leads to that\n@_decorator.ccclass           //  ↓\nexport class Foo {            //  ↓\n    @_decorator.type(Bar)     //  → is equivalent to `@_decorator.type(undefined)`\n    public bar: Bar;          // To eliminate this error, either:\n                              // - Refactor your module structure(recommended), or\n                              // - specify the type as cc class name: `@_decorator.type('Bar'/* or any name you specified for `Bar` */)`\n}",
            	"3700": "internal error: _prefab is undefined",
            	"3701": "Failed to load prefab asset for node '%s'",
            	"3800": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
            	"3801": "The node can not be made persist because it's not under root node.",
            	"3802": "The node can not be made persist because it's not in current scene.",
            	"3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
            	"3804": "getComponent: Type must be non-nil",
            	"3805": "Can't add component '%s' because %s already contains the same component.",
            	"3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
            	"3807": "addComponent: Failed to get class '%s'",
            	"3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
            	"3809": "addComponent: The component to add must be a constructor",
            	"3810": "addComponent: The component to add must be child class of cc.Component",
            	"3811": "_addComponentAt: The component to add must be a constructor",
            	"3812": "_addComponentAt: Index out of range",
            	"3813": "removeComponent: Component must be non-nil",
            	"3814": "Argument must be non-nil",
            	"3815": "Component not owned by this entity",
            	"3816": "Node '%s' is already activating",
            	"3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
            	"3818": "Failed to read or parse project.json",
            	"3819": "Warning: target element is not a DIV or CANVAS",
            	"3820": "The renderer doesn't support the renderMode %s",
            	"3821": "Cannot change hierarchy while activating or deactivating the parent.",
            	"3822": "addComponent: Cannot add any component to the scene.",
            	"3823": "The enabled component (id: %s, name: %s) doesn't have a valid node",
            	"3900": "Invalid clip to add",
            	"3901": "Invalid clip to remove",
            	"3902": "clip is defaultClip, set force to true to force remove clip and animation state",
            	"3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
            	"3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
            	"3905": "sprite frames must be an Array.",
            	"3906": "Can't find easing type [%s]",
            	"3907": "animator not added or already removed",
            	"3912": "already-playing",
            	"3920": "Current context does not allow root motion.",
            	"3921": "You provided a ill-formed track path. The last component of track path should be property key, or the setter should not be empty.",
            	"3923": "Root motion is ignored since root bone could not be located in animation.",
            	"3924": "Root motion is ignored since the root bone could not be located in scene.",
            	"3925": "Target of hierarchy path should be of type Node.",
            	"3926": "Node \"%s\" has no path \"%s\".",
            	"3927": "Target of component path should be of type Node.",
            	"3928": "Node \"%s\" has no component \"%s\".",
            	"3929": "Target object has no property \"%s\".",
            	"3930": "Can not decide type for untyped track: runtime binding does not provide a getter.",
            	"3931": "Can not decide type for untyped track: got a unsupported value from runtime binding.",
            	"3932": "Common targets should only target Vectors/`Size`/`Color`.",
            	"3933": "Each curve that has common target should be numeric curve and targets string property.",
            	"3934": "Misconfigured legacy curve: the first keyframe value is number but others aren't.",
            	"3935": "We don't currently support conversion of \\`CubicSplineQuatValue\\`.",
            	"3936": "Instancing/Batching enabled for non-baked skinning model '%s', this may result in unexpected rendering artifacts. Consider turning it off in the material if you do not intend to do this.",
            	"4003": "Label font size can't be shirnked less than 0!",
            	"4004": "force notify all fonts loaded!",
            	"4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
            	"4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
            	"4013": "Sorry, lineHeight of system font not supported on JSB.",
            	"4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
            	"4201": "The alphaThreshold invalid in Canvas Mode.",
            	"4202": "The inverted invalid in Canvas Mode.",
            	"4300": "Can not found the %s page.",
            	"4301": "Can not add a page without UITransform.",
            	"4302": "Can not set the scroll view content when it hasn't UITransform or its parent hasn't UITransform.",
            	"4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
            	"4500": "Graphics: There is no model in %s.",
            	"4600": "Script attached to '%s' is missing or invalid.",
            	"4700": "The dom control is not created!",
            	"4800": "unknown asset type",
            	"4901": "loadRes: should not specify the extname in %s %s",
            	"4902": "No need to release non-cached asset.",
            	"4914": "Resources url '%s' does not exist.",
            	"4915": "Pack indices and data do not match in size",
            	"4916": "Failed to download package for %s",
            	"4921": "Invalid pipe or invalid index provided!",
            	"4922": "The pipe to be inserted is already in the pipeline!",
            	"4923": "Uuid Loader: Parse asset [ %s ] failed : %s",
            	"4924": "JSON Loader: Input item doesn't contain string content",
            	"4925": "Uuid Loader: Deserialize asset [ %s ] failed : %s",
            	"4926": "Audio Downloader: no web audio context.",
            	"4927": "Audio Downloader: audio not supported on this browser!",
            	"4928": "Load %s failed!",
            	"4929": "Load Webp ( %s ) failed",
            	"4930": "Load image ( %s ) failed",
            	"4932": "Since v1.10, for any atlas (\"%s\") in the \"resources\" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.",
            	"4933": "Download Font [ %s ] failed, using Arial or system default font instead",
            	"4934": "Please assure that the full path of sub asset is correct!",
            	"4935": "Failed to skip prefab asset while deserializing PrefabInfo",
            	"5000": "You are trying to destroy a object twice or more.",
            	"5001": "object not yet destroyed",
            	"5100": "Not a plist file!",
            	"5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
            	"5201": "browser don't support web audio",
            	"5202": "This feature supports WebGL render mode only.",
            	"5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
            	"5301": "Can not find script '%s'",
            	"5302": "Can not find class '%s'",
            	"5303": "Failed to deserialize %s, missing _deserialize function.",
            	"5304": "Unable to deserialize version %s data.",
            	"5402": "cc.js.addon called on non-object:",
            	"5403": "cc.js.mixin: arguments must be type object:",
            	"5404": "The base class to extend from must be non-nil",
            	"5405": "The class to extend must be non-nil",
            	"5406": "Class should be extended before assigning any prototype members.",
            	"5500": "'notify' can not be used in 'get/set' !",
            	"5501": "'notify' must be used with 'default' !",
            	"5507": "The 'default' attribute of '%s.%s' must be an array",
            	"5508": "Invalid type of %s.%s",
            	"5510": "The 'type' attribute of '%s.%s' can not be 'Number', use cc.Float or cc.Integer instead please.",
            	"5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
            	"5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
            	"5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
            	"5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
            	"5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
            	"5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
            	"5601": "Can not get current scene.",
            	"5602": "Scene is destroyed",
            	"5603": "reference node is destroyed",
            	"5700": "no %s or %s on %s",
            	"5800": "%s.lerp not yet implemented.",
            	"5801": "%s.clone not yet implemented.",
            	"5802": "%s.equals not yet implemented.",
            	"5900": "MotionStreak only support WebGL mode.",
            	"5901": "cc.MotionStreak.getOpacity has not been supported.",
            	"5902": "cc.MotionStreak.setOpacity has not been supported.",
            	"6000": "Custom should not be false if file is not specified.",
            	"6001": "The new %s must not be NaN",
            	"6017": "Incomplete or corrupt PNG file",
            	"6018": "Invalid filter algorithm: %s",
            	"6019": "Invalid byte order value.",
            	"6020": "You forgot your towel!",
            	"6021": "Unknown Field Tag: %s",
            	"6022": "Too many bits requested",
            	"6023": "No bits requested",
            	"6024": "Cannot recover from missing StripByteCounts",
            	"6025": "Cannot handle sub-byte bits per sample",
            	"6026": "Cannot handle sub-byte bits per pixel",
            	"6027": "Palette image missing color map",
            	"6028": "Unknown Photometric Interpretation: %s",
            	"6029": "Unkown error",
            	"6030": "cc.ParticleSystem: error decoding or ungzipping textureImageData",
            	"6031": "cc.ParticleSystem: unknown image format with Data",
            	"6032": "cc.ParticleSystem.initWithDictionary() : error loading the texture",
            	"6033": "cc.ParticleSystem: not allowing create to be invoked twice with different particle system",
            	"6034": "cc.ParticleSystem: shouldn't be initialized repetitively, otherwise there will be potential leak",
            	"6400": "asset.url is not usable in core process",
            	"6402": "AssetLibrary has already been initialized!",
            	"6500": "Widget target must be one of the parent nodes of it",
            	"6600": "collider not added or already removed",
            	"6601": "Can't find testFunc for (%s, $s).",
            	"6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time.",
            	"6705": "Argument must be non-nil",
            	"6706": "Priority can't be set in RenderRoot2D node",
            	"6800": "Callback of event must be non-nil",
            	"6801": "The message must be provided",
            	"6900": "The thing you want to instantiate must be an object",
            	"6901": "The thing you want to instantiate is nil",
            	"6902": "The thing you want to instantiate is destroyed",
            	"6903": "The instantiate method for given asset do not implemented",
            	"6904": "Can not instantiate array",
            	"6905": "Can not instantiate DOM element",
            	"7100": "%s already defined in Enum.",
            	"7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: <https://github.com/cocos-creator/engine/issues/new>",
            	"7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
            	"7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
            	"7202": "Add component TiledLayer into node failed.",
            	"7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
            	"7210": "TMX Hexa zOrder not supported",
            	"7211": "TMX invalid value",
            	"7215": "cocos2d: Warning: TMX Layer %s has no tiles",
            	"7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
            	"7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
            	"7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
            	"7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
            	"7221": "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
            	"7222": "Parse %s failed.",
            	"7236": "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
            	"7237": "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
            	"7238": "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
            	"7239": "cc.TMXLayer.setTileGID(): invalid gid: %s",
            	"7240": "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
            	"7241": "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
            	"7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
            	"7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
            	"7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
            	"7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
            	"7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
            	"7504": "Can not render dynamic created SkeletonData",
            	"7506": "Failed to load spine atlas '$s'",
            	"7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
            	"7508": "The atlas asset of '%s' is not exists!",
            	"7509": "Spine: Animation not found: %s",
            	"7510": "Spine: Animation not found: %s",
            	"7600": "The context of RenderTexture is invalid.",
            	"7601": "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
            	"7602": "Could not attach texture to the framebuffer",
            	"7603": "clearDepth isn't supported on Cocos2d-Html5",
            	"7604": "saveToFile isn't supported on Cocos2d-Html5",
            	"7605": "newCCImage isn't supported on Cocos2d-Html5",
            	"7606": "GFXTexture is null",
            	"7607": "readPixels buffer size smaller than %d",
            	"7700": "On the web is always keep the aspect ratio",
            	"7701": "Can't know status",
            	"7702": "Video player's duration is not ready to get now!",
            	"7703": "Video Downloader: video not supported on this browser!",
            	"7800": "Web does not support loading",
            	"7801": "Web does not support query history",
            	"7802": "Web does not support query history",
            	"7803": "The current browser does not support the GoBack",
            	"7804": "The current browser does not support the GoForward",
            	"7805": "Web does not support zoom",
            	"7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
            	"7901": "cc.math.mat4Assign(): pOut equals pIn",
            	"7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
            	"7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
            	"7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
            	"7905": "cc.math.mat4Assign(): pOut equals pIn",
            	"7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
            	"7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
            	"7908": "Invalid matrix mode specified",
            	"7909": "current quaternion is an invalid value",
            	"8000": "Can't handle this field type or size",
            	"8001": "No bytes requested",
            	"8002": "Too many bytes requested",
            	"8003": "Missing StripByteCounts!",
            	"8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
            	"8101": "cocos2d: ERROR: Failed to compile vertex shader",
            	"8102": "cocos2d: ERROR: Failed to compile fragment shader",
            	"8103": "cc.GLProgram.link(): Cannot link invalid program",
            	"8104": "cocos2d: ERROR: Failed to link program: %s",
            	"8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
            	"8106": "Please load the resource firset : %s",
            	"8107": "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
            	"8108": "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
            	"8109": "modelView matrix is undefined.",
            	"8200": "Please set node's active instead of rigidbody's enabled.",
            	"8300": "Should only one camera exists, please check your project.",
            	"8301": "Camera does not support Canvas Mode.",
            	"8302": "Camera.viewport is deprecated, please use setViewportInOrientedSpace instead.",
            	"8400": "Wrong type arguments, 'filePath' must be a String.",
            	"9000": "Stencil manager does not support level bigger than %d in this device.",
            	"9001": "Stencil manager is already empty, cannot pop any mask",
            	"9100": "texture size exceeds current device limits %d/%d",
            	"9201": "Cannot access game frame or container.",
            	"9202": "Setting window size is not supported.",
            	"9300": "The current buffer beyond the limit in ui static component, please reduce the amount",
            	"9301": "The UI has not been initialized",
            	"9302": "Can't getGFXSampler with out device",
            	"9600": "[Physics]: please check to see if physics modules are included",
            	"9610": "[Physics]: cannon.js physics system doesn't support capsule collider",
            	"9611": "[Physics]: builtin physics system doesn't support mesh collider",
            	"9612": "[Physics]: builtin physics system doesn't support cylinder collider",
            	"9620": "[Physics][Ammo]: changing the mesh is not supported after the initialization is completed",
            	"10001": "The sub-mesh contains %d vertices, which beyonds the capability (%d vertices most) of renderer of your platform.",
            	"10002": "Sub-mesh may include at most %d morph targets, but you specified %d.",
            	"11000": "WebGL context lost.",
            	"12001": "BlendFactors are disabled when using custom material, please modify the blend state in the material instead.",
            	"12002": "Can't add renderable component to this node because it already have one.",
            	"12004": "SubModel can only support %d passes.",
            	"12005": "Material already initialized, request aborted.",
            	"12006": "Pass already destroyed.",
            	"12007": "This is old usage, please swap the parameters.",
            	"12008": "GeometryRenderer: too many lines.",
            	"12009": "GeometryRenderer: too many triangles.",
            	"12100": "The font size is too big to be fitted into texture atlas. Please switch to other label cache modes or choose a smaller font size.",
            	"12101": "The asset %s has been destroyed!",
            	"13100": "Incorrect CCON magic.",
            	"13101": "Unknown CCON version number: %d.",
            	"13102": "CCON Format error.",
            	"13103": "Can not encode CCON binary: lack of text encoder.",
            	"13104": "Can not decode CCON binary: lack of text decoder.",
            	"14000": "Graph update has been interrupted since too many transitions(greater than %s) occurred during one frame.",
            	"14100": "Pool.destroy no longer take a function as parameter, Please specify destruct function in the construction of Pool instead",
            	"0100": "%s not yet implemented.",
            	"0200": "You should specify a valid DOM canvas element."
            };

            let logList = null;
            let ccLog = console.log.bind(console);
            let ccWarn = ccLog;
            let ccError = ccLog;

            let ccAssert = (condition, message, ...optionalParams) => {
              if (!condition) {
                console.log(`ASSERT: ${formatString(message, ...optionalParams)}`);
              }
            };

            let ccDebug = ccLog;

            function formatString(message, ...optionalParams) {
              return legacyCC.js.formatStr.apply(null, [message].concat(optionalParams));
            }

            function log(message, ...optionalParams) {
              return ccLog(message, ...optionalParams);
            }
            function warn(message, ...optionalParams) {
              return ccWarn(message, ...optionalParams);
            }
            function error(message, ...optionalParams) {
              return ccError(message, ...optionalParams);
            }
            function assert(value, message, ...optionalParams) {
              return ccAssert(value, message, ...optionalParams);
            }
            function debug(...data) {
              return ccDebug(...data);
            }
            function _resetDebugSetting(mode) {
              ccLog = ccWarn = ccError = ccAssert = ccDebug = () => {};

              if (mode === DebugMode.NONE) {
                return;
              }

              if (mode > DebugMode.ERROR) {
                const logToWebPage = msg => {
                  if (!legacyCC.game.canvas) {
                    return;
                  }

                  if (!logList) {
                    const logDiv = document.createElement('Div');
                    logDiv.setAttribute('id', 'logInfoDiv');
                    logDiv.setAttribute('width', '200');
                    logDiv.setAttribute('height', legacyCC.game.canvas.height);
                    const logDivStyle = logDiv.style;
                    logDivStyle.zIndex = '99999';
                    logDivStyle.position = 'absolute';
                    logDivStyle.top = logDivStyle.left = '0';
                    logList = document.createElement('textarea');
                    logList.setAttribute('rows', '20');
                    logList.setAttribute('cols', '30');
                    logList.setAttribute('disabled', 'true');
                    const logListStyle = logList.style;
                    logListStyle.backgroundColor = 'transparent';
                    logListStyle.borderBottom = '1px solid #cccccc';
                    logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = '0px';
                    logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = 'none';
                    logListStyle.padding = '0px';
                    logListStyle.margin = '0px';
                    logDiv.appendChild(logList);
                    legacyCC.game.canvas.parentNode.appendChild(logDiv);
                  }

                  logList.value = `${logList.value + msg}\r\n`;
                  logList.scrollTop = logList.scrollHeight;
                };

                ccError = (message, ...optionalParams) => {
                  logToWebPage(`ERROR :  ${formatString(message, ...optionalParams)}`);
                };

                ccAssert = (condition, message, ...optionalParams) => {
                  if (!condition) {
                    logToWebPage(`ASSERT: ${formatString(message, ...optionalParams)}`);
                  }
                };

                if (mode !== DebugMode.ERROR_FOR_WEB_PAGE) {
                  ccWarn = (message, ...optionalParams) => {
                    logToWebPage(`WARN :  ${formatString(message, ...optionalParams)}`);
                  };
                }

                if (mode === DebugMode.INFO_FOR_WEB_PAGE) {
                  ccLog = (message, ...optionalParams) => {
                    logToWebPage(formatString(message, ...optionalParams));
                  };
                }
              } else if (console) {
                if (!console.error) {
                  console.error = console.log;
                }

                if (!console.warn) {
                  console.warn = console.log;
                }

                if ( console.error.bind) {
                  ccError = console.error.bind(console);
                } else {
                  ccError =  console.error ;
                }

                ccAssert = (condition, message, ...optionalParams) => {
                  if (!condition) {
                    const errorText = formatString(message, ...optionalParams);

                    {
                      throw new Error(errorText);
                    }
                  }
                };
              }

              if (mode !== DebugMode.ERROR) {
                if (console.warn.bind) {
                  ccWarn = console.warn.bind(console);
                } else {
                  ccWarn =  console.warn ;
                }
              }

              if (mode <= DebugMode.INFO) {
                {
                  if (scriptEngineType === 'JavaScriptCore') {
                    ccLog = (message, ...optionalParams) => console.log.apply(console, [message, ...optionalParams]);
                  } else {
                    ccLog = console.log;
                  }
                }
              }

              if (mode <= DebugMode.VERBOSE) {
                if (typeof console.debug === 'function') {
                  const vendorDebug = console.debug.bind(console);

                  ccDebug = (...data) => vendorDebug(...data);
                }
              }
            }
            function _throw(error_) {
              {
                const stack = error_.stack;

                if (stack) {
                  error( `${error_}\n${stack}` );
                } else {
                  error(error_);
                }

                return undefined;
              }
            }

            function getTypedFormatter(type) {
              return (id, ...args) => {
                const msg =  debugInfos[id] || 'unknown id' ;

                if (args.length === 0) {
                  return msg;
                }

                return  formatString(msg, ...args) ;
              };
            }

            const logFormatter = getTypedFormatter();
            function logID(id, ...optionalParams) {
              log(logFormatter(id, ...optionalParams));
            }
            const warnFormatter = getTypedFormatter();
            function warnID(id, ...optionalParams) {
              warn(warnFormatter(id, ...optionalParams));
            }
            const errorFormatter = getTypedFormatter();
            function errorID(id, ...optionalParams) {
              error(errorFormatter(id, ...optionalParams));
            }
            const assertFormatter = getTypedFormatter();
            function assertID(condition, id, ...optionalParams) {
              if (condition) {
                return;
              }

              assert(false, assertFormatter(id, ...optionalParams));
            }
            let DebugMode;

            (function (DebugMode) {
              DebugMode[DebugMode["NONE"] = 0] = "NONE";
              DebugMode[DebugMode["VERBOSE"] = 1] = "VERBOSE";
              DebugMode[DebugMode["INFO"] = 2] = "INFO";
              DebugMode[DebugMode["WARN"] = 3] = "WARN";
              DebugMode[DebugMode["ERROR"] = 4] = "ERROR";
              DebugMode[DebugMode["INFO_FOR_WEB_PAGE"] = 5] = "INFO_FOR_WEB_PAGE";
              DebugMode[DebugMode["WARN_FOR_WEB_PAGE"] = 6] = "WARN_FOR_WEB_PAGE";
              DebugMode[DebugMode["ERROR_FOR_WEB_PAGE"] = 7] = "ERROR_FOR_WEB_PAGE";
            })(DebugMode || (DebugMode = exports('fO', {})));

            function getError(errorId, ...param) {
              return errorFormatter(errorId, ...param);
            }
            function isDisplayStats() {
              return legacyCC.profiler ? legacyCC.profiler.isShowingStats() : false;
            }
            function setDisplayStats(displayStats) {
              if (legacyCC.profiler) {
                displayStats ? legacyCC.profiler.showStats() : legacyCC.profiler.hideStats();
                legacyCC.game.config.showFPS = !!displayStats;
              }
            }

            var debug$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                log: log,
                warn: warn,
                error: error,
                assert: assert,
                debug: debug,
                _resetDebugSetting: _resetDebugSetting,
                _throw: _throw,
                logID: logID,
                warnID: warnID,
                errorID: errorID,
                assertID: assertID,
                get DebugMode () { return DebugMode; },
                getError: getError,
                isDisplayStats: isDisplayStats,
                setDisplayStats: setDisplayStats
            });

            class MutableForwardIterator {
              constructor(array) {
                this.i = 0;
                this.array = array;
              }

              get length() {
                return this.array.length;
              }

              set length(value) {
                this.array.length = value;

                if (this.i >= value) {
                  this.i = value - 1;
                }
              }

              remove(value) {
                const index = this.array.indexOf(value);

                if (index >= 0) {
                  this.removeAt(index);
                }
              }

              removeAt(i) {
                this.array.splice(i, 1);

                if (i <= this.i) {
                  --this.i;
                }
              }

              fastRemove(value) {
                const index = this.array.indexOf(value);

                if (index >= 0) {
                  this.fastRemoveAt(index);
                }
              }

              fastRemoveAt(i) {
                const array = this.array;
                array[i] = array[array.length - 1];
                --array.length;

                if (i <= this.i) {
                  --this.i;
                }
              }

              push(item) {
                this.array.push(item);
              }

            }

            function removeAt(array, index) {
              array.splice(index, 1);
            }
            function fastRemoveAt(array, index) {
              const length = array.length;

              if (index < 0 || index >= length) {
                return;
              }

              array[index] = array[length - 1];
              array.length = length - 1;
            }
            function remove(array, value) {
              const index = array.indexOf(value);

              if (index >= 0) {
                removeAt(array, index);
                return true;
              } else {
                return false;
              }
            }
            function fastRemove(array, value) {
              const index = array.indexOf(value);

              if (index >= 0) {
                array[index] = array[array.length - 1];
                --array.length;
              }
            }
            function removeIf(array, predicate) {
              const index = array.findIndex(predicate);

              if (index >= 0) {
                const value = array[index];
                removeAt(array, index);
                return value;
              }
            }
            function verifyType(array, type) {
              if (array && array.length > 0) {
                for (const item of array) {
                  if (!(item instanceof type)) {
                    logID(1300);
                    return false;
                  }
                }
              }

              return true;
            }
            function removeArray(array, removals) {
              for (let i = 0, l = removals.length; i < l; i++) {
                remove(array, removals[i]);
              }
            }
            function appendObjectsAt(array, objects, index) {
              array.splice.apply(array, [index, 0, ...objects]);
              return array;
            }
            function contains(array, value) {
              return array.indexOf(value) >= 0;
            }
            function copy(array) {
              const len = array.length;
              const cloned = new Array(len);

              for (let i = 0; i < len; i += 1) {
                cloned[i] = array[i];
              }

              return cloned;
            }

            var jsarray = /*#__PURE__*/Object.freeze({
                __proto__: null,
                removeAt: removeAt,
                fastRemoveAt: fastRemoveAt,
                remove: remove,
                fastRemove: fastRemove,
                removeIf: removeIf,
                verifyType: verifyType,
                removeArray: removeArray,
                appendObjectsAt: appendObjectsAt,
                contains: contains,
                copy: copy,
                MutableForwardIterator: MutableForwardIterator
            });

            class ContainerManager {
              constructor() {
                this._pools = [];
                this._lastShrinkPassed = 0;
                this.shrinkTimeSpan = 5;
              }

              addContainer(pool) {
                if (pool._poolHandle !== -1) return;
                pool._poolHandle = this._pools.length;

                this._pools.push(pool);
              }

              removeContainer(pool) {
                if (pool._poolHandle === -1) return;
                this._pools[this._pools.length - 1]._poolHandle = pool._poolHandle;
                fastRemoveAt(this._pools, pool._poolHandle);
                pool._poolHandle = -1;
              }

              tryShrink() {
                for (let i = 0; i < this._pools.length; i++) {
                  this._pools[i].tryShrink();
                }
              }

              update(dt) {
                this._lastShrinkPassed += dt;

                if (this._lastShrinkPassed > this.shrinkTimeSpan) {
                  this.tryShrink();
                  this._lastShrinkPassed -= this.shrinkTimeSpan;
                }
              }

            }

            const containerManager = new ContainerManager();

            class ScalableContainer {
              constructor() {
                this._poolHandle = -1;
                containerManager.addContainer(this);
              }

              destroy() {
                containerManager.removeContainer(this);
              }

            } exports('S', ScalableContainer);

            class Pool extends ScalableContainer {
              constructor(ctor, elementsPerBatch, dtor) {
                super();
                this._ctor = void 0;
                this._elementsPerBatch = void 0;
                this._nextAvail = void 0;
                this._freepool = [];
                this._dtor = void 0;
                this._ctor = ctor;
                this._dtor = dtor || null;
                this._elementsPerBatch = Math.max(elementsPerBatch, 1);
                this._nextAvail = this._elementsPerBatch - 1;

                for (let i = 0; i < this._elementsPerBatch; ++i) {
                  this._freepool.push(ctor());
                }
              }

              alloc() {
                if (this._nextAvail < 0) {
                  this._freepool.length = this._elementsPerBatch;

                  for (let i = 0; i < this._elementsPerBatch; i++) {
                    this._freepool[i] = this._ctor();
                  }

                  this._nextAvail = this._elementsPerBatch - 1;
                }

                return this._freepool[this._nextAvail--];
              }

              free(obj) {
                this._freepool[++this._nextAvail] = obj;
              }

              freeArray(objs) {
                this._freepool.length = this._nextAvail + 1;
                Array.prototype.push.apply(this._freepool, objs);
                this._nextAvail += objs.length;
              }

              tryShrink() {
                if (this._nextAvail >> 1 > this._elementsPerBatch) {
                  if (this._dtor) {
                    for (let i = this._nextAvail >> 1; i <= this._nextAvail; i++) {
                      this._dtor(this._freepool[i]);
                    }
                  }

                  this._freepool.length = this._nextAvail >> 1;
                  this._nextAvail = this._freepool.length - 1;
                }
              }

              destroy() {
                const dtor = arguments.length > 0 ? arguments[0] : null;

                if (dtor) {
                  warnID(14100);
                }

                const readDtor = dtor || this._dtor;

                if (readDtor) {
                  for (let i = 0; i <= this._nextAvail; i++) {
                    readDtor(this._freepool[i]);
                  }
                }

                this._freepool.length = 0;
                this._nextAvail = -1;
                super.destroy();
              }

            } exports('P', Pool);

            class RecyclePool extends ScalableContainer {
              constructor(fn, size, dtor) {
                super();
                this._fn = void 0;
                this._dtor = null;
                this._count = 0;
                this._data = void 0;
                this._initSize = 0;
                this._fn = fn;
                this._dtor = dtor || null;
                this._data = new Array(size);
                this._initSize = size;

                for (let i = 0; i < size; ++i) {
                  this._data[i] = fn();
                }
              }

              get length() {
                return this._count;
              }

              get data() {
                return this._data;
              }

              reset() {
                this._count = 0;
              }

              resize(size) {
                if (size > this._data.length) {
                  for (let i = this._data.length; i < size; ++i) {
                    this._data[i] = this._fn();
                  }
                }
              }

              add() {
                if (this._count >= this._data.length) {
                  this.resize(this._data.length << 1);
                }

                return this._data[this._count++];
              }

              destroy() {
                if (this._dtor) {
                  for (let i = 0; i < this._data.length; i++) {
                    this._dtor(this._data[i]);
                  }
                }

                this._data.length = 0;
                this._count = 0;
                super.destroy();
              }

              tryShrink() {
                if (this._data.length >> 2 > this._count) {
                  const length = Math.max(this._initSize, this._data.length >> 1);

                  if (this._dtor) {
                    for (let i = length; i < this._data.length; i++) {
                      this._dtor(this._data[i]);
                    }
                  }

                  this._data.length = length;
                }
              }

              removeAt(idx) {
                if (idx >= this._count) {
                  return;
                }

                const last = this._count - 1;
                const tmp = this._data[idx];
                this._data[idx] = this._data[last];
                this._data[last] = tmp;
                this._count -= 1;
              }

            } exports('R', RecyclePool);

            const NonUuidMark = '.';
            class IDGenerator {
              constructor(category) {
                this.id = void 0;
                this.prefix = void 0;
                this.id = 0 | Math.random() * 998;
                this.prefix = category ? category + NonUuidMark : '';
              }

              getNewId() {

                return this.prefix + ++this.id;
              }

            }
            IDGenerator.global = new IDGenerator('global');

            const tempCIDGenerator = new IDGenerator('TmpCId.');
            const aliasesTag = typeof Symbol === 'undefined' ? '__aliases__' : Symbol('[[Aliases]]');
            const classNameTag = '__classname__';
            const classIdTag = '__cid__';
            function isNumber(object) {
              return typeof object === 'number' || object instanceof Number;
            }
            function isString(object) {
              return typeof object === 'string' || object instanceof String;
            }
            function isEmptyObject(obj) {
              for (const key in obj) {
                return false;
              }

              return true;
            }
            const value = (() => {
              const descriptor = {
                value: undefined,
                enumerable: false,
                writable: false,
                configurable: true
              };
              return (object, propertyName, value_, writable, enumerable) => {
                descriptor.value = value_;
                descriptor.writable = writable;
                descriptor.enumerable = enumerable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.value = undefined;
              };
            })();
            const getset = (() => {
              const descriptor = {
                get: undefined,
                set: undefined,
                enumerable: false
              };
              return (object, propertyName, getter, setter, enumerable = false, configurable = false) => {
                if (typeof setter === 'boolean') {
                  enumerable = setter;
                  setter = undefined;
                }

                descriptor.get = getter;
                descriptor.set = setter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.get = undefined;
                descriptor.set = undefined;
              };
            })();
            const get = (() => {
              const descriptor = {
                get: undefined,
                enumerable: false,
                configurable: false
              };
              return (object, propertyName, getter, enumerable, configurable) => {
                descriptor.get = getter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.get = undefined;
              };
            })();
            const set = (() => {
              const descriptor = {
                set: undefined,
                enumerable: false,
                configurable: false
              };
              return (object, propertyName, setter, enumerable, configurable) => {
                descriptor.set = setter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.set = undefined;
              };
            })();
            function createMap(forceDictMode) {
              const map = Object.create(null);

              if (forceDictMode) {
                const INVALID_IDENTIFIER_1 = '.';
                const INVALID_IDENTIFIER_2 = '/';
                map[INVALID_IDENTIFIER_1] = 1;
                map[INVALID_IDENTIFIER_2] = 1;
                delete map[INVALID_IDENTIFIER_1];
                delete map[INVALID_IDENTIFIER_2];
              }

              return map;
            }
            function getClassName(objOrCtor) {
              if (typeof objOrCtor === 'function') {
                const prototype = objOrCtor.prototype;

                if (prototype && prototype.hasOwnProperty(classNameTag) && prototype[classNameTag]) {
                  return prototype[classNameTag];
                }

                let retval = '';

                if (objOrCtor.name) {
                  retval = objOrCtor.name;
                }

                if (objOrCtor.toString) {
                  let arr;
                  const str = objOrCtor.toString();

                  if (str.charAt(0) === '[') {
                    arr = str.match(/\[\w+\s*(\w+)\]/);
                  } else {
                    arr = str.match(/function\s*(\w+)/);
                  }

                  if (arr && arr.length === 2) {
                    retval = arr[1];
                  }
                }

                return retval !== 'Object' ? retval : '';
              } else if (objOrCtor && objOrCtor.constructor) {
                return getClassName(objOrCtor.constructor);
              }

              return '';
            }
            function obsolete(object, obsoleted, newExpr, writable) {
              const extractPropName = /([^.]+)$/;
              const oldProp = extractPropName.exec(obsoleted)[0];
              const newProp = extractPropName.exec(newExpr)[0];

              function getter() {

                return this[newProp];
              }

              function setter(value_) {

                this[newProp] = value_;
              }

              if (writable) {
                getset(object, oldProp, getter, setter);
              } else {
                get(object, oldProp, getter);
              }
            }
            function obsoletes(obj, objName, props, writable) {
              for (const obsoleted in props) {
                const newName = props[obsoleted];
                obsolete(obj, `${objName}.${obsoleted}`, newName, writable);
              }
            }
            const REGEXP_NUM_OR_STR = /(%d)|(%s)/;
            const REGEXP_STR = /%s/;
            function formatStr(msg, ...subst) {
              if (arguments.length === 0) {
                return '';
              }

              if (subst.length === 0) {
                return `${msg}`;
              }

              const hasSubstitution = typeof msg === 'string' && REGEXP_NUM_OR_STR.test(msg);

              if (hasSubstitution) {
                for (const arg of subst) {
                  const regExpToTest = typeof arg === 'number' ? REGEXP_NUM_OR_STR : REGEXP_STR;

                  if (regExpToTest.test(msg)) {
                    const notReplaceFunction = `${arg}`;
                    msg = msg.replace(regExpToTest, notReplaceFunction);
                  } else {
                    msg += ` ${arg}`;
                  }
                }
              } else {
                for (const arg of subst) {
                  msg += ` ${arg}`;
                }
              }

              return msg;
            }
            function shiftArguments() {
              const len = arguments.length - 1;
              const args = new Array(len);

              for (let i = 0; i < len; ++i) {
                args[i] = arguments[i + 1];
              }

              return args;
            }
            function getPropertyDescriptor(object, propertyName) {
              while (object) {
                const pd = Object.getOwnPropertyDescriptor(object, propertyName);

                if (pd) {
                  return pd;
                }

                object = Object.getPrototypeOf(object);
              }

              return null;
            }

            function _copyprop(name, source, target) {
              const pd = getPropertyDescriptor(source, name);

              if (pd) {
                Object.defineProperty(target, name, pd);
              }
            }

            function addon(object, ...sources) {
              object = object || {};

              for (const source of sources) {
                if (source) {
                  if (typeof source !== 'object') {
                    errorID(5402, source);
                    continue;
                  }

                  for (const name in source) {
                    if (!(name in object)) {
                      _copyprop(name, source, object);
                    }
                  }
                }
              }

              return object;
            }
            function mixin(object, ...sources) {
              object = object || {};

              for (const source of sources) {
                if (source) {
                  if (typeof source !== 'object') {
                    errorID(5403, source);
                    continue;
                  }

                  for (const name in source) {
                    _copyprop(name, source, object);
                  }
                }
              }

              return object;
            }
            function extend(cls, base) {

              for (const p in base) {
                if (base.hasOwnProperty(p)) {
                  cls[p] = base[p];
                }
              }

              cls.prototype = Object.create(base.prototype, {
                constructor: {
                  value: cls,
                  writable: true,
                  configurable: true
                }
              });
              return cls;
            }
            function getSuper(constructor) {
              const proto = constructor.prototype;
              const dunderProto = proto && Object.getPrototypeOf(proto);
              return dunderProto && dunderProto.constructor;
            }
            function isChildClassOf(subclass, superclass) {
              if (subclass && superclass) {
                if (typeof subclass !== 'function') {
                  return false;
                }

                if (typeof superclass !== 'function') {

                  return false;
                }

                if (subclass === superclass) {
                  return true;
                }

                for (;;) {
                  subclass = getSuper(subclass);

                  if (!subclass) {
                    return false;
                  }

                  if (subclass === superclass) {
                    return true;
                  }
                }
              }

              return false;
            }
            function clear(object) {
              for (const key of Object.keys(object)) {
                delete object[key];
              }
            }

            function isTempClassId(id) {
              return typeof id !== 'string' || id.startsWith(tempCIDGenerator.prefix);
            }

            const _idToClass = createMap(true);
            const _nameToClass = createMap(true);

            function setup(tag, table) {
              return function (id, constructor) {
                if (constructor.prototype.hasOwnProperty(tag)) {
                  delete table[constructor.prototype[tag]];
                }

                value(constructor.prototype, tag, id);

                if (id) {
                  const registered = table[id];

                  if (registered && registered !== constructor) {
                    let err = `A Class already exists with the same ${tag} : "${id}".`;

                    error(err);
                  } else {
                    table[id] = constructor;
                  }
                }
              };
            }

            const _setClassId = setup('__cid__', _idToClass);
            const doSetClassName = setup('__classname__', _nameToClass);
            function setClassName(className, constructor) {
              doSetClassName(className, constructor);

              if (!constructor.prototype.hasOwnProperty(classIdTag)) {
                const id = className || tempCIDGenerator.getNewId();

                if (id) {
                  _setClassId(id, constructor);
                }
              }
            }
            function setClassAlias(target, alias) {
              const nameRegistry = _nameToClass[alias];
              const idRegistry = _idToClass[alias];
              let ok = true;

              if (nameRegistry && nameRegistry !== target) {
                error(`"${alias}" has already been set as name or alias of another class.`);
                ok = false;
              }

              if (idRegistry && idRegistry !== target) {
                error(`"${alias}" has already been set as id or alias of another class.`);
                ok = false;
              }

              if (ok) {
                let classAliases = target[aliasesTag];

                if (!classAliases) {
                  classAliases = [];
                  target[aliasesTag] = classAliases;
                }

                classAliases.push(alias);
                _nameToClass[alias] = target;
                _idToClass[alias] = target;
              }
            }
            function unregisterClass(...constructors) {
              for (const constructor of constructors) {
                const p = constructor.prototype;
                const classId = p[classIdTag];

                if (classId) {
                  delete _idToClass[classId];
                }

                const classname = p[classNameTag];

                if (classname) {
                  delete _nameToClass[classname];
                }

                const aliases = p[aliasesTag];

                if (aliases) {
                  for (let iAlias = 0; iAlias < aliases.length; ++iAlias) {
                    const alias = aliases[iAlias];
                    delete _nameToClass[alias];
                    delete _idToClass[alias];
                  }
                }
              }
            }
            function _getClassById(classId) {
              return _idToClass[classId];
            }
            function getClassByName(classname) {
              return _nameToClass[classname];
            }
            function _getClassId(obj, allowTempId) {
              allowTempId = typeof allowTempId !== 'undefined' ? allowTempId : true;
              let res;

              if (typeof obj === 'function' && obj.prototype.hasOwnProperty(classIdTag)) {
                res = obj.prototype[classIdTag];

                if (!allowTempId && ( EDITOR) && isTempClassId(res)) {
                  return '';
                }

                return res;
              }

              if (obj && obj.constructor) {
                const prototype = obj.constructor.prototype;

                if (prototype && prototype.hasOwnProperty(classIdTag)) {
                  res = obj[classIdTag];

                  if (!allowTempId && ( EDITOR) && isTempClassId(res)) {
                    return '';
                  }

                  return res;
                }
              }

              return '';
            }

            class Pool$1 {
              get() {
                return this._get();
              }

              constructor(_0, _1) {
                this.count = void 0;
                this._pool = void 0;
                this._cleanup = void 0;
                const size = _1 === undefined ? _0 : _1;
                const cleanupFunc = _1 === undefined ? null : _0;
                this.count = 0;
                this._pool = new Array(size);
                this._cleanup = cleanupFunc;
              }

              _get() {
                if (this.count > 0) {
                  --this.count;
                  const cache = this._pool[this.count];
                  this._pool[this.count] = null;
                  return cache;
                }

                return null;
              }

              put(obj) {
                const pool = this._pool;

                if (this.count < pool.length) {
                  if (this._cleanup && this._cleanup(obj) === false) {
                    return;
                  }

                  pool[this.count] = obj;
                  ++this.count;
                }
              }

              resize(length) {
                if (length >= 0) {
                  this._pool.length = length;

                  if (this.count > length) {
                    this.count = length;
                  }
                }
              }

            } exports('e3', Pool$1);

            const array = exports('eF', jsarray);
            const js = exports('ci', {
              IDGenerator,
              Pool: Pool$1,
              array: jsarray,
              isNumber,
              isString,
              isEmptyObject,
              getPropertyDescriptor,
              addon,
              mixin,
              extend,
              getSuper,
              isChildClassOf,
              clear,
              value,
              getset,
              get,
              set,
              unregisterClass,
              getClassName,
              setClassName,
              setClassAlias,
              getClassByName,

              get _registeredClassNames() {
                return { ..._nameToClass
                };
              },

              set _registeredClassNames(value) {
                clear(_nameToClass);
                Object.assign(_nameToClass, value);
              },

              get _registeredClassIds() {
                return { ..._idToClass
                };
              },

              set _registeredClassIds(value) {
                clear(_idToClass);
                Object.assign(_idToClass, value);
              },

              _getClassId,
              _setClassId,
              _getClassById,
              obsolete,
              obsoletes,
              formatStr,
              shiftArguments,
              createMap
            });
            legacyCC.js = js;

            var js$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                array: array,
                js: js,
                IDGenerator: IDGenerator,
                Pool: Pool$1,
                isNumber: isNumber,
                isString: isString,
                isEmptyObject: isEmptyObject,
                value: value,
                getset: getset,
                get: get,
                set: set,
                createMap: createMap,
                getClassName: getClassName,
                obsolete: obsolete,
                obsoletes: obsoletes,
                formatStr: formatStr,
                shiftArguments: shiftArguments,
                getPropertyDescriptor: getPropertyDescriptor,
                addon: addon,
                mixin: mixin,
                extend: extend,
                getSuper: getSuper,
                isChildClassOf: isChildClassOf,
                clear: clear,
                _idToClass: _idToClass,
                _nameToClass: _nameToClass,
                _setClassId: _setClassId,
                setClassName: setClassName,
                setClassAlias: setClassAlias,
                unregisterClass: unregisterClass,
                _getClassById: _getClassById,
                getClassByName: getClassByName,
                _getClassId: _getClassId
            });
            exports('fl', js$1);

            function BitMask(obj) {
              if ('__bitmask__' in obj) {
                return obj;
              }

              value(obj, '__bitmask__', null, true);
              let lastIndex = -1;
              const keys = Object.keys(obj);

              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                let val = obj[key];

                if (val === -1) {
                  val = ++lastIndex;
                  obj[key] = val;
                } else if (typeof val === 'number') {
                  lastIndex = val;
                } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
                  continue;
                }

                const reverseKey = `${val}`;

                if (key !== reverseKey) {

                  value(obj, reverseKey, key);
                }
              }

              return obj;
            }

            BitMask.isBitMask = BitMaskType => BitMaskType && BitMaskType.hasOwnProperty('__bitmask__');

            BitMask.getList = BitMaskDef => {
              if (BitMaskDef.__bitmask__) {
                return BitMaskDef.__bitmask__;
              }

              const bitlist = BitMaskDef.__bitmask__ = [];

              for (const name in BitMaskDef) {
                const v = BitMaskDef[name];

                if (Number.isInteger(v)) {
                  bitlist.push({
                    name,
                    value: v
                  });
                }
              }

              bitlist.sort((a, b) => a.value - b.value);
              return bitlist;
            };
            legacyCC.BitMask = BitMask;

            function assertIsNonNullable(expr, message) {
              assertIsTrue(!(expr === null || expr === undefined), message);
            }
            function assertIsTrue(expr, message) {
              if ( !expr) {
                throw new Error(`Assertion failed: ${message !== null && message !== void 0 ? message : '<no-message>'}`);
              }
            }

            function Enum(obj) {
              if ('__enums__' in obj) {
                return obj;
              }

              value(obj, '__enums__', null, true);
              return Enum.update(obj);
            }

            Enum.update = obj => {
              let lastIndex = -1;
              const keys = Object.keys(obj);

              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                let val = obj[key];

                if (val === -1) {
                  val = ++lastIndex;
                  obj[key] = val;
                } else if (typeof val === 'number') {
                  lastIndex = val;
                } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
                  continue;
                }

                const reverseKey = `${val}`;

                if (key !== reverseKey) {

                  value(obj, reverseKey, key);
                }
              }

              if (Array.isArray(obj.__enums__)) {
                updateList(obj);
              }

              return obj;
            };

            (function (_Enum) {})(Enum || (Enum = exports('bC', {})));

            Enum.isEnum = enumType => enumType && enumType.hasOwnProperty('__enums__');

            function assertIsEnum(enumType) {
              assertIsTrue(enumType.hasOwnProperty('__enums__'));
            }

            Enum.getList = enumType => {
              assertIsEnum(enumType);

              if (enumType.__enums__) {
                return enumType.__enums__;
              }

              return updateList(enumType);
            };

            function updateList(enumType) {
              assertIsEnum(enumType);
              const enums = enumType.__enums__ || [];
              enums.length = 0;

              for (const name in enumType) {
                const v = enumType[name];

                if (Number.isInteger(v)) {
                  enums.push({
                    name,
                    value: v
                  });
                }
              }

              enums.sort((a, b) => a.value - b.value);
              enumType.__enums__ = enums;
              return enums;
            }

            function ccenum(enumType) {
              if (!('__enums__' in enumType)) {
                value(enumType, '__enums__', null, true);
              }
            }
            legacyCC.Enum = Enum;

            class ValueType {
              clone() {
                errorID(100, `${getClassName(this)}.clone`);
                return this;
              }

              equals(other) {
                return false;
              }

              set(other) {
                errorID(100, `${getClassName(this)}.set`);
              }

              toString() {
                return `${{}}`;
              }

            } exports('fk', ValueType);
            setClassName('cc.ValueType', ValueType);
            legacyCC.ValueType = ValueType;

            const SUPPORT_TEXTURE_FORMATS = ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'];
            const KEY = {
              none: 0,
              back: 6,
              menu: 18,
              backspace: 8,
              tab: 9,
              enter: 13,
              shift: 16,
              ctrl: 17,
              alt: 18,
              pause: 19,
              capslock: 20,
              escape: 27,
              space: 32,
              pageup: 33,
              pagedown: 34,
              end: 35,
              home: 36,
              left: 37,
              up: 38,
              right: 39,
              down: 40,
              select: 41,
              insert: 45,
              Delete: 46,
              0: 48,
              1: 49,
              2: 50,
              3: 51,
              4: 52,
              5: 53,
              6: 54,
              7: 55,
              8: 56,
              9: 57,
              a: 65,
              b: 66,
              c: 67,
              d: 68,
              e: 69,
              f: 70,
              g: 71,
              h: 72,
              i: 73,
              j: 74,
              k: 75,
              l: 76,
              m: 77,
              n: 78,
              o: 79,
              p: 80,
              q: 81,
              r: 82,
              s: 83,
              t: 84,
              u: 85,
              v: 86,
              w: 87,
              x: 88,
              y: 89,
              z: 90,
              num0: 96,
              num1: 97,
              num2: 98,
              num3: 99,
              num4: 100,
              num5: 101,
              num6: 102,
              num7: 103,
              num8: 104,
              num9: 105,
              '*': 106,
              '+': 107,
              '-': 109,
              numdel: 110,
              '/': 111,
              f1: 112,
              f2: 113,
              f3: 114,
              f4: 115,
              f5: 116,
              f6: 117,
              f7: 118,
              f8: 119,
              f9: 120,
              f10: 121,
              f11: 122,
              f12: 123,
              numlock: 144,
              scrolllock: 145,
              ';': 186,
              semicolon: 186,
              equal: 187,
              '=': 187,
              ',': 188,
              comma: 188,
              dash: 189,
              '.': 190,
              period: 190,
              forwardslash: 191,
              grave: 192,
              '[': 219,
              openbracket: 219,
              backslash: 220,
              ']': 221,
              closebracket: 221,
              quote: 222,
              dpadLeft: 1000,
              dpadRight: 1001,
              dpadUp: 1003,
              dpadDown: 1004,
              dpadCenter: 1005
            };
            const macro = exports('bw', {
              SUPPORT_TEXTURE_FORMATS,
              KEY,
              RAD: Math.PI / 180,
              DEG: 180 / Math.PI,
              REPEAT_FOREVER: Number.MAX_VALUE - 1,
              FLT_EPSILON: 0.0000001192092896,
              ORIENTATION_PORTRAIT: 1,
              ORIENTATION_LANDSCAPE: 2,
              ORIENTATION_AUTO: 3,
              ENABLE_TILEDMAP_CULLING: true,
              TOUCH_TIMEOUT: 5000,
              ENABLE_TRANSPARENT_CANVAS: false,
              ENABLE_WEBGL_ANTIALIAS: true,
              ENABLE_ANTIALIAS_FXAA: false,
              ENABLE_BLOOM: false,
              CLEANUP_IMAGE_CACHE: false,
              ENABLE_MULTI_TOUCH: true,
              MAX_LABEL_CANVAS_POOL_SIZE: 20,
              ENABLE_WEBGL_HIGHP_STRUCT_VALUES: false
            });
            legacyCC.macro = macro;

            const BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
            const BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            const values = new Array(123);

            for (let i = 0; i < 123; ++i) {
              values[i] = 64;
            }

            for (let i = 0; i < 64; ++i) {
              values[BASE64_KEYS.charCodeAt(i)] = i;
            }

            const BASE64_VALUES = values;
            function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
              function define(np, propName, getter, setter) {
                const pd = Object.getOwnPropertyDescriptor(np, propName);

                if (pd) {
                  if (pd.get) {
                    np[getter] = pd.get;
                  }

                  if (pd.set && setter) {
                    np[setter] = pd.set;
                  }
                } else {
                  const getterFunc = np[getter];

                  {
                    getset(np, propName, getterFunc, np[setter]);
                  }
                }
              }

              let propName;
              const np = ctor.prototype;

              for (let i = 0; i < sameNameGetSets.length; i++) {
                propName = sameNameGetSets[i];
                const suffix = propName[0].toUpperCase() + propName.slice(1);
                define(np, propName, `get${suffix}`, `set${suffix}`);
              }

              for (propName in diffNameGetSets) {
                const gs = diffNameGetSets[propName];
                define(np, propName, gs[0], gs[1]);
              }
            }
            function pushToMap(map, key, value, pushFront) {
              const exists = map[key];

              if (exists) {
                if (Array.isArray(exists)) {
                  if (pushFront) {
                    exists.push(exists[0]);
                    exists[0] = value;
                  } else {
                    exists.push(value);
                  }
                } else {
                  map[key] = pushFront ? [value, exists] : [exists, value];
                }
              } else {
                map[key] = value;
              }
            }
            function contains$1(refNode, otherNode) {
              if (typeof refNode.contains === 'function') {
                return refNode.contains(otherNode);
              } else if (typeof refNode.compareDocumentPosition === 'function') {
                return !!(refNode.compareDocumentPosition(otherNode) & 16);
              } else {
                let node = otherNode.parentNode;

                if (node) {
                  do {
                    if (node === refNode) {
                      return true;
                    } else {
                      node = node.parentNode;
                    }
                  } while (node !== null);
                }

                return false;
              }
            }
            function isDomNode(obj) {
              if (typeof window === 'object' && typeof Node === 'function') {
                return obj instanceof Node;
              } else {
                return obj && typeof obj === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
              }
            }
            function callInNextTick(callback, p1, p2) {
              if (callback) {
                setTimeout(() => {
                  callback(p1, p2);
                }, 0);
              }
            }
            function tryCatchFunctor_EDITOR(funcName) {
              return Function('target', `${'try {\n' + '  target.'}${funcName}();\n` + `}\n` + `catch (e) {\n` + `  cc._throw(e);\n` + `}`);
            }
            function isPlainEmptyObj_DEV(obj) {
              if (!obj || obj.constructor !== Object) {
                return false;
              }

              return isEmptyObject(obj);
            }
            function clampf(value, min_inclusive, max_inclusive) {
              if (min_inclusive > max_inclusive) {
                const temp = min_inclusive;
                min_inclusive = max_inclusive;
                max_inclusive = temp;
              }

              return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
            }
            function degreesToRadians(angle) {
              return angle * macro.RAD;
            }
            function radiansToDegrees(angle) {
              return angle * macro.DEG;
            }
            legacyCC.misc = {
              BUILTIN_CLASSID_RE,
              BASE64_VALUES,
              propertyDefine,
              pushToMap,
              contains: contains$1,
              isDomNode,
              callInNextTick,
              isPlainEmptyObj_DEV,
              clampf,
              degreesToRadians,
              radiansToDegrees
            };

            var misc = /*#__PURE__*/Object.freeze({
                __proto__: null,
                BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
                BASE64_VALUES: BASE64_VALUES,
                propertyDefine: propertyDefine,
                pushToMap: pushToMap,
                contains: contains$1,
                isDomNode: isDomNode,
                callInNextTick: callInNextTick,
                tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
                isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
                clampf: clampf,
                degreesToRadians: degreesToRadians,
                radiansToDegrees: radiansToDegrees
            });
            exports('fm', misc);

            const DELIMETER = '$_$';
            function createAttrsSingle(owner, superAttrs) {
              const attrs = superAttrs ? Object.create(superAttrs) : {};
              value(owner, '__attrs__', attrs);
              return attrs;
            }
            function createAttrs(subclass) {
              if (typeof subclass !== 'function') {
                const instance = subclass;
                return createAttrsSingle(instance, getClassAttrs(instance.constructor));
              }

              let superClass;
              const chains = legacyCC.Class.getInheritanceChain(subclass);

              for (let i = chains.length - 1; i >= 0; i--) {
                const cls = chains[i];

                const attrs = cls.hasOwnProperty('__attrs__') && cls.__attrs__;

                if (!attrs) {
                  superClass = chains[i + 1];
                  createAttrsSingle(cls, superClass && superClass.__attrs__);
                }
              }

              superClass = chains[0];
              createAttrsSingle(subclass, superClass && superClass.__attrs__);
              return subclass.__attrs__;
            }
            function attr(constructor, propertyName) {
              const attrs = getClassAttrs(constructor);
              const prefix = propertyName + DELIMETER;
              const ret = {};

              for (const key in attrs) {
                if (key.startsWith(prefix)) {
                  ret[key.slice(prefix.length)] = attrs[key];
                }
              }

              return ret;
            }
            function getClassAttrs(constructor) {
              return constructor.hasOwnProperty('__attrs__') && constructor.__attrs__ || createAttrs(constructor);
            }
            function setClassAttr(ctor, propName, key, value) {
              getClassAttrs(ctor)[propName + DELIMETER + key] = value;
            }
            class PrimitiveType {
              constructor(name, defaultValue) {
                this.name = void 0;
                this.default = void 0;
                this.name = name;
                this.default = defaultValue;
              }

              toString() {
                return this.name;
              }

            }
            const CCInteger = exports('eV', new PrimitiveType('Integer', 0));
            legacyCC.Integer = CCInteger;
            legacyCC.CCInteger = CCInteger;
            const CCFloat = exports('dN', new PrimitiveType('Float', 0.0));
            legacyCC.Float = CCFloat;
            legacyCC.CCFloat = CCFloat;

            const CCBoolean = exports('dM', new PrimitiveType('Boolean', false));
            legacyCC.Boolean = CCBoolean;
            legacyCC.CCBoolean = CCBoolean;
            const CCString = exports('cV', new PrimitiveType('String', ''));
            legacyCC.String = CCString;
            legacyCC.CCString = CCString;
            function getTypeChecker_ET(type, attributeName) {
              return function (constructor, mainPropertyName) {
                const propInfo = `"${getClassName(constructor)}.${mainPropertyName}"`;
                const mainPropAttrs = attr(constructor, mainPropertyName);
                let mainPropAttrsType = mainPropAttrs.type;

                if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat) {
                  mainPropAttrsType = 'Number';
                } else if (mainPropAttrsType === CCString || mainPropAttrsType === CCBoolean) {
                  mainPropAttrsType = `${mainPropAttrsType}`;
                }

                if (mainPropAttrsType !== type) {
                  warnID(3604, propInfo);
                  return;
                }

                if (!mainPropAttrs.hasOwnProperty('default')) {
                  return;
                }

                const defaultVal = mainPropAttrs.default;

                if (typeof defaultVal === 'undefined') {
                  return;
                }

                const isContainer = Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal);

                if (isContainer) {
                  return;
                }

                const defaultType = typeof defaultVal;
                const type_lowerCase = type.toLowerCase();

                if (defaultType === type_lowerCase) {
                  if (type_lowerCase === 'object') {
                    if (defaultVal && !(defaultVal instanceof mainPropAttrs.ctor)) {
                      warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
                    } else {
                      return;
                    }
                  } else if (type !== 'Number') {
                    warnID(3606, attributeName, propInfo, type);
                  }
                } else if (defaultType !== 'function') {
                  if (type === CCString.default && defaultVal == null) {
                    warnID(3607, propInfo);
                  } else {
                    warnID(3611, attributeName, propInfo, defaultType);
                  }
                } else {
                  return;
                }

                delete mainPropAttrs.type;
              };
            }
            function getObjTypeChecker_ET(typeCtor) {
              return function (classCtor, mainPropName) {
                getTypeChecker_ET('Object', 'type')(classCtor, mainPropName);
                const defaultDef = getClassAttrs(classCtor)[`${mainPropName + DELIMETER}default`];
                const defaultVal = legacyCC.Class.getDefault(defaultDef);

                if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, legacyCC.ValueType)) {
                  const typename = getClassName(typeCtor);
                  const info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);

                  if (defaultDef) {
                    log(info);
                  } else {
                    warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
                  }
                }
              };
            }

            var attributeUtils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                DELIMETER: DELIMETER,
                createAttrsSingle: createAttrsSingle,
                createAttrs: createAttrs,
                attr: attr,
                getClassAttrs: getClassAttrs,
                setClassAttr: setClassAttr,
                PrimitiveType: PrimitiveType,
                CCInteger: CCInteger,
                CCFloat: CCFloat,
                CCBoolean: CCBoolean,
                CCString: CCString,
                getTypeChecker_ET: getTypeChecker_ET,
                getObjTypeChecker_ET: getObjTypeChecker_ET
            });

            const SerializableAttrs = {
              default: {},
              serializable: {},
              editorOnly: {},
              formerlySerializedAs: {}
            };

            function parseNotify(val, propName, notify, properties) {
              if (val.get || val.set) {

                return;
              }

              if (val.hasOwnProperty('default')) {
                const newKey = `_N$${propName}`;

                val.get = function () {
                  return this[newKey];
                };

                val.set = function (value) {
                  const oldValue = this[newKey];
                  this[newKey] = value;
                  notify.call(this, oldValue);
                };

                const newValue = {};
                properties[newKey] = newValue;

                for (const attr in SerializableAttrs) {
                  const v = SerializableAttrs[attr];

                  if (val.hasOwnProperty(attr)) {
                    newValue[attr] = val[attr];

                    if (!v.canUsedInGet) {
                      delete val[attr];
                    }
                  }
                }
              }
            }

            function parseType(val, type, className, propName) {

              if (Array.isArray(type)) {

                if (type.length > 0) {
                  val.type = type = type[0];
                } else {
                  return errorID(5508, className, propName);
                }
              }

              if (typeof type === 'function') {
                if (type === String) {
                  val.type = legacyCC.String;
                } else if (type === Boolean) {
                  val.type = legacyCC.Boolean;
                } else if (type === Number) {
                  val.type = legacyCC.Float;
                }
              }
            }

            function _wrapOptions(isGetset, _default, type) {
              const res = isGetset ? {
                _short: true
              } : {
                _short: true,
                default: _default
              };

              if (type) {
                res.type = type;
              }

              return res;
            }

            function getFullFormOfProperty(options, isGetset) {
              const isLiteral = options && options.constructor === Object;

              if (!isLiteral) {
                if (Array.isArray(options) && options.length > 0) {
                  return _wrapOptions(isGetset, [], options);
                } else if (typeof options === 'function') {
                  const type = options;
                  return _wrapOptions(isGetset, isChildClassOf(type, legacyCC.ValueType) ? new type() : null, type);
                } else if (options instanceof PrimitiveType) {
                  return _wrapOptions(isGetset, options.default);
                } else {
                  return _wrapOptions(isGetset, options);
                }
              }

              return null;
            }
            function preprocessAttrs(properties, className, cls) {
              for (const propName in properties) {
                let val = properties[propName];
                const fullForm = getFullFormOfProperty(val, false);

                if (fullForm) {
                  val = properties[propName] = fullForm;
                }

                if (val) {

                  const notify = val.notify;

                  if (notify) {
                    {
                      parseNotify(val, propName, notify, properties);
                    }
                  }

                  if ('type' in val) {
                    parseType(val, val.type, className, propName);
                  }
                }
              }
            }

            let requiringFrames = [];
            function push(module, uuid, script, importMeta) {
              if (script === undefined) {
                script = uuid;
                uuid = '';
              }

              requiringFrames.push({
                uuid,
                script,
                module,
                exports: module.exports,
                beh: null,
                importMeta
              });
            }
            function pop() {
              const frameInfo = requiringFrames.pop();
              const module = frameInfo.module;
              let exports = module.exports;

              if (exports === frameInfo.exports) {
                for (const anykey in exports) {
                  return;
                }

                module.exports = exports = frameInfo.cls;
              }
            }
            function peek() {
              return requiringFrames[requiringFrames.length - 1];
            }
            legacyCC._RF = {
              push,
              pop,
              peek
            };

            let PropertyStashInternalFlag;

            (function (PropertyStashInternalFlag) {
              PropertyStashInternalFlag[PropertyStashInternalFlag["STANDALONE"] = 1] = "STANDALONE";
              PropertyStashInternalFlag[PropertyStashInternalFlag["IMPLICIT_VISIBLE"] = 2] = "IMPLICIT_VISIBLE";
              PropertyStashInternalFlag[PropertyStashInternalFlag["IMPLICIT_SERIALIZABLE"] = 4] = "IMPLICIT_SERIALIZABLE";
            })(PropertyStashInternalFlag || (PropertyStashInternalFlag = {}));

            const DELIMETER$1 = DELIMETER;

            function pushUnique(array, item) {
              if (array.indexOf(item) < 0) {
                array.push(item);
              }
            }

            const deferredInitializer = {
              datas: null,

              push(data) {
                if (this.datas) {
                  this.datas.push(data);
                } else {
                  this.datas = [data];
                  const self = this;
                  setTimeout(() => {
                    self.init();
                  }, 0);
                }
              },

              init() {
                const datas = this.datas;

                if (datas) {
                  for (let i = 0; i < datas.length; ++i) {
                    const data = datas[i];
                    const cls = data.cls;
                    let properties = data.props;

                    if (typeof properties === 'function') {
                      properties = properties();
                    }

                    const name = getClassName(cls);

                    if (properties) {
                      declareProperties(cls, name, properties, cls.$super, data.mixins);
                    } else {
                      errorID(3633, name);
                    }
                  }

                  this.datas = null;
                }
              }

            };

            function appendProp(cls, name) {

              pushUnique(cls.__props__, name);
            }

            function defineProp(cls, className, propName, val) {

              appendProp(cls, propName);
              parseAttributes(cls, val, className, propName);
            }

            function defineGetSet(cls, name, propName, val) {
              const getter = val.get;
              const setter = val.set;

              if (getter) {
                parseAttributes(cls, val, name, propName);

                setClassAttr(cls, propName, 'serializable', false);
              }
            }

            function getDefault(defaultVal) {
              if (typeof defaultVal === 'function') {
                {
                  return defaultVal();
                }
              }

              return defaultVal;
            }

            function mixinWithInherited(dest, src, filter) {
              for (const prop in src) {
                if (!dest.hasOwnProperty(prop) && (!filter || filter(prop))) {
                  Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
                }
              }
            }

            function doDefine(className, baseClass, mixins, options) {
              const ctor = options.ctor;

              const ctors = [ctor];
              const fireClass = ctor;
              value(fireClass, '__ctors__', ctors.length > 0 ? ctors : null, true);
              const prototype = fireClass.prototype;

              if (baseClass) {
                fireClass.$super = baseClass;
              }

              if (mixins) {
                for (let m = mixins.length - 1; m >= 0; m--) {
                  const mixin = mixins[m];
                  mixinWithInherited(prototype, mixin.prototype);

                  if (CCClass._isCCClass(mixin)) {
                    mixinWithInherited(getClassAttrs(fireClass), getClassAttrs(mixin));
                  }
                }

                prototype.constructor = fireClass;
              }

              setClassName(className, fireClass);
              return fireClass;
            }

            function define(className, baseClass, mixins, options) {
              const Component = legacyCC.Component;
              const frame = peek();

              if (frame && isChildClassOf(baseClass, Component)) {
                if (isChildClassOf(frame.cls, Component)) {
                  errorID(3615);
                  return null;
                }

                className = className || frame.script;
              }

              const cls = doDefine(className, baseClass, mixins, options);

              if (frame) {
                if (isChildClassOf(baseClass, Component)) {
                  const uuid = frame.uuid;

                  if (uuid) {
                    _setClassId(uuid, cls);
                  }

                  frame.cls = cls;
                } else if (!isChildClassOf(frame.cls, Component)) {
                  frame.cls = cls;
                }
              }

              return cls;
            }

            function getNewValueTypeCodeJit(value) {
              const clsName = getClassName(value);
              const type = value.constructor;
              let res = `new ${clsName}(`;

              for (let i = 0; i < type.__props__.length; i++) {
                const prop = type.__props__[i];
                const propVal = value[prop];

                res += propVal;

                if (i < type.__props__.length - 1) {
                  res += ',';
                }
              }

              return `${res})`;
            }

            function escapeForJS(s) {
              return JSON.stringify(s).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
            }

            const IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;

            function declareProperties(cls, className, properties, baseClass, mixins) {
              cls.__props__ = [];

              if (baseClass && baseClass.__props__) {
                cls.__props__ = baseClass.__props__.slice();
              }

              if (mixins) {
                for (let m = 0; m < mixins.length; ++m) {
                  const mixin = mixins[m];

                  if (mixin.__props__) {
                    cls.__props__ = cls.__props__.concat(mixin.__props__.filter(x => cls.__props__.indexOf(x) < 0));
                  }
                }
              }

              if (properties) {
                preprocessAttrs(properties, className);

                for (const propName in properties) {
                  const val = properties[propName];

                  if (!val.get && !val.set) {
                    defineProp(cls, className, propName, val);
                  } else {
                    defineGetSet(cls, className, propName, val);
                  }
                }
              }

              const attrs = getClassAttrs(cls);
              cls.__values__ = cls.__props__.filter(prop => attrs[`${prop + DELIMETER$1}serializable`] !== false);
            }

            function CCClass(options) {
              let name = options.name;
              const base = options.extends;
              const mixins = options.mixins;
              const cls = define(name, base, mixins, options);

              if (!name) {
                name = legacyCC.js.getClassName(cls);
              }

              cls._sealed = true;

              if (base) {
                base._sealed = false;
              }

              const properties = options.properties;

              if (typeof properties === 'function' || base && base.__props__ === null || mixins && mixins.some(x => x.__props__ === null)) {
                {
                  deferredInitializer.push({
                    cls,
                    props: properties,
                    mixins
                  });
                  cls.__props__ = cls.__values__ = null;
                }
              } else {
                declareProperties(cls, name, properties, base, options.mixins);
              }

              const editor = options.editor;

              if (editor) {
                if (isChildClassOf(base, legacyCC.Component)) {
                  legacyCC.Component._registerEditorProps(cls, editor);
                }
              }

              return cls;
            }

            CCClass._isCCClass = function isCCClass(constructor) {
              var _constructor$hasOwnPr;

              return constructor === null || constructor === void 0 ? void 0 : (_constructor$hasOwnPr = constructor.hasOwnProperty) === null || _constructor$hasOwnPr === void 0 ? void 0 : _constructor$hasOwnPr.call(constructor, '__ctors__');
            };

            CCClass.fastDefine = function (className, constructor, serializableFields) {
              setClassName(className, constructor);
              const props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
              const attrs = getClassAttrs(constructor);

              for (let i = 0; i < props.length; i++) {
                const key = props[i];
                attrs[`${key + DELIMETER$1}visible`] = false;
                attrs[`${key + DELIMETER$1}default`] = serializableFields[key];
              }
            };

            CCClass.Attr = attributeUtils;
            CCClass.attr = attr;

            function getInheritanceChain(constructor) {
              const chain = [];

              for (;;) {
                constructor = getSuper(constructor);

                if (!constructor) {
                  break;
                }

                if (constructor !== Object) {
                  chain.push(constructor);
                }
              }

              return chain;
            }

            CCClass.getInheritanceChain = getInheritanceChain;
            const PrimitiveTypes = {
              Integer: 'Number',
              Float: 'Number',
              Boolean: 'Boolean',
              String: 'String'
            };

            function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
              let attrs = null;
              let propertyNamePrefix = '';

              function initAttrs() {
                propertyNamePrefix = propertyName + DELIMETER$1;
                return attrs = getClassAttrs(constructor);
              }

              if ('type' in attributes && typeof attributes.type === 'undefined') {
                warnID(3660, propertyName, className);
              }
              const type = attributes.type;

              if (type) {
                const primitiveType = PrimitiveTypes[type];

                if (primitiveType) {
                  (attrs || initAttrs())[`${propertyNamePrefix}type`] = type;
                } else if (type === 'Object') ; else if (typeof type === 'object') {
                    if (Enum.isEnum(type)) {
                      (attrs || initAttrs())[`${propertyNamePrefix}type`] = 'Enum';
                      attrs[`${propertyNamePrefix}enumList`] = Enum.getList(type);
                    } else if (BitMask.isBitMask(type)) {
                      (attrs || initAttrs())[`${propertyNamePrefix}type`] = 'BitMask';
                      attrs[`${propertyNamePrefix}bitmaskList`] = BitMask.getList(type);
                    } else ;
                  } else if (typeof type === 'function') {
                    (attrs || initAttrs())[`${propertyNamePrefix}type`] = 'Object';
                    attrs[`${propertyNamePrefix}ctor`] = type;
                  } else ;
              }

              if ('default' in attributes) {
                (attrs || initAttrs())[`${propertyNamePrefix}default`] = attributes.default;
              }

              const parseSimpleAttribute = (attributeName, expectType) => {
                if (attributeName in attributes) {
                  const val = attributes[attributeName];

                  if (typeof val === expectType) {
                    (attrs || initAttrs())[propertyNamePrefix + attributeName] = val;
                  }
                }
              };

              if (attributes.editorOnly) {
                {
                  (attrs || initAttrs())[`${propertyNamePrefix}editorOnly`] = true;
                }
              }

              const isStandaloneMode = attributes.__internalFlags & PropertyStashInternalFlag.STANDALONE;
              let normalizedSerializable;

              if (isStandaloneMode) {
                normalizedSerializable = attributes.serializable === true || (attributes.__internalFlags & PropertyStashInternalFlag.IMPLICIT_SERIALIZABLE) !== 0;
              } else if (attributes.serializable === false) {
                normalizedSerializable = false;
              }

              if (typeof normalizedSerializable !== 'undefined') {
                (attrs || initAttrs())[`${propertyNamePrefix}serializable`] = normalizedSerializable;
              }

              parseSimpleAttribute('formerlySerializedAs', 'string');

              const range = attributes.range;

              if (range) {
                if (Array.isArray(range)) {
                  if (range.length >= 2) {
                    (attrs || initAttrs())[`${propertyNamePrefix}min`] = range[0];
                    attrs[`${propertyNamePrefix}max`] = range[1];

                    if (range.length > 2) {
                      attrs[`${propertyNamePrefix}step`] = range[2];
                    }
                  }
                }
              }

              parseSimpleAttribute('min', 'number');
              parseSimpleAttribute('max', 'number');
              parseSimpleAttribute('step', 'number');
            }

            CCClass.isArray = function (defaultVal) {
              defaultVal = getDefault(defaultVal);
              return Array.isArray(defaultVal);
            };

            CCClass.getDefault = getDefault;
            CCClass.escapeForJS = escapeForJS;
            CCClass.IDENTIFIER_RE = IDENTIFIER_RE;
            CCClass.getNewValueTypeCode =  getNewValueTypeCodeJit;
            legacyCC.Class = CCClass;

            const editorExtrasTag = exports('fy', '__editorExtras__');

            const Destroyed = 1 << 0;
            const ToDestroy = 1 << 2;
            const DontSave = 1 << 3;
            const EditorOnly = 1 << 4;
            const Dirty = 1 << 5;
            const DontDestroy = 1 << 6;
            const Destroying = 1 << 7;
            const Deactivating = 1 << 8;
            const LockedInEditor = 1 << 9;
            const HideInHierarchy = 1 << 10;
            const IsOnEnableCalled = 1 << 11;
            const IsEditorOnEnableCalled = 1 << 12;
            const IsPreloadStarted = 1 << 13;
            const IsOnLoadCalled = 1 << 14;
            const IsOnLoadStarted = 1 << 15;
            const IsStartCalled = 1 << 16;
            const IsRotationLocked = 1 << 17;
            const IsScaleLocked = 1 << 18;
            const IsAnchorLocked = 1 << 19;
            const IsSizeLocked = 1 << 20;
            const IsPositionLocked = 1 << 21;
            const IsReplicated = 1 << 22;
            const PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
            const AllHideMasks = DontSave | EditorOnly | LockedInEditor | HideInHierarchy;
            const objectsToDestroy = [];

            function compileDestruct(obj, ctor) {
              const shouldSkipId = obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component;
              const idToSkip = shouldSkipId ? '_id' : null;
              let key;
              const propsToReset = {};

              for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                  if (key === idToSkip) {
                    continue;
                  }

                  switch (typeof obj[key]) {
                    case 'string':
                      propsToReset[key] = '';
                      break;

                    case 'object':
                    case 'function':
                      propsToReset[key] = null;
                      break;
                  }
                }
              }

              if (CCClass._isCCClass(ctor)) {
                const attrs = legacyCC.Class.Attr.getClassAttrs(ctor);
                const propList = ctor.__props__;

                for (let i = 0; i < propList.length; i++) {
                  key = propList[i];
                  const attrKey = `${key + legacyCC.Class.Attr.DELIMETER}default`;

                  if (attrKey in attrs) {
                    if (shouldSkipId && key === '_id') {
                      continue;
                    }

                    switch (typeof attrs[attrKey]) {
                      case 'string':
                        propsToReset[key] = '';
                        break;

                      case 'object':
                      case 'function':
                        propsToReset[key] = null;
                        break;

                      case 'undefined':
                        propsToReset[key] = undefined;
                        break;
                    }
                  }
                }
              }

              {
                let func = '';

                for (key in propsToReset) {
                  let statement;

                  if (CCClass.IDENTIFIER_RE.test(key)) {
                    statement = `o.${key}=`;
                  } else {
                    statement = `o[${CCClass.escapeForJS(key)}]=`;
                  }

                  let val = propsToReset[key];

                  if (val === '') {
                    val = '""';
                  }

                  func += `${statement + val};\n`;
                }

                return Function('o', func);
              }
            }

            class CCObject {
              static _deferredDestroy() {
                const deleteCount = objectsToDestroy.length;

                for (let i = 0; i < deleteCount; ++i) {
                  const obj = objectsToDestroy[i];

                  if (!(obj._objFlags & Destroyed)) {
                    obj._destroyImmediate();
                  }
                }

                if (deleteCount === objectsToDestroy.length) {
                  objectsToDestroy.length = 0;
                } else {
                  objectsToDestroy.splice(0, deleteCount);
                }
              }

              constructor(name = '') {
                this._objFlags = void 0;
                this._name = void 0;
                this._name = name;
                this._objFlags = 0;
              }

              get name() {
                return this._name;
              }

              set name(value) {
                this._name = value;
              }

              set hideFlags(hideFlags) {
                const flags = hideFlags & CCObject.Flags.AllHideMasks;
                this._objFlags = this._objFlags & ~CCObject.Flags.AllHideMasks | flags;
              }

              get hideFlags() {
                return this._objFlags & CCObject.Flags.AllHideMasks;
              }

              set replicated(value) {
                if (value) {
                  this._objFlags |= IsReplicated;
                } else {
                  this._objFlags &= ~IsReplicated;
                }
              }

              get replicated() {
                return !!(this._objFlags & IsReplicated);
              }

              get isValid() {
                return !(this._objFlags & Destroyed);
              }

              destroy() {
                if (this._objFlags & Destroyed) {
                  warnID(5000);
                  return false;
                }

                if (this._objFlags & ToDestroy) {
                  return false;
                }

                this._objFlags |= ToDestroy;
                objectsToDestroy.push(this);

                return true;
              }

              _destruct() {
                const ctor = this.constructor;
                let destruct = ctor.__destruct__;

                if (!destruct) {
                  destruct = compileDestruct(this, ctor);
                  value(ctor, '__destruct__', destruct, true);
                }

                destruct(this);
              }

              _destroyImmediate() {
                if (this._objFlags & Destroyed) {
                  errorID(5000);
                  return;
                }

                if (this._onPreDestroy) {
                  this._onPreDestroy();
                }

                {
                  this._destruct();
                }

                this._objFlags |= Destroyed;
              }

            } exports('ck', CCObject);

            const prototype = CCObject.prototype;

            prototype._deserialize = null;
            prototype._onPreDestroy = null;
            CCClass.fastDefine('cc.Object', CCObject, {
              _name: '',
              _objFlags: 0,
              [editorExtrasTag]: {}
            });
            CCClass.Attr.setClassAttr(CCObject, editorExtrasTag, 'editorOnly', true);
            CCClass.Attr.setClassAttr(CCObject, 'replicated', 'visible', false);
            value(CCObject, 'Flags', {
              Destroyed,
              DontSave,
              EditorOnly,
              Dirty,
              DontDestroy,
              PersistentMask,
              Destroying,
              Deactivating,
              LockedInEditor,
              HideInHierarchy,
              AllHideMasks,
              IsPreloadStarted,
              IsOnLoadStarted,
              IsOnLoadCalled,
              IsOnEnableCalled,
              IsStartCalled,
              IsEditorOnEnableCalled,
              IsPositionLocked,
              IsRotationLocked,
              IsScaleLocked,
              IsAnchorLocked,
              IsSizeLocked
            });
            function isValid(value, strictMode) {
              if (typeof value === 'object') {
                return !!value && !(value._objFlags & (strictMode ? Destroyed | ToDestroy : Destroyed));
              } else {
                return typeof value !== 'undefined';
              }
            }
            legacyCC.isValid = isValid;

            legacyCC.Object = CCObject;

            const fastRemoveAt$1 = array.fastRemoveAt;

            function empty() {}

            class CallbackInfo {
              constructor() {
                this.callback = empty;
                this.target = undefined;
                this.once = false;
              }

              set(callback, target, once) {
                this.callback = callback || empty;
                this.target = target;
                this.once = !!once;
              }

              reset() {
                this.target = undefined;
                this.callback = empty;
                this.once = false;
              }

              check() {
                if (this.target instanceof CCObject && !isValid(this.target, true)) {
                  return false;
                } else {
                  return true;
                }
              }

            }

            const callbackInfoPool = new Pool(() => new CallbackInfo(), 32);
            class CallbackList {
              constructor() {
                this.callbackInfos = [];
                this.isInvoking = false;
                this.containCanceled = false;
              }

              removeByCallback(cb) {
                for (let i = 0; i < this.callbackInfos.length; ++i) {
                  const info = this.callbackInfos[i];

                  if (info && info.callback === cb) {
                    info.reset();
                    callbackInfoPool.free(info);
                    fastRemoveAt$1(this.callbackInfos, i);
                    --i;
                  }
                }
              }

              removeByTarget(target) {
                for (let i = 0; i < this.callbackInfos.length; ++i) {
                  const info = this.callbackInfos[i];

                  if (info && info.target === target) {
                    info.reset();
                    callbackInfoPool.free(info);
                    fastRemoveAt$1(this.callbackInfos, i);
                    --i;
                  }
                }
              }

              cancel(index) {
                const info = this.callbackInfos[index];

                if (info) {
                  info.reset();

                  if (this.isInvoking) {
                    this.callbackInfos[index] = null;
                  } else {
                    fastRemoveAt$1(this.callbackInfos, index);
                  }

                  callbackInfoPool.free(info);
                }

                this.containCanceled = true;
              }

              cancelAll() {
                for (let i = 0; i < this.callbackInfos.length; i++) {
                  const info = this.callbackInfos[i];

                  if (info) {
                    info.reset();
                    callbackInfoPool.free(info);
                    this.callbackInfos[i] = null;
                  }
                }

                this.containCanceled = true;
              }

              purgeCanceled() {
                for (let i = this.callbackInfos.length - 1; i >= 0; --i) {
                  const info = this.callbackInfos[i];

                  if (!info) {
                    fastRemoveAt$1(this.callbackInfos, i);
                  }
                }

                this.containCanceled = false;
              }

              clear() {
                this.cancelAll();
                this.callbackInfos.length = 0;
                this.isInvoking = false;
                this.containCanceled = false;
              }

            }
            const MAX_SIZE = 16;
            const callbackListPool = new Pool(() => new CallbackList(), MAX_SIZE);
            class CallbacksInvoker {
              constructor() {
                this._callbackTable = createMap(true);
                this._offCallback = void 0;
              }

              on(key, callback, target, once) {
                if (!this.hasEventListener(key, callback, target)) {
                  let list = this._callbackTable[key];

                  if (!list) {
                    list = this._callbackTable[key] = callbackListPool.alloc();
                  }

                  const info = callbackInfoPool.alloc();
                  info.set(callback, target, once);
                  list.callbackInfos.push(info);
                }

                return callback;
              }

              hasEventListener(key, callback, target) {
                const list = this._callbackTable && this._callbackTable[key];

                if (!list) {
                  return false;
                }

                const infos = list.callbackInfos;

                if (!callback) {
                  if (list.isInvoking) {
                    for (let i = 0; i < infos.length; ++i) {
                      if (infos[i]) {
                        return true;
                      }
                    }

                    return false;
                  } else {
                    return infos.length > 0;
                  }
                }

                for (let i = 0; i < infos.length; ++i) {
                  const info = infos[i];

                  if (info && info.check() && info.callback === callback && info.target === target) {
                    return true;
                  }
                }

                return false;
              }

              removeAll(keyOrTarget) {
                const type = typeof keyOrTarget;

                if (type === 'string' || type === 'number') {
                  const list = this._callbackTable && this._callbackTable[keyOrTarget];

                  if (list) {
                    if (list.isInvoking) {
                      list.cancelAll();
                    } else {
                      list.clear();
                      callbackListPool.free(list);
                      delete this._callbackTable[keyOrTarget];
                    }
                  }
                } else if (keyOrTarget) {
                  for (const key in this._callbackTable) {
                    const list = this._callbackTable[key];

                    if (list.isInvoking) {
                      const infos = list.callbackInfos;

                      for (let i = 0; i < infos.length; ++i) {
                        const info = infos[i];

                        if (info && info.target === keyOrTarget) {
                          list.cancel(i);
                        }
                      }
                    } else {
                      list.removeByTarget(keyOrTarget);
                    }
                  }
                }
              }

              off(key, callback, target) {
                var _this$_offCallback;

                const list = this._callbackTable && this._callbackTable[key];

                if (list) {
                  const infos = list.callbackInfos;

                  if (callback) {
                    for (let i = 0; i < infos.length; ++i) {
                      const info = infos[i];

                      if (info && info.callback === callback && info.target === target) {
                        list.cancel(i);
                        break;
                      }
                    }
                  } else {
                    this.removeAll(key);
                  }
                }

                (_this$_offCallback = this._offCallback) === null || _this$_offCallback === void 0 ? void 0 : _this$_offCallback.call(this);
              }

              emit(key, arg0, arg1, arg2, arg3, arg4) {
                const list = this._callbackTable && this._callbackTable[key];

                if (list) {
                  const rootInvoker = !list.isInvoking;
                  list.isInvoking = true;
                  const infos = list.callbackInfos;

                  for (let i = 0, len = infos.length; i < len; ++i) {
                    const info = infos[i];

                    if (info) {
                      const callback = info.callback;
                      const target = info.target;

                      if (info.once) {
                        this.off(key, callback, target);
                      }

                      if (!info.check()) {
                        this.off(key, callback, target);
                      } else if (target) {
                        callback.call(target, arg0, arg1, arg2, arg3, arg4);
                      } else {
                        callback(arg0, arg1, arg2, arg3, arg4);
                      }
                    }
                  }

                  if (rootInvoker) {
                    list.isInvoking = false;

                    if (list.containCanceled) {
                      list.purgeCanceled();
                    }
                  }
                }
              }

              clear() {
                for (const key in this._callbackTable) {
                  const list = this._callbackTable[key];

                  if (list) {
                    list.clear();
                    callbackListPool.free(list);
                    delete this._callbackTable[key];
                  }
                }
              }

              _registerOffCallback(cb) {
                this._offCallback = cb;
              }

            }

            function Eventify(base) {
              class Eventified extends base {
                constructor(...args) {
                  super(...args);
                  this._callbackTable = createMap(true);
                }

                once(type, callback, target) {
                  return this.on(type, callback, target, true);
                }

                targetOff(typeOrTarget) {
                  this.removeAll(typeOrTarget);
                }

              }

              const callbacksInvokerPrototype = CallbacksInvoker.prototype;
              const propertyKeys = Object.getOwnPropertyNames(callbacksInvokerPrototype).concat(Object.getOwnPropertySymbols(callbacksInvokerPrototype));

              for (let iPropertyKey = 0; iPropertyKey < propertyKeys.length; ++iPropertyKey) {
                const propertyKey = propertyKeys[iPropertyKey];

                if (!(propertyKey in Eventified.prototype)) {
                  const propertyDescriptor = Object.getOwnPropertyDescriptor(callbacksInvokerPrototype, propertyKey);

                  if (propertyDescriptor) {
                    Object.defineProperty(Eventified.prototype, propertyKey, propertyDescriptor);
                  }
                }
              }

              return Eventified;
            }

            class Empty {}

            const EventTarget = exports('c5', Eventify(Empty));
            legacyCC.EventTarget = EventTarget;

            let BrowserType;

            (function (BrowserType) {
              BrowserType["UNKNOWN"] = "unknown";
              BrowserType["WECHAT"] = "wechat";
              BrowserType["ANDROID"] = "androidbrowser";
              BrowserType["IE"] = "ie";
              BrowserType["EDGE"] = "edge";
              BrowserType["QQ"] = "qqbrowser";
              BrowserType["MOBILE_QQ"] = "mqqbrowser";
              BrowserType["UC"] = "ucbrowser";
              BrowserType["UCBS"] = "ucbs";
              BrowserType["BROWSER_360"] = "360browser";
              BrowserType["BAIDU_APP"] = "baiduboxapp";
              BrowserType["BAIDU"] = "baidubrowser";
              BrowserType["MAXTHON"] = "maxthon";
              BrowserType["OPERA"] = "opera";
              BrowserType["OUPENG"] = "oupeng";
              BrowserType["MIUI"] = "miuibrowser";
              BrowserType["FIREFOX"] = "firefox";
              BrowserType["SAFARI"] = "safari";
              BrowserType["CHROME"] = "chrome";
              BrowserType["LIEBAO"] = "liebao";
              BrowserType["QZONE"] = "qzone";
              BrowserType["SOUGOU"] = "sogou";
              BrowserType["HUAWEI"] = "huawei";
            })(BrowserType || (BrowserType = exports('bu', {})));

            let Language;

            (function (Language) {
              Language["UNKNOWN"] = "unknown";
              Language["ENGLISH"] = "en";
              Language["CHINESE"] = "zh";
              Language["FRENCH"] = "fr";
              Language["ITALIAN"] = "it";
              Language["GERMAN"] = "de";
              Language["SPANISH"] = "es";
              Language["DUTCH"] = "du";
              Language["RUSSIAN"] = "ru";
              Language["KOREAN"] = "ko";
              Language["JAPANESE"] = "ja";
              Language["HUNGARIAN"] = "hu";
              Language["PORTUGUESE"] = "pt";
              Language["ARABIC"] = "ar";
              Language["NORWEGIAN"] = "no";
              Language["POLISH"] = "pl";
              Language["TURKISH"] = "tr";
              Language["UKRAINIAN"] = "uk";
              Language["ROMANIAN"] = "ro";
              Language["BULGARIAN"] = "bg";
            })(Language || (Language = {}));

            let NetworkType;

            (function (NetworkType) {
              NetworkType[NetworkType["NONE"] = 0] = "NONE";
              NetworkType[NetworkType["LAN"] = 1] = "LAN";
              NetworkType[NetworkType["WWAN"] = 2] = "WWAN";
            })(NetworkType || (NetworkType = {}));

            let OS;

            (function (OS) {
              OS["UNKNOWN"] = "Unknown";
              OS["IOS"] = "iOS";
              OS["ANDROID"] = "Android";
              OS["WINDOWS"] = "Windows";
              OS["LINUX"] = "Linux";
              OS["OSX"] = "OS X";
              OS["OHOS"] = "OHOS";
            })(OS || (OS = exports('bt', {})));

            let Platform;

            (function (Platform) {
              Platform["UNKNOWN"] = "UNKNOWN";
              Platform["EDITOR_PAGE"] = "EDITOR_PAGE";
              Platform["EDITOR_CORE"] = "EDITOR_CORE";
              Platform["MOBILE_BROWSER"] = "MOBILE_BROWSER";
              Platform["DESKTOP_BROWSER"] = "DESKTOP_BROWSER";
              Platform["WIN32"] = "WIN32";
              Platform["ANDROID"] = "ANDROID";
              Platform["IOS"] = "IOS";
              Platform["MACOS"] = "MACOS";
              Platform["OHOS"] = "OHOS";
              Platform["WECHAT_GAME"] = "WECHAT_GAME";
              Platform["BAIDU_MINI_GAME"] = "BAIDU_MINI_GAME";
              Platform["XIAOMI_QUICK_GAME"] = "XIAOMI_QUICK_GAME";
              Platform["ALIPAY_MINI_GAME"] = "ALIPAY_MINI_GAME";
              Platform["BYTEDANCE_MINI_GAME"] = "BYTEDANCE_MINI_GAME";
              Platform["OPPO_MINI_GAME"] = "OPPO_MINI_GAME";
              Platform["VIVO_MINI_GAME"] = "VIVO_MINI_GAME";
              Platform["HUAWEI_QUICK_GAME"] = "HUAWEI_QUICK_GAME";
              Platform["COCOSPLAY"] = "COCOSPLAY";
              Platform["LINKSURE_MINI_GAME"] = "LINKSURE_MINI_GAME";
              Platform["QTT_MINI_GAME"] = "QTT_MINI_GAME";
            })(Platform || (Platform = exports('c6', {})));

            let Feature;

            (function (Feature) {
              Feature["WEBP"] = "WEBP";
              Feature["IMAGE_BITMAP"] = "IMAGE_BITMAP";
              Feature["WEB_VIEW"] = "WEB_VIEW";
              Feature["VIDEO_PLAYER"] = "VIDEO_PLAYER";
              Feature["SAFE_AREA"] = "SAFE_AREA";
              Feature["INPUT_TOUCH"] = "INPUT_TOUCH";
              Feature["EVENT_KEYBOARD"] = "EVENT_KEYBOARD";
              Feature["EVENT_MOUSE"] = "EVENT_MOUSE";
              Feature["EVENT_TOUCH"] = "EVENT_TOUCH";
              Feature["EVENT_ACCELEROMETER"] = "EVENT_ACCELEROMETER";
            })(Feature || (Feature = {}));

            const networkTypeMap = {
              0: NetworkType.NONE,
              1: NetworkType.LAN,
              2: NetworkType.WWAN
            };
            const platformMap = {
              0: Platform.WIN32,
              2: Platform.MACOS,
              3: Platform.ANDROID,
              4: Platform.IOS,
              5: Platform.IOS,
              6: Platform.OHOS
            };

            class SystemInfo extends EventTarget {
              get networkType() {
                return networkTypeMap[jsb.device.getNetworkType()];
              }

              constructor() {
                super();
                this.isNative = void 0;
                this.isBrowser = void 0;
                this.isMobile = void 0;
                this.isLittleEndian = void 0;
                this.platform = void 0;
                this.language = void 0;
                this.nativeLanguage = void 0;
                this.os = void 0;
                this.osVersion = void 0;
                this.osMainVersion = void 0;
                this.browserType = void 0;
                this.browserVersion = void 0;
                this._featureMap = void 0;
                this.isNative = true;
                this.isBrowser = false;
                this.platform = platformMap[__getPlatform()];
                this.isMobile = this.platform === Platform.ANDROID || this.platform === Platform.IOS || this.platform === Platform.OHOS;

                this.isLittleEndian = (() => {
                  const buffer = new ArrayBuffer(2);
                  new DataView(buffer).setInt16(0, 256, true);
                  return new Int16Array(buffer)[0] === 256;
                })();

                const currLanguage = __getCurrentLanguageCode();

                this.nativeLanguage = currLanguage ? currLanguage.toLowerCase() : Language.UNKNOWN;
                this.language = __getCurrentLanguage();
                this.os = __getOS();
                this.osVersion = __getOSVersion();
                this.osMainVersion = parseInt(this.osVersion);
                this.browserType = BrowserType.UNKNOWN;
                this.browserVersion = '';
                this._featureMap = {
                  [Feature.WEBP]: true,
                  [Feature.IMAGE_BITMAP]: false,
                  [Feature.WEB_VIEW]: this.isMobile,
                  [Feature.VIDEO_PLAYER]: this.isMobile,
                  [Feature.SAFE_AREA]: this.isMobile,
                  [Feature.INPUT_TOUCH]: this.isMobile,
                  [Feature.EVENT_KEYBOARD]: !this.isMobile,
                  [Feature.EVENT_MOUSE]: !this.isMobile,
                  [Feature.EVENT_TOUCH]: true,
                  [Feature.EVENT_ACCELEROMETER]: this.isMobile
                };

                this._registerEvent();
              }

              _registerEvent() {
                jsb.onPause = () => {
                  this.emit('hide');
                  legacyCC.internal.SplashScreen.instance.pauseRendering();
                };

                jsb.onResume = () => {
                  this.emit('show');
                  legacyCC.internal.SplashScreen.instance.resumeRendering();
                };

                jsb.onClose = () => {
                  this.emit('close');
                };
              }

              hasFeature(feature) {
                return this._featureMap[feature];
              }

              getBatteryLevel() {
                return jsb.device.getBatteryLevel();
              }

              triggerGC() {
                jsb.garbageCollect();
              }

              openURL(url) {
                jsb.openURL(url);
              }

              now() {
                if (Date.now) {
                  return Date.now();
                }

                return +new Date();
              }

              restartJSVM() {
                __restartVM();
              }

              close() {
                __close();
              }

            }

            const systemInfo = exports('bs', new SystemInfo());

            const EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
            const DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
            const NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
            function join(...segments) {
              let result = '';

              for (const segment of segments) {
                result = (result + (result === '' ? '' : '/') + segment).replace(/(\/|\\\\)$/, '');
              }

              return result;
            }
            function extname(path) {
              const temp = EXTNAME_RE.exec(path);
              return temp ? temp[1] : '';
            }
            function mainFileName(fileName) {
              if (fileName) {
                const idx = fileName.lastIndexOf('.');

                if (idx !== -1) {
                  return fileName.substring(0, idx);
                }
              }

              return fileName;
            }
            function basename(path, extName) {
              const index = path.indexOf('?');

              if (index > 0) {
                path = path.substring(0, index);
              }

              const reg = /(\/|\\)([^\/\\]+)$/g;
              const result = reg.exec(path.replace(/(\/|\\)$/, ''));

              if (!result) {
                return path;
              }

              const baseName = result[2];

              if (extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase()) {
                return baseName.substring(0, baseName.length - extName.length);
              }

              return baseName;
            }
            function dirname(path) {
              const temp = DIRNAME_RE.exec(path);
              return temp ? temp[2] : '';
            }
            function changeExtname(path, extName) {
              extName = extName || '';
              let index = path.indexOf('?');
              let tempStr = '';

              if (index > 0) {
                tempStr = path.substring(index);
                path = path.substring(0, index);
              }

              index = path.lastIndexOf('.');

              if (index < 0) {
                return path + extName + tempStr;
              }

              return path.substring(0, index) + extName + tempStr;
            }
            function changeBasename(path, baseName, isSameExt) {
              if (baseName.indexOf('.') === 0) {
                return changeExtname(path, baseName);
              }

              let index = path.indexOf('?');
              let tempStr = '';
              const ext = isSameExt ? extname(path) : '';

              if (index > 0) {
                tempStr = path.substring(index);
                path = path.substring(0, index);
              }

              index = path.lastIndexOf('/');
              index = index <= 0 ? 0 : index + 1;
              return path.substring(0, index) + baseName + ext + tempStr;
            }
            function _normalize(url) {
              let oldUrl = url = String(url);

              do {
                oldUrl = url;
                url = url.replace(NORMALIZE_RE, '');
              } while (oldUrl.length !== url.length);

              return url;
            }
            function stripSep(path) {
              return path.replace(/[\/\\]$/, '');
            }
            function getSeperator() {
              return systemInfo.os === OS.WINDOWS ? '\\' : '/';
            }

            var path = /*#__PURE__*/Object.freeze({
                __proto__: null,
                join: join,
                extname: extname,
                mainFileName: mainFileName,
                basename: basename,
                dirname: dirname,
                changeExtname: changeExtname,
                changeBasename: changeBasename,
                _normalize: _normalize,
                stripSep: stripSep,
                getSeperator: getSeperator
            });
            exports('fn', path);

            legacyCC.log = log;
            legacyCC.warn = warn;
            legacyCC.error = error;
            legacyCC.assert = assert;
            legacyCC._throw = _throw;
            legacyCC.logID = logID;
            legacyCC.warnID = warnID;
            legacyCC.errorID = errorID;
            legacyCC.assertID = assertID;
            legacyCC.debug = debug$1;
            legacyCC.path = {
              join,
              extname,
              mainFileName,
              basename,
              dirname,
              changeExtname,
              changeBasename,
              _normalize,
              stripSep,

              get sep() {
                return getSeperator();
              }

            };

            let _stageOffset = 0;
            const _name2stageID = {};
            var config = {
              addStage(name) {
                if (_name2stageID[name] !== undefined) {
                  return;
                }

                const stageID = 1 << _stageOffset;
                _name2stageID[name] = stageID;
                _stageOffset += 1;
              },

              stageID(name) {
                const id = _name2stageID[name];

                if (id === undefined) {
                  return -1;
                }

                return id;
              },

              stageIDs(nameList) {
                let key = 0;

                for (const name of nameList) {
                  const id = _name2stageID[name];

                  if (id !== undefined) {
                    key |= id;
                  }
                }

                return key;
              }

            };

            const INT_BITS = 32;
            const INT_MAX = exports('dj', 0x7fffffff);
            const INT_MIN = -1 << INT_BITS - 1;
            function sign(v) {
              return (v > 0) - (v < 0);
            }
            function abs(v) {
              const mask = v >> INT_BITS - 1;
              return (v ^ mask) - mask;
            }
            function min(x, y) {
              return y ^ (x ^ y) & -(x < y);
            }
            function max(x, y) {
              return x ^ (x ^ y) & -(x < y);
            }
            function isPow2(v) {
              return !(v & v - 1) && !!v;
            }
            function log2(v) {
              let r;
              let shift;
              r = (v > 0xFFFF) << 4;
              v >>>= r;
              shift = (v > 0xFF) << 3;
              v >>>= shift;
              r |= shift;
              shift = (v > 0xF) << 2;
              v >>>= shift;
              r |= shift;
              shift = (v > 0x3) << 1;
              v >>>= shift;
              r |= shift;
              return r | v >> 1;
            }
            function log10(v) {
              return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
            }
            function popCount(v) {
              v -= v >>> 1 & 0x55555555;
              v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
              return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
            }
            function countTrailingZeros(v) {
              let c = 32;
              v &= -v;

              if (v) {
                c--;
              }

              if (v & 0x0000FFFF) {
                c -= 16;
              }

              if (v & 0x00FF00FF) {
                c -= 8;
              }

              if (v & 0x0F0F0F0F) {
                c -= 4;
              }

              if (v & 0x33333333) {
                c -= 2;
              }

              if (v & 0x55555555) {
                c -= 1;
              }

              return c;
            }
            function nextPow2(v) {
              --v;
              v |= v >>> 1;
              v |= v >>> 2;
              v |= v >>> 4;
              v |= v >>> 8;
              v |= v >>> 16;
              return v + 1;
            }
            function prevPow2(v) {
              v |= v >>> 1;
              v |= v >>> 2;
              v |= v >>> 4;
              v |= v >>> 8;
              v |= v >>> 16;
              return v - (v >>> 1);
            }
            function parity(v) {
              v ^= v >>> 16;
              v ^= v >>> 8;
              v ^= v >>> 4;
              v &= 0xf;
              return 0x6996 >>> v & 1;
            }
            const REVERSE_TABLE = new Array(256);

            (tab => {
              for (let i = 0; i < 256; ++i) {
                let v = i;
                let r = i;
                let s = 7;

                for (v >>>= 1; v; v >>>= 1) {
                  r <<= 1;
                  r |= v & 1;
                  --s;
                }

                tab[i] = r << s & 0xff;
              }
            })(REVERSE_TABLE);

            function reverse(v) {
              return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
            }
            function interleave2(x, y) {
              x &= 0xFFFF;
              x = (x | x << 8) & 0x00FF00FF;
              x = (x | x << 4) & 0x0F0F0F0F;
              x = (x | x << 2) & 0x33333333;
              x = (x | x << 1) & 0x55555555;
              y &= 0xFFFF;
              y = (y | y << 8) & 0x00FF00FF;
              y = (y | y << 4) & 0x0F0F0F0F;
              y = (y | y << 2) & 0x33333333;
              y = (y | y << 1) & 0x55555555;
              return x | y << 1;
            }
            function deinterleave2(v, n) {
              v = v >>> n & 0x55555555;
              v = (v | v >>> 1) & 0x33333333;
              v = (v | v >>> 2) & 0x0F0F0F0F;
              v = (v | v >>> 4) & 0x00FF00FF;
              v = (v | v >>> 16) & 0x000FFFF;
              return v << 16 >> 16;
            }
            function interleave3(x, y, z) {
              x &= 0x3FF;
              x = (x | x << 16) & 4278190335;
              x = (x | x << 8) & 251719695;
              x = (x | x << 4) & 3272356035;
              x = (x | x << 2) & 1227133513;
              y &= 0x3FF;
              y = (y | y << 16) & 4278190335;
              y = (y | y << 8) & 251719695;
              y = (y | y << 4) & 3272356035;
              y = (y | y << 2) & 1227133513;
              x |= y << 1;
              z &= 0x3FF;
              z = (z | z << 16) & 4278190335;
              z = (z | z << 8) & 251719695;
              z = (z | z << 4) & 3272356035;
              z = (z | z << 2) & 1227133513;
              return x | z << 2;
            }
            function deinterleave3(v, n) {
              v = v >>> n & 1227133513;
              v = (v | v >>> 2) & 3272356035;
              v = (v | v >>> 4) & 251719695;
              v = (v | v >>> 8) & 4278190335;
              v = (v | v >>> 16) & 0x3FF;
              return v << 22 >> 22;
            }
            function nextCombination(v) {
              const t = v | v - 1;
              return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
            }

            var bits = /*#__PURE__*/Object.freeze({
                __proto__: null,
                INT_BITS: INT_BITS,
                INT_MAX: INT_MAX,
                INT_MIN: INT_MIN,
                sign: sign,
                abs: abs,
                min: min,
                max: max,
                isPow2: isPow2,
                log2: log2,
                log10: log10,
                popCount: popCount,
                countTrailingZeros: countTrailingZeros,
                nextPow2: nextPow2,
                prevPow2: prevPow2,
                parity: parity,
                reverse: reverse,
                interleave2: interleave2,
                deinterleave2: deinterleave2,
                interleave3: interleave3,
                deinterleave3: deinterleave3,
                nextCombination: nextCombination
            });
            exports('e_', bits);

            let defaultLogTimes = 10;
            function setDefaultLogTimes(times) {
              if (times > 0) {
                defaultLogTimes = times;
              }
            }
            let replaceProperty;
            let removeProperty;
            let markAsWarning;
            let replacePropertyLog;
            let markAsWarningLog;
            let removePropertyLog;
            let messageID = 0;
            const messageMap = new Map();

            replacePropertyLog = (n, dp, n2, newp, f, id, s) => {
              const item = messageMap.get(id);

              if (item && item.logTimes > item.count) {
                f(`'%s' is deprecated, please use '%s' instead. ${s}`, `${n}.${dp}`, `${n2}.${newp}`);
                item.count++;
              }
            };

            replaceProperty = exports('cg', (owner, ownerName, properties) => {
              if (owner == null) return;
              properties.forEach(item => {
                const id = messageID++;
                messageMap.set(id, {
                  id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                const target = item.target != null ? item.target : owner;
                const newName = item.newName != null ? item.newName : item.name;
                const targetName = item.targetName != null ? item.targetName : ownerName;
                const sameTarget = target === owner;
                const suggest = item.suggest ? `(${item.suggest})` : '';

                if (item.customFunction != null) {
                  owner[item.name] = function () {
                    replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                    return item.customFunction.call(this, ...arguments);
                  };
                } else if (item.customSetter != null || item.customGetter != null) {
                  const hasSetter = item.customSetter != null;
                  const hasGetter = item.customGetter != null;

                  if (hasSetter && hasGetter) {
                    Object.defineProperty(owner, item.name, {
                      get() {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        return item.customGetter.call(this);
                      },

                      set(v) {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        item.customSetter.call(this, v);
                      },

                      enumerable: false
                    });
                  } else if (hasSetter) {
                    Object.defineProperty(owner, item.name, {
                      set(v) {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        item.customSetter.call(this, v);
                      },

                      enumerable: false
                    });
                  } else if (hasGetter) {
                    Object.defineProperty(owner, item.name, {
                      get() {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        return item.customGetter.call(this);
                      },

                      enumerable: false
                    });
                  }
                } else {
                  Object.defineProperty(owner, item.name, {
                    get() {
                      replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                      return sameTarget ? this[newName] : target[newName];
                    },

                    set(v) {
                      replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);

                      if (sameTarget) {
                        this[newName] = v;
                      } else {
                        target[newName] = v;
                      }
                    },

                    enumerable: false
                  });
                }
              });
            });

            removePropertyLog = (n, dp, f, id, s) => {
              const item = messageMap.get(id);

              if (item && item.logTimes > item.count) {
                f(`'%s' has been removed. ${s}`, `${n}.${dp}`);
                item.count++;
              }
            };

            removeProperty = exports('cr', (owner, ownerName, properties) => {
              if (owner == null) return;
              properties.forEach(item => {
                const id = messageID++;
                messageMap.set(id, {
                  id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                const suggest = item.suggest ? `(${item.suggest})` : '';
                Object.defineProperty(owner, item.name, {
                  get() {
                    return removePropertyLog(ownerName, item.name, error, id, suggest);
                  },

                  set() {
                    removePropertyLog(ownerName, item.name, error, id, suggest);
                  },

                  enumerable: false
                });
              });
            });

            markAsWarningLog = (n, dp, f, id, s) => {
              const item = messageMap.get(id);

              if (item && item.logTimes > item.count) {
                f(`'%s' is deprecated. ${s}`, `${n}.${dp}`);
                item.count++;
              }
            };

            markAsWarning = exports('ch', (owner, ownerName, properties) => {
              if (owner == null) return;

              const _defaultGetSet = (d, n, dp, f, id, s) => {
                if (d.get) {
                  const oldGet = d.get;

                  d.get = function () {
                    markAsWarningLog(n, dp, f, id, s);
                    return oldGet.call(this);
                  };
                }

                if (d.set) {
                  const oldSet = d.set;

                  d.set = function (v) {
                    markAsWarningLog(n, dp, f, id, s);
                    oldSet.call(this, v);
                  };
                }

                Object.defineProperty(owner, dp, d);
              };

              properties.forEach(item => {
                const deprecatedProp = item.name;
                const descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);

                if (!descriptor || !descriptor.configurable) {
                  return;
                }

                const id = messageID++;
                messageMap.set(id, {
                  id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                const suggest = item.suggest ? `(${item.suggest})` : '';

                if (typeof descriptor.value !== 'undefined') {
                  if (typeof descriptor.value === 'function') {
                    const oldValue = descriptor.value;

                    owner[deprecatedProp] = function () {
                      markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                      return oldValue.call(this, ...arguments);
                    };
                  } else {
                    let oldValue = descriptor.value;
                    Object.defineProperty(owner, deprecatedProp, {
                      configurable: true,

                      get() {
                        markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                        return oldValue;
                      }

                    });

                    if (descriptor.writable) {
                      Object.defineProperty(owner, deprecatedProp, {
                        set(value) {
                          markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                          oldValue = value;
                        }

                      });
                    }
                  }
                } else {
                  _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, suggest);
                }

                Object.defineProperty(owner, deprecatedProp, {
                  enumerable: false
                });
              });
            });

            const _d2r = Math.PI / 180.0;

            const _r2d = 180.0 / Math.PI;

            const EPSILON = exports('f9', 0.000001);
            function equals(a, b) {
              return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
            }
            function approx(a, b, maxDiff) {
              maxDiff = maxDiff || EPSILON;
              return Math.abs(a - b) <= maxDiff;
            }
            function clamp(val, min, max) {
              if (min > max) {
                const temp = min;
                min = max;
                max = temp;
              }

              return val < min ? min : val > max ? max : val;
            }
            function clamp01(val) {
              return val < 0 ? 0 : val > 1 ? 1 : val;
            }
            function lerp(from, to, ratio) {
              return from + (to - from) * ratio;
            }
            function toRadian(a) {
              return a * _d2r;
            }
            function toDegree(a) {
              return a * _r2d;
            }
            const random = exports('dc', Math.random);
            function randomRange(min, max) {
              return Math.random() * (max - min) + min;
            }
            function randomRangeInt(min, max) {
              return Math.floor(randomRange(min, max));
            }
            function pseudoRandom(seed) {
              seed = (seed * 9301 + 49297) % 233280;
              return seed / 233280.0;
            }
            function pseudoRandomRange(seed, min, max) {
              return pseudoRandom(seed) * (max - min) + min;
            }
            function pseudoRandomRangeInt(seed, min, max) {
              return Math.floor(pseudoRandomRange(seed, min, max));
            }
            function nextPow2$1(val) {
              --val;
              val = val >> 1 | val;
              val = val >> 2 | val;
              val = val >> 4 | val;
              val = val >> 8 | val;
              val = val >> 16 | val;
              ++val;
              return val;
            }
            function repeat(t, length) {
              return t - Math.floor(t / length) * length;
            }
            function pingPong(t, length) {
              t = repeat(t, length * 2);
              t = length - Math.abs(t - length);
              return t;
            }
            function inverseLerp(from, to, value) {
              return (value - from) / (to - from);
            }
            function absMaxComponent(v) {
              if (Math.abs(v.x) > Math.abs(v.y)) {
                if (Math.abs(v.x) > Math.abs(v.z)) {
                  return v.x;
                } else {
                  return v.z;
                }
              } else if (Math.abs(v.y) > Math.abs(v.z)) {
                return v.y;
              } else {
                return v.z;
              }
            }
            function absMax(a, b) {
              if (Math.abs(a) > Math.abs(b)) {
                return a;
              } else {
                return b;
              }
            }
            function enumerableProps(prototype, attrs) {
              attrs.forEach(key => {
                Object.defineProperty(prototype, key, {
                  enumerable: true
                });
              });
            }

            const toFloat = 1 / 255;
            class Color extends ValueType {
              static clone(a) {
                const out = new Color();

                if (a._val) {
                  out._val = a._val;
                } else {
                  out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r;
                }

                return out;
              }

              static copy(out, a) {
                out.r = a.r;
                out.g = a.g;
                out.b = a.b;
                out.a = a.a;
                return out;
              }

              static set(out, r, g, b, a) {
                out.r = r;
                out.g = g;
                out.b = b;
                out.a = a;
                return out;
              }

              static fromHEX(out, hexString) {
                hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
                out.r = parseInt(hexString.substr(0, 2), 16) || 0;
                out.g = parseInt(hexString.substr(2, 2), 16) || 0;
                out.b = parseInt(hexString.substr(4, 2), 16) || 0;
                const a = parseInt(hexString.substr(6, 2), 16);
                out.a = !Number.isNaN(a) ? a : 255;
                out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r;
                return out;
              }

              static add(out, a, b) {
                out.r = a.r + b.r;
                out.g = a.g + b.g;
                out.b = a.b + b.b;
                out.a = a.a + b.a;
                return out;
              }

              static subtract(out, a, b) {
                out.r = a.r - b.r;
                out.g = a.g - b.g;
                out.b = a.b - b.b;
                out.a = a.a - b.a;
                return out;
              }

              static multiply(out, a, b) {
                out.r = a.r * b.r;
                out.g = a.g * b.g;
                out.b = a.b * b.b;
                out.a = a.a * b.a;
                return out;
              }

              static divide(out, a, b) {
                out.r = a.r / b.r;
                out.g = a.g / b.g;
                out.b = a.b / b.b;
                out.a = a.a / b.a;
                return out;
              }

              static scale(out, a, b) {
                out.r = a.r * b;
                out.g = a.g * b;
                out.b = a.b * b;
                out.a = a.a * b;
                return out;
              }

              static lerp(out, from, to, ratio) {
                let r = from.r;
                let g = from.g;
                let b = from.b;
                let a = from.a;
                r += (to.r - r) * ratio;
                g += (to.g - g) * ratio;
                b += (to.b - b) * ratio;
                a += (to.a - a) * ratio;
                out._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
                return out;
              }

              static toArray(out, a, ofs = 0) {
                const scale = a instanceof Color || a.a > 1 ? 1 / 255 : 1;
                out[ofs + 0] = a.r * scale;
                out[ofs + 1] = a.g * scale;
                out[ofs + 2] = a.b * scale;
                out[ofs + 3] = a.a * scale;
                return out;
              }

              static fromArray(arr, out, ofs = 0) {
                out.r = arr[ofs + 0] * 255;
                out.g = arr[ofs + 1] * 255;
                out.b = arr[ofs + 2] * 255;
                out.a = arr[ofs + 3] * 255;
                return out;
              }

              static strictEquals(a, b) {
                return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.r - b.r) <= epsilon * Math.max(1.0, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1.0, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1.0, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1.0, Math.abs(a.a), Math.abs(b.a));
              }

              static hex(a) {
                return (a.r * 255 << 24 | a.g * 255 << 16 | a.b * 255 << 8 | a.a * 255) >>> 0;
              }

              get r() {
                return this._val & 0x000000ff;
              }

              set r(red) {
                red = ~~clamp(red, 0, 255);
                this._val = (this._val & 0xffffff00 | red) >>> 0;
              }

              get g() {
                return (this._val & 0x0000ff00) >> 8;
              }

              set g(green) {
                green = ~~clamp(green, 0, 255);
                this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
              }

              get b() {
                return (this._val & 0x00ff0000) >> 16;
              }

              set b(blue) {
                blue = ~~clamp(blue, 0, 255);
                this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
              }

              get a() {
                return (this._val & 0xff000000) >>> 24;
              }

              set a(alpha) {
                alpha = ~~clamp(alpha, 0, 255);
                this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
              }

              get x() {
                return this.r * toFloat;
              }

              set x(value) {
                this.r = value * 255;
              }

              get y() {
                return this.g * toFloat;
              }

              set y(value) {
                this.g = value * 255;
              }

              get z() {
                return this.b * toFloat;
              }

              set z(value) {
                this.b = value * 255;
              }

              get w() {
                return this.a * toFloat;
              }

              set w(value) {
                this.a = value * 255;
              }

              constructor(r, g, b, a) {
                super();
                this._val = 0;

                if (typeof r === 'string') {
                  this.fromHEX(r);
                } else if (g !== undefined) {
                  this.set(r, g, b, a);
                } else {
                  this.set(r);
                }
              }

              clone() {
                const ret = new Color();
                ret._val = this._val;
                return ret;
              }

              equals(other) {
                return other && this._val === other._val;
              }

              lerp(to, ratio) {
                let r = this.r;
                let g = this.g;
                let b = this.b;
                let a = this.a;
                r += (to.r - r) * ratio;
                g += (to.g - g) * ratio;
                b += (to.b - b) * ratio;
                a += (to.a - a) * ratio;
                this._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r);
                return this;
              }

              toString() {
                return `rgba(${this.r.toFixed()}, ${this.g.toFixed()}, ${this.b.toFixed()}, ${this.a.toFixed()})`;
              }

              toCSS(opt = 'rgba') {
                if (opt === 'rgba') {
                  return `rgba(${this.r},${this.g},${this.b},${(this.a * toFloat).toFixed(2)})`;
                } else if (opt === 'rgb') {
                  return `rgb(${this.r},${this.g},${this.b})`;
                } else {
                  return `#${this.toHEX(opt)}`;
                }
              }

              fromHEX(hexString) {
                hexString = hexString.indexOf('#') === 0 ? hexString.substring(1) : hexString;
                const r = parseInt(hexString.substr(0, 2), 16) || 0;
                const g = parseInt(hexString.substr(2, 2), 16) || 0;
                const b = parseInt(hexString.substr(4, 2), 16) || 0;
                let a = parseInt(hexString.substr(6, 2), 16);
                a = !Number.isNaN(a) ? a : 255;
                this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
                return this;
              }

              toHEX(fmt = '#rrggbb') {
                const prefix = '0';
                const hex = [(this.r < 16 ? prefix : '') + this.r.toString(16), (this.g < 16 ? prefix : '') + this.g.toString(16), (this.b < 16 ? prefix : '') + this.b.toString(16)];

                if (fmt === '#rgb') {
                  hex[0] = hex[0][0];
                  hex[1] = hex[1][0];
                  hex[2] = hex[2][0];
                } else if (fmt === '#rrggbbaa') {
                  hex.push((this.a < 16 ? prefix : '') + this.a.toString(16));
                }

                return hex.join('');
              }

              toRGBValue() {
                return this._val & 0x00ffffff;
              }

              fromHSV(h, s, v) {
                let r = 0;
                let g = 0;
                let b = 0;

                if (s === 0) {
                  r = g = b = v;
                } else if (v === 0) {
                  r = g = b = 0;
                } else {
                  if (h === 1) {
                    h = 0;
                  }

                  h *= 6;
                  const i = Math.floor(h);
                  const f = h - i;
                  const p = v * (1 - s);
                  const q = v * (1 - s * f);
                  const t = v * (1 - s * (1 - f));

                  switch (i) {
                    case 0:
                      r = v;
                      g = t;
                      b = p;
                      break;

                    case 1:
                      r = q;
                      g = v;
                      b = p;
                      break;

                    case 2:
                      r = p;
                      g = v;
                      b = t;
                      break;

                    case 3:
                      r = p;
                      g = q;
                      b = v;
                      break;

                    case 4:
                      r = t;
                      g = p;
                      b = v;
                      break;

                    case 5:
                      r = v;
                      g = p;
                      b = q;
                      break;
                  }
                }

                r *= 255;
                g *= 255;
                b *= 255;
                this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
                return this;
              }

              toHSV() {
                const r = this.r * toFloat;
                const g = this.g * toFloat;
                const b = this.b * toFloat;
                const hsv = {
                  h: 0,
                  s: 0,
                  v: 0
                };
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let delta = 0;
                hsv.v = max;
                hsv.s = max ? (max - min) / max : 0;

                if (!hsv.s) {
                  hsv.h = 0;
                } else {
                  delta = max - min;

                  if (r === max) {
                    hsv.h = (g - b) / delta;
                  } else if (g === max) {
                    hsv.h = 2 + (b - r) / delta;
                  } else {
                    hsv.h = 4 + (r - g) / delta;
                  }

                  hsv.h /= 6;

                  if (hsv.h < 0) {
                    hsv.h += 1.0;
                  }
                }

                return hsv;
              }

              set(r, g, b, a) {
                if (typeof r === 'object') {
                  if (r._val != null) {
                    this._val = r._val;
                  } else {
                    g = r.g || 0;
                    b = r.b || 0;
                    a = typeof r.a === 'number' ? r.a : 255;
                    r = r.r || 0;
                    this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
                  }
                } else {
                  r = r || 0;
                  g = g || 0;
                  b = b || 0;
                  a = typeof a === 'number' ? a : 255;
                  this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (r | 0);
                }

                return this;
              }

              multiply(other) {
                const r = (this._val & 0x000000ff) * other.r >> 8;
                const g = (this._val & 0x0000ff00) * other.g >> 8;
                const b = (this._val & 0x00ff0000) * other.b >> 8;
                const a = ((this._val & 0xff000000) >>> 8) * other.a;
                this._val = a & 0xff000000 | b & 0x00ff0000 | g & 0x0000ff00 | r & 0x000000ff;
                return this;
              }

              _set_r_unsafe(red) {
                this._val = (this._val & 0xffffff00 | red) >>> 0;
                return this;
              }

              _set_g_unsafe(green) {
                this._val = (this._val & 0xffff00ff | green << 8) >>> 0;
                return this;
              }

              _set_b_unsafe(blue) {
                this._val = (this._val & 0xff00ffff | blue << 16) >>> 0;
                return this;
              }

              _set_a_unsafe(alpha) {
                this._val = (this._val & 0x00ffffff | alpha << 24) >>> 0;
                return this;
              }

            } exports('cv', Color);
            Color.WHITE = Object.freeze(new Color(255, 255, 255, 255));
            Color.GRAY = Object.freeze(new Color(127, 127, 127, 255));
            Color.BLACK = Object.freeze(new Color(0, 0, 0, 255));
            Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0));
            Color.RED = Object.freeze(new Color(255, 0, 0, 255));
            Color.GREEN = Object.freeze(new Color(0, 255, 0, 255));
            Color.BLUE = Object.freeze(new Color(0, 0, 255, 255));
            Color.CYAN = Object.freeze(new Color(0, 255, 255, 255));
            Color.MAGENTA = Object.freeze(new Color(255, 0, 255, 255));
            Color.YELLOW = Object.freeze(new Color(255, 255, 0, 255));
            CCClass.fastDefine('cc.Color', Color, {
              r: 0,
              g: 0,
              b: 0,
              a: 255
            });
            legacyCC.Color = Color;
            function color(r, g, b, a) {
              return new Color(r, g, b, a);
            }
            legacyCC.color = color;

            const MATH_FLOAT_ARRAY = exports('fh',  Float32Array );
            class MathBase extends ValueType {
              static createFloatArray(size) {
                return new MATH_FLOAT_ARRAY(size);
              }

              get array() {
                return this._array;
              }

            } exports('fi', MathBase);

            class Vec3 extends MathBase {
              static zero(out) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                return out;
              }

              static clone(a) {
                return new Vec3(a.x, a.y, a.z);
              }

              static copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                return out;
              }

              static set(out, x, y, z) {
                out.x = x;
                out.y = y;
                out.z = z;
                return out;
              }

              static add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                out.z = a.z + b.z;
                return out;
              }

              static subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                out.z = a.z - b.z;
                return out;
              }

              static multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                out.z = a.z * b.z;
                return out;
              }

              static divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                out.z = a.z / b.z;
                return out;
              }

              static ceil(out, a) {
                out.x = Math.ceil(a.x);
                out.y = Math.ceil(a.y);
                out.z = Math.ceil(a.z);
                return out;
              }

              static floor(out, a) {
                out.x = Math.floor(a.x);
                out.y = Math.floor(a.y);
                out.z = Math.floor(a.z);
                return out;
              }

              static min(out, a, b) {
                out.x = Math.min(a.x, b.x);
                out.y = Math.min(a.y, b.y);
                out.z = Math.min(a.z, b.z);
                return out;
              }

              static max(out, a, b) {
                out.x = Math.max(a.x, b.x);
                out.y = Math.max(a.y, b.y);
                out.z = Math.max(a.z, b.z);
                return out;
              }

              static round(out, a) {
                out.x = Math.round(a.x);
                out.y = Math.round(a.y);
                out.z = Math.round(a.z);
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                return out;
              }

              static scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                return out;
              }

              static distance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                const z = b.z - a.z;
                return Math.sqrt(x * x + y * y + z * z);
              }

              static squaredDistance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                const z = b.z - a.z;
                return x * x + y * y + z * z;
              }

              static len(a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                return Math.sqrt(x * x + y * y + z * z);
              }

              static lengthSqr(a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                return x * x + y * y + z * z;
              }

              static negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                return out;
              }

              static invert(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                out.z = 1.0 / a.z;
                return out;
              }

              static invertSafe(out, a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;

                if (Math.abs(x) < EPSILON) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }

                if (Math.abs(y) < EPSILON) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }

                if (Math.abs(z) < EPSILON) {
                  out.z = 0;
                } else {
                  out.z = 1.0 / z;
                }

                return out;
              }

              static normalize(out, a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                let len = x * x + y * y + z * z;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  out.x = x * len;
                  out.y = y * len;
                  out.z = z * len;
                }

                return out;
              }

              static dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z;
              }

              static cross(out, a, b) {
                const {
                  x: ax,
                  y: ay,
                  z: az
                } = a;
                const {
                  x: bx,
                  y: by,
                  z: bz
                } = b;
                out.x = ay * bz - az * by;
                out.y = az * bx - ax * bz;
                out.z = ax * by - ay * bx;
                return out;
              }

              static lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                return out;
              }

              static random(out, scale) {
                scale = scale || 1.0;
                const phi = random() * 2.0 * Math.PI;
                const cosTheta = random() * 2 - 1;
                const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                out.x = sinTheta * Math.cos(phi) * scale;
                out.y = sinTheta * Math.sin(phi) * scale;
                out.z = cosTheta * scale;
                return out;
              }

              static transformMat4(out, a, m) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                let rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
                rhw = rhw ? Math.abs(1 / rhw) : 1;
                out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
                out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
                out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
                return out;
              }

              static transformMat4Normal(out, a, m) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                let rhw = m.m03 * x + m.m07 * y + m.m11 * z;
                rhw = rhw ? Math.abs(1 / rhw) : 1;
                out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw;
                out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw;
                out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw;
                return out;
              }

              static transformMat3(out, a, m) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                out.x = x * m.m00 + y * m.m03 + z * m.m06;
                out.y = x * m.m01 + y * m.m04 + z * m.m07;
                out.z = x * m.m02 + y * m.m05 + z * m.m08;
                return out;
              }

              static transformAffine(out, v, m) {
                const x = v.x;
                const y = v.y;
                const z = v.z;
                out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12;
                out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13;
                out.x = m.m02 * x + m.m06 * y + m.m10 * z + m.m14;
                return out;
              }

              static transformQuat(out, a, q) {
                const ix = q.w * a.x + q.y * a.z - q.z * a.y;
                const iy = q.w * a.y + q.z * a.x - q.x * a.z;
                const iz = q.w * a.z + q.x * a.y - q.y * a.x;
                const iw = -q.x * a.x - q.y * a.y - q.z * a.z;
                out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
                out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
                out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
                return out;
              }

              static transformRTS(out, a, r, t, s) {
                const x = a.x * s.x;
                const y = a.y * s.y;
                const z = a.z * s.z;
                const ix = r.w * x + r.y * z - r.z * y;
                const iy = r.w * y + r.z * x - r.x * z;
                const iz = r.w * z + r.x * y - r.y * x;
                const iw = -r.x * x - r.y * y - r.z * z;
                out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x;
                out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y;
                out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z;
                return out;
              }

              static transformInverseRTS(out, a, r, t, s) {
                const x = a.x - t.x;
                const y = a.y - t.y;
                const z = a.z - t.z;
                const ix = r.w * x - r.y * z + r.z * y;
                const iy = r.w * y - r.z * x + r.x * z;
                const iz = r.w * z - r.x * y + r.y * x;
                const iw = r.x * x + r.y * y + r.z * z;
                out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x;
                out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y;
                out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z;
                return out;
              }

              static rotateX(out, v, o, a) {
                const x = v.x - o.x;
                const y = v.y - o.y;
                const z = v.z - o.z;
                const cos = Math.cos(a);
                const sin = Math.sin(a);
                const rx = x;
                const ry = y * cos - z * sin;
                const rz = y * sin + z * cos;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              }

              static rotateY(out, v, o, a) {
                const x = v.x - o.x;
                const y = v.y - o.y;
                const z = v.z - o.z;
                const cos = Math.cos(a);
                const sin = Math.sin(a);
                const rx = z * sin + x * cos;
                const ry = y;
                const rz = z * cos - x * sin;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              }

              static rotateZ(out, v, o, a) {
                const x = v.x - o.x;
                const y = v.y - o.y;
                const z = v.z - o.z;
                const cos = Math.cos(a);
                const sin = Math.sin(a);
                const rx = x * cos - y * sin;
                const ry = x * sin + y * cos;
                const rz = z;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              }

              static toArray(out, v, ofs = 0) {
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                out[ofs + 2] = v.z;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                return out;
              }

              static strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z;
              }

              static equals(a, b, epsilon = EPSILON) {
                const {
                  x: a0,
                  y: a1,
                  z: a2
                } = a;
                const {
                  x: b0,
                  y: b1,
                  z: b2
                } = b;
                return Math.abs(a0 - b0) <= epsilon * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1.0, Math.abs(a2), Math.abs(b2));
              }

              static angle(a, b) {
                Vec3.normalize(v3_1, a);
                Vec3.normalize(v3_2, b);
                const cosine = Vec3.dot(v3_1, v3_2);

                if (cosine > 1.0) {
                  return 0;
                }

                if (cosine < -1.0) {
                  return Math.PI;
                }

                return Math.acos(cosine);
              }

              static projectOnPlane(out, a, n) {
                return Vec3.subtract(out, a, Vec3.project(out, a, n));
              }

              static project(out, a, b) {
                const sqrLen = Vec3.lengthSqr(b);

                if (sqrLen < 0.000001) {
                  return Vec3.set(out, 0, 0, 0);
                } else {
                  return Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
                }
              }

              get x() {
                return this._array[0];
              }

              set x(x) {
                this._array[0] = x;
              }

              get y() {
                return this._array[1];
              }

              set y(y) {
                this._array[1] = y;
              }

              get z() {
                return this._array[2];
              }

              set z(z) {
                this._array[2] = z;
              }

              constructor(x, y, z) {
                super();

                if (x && typeof x === 'object') {
                  if (ArrayBuffer.isView(x)) {
                    this._array = x;

                    this._array.fill(0);
                  } else {
                    const v = x.array;
                    this._array = MathBase.createFloatArray(3);
                    this._array[0] = v[0];
                    this._array[1] = v[1];
                    this._array[2] = v[2];
                  }
                } else {
                  this._array = MathBase.createFloatArray(3);
                  this._array[0] = x || 0;
                  this._array[1] = y || 0;
                  this._array[2] = z || 0;
                }
              }

              clone() {
                return new Vec3(this._array[0], this._array[1], this._array[2]);
              }

              set(x, y, z) {
                if (x && typeof x === 'object') {
                  this._array[0] = x.x;
                  this._array[1] = x.y;
                  this._array[2] = x.z;
                } else {
                  this._array[0] = x || 0;
                  this._array[1] = y || 0;
                  this._array[2] = z || 0;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                const v = other.array;
                return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2]));
              }

              equals3f(x, y, z, epsilon = EPSILON) {
                return Math.abs(this._array[0] - x) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(x)) && Math.abs(this._array[1] - y) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(y)) && Math.abs(this._array[2] - z) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(z));
              }

              strictEquals(other) {
                const v = other.array;
                return this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2];
              }

              strictEquals3f(x, y, z) {
                return this._array[0] === x && this._array[1] === y && this._array[2] === z;
              }

              toString() {
                return `(${this._array[0].toFixed(2)}, ${this._array[1].toFixed(2)}, ${this._array[2].toFixed(2)})`;
              }

              lerp(to, ratio) {
                this._array[0] += ratio * (to.x - this._array[0]);
                this._array[1] += ratio * (to.y - this._array[1]);
                this._array[2] += ratio * (to.z - this._array[2]);
                return this;
              }

              add(other) {
                const v = other.array;
                this._array[0] += v[0];
                this._array[1] += v[1];
                this._array[2] += v[2];
                return this;
              }

              add3f(x, y, z) {
                this._array[0] += x;
                this._array[1] += y;
                this._array[2] += z;
                return this;
              }

              subtract(other) {
                const v = other.array;
                this._array[0] -= v[0];
                this._array[1] -= v[1];
                this._array[2] -= v[2];
                return this;
              }

              subtract3f(x, y, z) {
                this._array[0] -= x;
                this._array[1] -= y;
                this._array[2] -= z;
                return this;
              }

              multiplyScalar(scalar) {
                if (typeof scalar === 'object') {
                  console.warn('should use Vec3.multiply for vector * vector operation');
                }

                this._array[0] *= scalar;
                this._array[1] *= scalar;
                this._array[2] *= scalar;
                return this;
              }

              multiply(other) {
                if (typeof other !== 'object') {
                  console.warn('should use Vec3.scale for vector * scalar operation');
                }

                const v = other.array;
                this._array[0] *= v[0];
                this._array[1] *= v[1];
                this._array[2] *= v[2];
                return this;
              }

              multiply3f(x, y, z) {
                this._array[0] *= x;
                this._array[1] *= y;
                this._array[2] *= z;
                return this;
              }

              divide(other) {
                const v = other.array;
                this._array[0] /= v[0];
                this._array[1] /= v[1];
                this._array[2] /= v[2];
                return this;
              }

              divide3f(x, y, z) {
                this._array[0] /= x;
                this._array[1] /= y;
                this._array[2] /= z;
                return this;
              }

              negative() {
                this._array[0] = -this._array[0];
                this._array[1] = -this._array[1];
                this._array[2] = -this._array[2];
                return this;
              }

              clampf(minInclusive, maxInclusive) {
                const min = minInclusive.array;
                const max = maxInclusive.array;
                this._array[0] = clamp(this._array[0], min[0], max[0]);
                this._array[1] = clamp(this._array[1], min[1], max[1]);
                this._array[2] = clamp(this._array[2], min[2], max[2]);
                return this;
              }

              dot(other) {
                const v = other.array;
                return this._array[0] * v[0] + this._array[1] * v[1] + this._array[2] * v[2];
              }

              cross(other) {
                const ax = this._array[0];
                const ay = this._array[1];
                const az = this._array[2];
                const bx = other.array[0];
                const by = other.array[1];
                const bz = other.array[2];
                this._array[0] = ay * bz - az * by;
                this._array[1] = az * bx - ax * bz;
                this._array[2] = ax * by - ay * bx;
                return this;
              }

              length() {
                return Math.sqrt(this._array[0] * this._array[0] + this._array[1] * this._array[1] + this._array[2] * this._array[2]);
              }

              lengthSqr() {
                return this._array[0] * this._array[0] + this._array[1] * this._array[1] + this._array[2] * this._array[2];
              }

              normalize() {
                const x = this._array[0];
                const y = this._array[1];
                const z = this._array[2];
                let len = x * x + y * y + z * z;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this._array[0] = x * len;
                  this._array[1] = y * len;
                  this._array[2] = z * len;
                }

                return this;
              }

              transformMat4(matrix) {
                const x = this._array[0];
                const y = this._array[1];
                const z = this._array[2];
                const v = matrix.array;
                let rhw = v[3] * x + v[7] * y + v[11] * z + v[15];
                rhw = rhw ? 1 / rhw : 1;
                this._array[0] = (v[0] * x + v[4] * y + v[8] * z + v[12]) * rhw;
                this._array[1] = (v[1] * x + v[5] * y + v[9] * z + v[13]) * rhw;
                this._array[2] = (v[2] * x + v[6] * y + v[10] * z + v[14]) * rhw;
                return this;
              }

            } exports('bY', Vec3);
            Vec3.UNIT_X = Object.freeze(new Vec3(1, 0, 0));
            Vec3.UNIT_Y = Object.freeze(new Vec3(0, 1, 0));
            Vec3.UNIT_Z = Object.freeze(new Vec3(0, 0, 1));
            Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
            Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
            Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
            Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
            Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
            Vec3.NEG_ONE = Object.freeze(new Vec3(-1, -1, -1));
            const v3_1 = new Vec3();
            const v3_2 = new Vec3();
            enumerableProps(Vec3.prototype, ['x', 'y', 'z']);
            CCClass.fastDefine('cc.Vec3', Vec3, {
              x: 0,
              y: 0,
              z: 0
            });
            legacyCC.Vec3 = Vec3;
            function v3(x, y, z) {
              return new Vec3(x, y, z);
            }
            legacyCC.v3 = v3;

            class Mat3 extends MathBase {
              static clone(a) {
                return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
              }

              static copy(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m03;
                out.m04 = a.m04;
                out.m05 = a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                return out;
              }

              static set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
                out.m00 = m00;
                out.m01 = m01;
                out.m02 = m02;
                out.m03 = m10;
                out.m04 = m11;
                out.m05 = m12;
                out.m06 = m20;
                out.m07 = m21;
                out.m08 = m22;
                return out;
              }

              static identity(out) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 1;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              }

              static transpose(out, a) {
                if (out === a) {
                  const a01 = a.m01;
                  const a02 = a.m02;
                  const a12 = a.m05;
                  out.m01 = a.m03;
                  out.m02 = a.m06;
                  out.m03 = a01;
                  out.m05 = a.m07;
                  out.m06 = a02;
                  out.m07 = a12;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m03;
                  out.m02 = a.m06;
                  out.m03 = a.m01;
                  out.m04 = a.m04;
                  out.m05 = a.m07;
                  out.m06 = a.m02;
                  out.m07 = a.m05;
                  out.m08 = a.m08;
                }

                return out;
              }

              static invert(out, a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const b01 = a22 * a11 - a12 * a21;
                const b11 = -a22 * a10 + a12 * a20;
                const b21 = a21 * a10 - a11 * a20;
                let det = a00 * b01 + a01 * b11 + a02 * b21;

                if (det === 0) {
                  out.m00 = 0;
                  out.m01 = 0;
                  out.m02 = 0;
                  out.m03 = 0;
                  out.m04 = 0;
                  out.m05 = 0;
                  out.m06 = 0;
                  out.m07 = 0;
                  out.m08 = 0;
                  return out;
                }

                det = 1.0 / det;
                out.m00 = b01 * det;
                out.m01 = (-a22 * a01 + a02 * a21) * det;
                out.m02 = (a12 * a01 - a02 * a11) * det;
                out.m03 = b11 * det;
                out.m04 = (a22 * a00 - a02 * a20) * det;
                out.m05 = (-a12 * a00 + a02 * a10) * det;
                out.m06 = b21 * det;
                out.m07 = (-a21 * a00 + a01 * a20) * det;
                out.m08 = (a11 * a00 - a01 * a10) * det;
                return out;
              }

              static determinant(a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
              }

              static multiply(out, a, b) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const b00 = b.m00;
                const b01 = b.m01;
                const b02 = b.m02;
                const b10 = b.m03;
                const b11 = b.m04;
                const b12 = b.m05;
                const b20 = b.m06;
                const b21 = b.m07;
                const b22 = b.m08;
                out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
                out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
                out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
                out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
                out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
                out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
                out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
                out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
                out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
                return out;
              }

              static multiplyMat4(out, a, b) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const b00 = b.m00;
                const b01 = b.m01;
                const b02 = b.m02;
                const b10 = b.m04;
                const b11 = b.m05;
                const b12 = b.m06;
                const b20 = b.m08;
                const b21 = b.m09;
                const b22 = b.m10;
                out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
                out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
                out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
                out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
                out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
                out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
                out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
                out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
                out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
                return out;
              }

              static transform(out, a, v) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const x = v.x;
                const y = v.y;
                out.m00 = a00;
                out.m01 = a01;
                out.m02 = a02;
                out.m03 = a10;
                out.m04 = a11;
                out.m05 = a12;
                out.m06 = x * a00 + y * a10 + a20;
                out.m07 = x * a01 + y * a11 + a21;
                out.m08 = x * a02 + y * a12 + a22;
                return out;
              }

              static scale(out, a, v) {
                const x = v.x;
                const y = v.y;
                out.m00 = x * a.m00;
                out.m01 = x * a.m01;
                out.m02 = x * a.m02;
                out.m03 = y * a.m03;
                out.m04 = y * a.m04;
                out.m05 = y * a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                return out;
              }

              static rotate(out, a, rad) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a10 = a.m03;
                const a11 = a.m04;
                const a12 = a.m05;
                const a20 = a.m06;
                const a21 = a.m07;
                const a22 = a.m08;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = c * a00 + s * a10;
                out.m01 = c * a01 + s * a11;
                out.m02 = c * a02 + s * a12;
                out.m03 = c * a10 - s * a00;
                out.m04 = c * a11 - s * a01;
                out.m05 = c * a12 - s * a02;
                out.m06 = a20;
                out.m07 = a21;
                out.m08 = a22;
                return out;
              }

              static fromMat4(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m04;
                out.m04 = a.m05;
                out.m05 = a.m06;
                out.m06 = a.m08;
                out.m07 = a.m09;
                out.m08 = a.m10;
                return out;
              }

              static fromViewUp(out, view, up) {
                if (Vec3.lengthSqr(view) < EPSILON * EPSILON) {
                  Mat3.identity(out);
                  return out;
                }

                Vec3.normalize(v3_1$1, Vec3.cross(v3_1$1, up || Vec3.UNIT_Y, view));

                if (Vec3.lengthSqr(v3_1$1) < EPSILON * EPSILON) {
                  Mat3.identity(out);
                  return out;
                }

                Vec3.cross(v3_2$1, view, v3_1$1);
                Mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z);
                return out;
              }

              static fromTranslation(out, v) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 1;
                out.m05 = 0;
                out.m06 = v.x;
                out.m07 = v.y;
                out.m08 = 1;
                return out;
              }

              static fromScaling(out, v) {
                out.m00 = v.x;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = v.y;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              }

              static fromRotation(out, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = c;
                out.m01 = s;
                out.m02 = 0;
                out.m03 = -s;
                out.m04 = c;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              }

              static fromQuat(out, q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const yx = y * x2;
                const yy = y * y2;
                const zx = z * x2;
                const zy = z * y2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                out.m00 = 1 - yy - zz;
                out.m03 = yx - wz;
                out.m06 = zx + wy;
                out.m01 = yx + wz;
                out.m04 = 1 - xx - zz;
                out.m07 = zy - wx;
                out.m02 = zx - wy;
                out.m05 = zy + wx;
                out.m08 = 1 - xx - yy;
                return out;
              }

              static inverseTransposeMat4(out, a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (!det) {
                  return null;
                }

                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                return out;
              }

              static toArray(out, m, ofs = 0) {
                out[ofs + 0] = m.m00;
                out[ofs + 1] = m.m01;
                out[ofs + 2] = m.m02;
                out[ofs + 3] = m.m03;
                out[ofs + 4] = m.m04;
                out[ofs + 5] = m.m05;
                out[ofs + 6] = m.m06;
                out[ofs + 7] = m.m07;
                out[ofs + 8] = m.m08;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.m00 = arr[ofs + 0];
                out.m01 = arr[ofs + 1];
                out.m02 = arr[ofs + 2];
                out.m03 = arr[ofs + 3];
                out.m04 = arr[ofs + 4];
                out.m05 = arr[ofs + 5];
                out.m06 = arr[ofs + 6];
                out.m07 = arr[ofs + 7];
                out.m08 = arr[ofs + 8];
                return out;
              }

              static add(out, a, b) {
                out.m00 = a.m00 + b.m00;
                out.m01 = a.m01 + b.m01;
                out.m02 = a.m02 + b.m02;
                out.m03 = a.m03 + b.m03;
                out.m04 = a.m04 + b.m04;
                out.m05 = a.m05 + b.m05;
                out.m06 = a.m06 + b.m06;
                out.m07 = a.m07 + b.m07;
                out.m08 = a.m08 + b.m08;
                return out;
              }

              static subtract(out, a, b) {
                out.m00 = a.m00 - b.m00;
                out.m01 = a.m01 - b.m01;
                out.m02 = a.m02 - b.m02;
                out.m03 = a.m03 - b.m03;
                out.m04 = a.m04 - b.m04;
                out.m05 = a.m05 - b.m05;
                out.m06 = a.m06 - b.m06;
                out.m07 = a.m07 - b.m07;
                out.m08 = a.m08 - b.m08;
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.m00 = a.m00 * b;
                out.m01 = a.m01 * b;
                out.m02 = a.m02 * b;
                out.m03 = a.m03 * b;
                out.m04 = a.m04 * b;
                out.m05 = a.m05 * b;
                out.m06 = a.m06 * b;
                out.m07 = a.m07 * b;
                out.m08 = a.m08 * b;
                return out;
              }

              static multiplyScalarAndAdd(out, a, b, scale) {
                out.m00 = b.m00 * scale + a.m00;
                out.m01 = b.m01 * scale + a.m01;
                out.m02 = b.m02 * scale + a.m02;
                out.m03 = b.m03 * scale + a.m03;
                out.m04 = b.m04 * scale + a.m04;
                out.m05 = b.m05 * scale + a.m05;
                out.m06 = b.m06 * scale + a.m06;
                out.m07 = b.m07 * scale + a.m07;
                out.m08 = b.m08 * scale + a.m08;
                return out;
              }

              static strictEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08));
              }

              get m00() {
                return this._array[0];
              }

              set m00(m) {
                this._array[0] = m;
              }

              get m01() {
                return this._array[1];
              }

              set m01(m) {
                this._array[1] = m;
              }

              get m02() {
                return this._array[2];
              }

              set m02(m) {
                this._array[2] = m;
              }

              get m03() {
                return this._array[3];
              }

              set m03(m) {
                this._array[3] = m;
              }

              get m04() {
                return this._array[4];
              }

              set m04(m) {
                this._array[4] = m;
              }

              get m05() {
                return this._array[5];
              }

              set m05(m) {
                this._array[5] = m;
              }

              get m06() {
                return this._array[6];
              }

              set m06(m) {
                this._array[6] = m;
              }

              get m07() {
                return this._array[7];
              }

              set m07(m) {
                this._array[7] = m;
              }

              get m08() {
                return this._array[8];
              }

              set m08(m) {
                this._array[8] = m;
              }

              constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 1, m05 = 0, m06 = 0, m07 = 0, m08 = 1) {
                super();

                if (m00 && typeof m00 === 'object') {
                  if (ArrayBuffer.isView(m00)) {
                    this._array = m00;

                    this._array.set([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                  } else {
                    const v = m00.array;
                    this._array = MathBase.createFloatArray(9);
                    this._array[0] = v[0];
                    this._array[1] = v[1];
                    this._array[2] = v[2];
                    this._array[3] = v[3];
                    this._array[4] = v[4];
                    this._array[5] = v[5];
                    this._array[6] = v[6];
                    this._array[7] = v[7];
                    this._array[8] = v[8];
                  }
                } else {
                  this._array = MathBase.createFloatArray(9);
                  this._array[0] = m00;
                  this._array[1] = m01;
                  this._array[2] = m02;
                  this._array[3] = m03;
                  this._array[4] = m04;
                  this._array[5] = m05;
                  this._array[6] = m06;
                  this._array[7] = m07;
                  this._array[8] = m08;
                }
              }

              clone() {
                const m = this._array;
                return new Mat3(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
              }

              set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 1, m05 = 0, m06 = 0, m07 = 0, m08 = 1) {
                if (m00 && typeof m00 === 'object') {
                  const v = m00.array;
                  this._array[0] = v[0];
                  this._array[1] = v[1];
                  this._array[2] = v[2];
                  this._array[3] = v[3];
                  this._array[4] = v[4];
                  this._array[5] = v[5];
                  this._array[6] = v[6];
                  this._array[7] = v[7];
                  this._array[8] = v[8];
                } else {
                  this._array[0] = m00;
                  this._array[1] = m01;
                  this._array[2] = m02;
                  this._array[3] = m03;
                  this._array[4] = m04;
                  this._array[5] = m05;
                  this._array[6] = m06;
                  this._array[7] = m07;
                  this._array[8] = m08;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                const v = other.array;
                return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3])) && Math.abs(this._array[4] - v[4]) <= epsilon * Math.max(1.0, Math.abs(this._array[4]), Math.abs(v[4])) && Math.abs(this._array[5] - v[5]) <= epsilon * Math.max(1.0, Math.abs(this._array[5]), Math.abs(v[5])) && Math.abs(this._array[6] - v[6]) <= epsilon * Math.max(1.0, Math.abs(this._array[6]), Math.abs(v[6])) && Math.abs(this._array[7] - v[7]) <= epsilon * Math.max(1.0, Math.abs(this._array[7]), Math.abs(v[7])) && Math.abs(this._array[8] - v[8]) <= epsilon * Math.max(1.0, Math.abs(this._array[8]), Math.abs(v[8]));
              }

              strictEquals(other) {
                const v = other.array;
                return this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3] && this._array[4] === v[4] && this._array[5] === v[5] && this._array[6] === v[6] && this._array[7] === v[7] && this._array[8] === v[8];
              }

              toString() {
                return `[\n${this._array[0]}, ${this._array[1]}, ${this._array[2]},\n${this._array[3]},\n${this._array[4]}, ${this._array[5]},\n${this._array[6]}, ${this._array[7]},\n${this._array[8]}\n` + `]`;
              }

              identity() {
                this._array[0] = 1;
                this._array[1] = 0;
                this._array[2] = 0;
                this._array[3] = 0;
                this._array[4] = 1;
                this._array[5] = 0;
                this._array[6] = 0;
                this._array[7] = 0;
                this._array[8] = 1;
                return this;
              }

              transpose() {
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a12 = this._array[5];
                this._array[1] = this._array[3];
                this._array[2] = this._array[6];
                this._array[3] = a01;
                this._array[5] = this._array[7];
                this._array[6] = a02;
                this._array[7] = a12;
                return this;
              }

              invert() {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a10 = this._array[3];
                const a11 = this._array[4];
                const a12 = this._array[5];
                const a20 = this._array[6];
                const a21 = this._array[7];
                const a22 = this._array[8];
                const b01 = a22 * a11 - a12 * a21;
                const b11 = -a22 * a10 + a12 * a20;
                const b21 = a21 * a10 - a11 * a20;
                let det = a00 * b01 + a01 * b11 + a02 * b21;

                if (det === 0) {
                  this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                  return this;
                }

                det = 1.0 / det;
                this._array[0] = b01 * det;
                this._array[1] = (-a22 * a01 + a02 * a21) * det;
                this._array[2] = (a12 * a01 - a02 * a11) * det;
                this._array[3] = b11 * det;
                this._array[4] = (a22 * a00 - a02 * a20) * det;
                this._array[5] = (-a12 * a00 + a02 * a10) * det;
                this._array[6] = b21 * det;
                this._array[7] = (-a21 * a00 + a01 * a20) * det;
                this._array[8] = (a11 * a00 - a01 * a10) * det;
                return this;
              }

              determinant() {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a10 = this._array[3];
                const a11 = this._array[4];
                const a12 = this._array[5];
                const a20 = this._array[6];
                const a21 = this._array[7];
                const a22 = this._array[8];
                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
              }

              add(mat) {
                const v = mat.array;
                this._array[0] += v[0];
                this._array[1] += v[1];
                this._array[2] += v[2];
                this._array[3] += v[3];
                this._array[4] += v[4];
                this._array[5] += v[5];
                this._array[6] += v[6];
                this._array[7] += v[7];
                this._array[8] += v[8];
                return this;
              }

              subtract(mat) {
                const v = mat.array;
                this._array[0] -= v[0];
                this._array[1] -= v[1];
                this._array[2] -= v[2];
                this._array[3] -= v[3];
                this._array[4] -= v[4];
                this._array[5] -= v[5];
                this._array[6] -= v[6];
                this._array[7] -= v[7];
                this._array[8] -= v[8];
                return this;
              }

              multiply(mat) {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a10 = this._array[3];
                const a11 = this._array[4];
                const a12 = this._array[5];
                const a20 = this._array[6];
                const a21 = this._array[7];
                const a22 = this._array[8];
                const v = mat.array;
                const b00 = v[0];
                const b01 = v[1];
                const b02 = v[2];
                const b10 = v[3];
                const b11 = v[4];
                const b12 = v[5];
                const b20 = v[6];
                const b21 = v[7];
                const b22 = v[8];
                this._array[0] = b00 * a00 + b01 * a10 + b02 * a20;
                this._array[1] = b00 * a01 + b01 * a11 + b02 * a21;
                this._array[2] = b00 * a02 + b01 * a12 + b02 * a22;
                this._array[3] = b10 * a00 + b11 * a10 + b12 * a20;
                this._array[4] = b10 * a01 + b11 * a11 + b12 * a21;
                this._array[5] = b10 * a02 + b11 * a12 + b12 * a22;
                this._array[6] = b20 * a00 + b21 * a10 + b22 * a20;
                this._array[7] = b20 * a01 + b21 * a11 + b22 * a21;
                this._array[8] = b20 * a02 + b21 * a12 + b22 * a22;
                return this;
              }

              multiplyScalar(scalar) {
                this._array[0] *= scalar;
                this._array[1] *= scalar;
                this._array[2] *= scalar;
                this._array[3] *= scalar;
                this._array[4] *= scalar;
                this._array[5] *= scalar;
                this._array[6] *= scalar;
                this._array[7] *= scalar;
                this._array[8] *= scalar;
                return this;
              }

              scale(vec) {
                const x = vec.array[0];
                const y = vec.array[1];
                this._array[0] *= x;
                this._array[1] *= x;
                this._array[2] *= x;
                this._array[3] *= y;
                this._array[4] *= y;
                this._array[5] *= y;
                return this;
              }

              rotate(rad) {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a10 = this._array[3];
                const a11 = this._array[4];
                const a12 = this._array[5];
                const a20 = this._array[6];
                const a21 = this._array[7];
                const a22 = this._array[8];
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                this._array[0] = c * a00 + s * a10;
                this._array[1] = c * a01 + s * a11;
                this._array[2] = c * a02 + s * a12;
                this._array[3] = c * a10 - s * a00;
                this._array[4] = c * a11 - s * a01;
                this._array[5] = c * a12 - s * a02;
                this._array[6] = a20;
                this._array[7] = a21;
                this._array[8] = a22;
                return this;
              }

              fromQuat(q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const yx = y * x2;
                const yy = y * y2;
                const zx = z * x2;
                const zy = z * y2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                this._array[0] = 1 - yy - zz;
                this._array[3] = yx - wz;
                this._array[6] = zx + wy;
                this._array[1] = yx + wz;
                this._array[4] = 1 - xx - zz;
                this._array[7] = zy - wx;
                this._array[2] = zx - wy;
                this._array[5] = zy + wx;
                this._array[8] = 1 - xx - yy;
                return this;
              }

            } exports('f3', Mat3);
            Mat3.IDENTITY = Object.freeze(new Mat3());
            const v3_1$1 = new Vec3();
            const v3_2$1 = new Vec3();
            enumerableProps(Mat3.prototype, ['m00', 'm01', 'm02', 'm03', 'm04', 'm05', 'm06', 'm07', 'm08']);
            CCClass.fastDefine('cc.Mat3', Mat3, {
              m00: 1,
              m01: 0,
              m02: 0,
              m03: 0,
              m04: 1,
              m05: 0,
              m06: 0,
              m07: 0,
              m08: 1
            });
            legacyCC.Mat3 = Mat3;

            class Quat extends MathBase {
              static clone(a) {
                return new Quat(a.x, a.y, a.z, a.w);
              }

              static copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = a.w;
                return out;
              }

              static set(out, x, y, z, w) {
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              }

              static identity(out) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return out;
              }

              static rotationTo(out, a, b) {
                const dot = Vec3.dot(a, b);

                if (dot < -0.999999) {
                  Vec3.cross(v3_1$2, Vec3.UNIT_X, a);

                  if (v3_1$2.length() < 0.000001) {
                    Vec3.cross(v3_1$2, Vec3.UNIT_Y, a);
                  }

                  Vec3.normalize(v3_1$2, v3_1$2);
                  Quat.fromAxisAngle(out, v3_1$2, Math.PI);
                  return out;
                } else if (dot > 0.999999) {
                  out.x = 0;
                  out.y = 0;
                  out.z = 0;
                  out.w = 1;
                  return out;
                } else {
                  Vec3.cross(v3_1$2, a, b);
                  out.x = v3_1$2.x;
                  out.y = v3_1$2.y;
                  out.z = v3_1$2.z;
                  out.w = 1 + dot;
                  return Quat.normalize(out, out);
                }
              }

              static getAxisAngle(outAxis, q) {
                const rad = Math.acos(q.w) * 2.0;
                const s = Math.sin(rad / 2.0);

                if (s !== 0.0) {
                  outAxis.x = q.x / s;
                  outAxis.y = q.y / s;
                  outAxis.z = q.z / s;
                } else {
                  outAxis.x = 1;
                  outAxis.y = 0;
                  outAxis.z = 0;
                }

                return rad;
              }

              static multiply(out, a, b) {
                const x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
                const y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
                const z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
                const w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                out.w = a.w * b;
                return out;
              }

              static scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                out.w = a.w + b.w * scale;
                return out;
              }

              static rotateX(out, a, rad) {
                rad *= 0.5;
                const bx = Math.sin(rad);
                const bw = Math.cos(rad);
                const {
                  x,
                  y,
                  z,
                  w
                } = a;
                out.x = x * bw + w * bx;
                out.y = y * bw + z * bx;
                out.z = z * bw - y * bx;
                out.w = w * bw - x * bx;
                return out;
              }

              static rotateY(out, a, rad) {
                rad *= 0.5;
                const by = Math.sin(rad);
                const bw = Math.cos(rad);
                const {
                  x,
                  y,
                  z,
                  w
                } = a;
                out.x = x * bw - z * by;
                out.y = y * bw + w * by;
                out.z = z * bw + x * by;
                out.w = w * bw - y * by;
                return out;
              }

              static rotateZ(out, a, rad) {
                rad *= 0.5;
                const bz = Math.sin(rad);
                const bw = Math.cos(rad);
                const {
                  x,
                  y,
                  z,
                  w
                } = a;
                out.x = x * bw + y * bz;
                out.y = y * bw - x * bz;
                out.z = z * bw + w * bz;
                out.w = w * bw - z * bz;
                return out;
              }

              static rotateAround(out, rot, axis, rad) {
                Quat.invert(qt_1, rot);
                Vec3.transformQuat(v3_1$2, axis, qt_1);
                Quat.fromAxisAngle(qt_1, v3_1$2, rad);
                Quat.multiply(out, rot, qt_1);
                return out;
              }

              static rotateAroundLocal(out, rot, axis, rad) {
                Quat.fromAxisAngle(qt_1, axis, rad);
                Quat.multiply(out, rot, qt_1);
                return out;
              }

              static calculateW(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = Math.sqrt(Math.abs(1.0 - a.x * a.x - a.y * a.y - a.z * a.z));
                return out;
              }

              static dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
              }

              static lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                out.w = a.w + t * (b.w - a.w);
                return out;
              }

              static slerp(out, a, b, t) {
                let scale0 = 0;
                let scale1 = 0;
                let bx = b.x;
                let by = b.y;
                let bz = b.z;
                let bw = b.w;
                let cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;

                if (cosom < 0.0) {
                  cosom = -cosom;
                  bx = -bx;
                  by = -by;
                  bz = -bz;
                  bw = -bw;
                }

                if (1.0 - cosom > 0.000001) {
                  const omega = Math.acos(cosom);
                  const sinom = Math.sin(omega);
                  scale0 = Math.sin((1.0 - t) * omega) / sinom;
                  scale1 = Math.sin(t * omega) / sinom;
                } else {
                  scale0 = 1.0 - t;
                  scale1 = t;
                }

                out.x = scale0 * a.x + scale1 * bx;
                out.y = scale0 * a.y + scale1 * by;
                out.z = scale0 * a.z + scale1 * bz;
                out.w = scale0 * a.w + scale1 * bw;
                return out;
              }

              static sqlerp(out, a, b, c, d, t) {
                Quat.slerp(qt_1, a, d, t);
                Quat.slerp(qt_2, b, c, t);
                Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t));
                return out;
              }

              static invert(out, a) {
                const dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
                const invDot = dot ? 1.0 / dot : 0;
                out.x = -a.x * invDot;
                out.y = -a.y * invDot;
                out.z = -a.z * invDot;
                out.w = a.w * invDot;
                return out;
              }

              static conjugate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                out.w = a.w;
                return out;
              }

              static len(a) {
                return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
              }

              static lengthSqr(a) {
                return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
              }

              static normalize(out, a) {
                let len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  out.x = a.x * len;
                  out.y = a.y * len;
                  out.z = a.z * len;
                  out.w = a.w * len;
                }

                return out;
              }

              static fromAxes(out, xAxis, yAxis, zAxis) {
                Mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
                return Quat.normalize(out, Quat.fromMat3(out, m3_1));
              }

              static fromViewUp(out, view, up) {
                Mat3.fromViewUp(m3_1, view, up);
                return Quat.normalize(out, Quat.fromMat3(out, m3_1));
              }

              static fromAxisAngle(out, axis, rad) {
                rad *= 0.5;
                const s = Math.sin(rad);
                out.x = s * axis.x;
                out.y = s * axis.y;
                out.z = s * axis.z;
                out.w = Math.cos(rad);
                return out;
              }

              static fromMat3(out, m) {
                const {
                  m00,
                  m03: m01,
                  m06: m02,
                  m01: m10,
                  m04: m11,
                  m07: m12,
                  m02: m20,
                  m05: m21,
                  m08: m22
                } = m;
                const trace = m00 + m11 + m22;

                if (trace > 0) {
                  const s = 0.5 / Math.sqrt(trace + 1.0);
                  out.w = 0.25 / s;
                  out.x = (m21 - m12) * s;
                  out.y = (m02 - m20) * s;
                  out.z = (m10 - m01) * s;
                } else if (m00 > m11 && m00 > m22) {
                  const s = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);
                  out.w = (m21 - m12) / s;
                  out.x = 0.25 * s;
                  out.y = (m01 + m10) / s;
                  out.z = (m02 + m20) / s;
                } else if (m11 > m22) {
                  const s = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);
                  out.w = (m02 - m20) / s;
                  out.x = (m01 + m10) / s;
                  out.y = 0.25 * s;
                  out.z = (m12 + m21) / s;
                } else {
                  const s = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);
                  out.w = (m10 - m01) / s;
                  out.x = (m02 + m20) / s;
                  out.y = (m12 + m21) / s;
                  out.z = 0.25 * s;
                }

                return out;
              }

              static fromEuler(out, x, y, z) {
                x *= halfToRad;
                y *= halfToRad;
                z *= halfToRad;
                const sx = Math.sin(x);
                const cx = Math.cos(x);
                const sy = Math.sin(y);
                const cy = Math.cos(y);
                const sz = Math.sin(z);
                const cz = Math.cos(z);
                out.x = sx * cy * cz + cx * sy * sz;
                out.y = cx * sy * cz + sx * cy * sz;
                out.z = cx * cy * sz - sx * sy * cz;
                out.w = cx * cy * cz - sx * sy * sz;
                return out;
              }

              static fromAngleZ(out, z) {
                z *= halfToRad;
                out.x = out.y = 0;
                out.z = Math.sin(z);
                out.w = Math.cos(z);
                return out;
              }

              static toAxisX(out, q) {
                const fy = 2.0 * q.y;
                const fz = 2.0 * q.z;
                out.x = 1.0 - fy * q.y - fz * q.z;
                out.y = fy * q.x + fz * q.w;
                out.z = fz * q.x + fy * q.w;
                return out;
              }

              static toAxisY(out, q) {
                const fx = 2.0 * q.x;
                const fy = 2.0 * q.y;
                const fz = 2.0 * q.z;
                out.x = fy * q.x - fz * q.w;
                out.y = 1.0 - fx * q.x - fz * q.z;
                out.z = fz * q.y + fx * q.w;
                return out;
              }

              static toAxisZ(out, q) {
                const fx = 2.0 * q.x;
                const fy = 2.0 * q.y;
                const fz = 2.0 * q.z;
                out.x = fz * q.x - fy * q.w;
                out.y = fz * q.y - fx * q.w;
                out.z = 1.0 - fx * q.x - fy * q.y;
                return out;
              }

              static toEuler(out, q, outerZ) {
                const {
                  x,
                  y,
                  z,
                  w
                } = q;
                let bank = 0;
                let heading = 0;
                let attitude = 0;
                const test = x * y + z * w;

                if (test > 0.499999) {
                  bank = 0;
                  heading = toDegree(2 * Math.atan2(x, w));
                  attitude = 90;
                } else if (test < -0.499999) {
                  bank = 0;
                  heading = -toDegree(2 * Math.atan2(x, w));
                  attitude = -90;
                } else {
                  const sqx = x * x;
                  const sqy = y * y;
                  const sqz = z * z;
                  bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz));
                  heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz));
                  attitude = toDegree(Math.asin(2 * test));

                  if (outerZ) {
                    bank = -180 * Math.sign(bank + 1e-6) + bank;
                    heading = -180 * Math.sign(heading + 1e-6) + heading;
                    attitude = 180 * Math.sign(attitude + 1e-6) - attitude;
                  }
                }

                out.x = bank;
                out.y = heading;
                out.z = attitude;
                return out;
              }

              static toArray(out, q, ofs = 0) {
                out[ofs + 0] = q.x;
                out[ofs + 1] = q.y;
                out[ofs + 2] = q.z;
                out[ofs + 3] = q.w;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                out.w = arr[ofs + 3];
                return out;
              }

              static strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
              }

              get x() {
                return this._array[0];
              }

              set x(x) {
                this._array[0] = x;
              }

              get y() {
                return this._array[1];
              }

              set y(y) {
                this._array[1] = y;
              }

              get z() {
                return this._array[2];
              }

              set z(z) {
                this._array[2] = z;
              }

              get w() {
                return this._array[3];
              }

              set w(w) {
                this._array[3] = w;
              }

              constructor(x, y, z, w) {
                super();

                if (x && typeof x === 'object') {
                  if (ArrayBuffer.isView(x)) {
                    this._array = x;

                    this._array.fill(0);

                    this._array[3] = 1;
                  } else {
                    const v = x.array;
                    this._array = MathBase.createFloatArray(4);
                    this._array[0] = v[0];
                    this._array[1] = v[1];
                    this._array[2] = v[2];
                    this._array[3] = v[3];
                  }
                } else {
                  this._array = MathBase.createFloatArray(4);
                  this._array[0] = x || 0;
                  this._array[1] = y || 0;
                  this._array[2] = z || 0;
                  this._array[3] = w !== null && w !== void 0 ? w : 1;
                }
              }

              clone() {
                return new Quat(this._array[0], this._array[1], this._array[2], this._array[3]);
              }

              set(x, y, z, w) {
                if (x && typeof x === 'object') {
                  const v = x.array;
                  this._array[0] = v[0];
                  this._array[1] = v[1];
                  this._array[2] = v[2];
                  this._array[3] = v[3];
                } else {
                  this._array[0] = x || 0;
                  this._array[1] = y || 0;
                  this._array[2] = z || 0;
                  this._array[3] = w !== null && w !== void 0 ? w : 1;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                const v = other.array;
                return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3]));
              }

              strictEquals(other) {
                const v = other.array;
                return other && this._array[0] === v[0] && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3];
              }

              getEulerAngles(out) {
                return Quat.toEuler(out, this);
              }

              lerp(to, ratio) {
                const tq = to.array;
                this._array[0] += ratio * (tq[0] - this._array[0]);
                this._array[1] += ratio * (tq[1] - this._array[1]);
                this._array[2] += ratio * (tq[2] - this._array[2]);
                this._array[3] += ratio * (tq[3] - this._array[3]);
                return this;
              }

              slerp(to, ratio) {
                return Quat.slerp(this, this, to, ratio);
              }

              length() {
                const v = this._array;
                return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3]);
              }

              lengthSqr() {
                const v = this._array;
                return v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3];
              }

            } exports('cD', Quat);
            Quat.IDENTITY = Object.freeze(new Quat());
            enumerableProps(Quat.prototype, ['x', 'y', 'z', 'w']);
            const qt_1 = new Quat();
            const qt_2 = new Quat();
            const v3_1$2 = new Vec3();
            const m3_1 = new Mat3();
            const halfToRad = 0.5 * Math.PI / 180.0;
            CCClass.fastDefine('cc.Quat', Quat, {
              x: 0,
              y: 0,
              z: 0,
              w: 1
            });
            legacyCC.Quat = Quat;
            function quat(x = 0, y = 0, z = 0, w = 1) {
              return new Quat(x, y, z, w);
            }
            legacyCC.quat = quat;

            const preTransforms = exports('c4', Object.freeze([Object.freeze([1, 0, 0, 1]), Object.freeze([0, 1, -1, 0]), Object.freeze([-1, 0, 0, -1]), Object.freeze([0, -1, 1, 0])]));
            class Mat4 extends MathBase {
              static clone(a) {
                return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
              }

              static copy(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m03;
                out.m04 = a.m04;
                out.m05 = a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                out.m09 = a.m09;
                out.m10 = a.m10;
                out.m11 = a.m11;
                out.m12 = a.m12;
                out.m13 = a.m13;
                out.m14 = a.m14;
                out.m15 = a.m15;
                return out;
              }

              static set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                out.m00 = m00;
                out.m01 = m01;
                out.m02 = m02;
                out.m03 = m03;
                out.m04 = m10;
                out.m05 = m11;
                out.m06 = m12;
                out.m07 = m13;
                out.m08 = m20;
                out.m09 = m21;
                out.m10 = m22;
                out.m11 = m23;
                out.m12 = m30;
                out.m13 = m31;
                out.m14 = m32;
                out.m15 = m33;
                return out;
              }

              static identity(out) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = 1;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = 1;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static transpose(out, a) {
                if (out === a) {
                  const a01 = a.m01;
                  const a02 = a.m02;
                  const a03 = a.m03;
                  const a12 = a.m06;
                  const a13 = a.m07;
                  const a23 = a.m11;
                  out.m01 = a.m04;
                  out.m02 = a.m08;
                  out.m03 = a.m12;
                  out.m04 = a01;
                  out.m06 = a.m09;
                  out.m07 = a.m13;
                  out.m08 = a02;
                  out.m09 = a12;
                  out.m11 = a.m14;
                  out.m12 = a03;
                  out.m13 = a13;
                  out.m14 = a23;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m04;
                  out.m02 = a.m08;
                  out.m03 = a.m12;
                  out.m04 = a.m01;
                  out.m05 = a.m05;
                  out.m06 = a.m09;
                  out.m07 = a.m13;
                  out.m08 = a.m02;
                  out.m09 = a.m06;
                  out.m10 = a.m10;
                  out.m11 = a.m14;
                  out.m12 = a.m03;
                  out.m13 = a.m07;
                  out.m14 = a.m11;
                  out.m15 = a.m15;
                }

                return out;
              }

              static invert(out, a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (det === 0) {
                  out.m00 = 0;
                  out.m01 = 0;
                  out.m02 = 0;
                  out.m03 = 0;
                  out.m04 = 0;
                  out.m05 = 0;
                  out.m06 = 0;
                  out.m07 = 0;
                  out.m08 = 0;
                  out.m09 = 0;
                  out.m10 = 0;
                  out.m11 = 0;
                  out.m12 = 0;
                  out.m13 = 0;
                  out.m14 = 0;
                  out.m15 = 0;
                  return out;
                }

                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return out;
              }

              static determinant(a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              }

              static multiply(out, a, b) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                let b0 = b.m00;
                let b1 = b.m01;
                let b2 = b.m02;
                let b3 = b.m03;
                out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m04;
                b1 = b.m05;
                b2 = b.m06;
                b3 = b.m07;
                out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m08;
                b1 = b.m09;
                b2 = b.m10;
                b3 = b.m11;
                out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m12;
                b1 = b.m13;
                b2 = b.m14;
                b3 = b.m15;
                out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return out;
              }

              static transform(out, a, v) {
                const x = v.x;
                const y = v.y;
                const z = v.z;

                if (a === out) {
                  out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
                  out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
                  out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
                  out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
                } else {
                  const a00 = a.m00;
                  const a01 = a.m01;
                  const a02 = a.m02;
                  const a03 = a.m03;
                  const a10 = a.m04;
                  const a11 = a.m05;
                  const a12 = a.m06;
                  const a13 = a.m07;
                  const a20 = a.m08;
                  const a21 = a.m09;
                  const a22 = a.m10;
                  const a23 = a.m11;
                  const a30 = a.m12;
                  const a31 = a.m13;
                  const a32 = a.m14;
                  const a33 = a.m15;
                  out.m00 = a00;
                  out.m01 = a01;
                  out.m02 = a02;
                  out.m03 = a03;
                  out.m04 = a10;
                  out.m05 = a11;
                  out.m06 = a12;
                  out.m07 = a13;
                  out.m08 = a20;
                  out.m09 = a21;
                  out.m10 = a22;
                  out.m11 = a23;
                  out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
                  out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
                  out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
                  out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
                }

                return out;
              }

              static translate(out, a, v) {
                console.warn('function changed');

                if (a === out) {
                  out.m12 += v.x;
                  out.m13 += v.y;
                  out.m14 += v.z;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m01;
                  out.m02 = a.m02;
                  out.m03 = a.m03;
                  out.m04 = a.m04;
                  out.m05 = a.m05;
                  out.m06 = a.m06;
                  out.m07 = a.m07;
                  out.m08 = a.m08;
                  out.m09 = a.m09;
                  out.m10 = a.m10;
                  out.m11 = a.m11;
                  out.m12 += v.x;
                  out.m13 += v.y;
                  out.m14 += v.z;
                  out.m15 = a.m15;
                }

                return out;
              }

              static scale(out, a, v) {
                const x = v.x;
                const y = v.y;
                const z = v.z;
                out.m00 = a.m00 * x;
                out.m01 = a.m01 * x;
                out.m02 = a.m02 * x;
                out.m03 = a.m03 * x;
                out.m04 = a.m04 * y;
                out.m05 = a.m05 * y;
                out.m06 = a.m06 * y;
                out.m07 = a.m07 * y;
                out.m08 = a.m08 * z;
                out.m09 = a.m09 * z;
                out.m10 = a.m10 * z;
                out.m11 = a.m11 * z;
                out.m12 = a.m12;
                out.m13 = a.m13;
                out.m14 = a.m14;
                out.m15 = a.m15;
                return out;
              }

              static rotate(out, a, rad, axis) {
                let x = axis.x;
                let y = axis.y;
                let z = axis.z;
                let len = Math.sqrt(x * x + y * y + z * z);

                if (Math.abs(len) < EPSILON) {
                  return null;
                }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const b00 = x * x * t + c;
                const b01 = y * x * t + z * s;
                const b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s;
                const b11 = y * y * t + c;
                const b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s;
                const b21 = y * z * t - x * s;
                const b22 = z * z * t + c;
                out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
                out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
                out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
                out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
                out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
                out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
                out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
                out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
                out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
                out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
                out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
                out.m11 = a03 * b20 + a13 * b21 + a23 * b22;

                if (a !== out) {
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }

                return out;
              }

              static rotateX(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;

                if (a !== out) {
                  out.m00 = a.m00;
                  out.m01 = a.m01;
                  out.m02 = a.m02;
                  out.m03 = a.m03;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }

                out.m04 = a10 * c + a20 * s;
                out.m05 = a11 * c + a21 * s;
                out.m06 = a12 * c + a22 * s;
                out.m07 = a13 * c + a23 * s;
                out.m08 = a20 * c - a10 * s;
                out.m09 = a21 * c - a11 * s;
                out.m10 = a22 * c - a12 * s;
                out.m11 = a23 * c - a13 * s;
                return out;
              }

              static rotateY(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;

                if (a !== out) {
                  out.m04 = a.m04;
                  out.m05 = a.m05;
                  out.m06 = a.m06;
                  out.m07 = a.m07;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }

                out.m00 = a00 * c - a20 * s;
                out.m01 = a01 * c - a21 * s;
                out.m02 = a02 * c - a22 * s;
                out.m03 = a03 * c - a23 * s;
                out.m08 = a00 * s + a20 * c;
                out.m09 = a01 * s + a21 * c;
                out.m10 = a02 * s + a22 * c;
                out.m11 = a03 * s + a23 * c;
                return out;
              }

              static rotateZ(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;

                if (a !== out) {
                  out.m08 = a.m08;
                  out.m09 = a.m09;
                  out.m10 = a.m10;
                  out.m11 = a.m11;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }

                out.m00 = a00 * c + a10 * s;
                out.m01 = a01 * c + a11 * s;
                out.m02 = a02 * c + a12 * s;
                out.m03 = a03 * c + a13 * s;
                out.m04 = a10 * c - a00 * s;
                out.m05 = a11 * c - a01 * s;
                out.m06 = a12 * c - a02 * s;
                out.m07 = a13 * c - a03 * s;
                return out;
              }

              static fromTranslation(out, v) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = 1;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = 1;
                out.m11 = 0;
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                out.m15 = 1;
                return out;
              }

              static fromScaling(out, v) {
                out.m00 = v.x;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = v.y;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = v.z;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromRotation(out, rad, axis) {
                let x = axis.x;
                let y = axis.y;
                let z = axis.z;
                let len = Math.sqrt(x * x + y * y + z * z);

                if (Math.abs(len) < EPSILON) {
                  return null;
                }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                out.m00 = x * x * t + c;
                out.m01 = y * x * t + z * s;
                out.m02 = z * x * t - y * s;
                out.m03 = 0;
                out.m04 = x * y * t - z * s;
                out.m05 = y * y * t + c;
                out.m06 = z * y * t + x * s;
                out.m07 = 0;
                out.m08 = x * z * t + y * s;
                out.m09 = y * z * t - x * s;
                out.m10 = z * z * t + c;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromXRotation(out, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = c;
                out.m06 = s;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = -s;
                out.m10 = c;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromYRotation(out, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = c;
                out.m01 = 0;
                out.m02 = -s;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = 1;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = s;
                out.m09 = 0;
                out.m10 = c;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromZRotation(out, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                out.m00 = c;
                out.m01 = s;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = -s;
                out.m05 = c;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = 1;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static fromRT(out, q, v) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                out.m00 = 1 - (yy + zz);
                out.m01 = xy + wz;
                out.m02 = xz - wy;
                out.m03 = 0;
                out.m04 = xy - wz;
                out.m05 = 1 - (xx + zz);
                out.m06 = yz + wx;
                out.m07 = 0;
                out.m08 = xz + wy;
                out.m09 = yz - wx;
                out.m10 = 1 - (xx + yy);
                out.m11 = 0;
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                out.m15 = 1;
                return out;
              }

              static getTranslation(out, mat) {
                out.x = mat.m12;
                out.y = mat.m13;
                out.z = mat.m14;
                return out;
              }

              static getScaling(out, mat) {
                const m00 = m3_1$1.m00 = mat.m00;
                const m01 = m3_1$1.m01 = mat.m01;
                const m02 = m3_1$1.m02 = mat.m02;
                const m04 = m3_1$1.m03 = mat.m04;
                const m05 = m3_1$1.m04 = mat.m05;
                const m06 = m3_1$1.m05 = mat.m06;
                const m08 = m3_1$1.m06 = mat.m08;
                const m09 = m3_1$1.m07 = mat.m09;
                const m10 = m3_1$1.m08 = mat.m10;
                out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
                out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
                out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);

                if (Mat3.determinant(m3_1$1) < 0) {
                  out.x *= -1;
                }

                return out;
              }

              static getRotation(out, mat) {
                const trace = mat.m00 + mat.m05 + mat.m10;
                let S = 0;

                if (trace > 0) {
                  S = Math.sqrt(trace + 1.0) * 2;
                  out.w = 0.25 * S;
                  out.x = (mat.m06 - mat.m09) / S;
                  out.y = (mat.m08 - mat.m02) / S;
                  out.z = (mat.m01 - mat.m04) / S;
                } else if (mat.m00 > mat.m05 && mat.m00 > mat.m10) {
                  S = Math.sqrt(1.0 + mat.m00 - mat.m05 - mat.m10) * 2;
                  out.w = (mat.m06 - mat.m09) / S;
                  out.x = 0.25 * S;
                  out.y = (mat.m01 + mat.m04) / S;
                  out.z = (mat.m08 + mat.m02) / S;
                } else if (mat.m05 > mat.m10) {
                  S = Math.sqrt(1.0 + mat.m05 - mat.m00 - mat.m10) * 2;
                  out.w = (mat.m08 - mat.m02) / S;
                  out.x = (mat.m01 + mat.m04) / S;
                  out.y = 0.25 * S;
                  out.z = (mat.m06 + mat.m09) / S;
                } else {
                  S = Math.sqrt(1.0 + mat.m10 - mat.m00 - mat.m05) * 2;
                  out.w = (mat.m01 - mat.m04) / S;
                  out.x = (mat.m08 + mat.m02) / S;
                  out.y = (mat.m06 + mat.m09) / S;
                  out.z = 0.25 * S;
                }

                return out;
              }

              static toRTS(m, q, v, s) {
                s.x = Vec3.set(v3_1$3, m.m00, m.m01, m.m02).length();
                m3_1$1.m00 = m.m00 / s.x;
                m3_1$1.m01 = m.m01 / s.x;
                m3_1$1.m02 = m.m02 / s.x;
                s.y = Vec3.set(v3_1$3, m.m04, m.m05, m.m06).length();
                m3_1$1.m03 = m.m04 / s.y;
                m3_1$1.m04 = m.m05 / s.y;
                m3_1$1.m05 = m.m06 / s.y;
                s.z = Vec3.set(v3_1$3, m.m08, m.m09, m.m10).length();
                m3_1$1.m06 = m.m08 / s.z;
                m3_1$1.m07 = m.m09 / s.z;
                m3_1$1.m08 = m.m10 / s.z;
                const det = Mat3.determinant(m3_1$1);

                if (det < 0) {
                  s.x *= -1;
                  m3_1$1.m00 *= -1;
                  m3_1$1.m01 *= -1;
                  m3_1$1.m02 *= -1;
                }

                Quat.fromMat3(q, m3_1$1);
                Vec3.set(v, m.m12, m.m13, m.m14);
              }

              static fromRTS(out, q, v, s) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                const sx = s.x;
                const sy = s.y;
                const sz = s.z;
                out.m00 = (1 - (yy + zz)) * sx;
                out.m01 = (xy + wz) * sx;
                out.m02 = (xz - wy) * sx;
                out.m03 = 0;
                out.m04 = (xy - wz) * sy;
                out.m05 = (1 - (xx + zz)) * sy;
                out.m06 = (yz + wx) * sy;
                out.m07 = 0;
                out.m08 = (xz + wy) * sz;
                out.m09 = (yz - wx) * sz;
                out.m10 = (1 - (xx + yy)) * sz;
                out.m11 = 0;
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                out.m15 = 1;
                return out;
              }

              static fromRTSOrigin(out, q, v, s, o) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                const sx = s.x;
                const sy = s.y;
                const sz = s.z;
                const ox = o.x;
                const oy = o.y;
                const oz = o.z;
                out.m00 = (1 - (yy + zz)) * sx;
                out.m01 = (xy + wz) * sx;
                out.m02 = (xz - wy) * sx;
                out.m03 = 0;
                out.m04 = (xy - wz) * sy;
                out.m05 = (1 - (xx + zz)) * sy;
                out.m06 = (yz + wx) * sy;
                out.m07 = 0;
                out.m08 = (xz + wy) * sz;
                out.m09 = (yz - wx) * sz;
                out.m10 = (1 - (xx + yy)) * sz;
                out.m11 = 0;
                out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
                out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
                out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
                out.m15 = 1;
                return out;
              }

              static fromQuat(out, q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const yx = y * x2;
                const yy = y * y2;
                const zx = z * x2;
                const zy = z * y2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                out.m00 = 1 - yy - zz;
                out.m01 = yx + wz;
                out.m02 = zx - wy;
                out.m03 = 0;
                out.m04 = yx - wz;
                out.m05 = 1 - xx - zz;
                out.m06 = zy + wx;
                out.m07 = 0;
                out.m08 = zx + wy;
                out.m09 = zy - wx;
                out.m10 = 1 - xx - yy;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static frustum(out, left, right, bottom, top, near, far) {
                const rl = 1 / (right - left);
                const tb = 1 / (top - bottom);
                const nf = 1 / (near - far);
                out.m00 = near * 2 * rl;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = near * 2 * tb;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = (right + left) * rl;
                out.m09 = (top + bottom) * tb;
                out.m10 = (far + near) * nf;
                out.m11 = -1;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = far * near * 2 * nf;
                out.m15 = 0;
                return out;
              }

              static perspective(out, fov, aspect, near, far, isFOVY = true, minClipZ = -1, projectionSignY = 1, orientation = 0) {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                const x = isFOVY ? f / aspect : f;
                const y = (isFOVY ? f : f * aspect) * projectionSignY;
                const preTransform = preTransforms[orientation];
                out.m00 = x * preTransform[0];
                out.m01 = x * preTransform[1];
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = y * preTransform[2];
                out.m05 = y * preTransform[3];
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = (far - minClipZ * near) * nf;
                out.m11 = -1;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = far * near * nf * (1 - minClipZ);
                out.m15 = 0;
                return out;
              }

              static ortho(out, left, right, bottom, top, near, far, minClipZ = -1, projectionSignY = 1, orientation = 0) {
                const lr = 1 / (left - right);
                const bt = 1 / (bottom - top) * projectionSignY;
                const nf = 1 / (near - far);
                const x = -2 * lr;
                const y = -2 * bt;
                const dx = (left + right) * lr;
                const dy = (top + bottom) * bt;
                const preTransform = preTransforms[orientation];
                out.m00 = x * preTransform[0];
                out.m01 = x * preTransform[1];
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = y * preTransform[2];
                out.m05 = y * preTransform[3];
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = nf * (1 - minClipZ);
                out.m11 = 0;
                out.m12 = dx * preTransform[0] + dy * preTransform[2];
                out.m13 = dx * preTransform[1] + dy * preTransform[3];
                out.m14 = (near - minClipZ * far) * nf;
                out.m15 = 1;
                return out;
              }

              static lookAt(out, eye, center, up) {
                const eyex = eye.x;
                const eyey = eye.y;
                const eyez = eye.z;
                const upx = up.x;
                const upy = up.y;
                const upz = up.z;
                const centerx = center.x;
                const centery = center.y;
                const centerz = center.z;
                let z0 = eyex - centerx;
                let z1 = eyey - centery;
                let z2 = eyez - centerz;
                let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len;
                z1 *= len;
                z2 *= len;
                let x0 = upy * z2 - upz * z1;
                let x1 = upz * z0 - upx * z2;
                let x2 = upx * z1 - upy * z0;
                len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                x0 *= len;
                x1 *= len;
                x2 *= len;
                const y0 = z1 * x2 - z2 * x1;
                const y1 = z2 * x0 - z0 * x2;
                const y2 = z0 * x1 - z1 * x0;
                out.m00 = x0;
                out.m01 = y0;
                out.m02 = z0;
                out.m03 = 0;
                out.m04 = x1;
                out.m05 = y1;
                out.m06 = z1;
                out.m07 = 0;
                out.m08 = x2;
                out.m09 = y2;
                out.m10 = z2;
                out.m11 = 0;
                out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out.m15 = 1;
                return out;
              }

              static inverseTranspose(out, a) {
                const a00 = a.m00;
                const a01 = a.m01;
                const a02 = a.m02;
                const a03 = a.m03;
                const a10 = a.m04;
                const a11 = a.m05;
                const a12 = a.m06;
                const a13 = a.m07;
                const a20 = a.m08;
                const a21 = a.m09;
                const a22 = a.m10;
                const a23 = a.m11;
                const a30 = a.m12;
                const a31 = a.m13;
                const a32 = a.m14;
                const a33 = a.m15;
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (!det) {
                  return null;
                }

                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m03 = 0;
                out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m07 = 0;
                out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              }

              static toArray(out, m, ofs = 0) {
                out[ofs + 0] = m.m00;
                out[ofs + 1] = m.m01;
                out[ofs + 2] = m.m02;
                out[ofs + 3] = m.m03;
                out[ofs + 4] = m.m04;
                out[ofs + 5] = m.m05;
                out[ofs + 6] = m.m06;
                out[ofs + 7] = m.m07;
                out[ofs + 8] = m.m08;
                out[ofs + 9] = m.m09;
                out[ofs + 10] = m.m10;
                out[ofs + 11] = m.m11;
                out[ofs + 12] = m.m12;
                out[ofs + 13] = m.m13;
                out[ofs + 14] = m.m14;
                out[ofs + 15] = m.m15;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.m00 = arr[ofs + 0];
                out.m01 = arr[ofs + 1];
                out.m02 = arr[ofs + 2];
                out.m03 = arr[ofs + 3];
                out.m04 = arr[ofs + 4];
                out.m05 = arr[ofs + 5];
                out.m06 = arr[ofs + 6];
                out.m07 = arr[ofs + 7];
                out.m08 = arr[ofs + 8];
                out.m09 = arr[ofs + 9];
                out.m10 = arr[ofs + 10];
                out.m11 = arr[ofs + 11];
                out.m12 = arr[ofs + 12];
                out.m13 = arr[ofs + 13];
                out.m14 = arr[ofs + 14];
                out.m15 = arr[ofs + 15];
                return out;
              }

              static add(out, a, b) {
                out.m00 = a.m00 + b.m00;
                out.m01 = a.m01 + b.m01;
                out.m02 = a.m02 + b.m02;
                out.m03 = a.m03 + b.m03;
                out.m04 = a.m04 + b.m04;
                out.m05 = a.m05 + b.m05;
                out.m06 = a.m06 + b.m06;
                out.m07 = a.m07 + b.m07;
                out.m08 = a.m08 + b.m08;
                out.m09 = a.m09 + b.m09;
                out.m10 = a.m10 + b.m10;
                out.m11 = a.m11 + b.m11;
                out.m12 = a.m12 + b.m12;
                out.m13 = a.m13 + b.m13;
                out.m14 = a.m14 + b.m14;
                out.m15 = a.m15 + b.m15;
                return out;
              }

              static subtract(out, a, b) {
                out.m00 = a.m00 - b.m00;
                out.m01 = a.m01 - b.m01;
                out.m02 = a.m02 - b.m02;
                out.m03 = a.m03 - b.m03;
                out.m04 = a.m04 - b.m04;
                out.m05 = a.m05 - b.m05;
                out.m06 = a.m06 - b.m06;
                out.m07 = a.m07 - b.m07;
                out.m08 = a.m08 - b.m08;
                out.m09 = a.m09 - b.m09;
                out.m10 = a.m10 - b.m10;
                out.m11 = a.m11 - b.m11;
                out.m12 = a.m12 - b.m12;
                out.m13 = a.m13 - b.m13;
                out.m14 = a.m14 - b.m14;
                out.m15 = a.m15 - b.m15;
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.m00 = a.m00 * b;
                out.m01 = a.m01 * b;
                out.m02 = a.m02 * b;
                out.m03 = a.m03 * b;
                out.m04 = a.m04 * b;
                out.m05 = a.m05 * b;
                out.m06 = a.m06 * b;
                out.m07 = a.m07 * b;
                out.m08 = a.m08 * b;
                out.m09 = a.m09 * b;
                out.m10 = a.m10 * b;
                out.m11 = a.m11 * b;
                out.m12 = a.m12 * b;
                out.m13 = a.m13 * b;
                out.m14 = a.m14 * b;
                out.m15 = a.m15 * b;
                return out;
              }

              static multiplyScalarAndAdd(out, a, b, scale) {
                out.m00 = a.m00 + b.m00 * scale;
                out.m01 = a.m01 + b.m01 * scale;
                out.m02 = a.m02 + b.m02 * scale;
                out.m03 = a.m03 + b.m03 * scale;
                out.m04 = a.m04 + b.m04 * scale;
                out.m05 = a.m05 + b.m05 * scale;
                out.m06 = a.m06 + b.m06 * scale;
                out.m07 = a.m07 + b.m07 * scale;
                out.m08 = a.m08 + b.m08 * scale;
                out.m09 = a.m09 + b.m09 * scale;
                out.m10 = a.m10 + b.m10 * scale;
                out.m11 = a.m11 + b.m11 * scale;
                out.m12 = a.m12 + b.m12 * scale;
                out.m13 = a.m13 + b.m13 * scale;
                out.m14 = a.m14 + b.m14 * scale;
                out.m15 = a.m15 + b.m15 * scale;
                return out;
              }

              static strictEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1.0, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1.0, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1.0, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1.0, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1.0, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1.0, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1.0, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1.0, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1.0, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1.0, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1.0, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1.0, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1.0, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1.0, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1.0, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1.0, Math.abs(a.m15), Math.abs(b.m15));
              }

              get m00() {
                return this._array[0];
              }

              set m00(m) {
                this._array[0] = m;
              }

              get m01() {
                return this._array[1];
              }

              set m01(m) {
                this._array[1] = m;
              }

              get m02() {
                return this._array[2];
              }

              set m02(m) {
                this._array[2] = m;
              }

              get m03() {
                return this._array[3];
              }

              set m03(m) {
                this._array[3] = m;
              }

              get m04() {
                return this._array[4];
              }

              set m04(m) {
                this._array[4] = m;
              }

              get m05() {
                return this._array[5];
              }

              set m05(m) {
                this._array[5] = m;
              }

              get m06() {
                return this._array[6];
              }

              set m06(m) {
                this._array[6] = m;
              }

              get m07() {
                return this._array[7];
              }

              set m07(m) {
                this._array[7] = m;
              }

              get m08() {
                return this._array[8];
              }

              set m08(m) {
                this._array[8] = m;
              }

              get m09() {
                return this._array[9];
              }

              set m09(m) {
                this._array[9] = m;
              }

              get m10() {
                return this._array[10];
              }

              set m10(m) {
                this._array[10] = m;
              }

              get m11() {
                return this._array[11];
              }

              set m11(m) {
                this._array[11] = m;
              }

              get m12() {
                return this._array[12];
              }

              set m12(m) {
                this._array[12] = m;
              }

              get m13() {
                return this._array[13];
              }

              set m13(m) {
                this._array[13] = m;
              }

              get m14() {
                return this._array[14];
              }

              set m14(m) {
                this._array[14] = m;
              }

              get m15() {
                return this._array[15];
              }

              set m15(m) {
                this._array[15] = m;
              }

              constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 0, m05 = 1, m06 = 0, m07 = 0, m08 = 0, m09 = 0, m10 = 1, m11 = 0, m12 = 0, m13 = 0, m14 = 0, m15 = 1) {
                super();

                if (m00 && typeof m00 === 'object') {
                  if (ArrayBuffer.isView(m00)) {
                    this._array = m00;

                    this._array.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                  } else {
                    const v = m00.array;
                    this._array = MathBase.createFloatArray(16);
                    this._array[0] = v[0];
                    this._array[1] = v[1];
                    this._array[2] = v[2];
                    this._array[3] = v[3];
                    this._array[4] = v[4];
                    this._array[5] = v[5];
                    this._array[6] = v[6];
                    this._array[7] = v[7];
                    this._array[8] = v[8];
                    this._array[9] = v[9];
                    this._array[10] = v[10];
                    this._array[11] = v[11];
                    this._array[12] = v[12];
                    this._array[13] = v[13];
                    this._array[14] = v[14];
                    this._array[15] = v[15];
                  }
                } else {
                  this._array = MathBase.createFloatArray(16);
                  this._array[0] = m00;
                  this._array[1] = m01;
                  this._array[2] = m02;
                  this._array[3] = m03;
                  this._array[4] = m04;
                  this._array[5] = m05;
                  this._array[6] = m06;
                  this._array[7] = m07;
                  this._array[8] = m08;
                  this._array[9] = m09;
                  this._array[10] = m10;
                  this._array[11] = m11;
                  this._array[12] = m12;
                  this._array[13] = m13;
                  this._array[14] = m14;
                  this._array[15] = m15;
                }
              }

              clone() {
                const v = this._array;
                return new Mat4(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]);
              }

              set(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m04 = 0, m05 = 1, m06 = 0, m07 = 0, m08 = 0, m09 = 0, m10 = 1, m11 = 0, m12 = 0, m13 = 0, m14 = 0, m15 = 1) {
                if (m00 && typeof m00 === 'object') {
                  const v = m00.array;
                  this._array[1] = v[1];
                  this._array[2] = v[2];
                  this._array[3] = v[3];
                  this._array[4] = v[4];
                  this._array[5] = v[5];
                  this._array[6] = v[6];
                  this._array[7] = v[7];
                  this._array[8] = v[8];
                  this._array[9] = v[9];
                  this._array[10] = v[10];
                  this._array[11] = v[11];
                  this._array[12] = v[12];
                  this._array[13] = v[13];
                  this._array[14] = v[14];
                  this._array[15] = v[15];
                  this._array[0] = v[0];
                } else {
                  this._array[1] = m01;
                  this._array[2] = m02;
                  this._array[3] = m03;
                  this._array[4] = m04;
                  this._array[5] = m05;
                  this._array[6] = m06;
                  this._array[7] = m07;
                  this._array[8] = m08;
                  this._array[9] = m09;
                  this._array[10] = m10;
                  this._array[11] = m11;
                  this._array[12] = m12;
                  this._array[13] = m13;
                  this._array[14] = m14;
                  this._array[15] = m15;
                  this._array[0] = m00;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                const v = other.array;
                return Math.abs(this._array[0] - v[0]) <= epsilon * Math.max(1.0, Math.abs(this._array[0]), Math.abs(v[0])) && Math.abs(this._array[1] - v[1]) <= epsilon * Math.max(1.0, Math.abs(this._array[1]), Math.abs(v[1])) && Math.abs(this._array[2] - v[2]) <= epsilon * Math.max(1.0, Math.abs(this._array[2]), Math.abs(v[2])) && Math.abs(this._array[3] - v[3]) <= epsilon * Math.max(1.0, Math.abs(this._array[3]), Math.abs(v[3])) && Math.abs(this._array[4] - v[4]) <= epsilon * Math.max(1.0, Math.abs(this._array[4]), Math.abs(v[4])) && Math.abs(this._array[5] - v[5]) <= epsilon * Math.max(1.0, Math.abs(this._array[5]), Math.abs(v[5])) && Math.abs(this._array[6] - v[6]) <= epsilon * Math.max(1.0, Math.abs(this._array[6]), Math.abs(v[6])) && Math.abs(this._array[7] - v[7]) <= epsilon * Math.max(1.0, Math.abs(this._array[7]), Math.abs(v[7])) && Math.abs(this._array[8] - v[8]) <= epsilon * Math.max(1.0, Math.abs(this._array[8]), Math.abs(v[8])) && Math.abs(this._array[9] - v[9]) <= epsilon * Math.max(1.0, Math.abs(this._array[9]), Math.abs(v[9])) && Math.abs(this._array[10] - v[10]) <= epsilon * Math.max(1.0, Math.abs(this._array[10]), Math.abs(v[10])) && Math.abs(this._array[11] - v[11]) <= epsilon * Math.max(1.0, Math.abs(this._array[11]), Math.abs(v[11])) && Math.abs(this._array[12] - v[12]) <= epsilon * Math.max(1.0, Math.abs(this._array[12]), Math.abs(v[12])) && Math.abs(this._array[13] - v[13]) <= epsilon * Math.max(1.0, Math.abs(this._array[13]), Math.abs(v[13])) && Math.abs(this._array[14] - v[14]) <= epsilon * Math.max(1.0, Math.abs(this._array[14]), Math.abs(v[14])) && Math.abs(this._array[15] - v[15]) <= epsilon * Math.max(1.0, Math.abs(this._array[15]), Math.abs(v[15]));
              }

              strictEquals(other) {
                const v = other.array;
                return this._array[0] === other.m00 && this._array[1] === v[1] && this._array[2] === v[2] && this._array[3] === v[3] && this._array[4] === v[4] && this._array[5] === v[5] && this._array[6] === v[6] && this._array[7] === v[7] && this._array[8] === v[8] && this._array[9] === v[9] && this._array[10] === v[10] && this._array[11] === v[11] && this._array[12] === v[12] && this._array[13] === v[13] && this._array[14] === v[14] && this._array[15] === v[15];
              }

              toString() {
                return `[\n${this._array[0]}, ${this._array[1]}, ${this._array[2]}, ${this._array[3]},\n${this._array[4]}, ${this._array[5]}, ${this._array[6]}, ${this._array[7]},\n${this._array[8]}, ${this._array[9]}, ${this._array[10]}, ${this._array[11]},\n${this._array[12]}, ${this._array[13]}, ${this._array[14]}, ${this._array[15]}\n` + `]`;
              }

              identity() {
                this._array[0] = 1;
                this._array[1] = 0;
                this._array[2] = 0;
                this._array[3] = 0;
                this._array[4] = 0;
                this._array[5] = 1;
                this._array[6] = 0;
                this._array[7] = 0;
                this._array[8] = 0;
                this._array[9] = 0;
                this._array[10] = 1;
                this._array[11] = 0;
                this._array[12] = 0;
                this._array[13] = 0;
                this._array[14] = 0;
                this._array[15] = 1;
                return this;
              }

              zero() {
                this.m00 = 0;
                this.m01 = 0;
                this.m02 = 0;
                this.m03 = 0;
                this.m04 = 0;
                this.m05 = 0;
                this.m06 = 0;
                this.m07 = 0;
                this.m08 = 0;
                this.m09 = 0;
                this.m10 = 0;
                this.m11 = 0;
                this.m12 = 0;
                this.m13 = 0;
                this.m14 = 0;
                this.m15 = 0;
                return this;
              }

              transpose() {
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a23 = this._array[11];
                this._array[1] = this._array[4];
                this._array[2] = this._array[8];
                this._array[3] = this._array[12];
                this._array[4] = a01;
                this._array[6] = this._array[9];
                this._array[7] = this._array[13];
                this._array[8] = a02;
                this._array[9] = a12;
                this._array[11] = this._array[14];
                this._array[12] = a03;
                this._array[13] = a13;
                this._array[14] = a23;
                return this;
              }

              invert() {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a10 = this._array[4];
                const a11 = this._array[5];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a20 = this._array[8];
                const a21 = this._array[9];
                const a22 = this._array[10];
                const a23 = this._array[11];
                const a30 = this._array[12];
                const a31 = this._array[13];
                const a32 = this._array[14];
                const a33 = this._array[15];
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (det === 0) {
                  this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                  return this;
                }

                det = 1.0 / det;
                this._array[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                this._array[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                this._array[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                this._array[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                this._array[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                this._array[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                this._array[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                this._array[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                this._array[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                this._array[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                this._array[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                this._array[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                this._array[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                this._array[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                this._array[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                this._array[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return this;
              }

              determinant() {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a10 = this._array[4];
                const a11 = this._array[5];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a20 = this._array[8];
                const a21 = this._array[9];
                const a22 = this._array[10];
                const a23 = this._array[11];
                const a30 = this._array[12];
                const a31 = this._array[13];
                const a32 = this._array[14];
                const a33 = this._array[15];
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              }

              add(mat) {
                const v = mat.array;
                this._array[0] += v[0];
                this._array[1] += v[1];
                this._array[2] += v[2];
                this._array[3] += v[3];
                this._array[4] += v[4];
                this._array[5] += v[5];
                this._array[6] += v[6];
                this._array[7] += v[7];
                this._array[8] += v[8];
                this._array[9] += v[9];
                this._array[10] += v[10];
                this._array[11] += v[11];
                this._array[12] += v[12];
                this._array[13] += v[13];
                this._array[14] += v[14];
                this._array[15] += v[15];
                return this;
              }

              subtract(mat) {
                const v = mat.array;
                this._array[0] -= v[0];
                this._array[1] -= v[1];
                this._array[2] -= v[2];
                this._array[3] -= v[3];
                this._array[4] -= v[4];
                this._array[5] -= v[5];
                this._array[6] -= v[6];
                this._array[7] -= v[7];
                this._array[8] -= v[8];
                this._array[9] -= v[9];
                this._array[10] -= v[10];
                this._array[11] -= v[11];
                this._array[12] -= v[12];
                this._array[13] -= v[13];
                this._array[14] -= v[14];
                this._array[15] -= v[15];
                return this;
              }

              multiply(mat) {
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a10 = this._array[4];
                const a11 = this._array[5];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a20 = this._array[8];
                const a21 = this._array[9];
                const a22 = this._array[10];
                const a23 = this._array[11];
                const a30 = this._array[12];
                const a31 = this._array[13];
                const a32 = this._array[14];
                const a33 = this._array[15];
                const v = mat.array;
                let b0 = v[0];
                let b1 = v[1];
                let b2 = v[2];
                let b3 = v[3];
                this._array[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                this._array[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                this._array[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                this._array[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = v[4];
                b1 = v[5];
                b2 = v[6];
                b3 = v[7];
                this._array[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                this._array[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                this._array[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                this._array[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = v[8];
                b1 = v[9];
                b2 = v[10];
                b3 = v[11];
                this._array[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                this._array[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                this._array[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                this._array[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = v[12];
                b1 = v[13];
                b2 = v[14];
                b3 = v[15];
                this._array[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                this._array[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                this._array[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                this._array[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return this;
              }

              multiplyScalar(scalar) {
                this._array[0] *= scalar;
                this._array[1] *= scalar;
                this._array[2] *= scalar;
                this._array[3] *= scalar;
                this._array[4] *= scalar;
                this._array[5] *= scalar;
                this._array[6] *= scalar;
                this._array[7] *= scalar;
                this._array[8] *= scalar;
                this._array[9] *= scalar;
                this._array[10] *= scalar;
                this._array[11] *= scalar;
                this._array[12] *= scalar;
                this._array[13] *= scalar;
                this._array[14] *= scalar;
                this._array[15] *= scalar;
                return this;
              }

              translate(vec) {
                console.warn('function changed');
                const v = vec.array;
                this._array[12] += v[0];
                this._array[13] += v[1];
                this._array[14] += v[2];
                return this;
              }

              scale(vec) {
                const v = vec.array;
                const x = v[0];
                const y = v[1];
                const z = v[2];
                this._array[0] *= x;
                this._array[1] *= x;
                this._array[2] *= x;
                this._array[3] *= x;
                this._array[4] *= y;
                this._array[5] *= y;
                this._array[6] *= y;
                this._array[7] *= y;
                this._array[8] *= z;
                this._array[9] *= z;
                this._array[10] *= z;
                this._array[11] *= z;
                return this;
              }

              rotate(rad, axis) {
                let x = axis.x;
                let y = axis.y;
                let z = axis.z;
                let len = Math.sqrt(x * x + y * y + z * z);

                if (Math.abs(len) < EPSILON) {
                  return null;
                }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                const a00 = this._array[0];
                const a01 = this._array[1];
                const a02 = this._array[2];
                const a03 = this._array[3];
                const a10 = this._array[4];
                const a11 = this._array[5];
                const a12 = this._array[6];
                const a13 = this._array[7];
                const a20 = this._array[8];
                const a21 = this._array[9];
                const a22 = this._array[10];
                const a23 = this._array[11];
                const b00 = x * x * t + c;
                const b01 = y * x * t + z * s;
                const b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s;
                const b11 = y * y * t + c;
                const b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s;
                const b21 = y * z * t - x * s;
                const b22 = z * z * t + c;
                this._array[0] = a00 * b00 + a10 * b01 + a20 * b02;
                this._array[1] = a01 * b00 + a11 * b01 + a21 * b02;
                this._array[2] = a02 * b00 + a12 * b01 + a22 * b02;
                this._array[3] = a03 * b00 + a13 * b01 + a23 * b02;
                this._array[4] = a00 * b10 + a10 * b11 + a20 * b12;
                this._array[5] = a01 * b10 + a11 * b11 + a21 * b12;
                this._array[6] = a02 * b10 + a12 * b11 + a22 * b12;
                this._array[7] = a03 * b10 + a13 * b11 + a23 * b12;
                this._array[8] = a00 * b20 + a10 * b21 + a20 * b22;
                this._array[9] = a01 * b20 + a11 * b21 + a21 * b22;
                this._array[10] = a02 * b20 + a12 * b21 + a22 * b22;
                this._array[11] = a03 * b20 + a13 * b21 + a23 * b22;
                return this;
              }

              getTranslation(out) {
                out.x = this._array[12];
                out.y = this._array[13];
                out.z = this._array[14];
                return out;
              }

              getScale(out) {
                const o = out.array;
                const t = m3_1$1.array;
                const m00 = t[0] = this._array[0];
                const m01 = t[1] = this._array[1];
                const m02 = t[2] = this._array[2];
                const m04 = t[3] = this._array[4];
                const m05 = t[4] = this._array[5];
                const m06 = t[5] = this._array[6];
                const m08 = t[6] = this._array[8];
                const m09 = t[7] = this._array[9];
                const m10 = t[8] = this._array[10];
                o[0] = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
                o[1] = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
                o[2] = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);

                if (Mat3.determinant(m3_1$1) < 0) {
                  out.x *= -1;
                }

                return out;
              }

              getRotation(out) {
                const trace = this._array[0] + this._array[5] + this._array[10];
                let S = 0;

                if (trace > 0) {
                  S = Math.sqrt(trace + 1.0) * 2;
                  out.w = 0.25 * S;
                  out.x = (this._array[6] - this._array[9]) / S;
                  out.y = (this._array[8] - this._array[2]) / S;
                  out.z = (this._array[1] - this._array[4]) / S;
                } else if (this._array[0] > this._array[5] && this._array[0] > this._array[10]) {
                  S = Math.sqrt(1.0 + this._array[0] - this._array[5] - this._array[10]) * 2;
                  out.w = (this._array[6] - this._array[9]) / S;
                  out.x = 0.25 * S;
                  out.y = (this._array[1] + this._array[4]) / S;
                  out.z = (this._array[8] + this._array[2]) / S;
                } else if (this._array[5] > this._array[10]) {
                  S = Math.sqrt(1.0 + this._array[5] - this._array[0] - this._array[10]) * 2;
                  out.w = (this._array[8] - this._array[2]) / S;
                  out.x = (this._array[1] + this._array[4]) / S;
                  out.y = 0.25 * S;
                  out.z = (this._array[6] + this._array[9]) / S;
                } else {
                  S = Math.sqrt(1.0 + this._array[10] - this._array[0] - this._array[5]) * 2;
                  out.w = (this._array[1] - this._array[4]) / S;
                  out.x = (this._array[8] + this._array[2]) / S;
                  out.y = (this._array[6] + this._array[9]) / S;
                  out.z = 0.25 * S;
                }

                return out;
              }

              fromRTS(q, v, s) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const xy = x * y2;
                const xz = x * z2;
                const yy = y * y2;
                const yz = y * z2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                const sx = s.x;
                const sy = s.y;
                const sz = s.z;
                this._array[0] = (1 - (yy + zz)) * sx;
                this._array[1] = (xy + wz) * sx;
                this._array[2] = (xz - wy) * sx;
                this._array[3] = 0;
                this._array[4] = (xy - wz) * sy;
                this._array[5] = (1 - (xx + zz)) * sy;
                this._array[6] = (yz + wx) * sy;
                this._array[7] = 0;
                this._array[8] = (xz + wy) * sz;
                this._array[9] = (yz - wx) * sz;
                this._array[10] = (1 - (xx + yy)) * sz;
                this._array[11] = 0;
                this._array[12] = v.x;
                this._array[13] = v.y;
                this._array[14] = v.z;
                this._array[15] = 1;
                return this;
              }

              fromQuat(q) {
                const x = q.x;
                const y = q.y;
                const z = q.z;
                const w = q.w;
                const x2 = x + x;
                const y2 = y + y;
                const z2 = z + z;
                const xx = x * x2;
                const yx = y * x2;
                const yy = y * y2;
                const zx = z * x2;
                const zy = z * y2;
                const zz = z * z2;
                const wx = w * x2;
                const wy = w * y2;
                const wz = w * z2;
                this._array[0] = 1 - yy - zz;
                this._array[1] = yx + wz;
                this._array[2] = zx - wy;
                this._array[3] = 0;
                this._array[4] = yx - wz;
                this._array[5] = 1 - xx - zz;
                this._array[6] = zy + wx;
                this._array[7] = 0;
                this._array[8] = zx + wy;
                this._array[9] = zy - wx;
                this._array[10] = 1 - xx - yy;
                this._array[11] = 0;
                this._array[12] = 0;
                this._array[13] = 0;
                this._array[14] = 0;
                this._array[15] = 1;
                return this;
              }

            } exports('cq', Mat4);
            Mat4.IDENTITY = Object.freeze(new Mat4());
            const v3_1$3 = new Vec3();
            const m3_1$1 = new Mat3();
            enumerableProps(Mat4.prototype, ['m00', 'm01', 'm02', 'm03', 'm04', 'm05', 'm06', 'm07', 'm08', 'm09', 'm10', 'm11', 'm12', 'm13', 'm14', 'm15']);
            CCClass.fastDefine('cc.Mat4', Mat4, {
              m00: 1,
              m01: 0,
              m02: 0,
              m03: 0,
              m04: 0,
              m05: 1,
              m06: 0,
              m07: 0,
              m08: 0,
              m09: 0,
              m10: 1,
              m11: 0,
              m12: 0,
              m13: 0,
              m14: 0,
              m15: 1
            });
            legacyCC.Mat4 = Mat4;
            function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
              return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
            }
            legacyCC.mat4 = mat4;

            class Vec2 extends ValueType {
              static clone(a) {
                return new Vec2(a.x, a.y);
              }

              static copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                return out;
              }

              static set(out, x, y) {
                out.x = x;
                out.y = y;
                return out;
              }

              static add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                return out;
              }

              static subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                return out;
              }

              static multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                return out;
              }

              static divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                return out;
              }

              static ceil(out, a) {
                out.x = Math.ceil(a.x);
                out.y = Math.ceil(a.y);
                return out;
              }

              static floor(out, a) {
                out.x = Math.floor(a.x);
                out.y = Math.floor(a.y);
                return out;
              }

              static min(out, a, b) {
                out.x = Math.min(a.x, b.x);
                out.y = Math.min(a.y, b.y);
                return out;
              }

              static max(out, a, b) {
                out.x = Math.max(a.x, b.x);
                out.y = Math.max(a.y, b.y);
                return out;
              }

              static round(out, a) {
                out.x = Math.round(a.x);
                out.y = Math.round(a.y);
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                return out;
              }

              static scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                return out;
              }

              static distance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                return Math.sqrt(x * x + y * y);
              }

              static squaredDistance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                return x * x + y * y;
              }

              static len(a) {
                const x = a.x;
                const y = a.y;
                return Math.sqrt(x * x + y * y);
              }

              static lengthSqr(a) {
                const x = a.x;
                const y = a.y;
                return x * x + y * y;
              }

              static negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                return out;
              }

              static inverse(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                return out;
              }

              static inverseSafe(out, a) {
                const x = a.x;
                const y = a.y;

                if (Math.abs(x) < EPSILON) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }

                if (Math.abs(y) < EPSILON) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }

                return out;
              }

              static normalize(out, a) {
                const x = a.x;
                const y = a.y;
                let len = x * x + y * y;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  out.x = x * len;
                  out.y = y * len;
                }

                return out;
              }

              static dot(a, b) {
                return a.x * b.x + a.y * b.y;
              }

              static cross(out, a, b) {
                if (out instanceof Vec3) {
                  out.x = out.y = 0;
                  out.z = a.x * b.y - a.y * b.x;
                  return out;
                } else {
                  return out.x * a.y - out.y * a.x;
                }
              }

              static lerp(out, a, b, t) {
                const x = a.x;
                const y = a.y;
                out.x = x + t * (b.x - x);
                out.y = y + t * (b.y - y);
                return out;
              }

              static random(out, scale) {
                scale = scale || 1.0;
                const r = random() * 2.0 * Math.PI;
                out.x = Math.cos(r) * scale;
                out.y = Math.sin(r) * scale;
                return out;
              }

              static transformMat3(out, a, m) {
                const x = a.x;
                const y = a.y;
                out.x = m.m00 * x + m.m03 * y + m.m06;
                out.y = m.m01 * x + m.m04 * y + m.m07;
                return out;
              }

              static transformMat4(out, a, m) {
                const x = a.x;
                const y = a.y;
                out.x = m.m00 * x + m.m04 * y + m.m12;
                out.y = m.m01 * x + m.m05 * y + m.m13;
                return out;
              }

              static str(a) {
                return `Vec2(${a.x}, ${a.y})`;
              }

              static toArray(out, v, ofs = 0) {
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                return out;
              }

              static strictEquals(a, b) {
                return a.x === b.x && a.y === b.y;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y));
              }

              static angle(a, b) {
                Vec2.normalize(v2_1, a);
                Vec2.normalize(v2_2, b);
                const cosine = Vec2.dot(v2_1, v2_2);

                if (cosine > 1.0) {
                  return 0;
                }

                if (cosine < -1.0) {
                  return Math.PI;
                }

                return Math.acos(cosine);
              }

              constructor(x, y) {
                super();

                if (x && typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                }
              }

              clone() {
                return new Vec2(this.x, this.y);
              }

              set(x, y) {
                if (x && typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y));
              }

              equals2f(x, y, epsilon = EPSILON) {
                return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y));
              }

              strictEquals(other) {
                return other && this.x === other.x && this.y === other.y;
              }

              strictEquals2f(x, y) {
                return this.x === x && this.y === y;
              }

              toString() {
                return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
              }

              lerp(to, ratio) {
                const x = this.x;
                const y = this.y;
                this.x = x + ratio * (to.x - x);
                this.y = y + ratio * (to.y - y);
                return this;
              }

              clampf(minInclusive, maxInclusive) {
                this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
                this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
                return this;
              }

              add(other) {
                this.x += other.x;
                this.y += other.y;
                return this;
              }

              add2f(x, y) {
                this.x += x;
                this.y += y;
                return this;
              }

              subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                return this;
              }

              subtract2f(x, y) {
                this.x -= x;
                this.y -= y;
                return this;
              }

              multiplyScalar(scalar) {
                if (typeof scalar === 'object') {
                  console.warn('should use Vec2.multiply for vector * vector operation');
                }

                this.x *= scalar;
                this.y *= scalar;
                return this;
              }

              multiply(other) {
                if (typeof other !== 'object') {
                  console.warn('should use Vec2.scale for vector * scalar operation');
                }

                this.x *= other.x;
                this.y *= other.y;
                return this;
              }

              multiply2f(x, y) {
                this.x *= x;
                this.y *= y;
                return this;
              }

              divide(other) {
                this.x /= other.x;
                this.y /= other.y;
                return this;
              }

              divide2f(x, y) {
                this.x /= x;
                this.y /= y;
                return this;
              }

              negative() {
                this.x = -this.x;
                this.y = -this.y;
                return this;
              }

              dot(other) {
                return this.x * other.x + this.y * other.y;
              }

              cross(other) {
                return this.x * other.y - this.y * other.x;
              }

              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
              }

              lengthSqr() {
                return this.x * this.x + this.y * this.y;
              }

              normalize() {
                const x = this.x;
                const y = this.y;
                let len = x * x + y * y;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this.x *= len;
                  this.y *= len;
                }

                return this;
              }

              angle(other) {
                const magSqr1 = this.lengthSqr();
                const magSqr2 = other.lengthSqr();

                if (magSqr1 === 0 || magSqr2 === 0) {
                  console.warn('Can\'t get angle between zero vector');
                  return 0.0;
                }

                const dot = this.dot(other);
                let theta = dot / Math.sqrt(magSqr1 * magSqr2);
                theta = clamp(theta, -1.0, 1.0);
                return Math.acos(theta);
              }

              signAngle(other) {
                const angle = this.angle(other);
                return this.cross(other) < 0 ? -angle : angle;
              }

              rotate(radians) {
                const x = this.x;
                const y = this.y;
                const sin = Math.sin(radians);
                const cos = Math.cos(radians);
                this.x = cos * x - sin * y;
                this.y = sin * x + cos * y;
                return this;
              }

              project(other) {
                const scalar = this.dot(other) / other.dot(other);
                this.x = other.x * scalar;
                this.y = other.y * scalar;
                return this;
              }

              transformMat4(matrix) {
                const x = this.x;
                const y = this.y;
                this.x = matrix.m00 * x + matrix.m04 * y + matrix.m12;
                this.y = matrix.m01 * x + matrix.m05 * y + matrix.m13;
                return this;
              }

            } exports('cW', Vec2);
            Vec2.ZERO = Object.freeze(new Vec2(0, 0));
            Vec2.ONE = Object.freeze(new Vec2(1, 1));
            Vec2.NEG_ONE = Object.freeze(new Vec2(-1, -1));
            Vec2.UNIT_X = Object.freeze(new Vec2(1, 0));
            Vec2.UNIT_Y = Object.freeze(new Vec2(0, 1));
            const v2_1 = new Vec2();
            const v2_2 = new Vec2();
            CCClass.fastDefine('cc.Vec2', Vec2, {
              x: 0,
              y: 0
            });
            legacyCC.Vec2 = Vec2;
            function v2(x, y) {
              return new Vec2(x, y);
            }
            legacyCC.v2 = v2;

            class Vec4 extends ValueType {
              static clone(a) {
                return new Vec4(a.x, a.y, a.z, a.w);
              }

              static copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = a.w;
                return out;
              }

              static set(out, x, y, z, w) {
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              }

              static add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                out.z = a.z + b.z;
                out.w = a.w + b.w;
                return out;
              }

              static subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                out.z = a.z - b.z;
                out.w = a.w - b.w;
                return out;
              }

              static multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                out.z = a.z * b.z;
                out.w = a.w * b.w;
                return out;
              }

              static divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                out.z = a.z / b.z;
                out.w = a.w / b.w;
                return out;
              }

              static ceil(out, a) {
                out.x = Math.ceil(a.x);
                out.y = Math.ceil(a.y);
                out.z = Math.ceil(a.z);
                out.w = Math.ceil(a.w);
                return out;
              }

              static floor(out, a) {
                out.x = Math.floor(a.x);
                out.y = Math.floor(a.y);
                out.z = Math.floor(a.z);
                out.w = Math.floor(a.w);
                return out;
              }

              static min(out, a, b) {
                out.x = Math.min(a.x, b.x);
                out.y = Math.min(a.y, b.y);
                out.z = Math.min(a.z, b.z);
                out.w = Math.min(a.w, b.w);
                return out;
              }

              static max(out, a, b) {
                out.x = Math.max(a.x, b.x);
                out.y = Math.max(a.y, b.y);
                out.z = Math.max(a.z, b.z);
                out.w = Math.max(a.w, b.w);
                return out;
              }

              static round(out, a) {
                out.x = Math.round(a.x);
                out.y = Math.round(a.y);
                out.z = Math.round(a.z);
                out.w = Math.round(a.w);
                return out;
              }

              static multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                out.w = a.w * b;
                return out;
              }

              static scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                out.w = a.w + b.w * scale;
                return out;
              }

              static distance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                const z = b.z - a.z;
                const w = b.w - a.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
              }

              static squaredDistance(a, b) {
                const x = b.x - a.x;
                const y = b.y - a.y;
                const z = b.z - a.z;
                const w = b.w - a.w;
                return x * x + y * y + z * z + w * w;
              }

              static len(a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
              }

              static lengthSqr(a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;
                return x * x + y * y + z * z + w * w;
              }

              static negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                out.w = -a.w;
                return out;
              }

              static inverse(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                out.z = 1.0 / a.z;
                out.w = 1.0 / a.w;
                return out;
              }

              static inverseSafe(out, a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;

                if (Math.abs(x) < EPSILON) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }

                if (Math.abs(y) < EPSILON) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }

                if (Math.abs(z) < EPSILON) {
                  out.z = 0;
                } else {
                  out.z = 1.0 / z;
                }

                if (Math.abs(w) < EPSILON) {
                  out.w = 0;
                } else {
                  out.w = 1.0 / w;
                }

                return out;
              }

              static normalize(out, a) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;
                let len = x * x + y * y + z * z + w * w;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  out.x = x * len;
                  out.y = y * len;
                  out.z = z * len;
                  out.w = w * len;
                }

                return out;
              }

              static dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
              }

              static lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                out.w = a.w + t * (b.w - a.w);
                return out;
              }

              static random(out, scale) {
                scale = scale || 1.0;
                const phi = random() * 2.0 * Math.PI;
                const cosTheta = random() * 2 - 1;
                const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
                out.x = sinTheta * Math.cos(phi) * scale;
                out.y = sinTheta * Math.sin(phi) * scale;
                out.z = cosTheta * scale;
                out.w = 0;
                return out;
              }

              static transformMat4(out, a, m) {
                const x = a.x;
                const y = a.y;
                const z = a.z;
                const w = a.w;
                out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
                out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
                out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
                out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
                return out;
              }

              static transformAffine(out, v, m) {
                const x = v.x;
                const y = v.y;
                const z = v.z;
                const w = v.w;
                out.x = m.m00 * x + m.m01 * y + m.m02 * z + m.m03 * w;
                out.y = m.m04 * x + m.m05 * y + m.m06 * z + m.m07 * w;
                out.x = m.m08 * x + m.m09 * y + m.m10 * z + m.m11 * w;
                out.w = v.w;
                return out;
              }

              static transformQuat(out, a, q) {
                const {
                  x,
                  y,
                  z
                } = a;
                const _x = q.x;
                const _y = q.y;
                const _z = q.z;
                const _w = q.w;
                const ix = _w * x + _y * z - _z * y;
                const iy = _w * y + _z * x - _x * z;
                const iz = _w * z + _x * y - _y * x;
                const iw = -_x * x - _y * y - _z * z;
                out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y;
                out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z;
                out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x;
                out.w = a.w;
                return out;
              }

              static toArray(out, v, ofs = 0) {
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                out[ofs + 2] = v.z;
                out[ofs + 3] = v.w;
                return out;
              }

              static fromArray(out, arr, ofs = 0) {
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                out.w = arr[ofs + 3];
                return out;
              }

              static strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
              }

              static equals(a, b, epsilon = EPSILON) {
                return Math.abs(a.x - b.x) <= epsilon * Math.max(1.0, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1.0, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1.0, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1.0, Math.abs(a.w), Math.abs(b.w));
              }

              constructor(x, y, z, w) {
                super();

                if (x && typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                  this.z = x.z;
                  this.w = x.w;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w || 0;
                }
              }

              clone() {
                return new Vec4(this.x, this.y, this.z, this.w);
              }

              set(x, y, z, w) {
                if (x && typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                  this.z = x.z;
                  this.w = x.w;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w || 0;
                }

                return this;
              }

              equals(other, epsilon = EPSILON) {
                return Math.abs(this.x - other.x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(other.w));
              }

              equals4f(x, y, z, w, epsilon = EPSILON) {
                return Math.abs(this.x - x) <= epsilon * Math.max(1.0, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1.0, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1.0, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1.0, Math.abs(this.w), Math.abs(w));
              }

              strictEquals(other) {
                return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
              }

              strictEquals4f(x, y, z, w) {
                return this.x === x && this.y === y && this.z === z && this.w === w;
              }

              lerp(to, ratio) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                this.x = x + ratio * (to.x - x);
                this.y = y + ratio * (to.y - y);
                this.z = z + ratio * (to.z - z);
                this.w = w + ratio * (to.w - w);
                return this;
              }

              toString() {
                return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.z.toFixed(2)}, ${this.w.toFixed(2)})`;
              }

              clampf(minInclusive, maxInclusive) {
                this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
                this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
                this.z = clamp(this.z, minInclusive.z, maxInclusive.z);
                this.w = clamp(this.w, minInclusive.w, maxInclusive.w);
                return this;
              }

              add(other) {
                this.x += other.x;
                this.y += other.y;
                this.z += other.z;
                this.w += other.w;
                return this;
              }

              add4f(x, y, z, w) {
                this.x += x;
                this.y += y;
                this.z += z;
                this.w += w;
                return this;
              }

              subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                this.z -= other.z;
                this.w -= other.w;
                return this;
              }

              subtract4f(x, y, z, w) {
                this.x -= x;
                this.y -= y;
                this.z -= z;
                this.w -= w;
                return this;
              }

              multiplyScalar(scalar) {
                if (typeof scalar === 'object') {
                  console.warn('should use Vec4.multiply for vector * vector operation');
                }

                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                this.w *= scalar;
                return this;
              }

              multiply(other) {
                if (typeof other !== 'object') {
                  console.warn('should use Vec4.scale for vector * scalar operation');
                }

                this.x *= other.x;
                this.y *= other.y;
                this.z *= other.z;
                this.w *= other.w;
                return this;
              }

              multiply4f(x, y, z, w) {
                this.x *= x;
                this.y *= y;
                this.z *= z;
                this.w *= w;
                return this;
              }

              divide(other) {
                this.x /= other.x;
                this.y /= other.y;
                this.z /= other.z;
                this.w /= other.w;
                return this;
              }

              divide4f(x, y, z, w) {
                this.x /= x;
                this.y /= y;
                this.z /= z;
                this.w /= w;
                return this;
              }

              negative() {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                this.w = -this.w;
                return this;
              }

              dot(vector) {
                return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
              }

              cross(vector) {
                const {
                  x: ax,
                  y: ay,
                  z: az
                } = this;
                const {
                  x: bx,
                  y: by,
                  z: bz
                } = vector;
                this.x = ay * bz - az * by;
                this.y = az * bx - ax * bz;
                this.z = ax * by - ay * bx;
                return this;
              }

              length() {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                return Math.sqrt(x * x + y * y + z * z + w * w);
              }

              lengthSqr() {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                return x * x + y * y + z * z + w * w;
              }

              normalize() {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                let len = x * x + y * y + z * z + w * w;

                if (len > 0) {
                  len = 1 / Math.sqrt(len);
                  this.x = x * len;
                  this.y = y * len;
                  this.z = z * len;
                  this.w = w * len;
                }

                return this;
              }

              transformMat4(matrix) {
                const x = this.x;
                const y = this.y;
                const z = this.z;
                const w = this.w;
                this.x = matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12 * w;
                this.y = matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13 * w;
                this.z = matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14 * w;
                this.w = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15 * w;
                return this;
              }

            } exports('bL', Vec4);
            Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
            Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));
            Vec4.NEG_ONE = Object.freeze(new Vec4(-1, -1, -1, -1));
            CCClass.fastDefine('cc.Vec4', Vec4, {
              x: 0,
              y: 0,
              z: 0,
              w: 0
            });
            legacyCC.Vec4 = Vec4;
            function v4(x, y, z, w) {
              return new Vec4(x, y, z, w);
            }
            legacyCC.v4 = v4;

            replaceProperty(Vec2, 'Vec2', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec2,
              targetName: 'Vec2'
            }]);
            replaceProperty(Vec2.prototype, 'Vec2', [{
              name: 'mag',
              newName: 'length',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }]);
            replaceProperty(Vec3, 'Vec3', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec3,
              targetName: 'Vec3'
            }]);
            replaceProperty(Vec3.prototype, 'Vec3', [{
              name: 'mag',
              newName: 'length',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }]);
            replaceProperty(Vec4, 'Vec4', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec4,
              targetName: 'Vec4'
            }]);
            replaceProperty(Vec4.prototype, 'Vec4', [{
              name: 'mag',
              newName: 'length',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }]);
            replaceProperty(Quat, 'Quat', [{
              name: 'mag',
              newName: 'len',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Quat,
              targetName: 'Quat'
            }]);
            replaceProperty(Quat.prototype, 'Quat', [{
              name: 'scale',
              newName: 'multiplyScalar',
              target: Quat.prototype,
              targetName: 'Quat'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Quat.prototype,
              targetName: 'Quat'
            }]);
            replaceProperty(Color, 'Color', [{
              name: 'sub',
              newName: 'subtract',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'div',
              newName: 'divide',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'fromHex',
              newName: 'fromHEX',

              customFunction(...args) {
                const arg1 = args[1].toString(16);
                return legacyCC.Color.fromHEX(args[0], arg1);
              }

            }]);
            replaceProperty(Mat3, 'Mat3', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'transfrom',
              newName: 'transform',
              target: Mat3,
              targetName: 'Mat3'
            }]);
            replaceProperty(Mat3.prototype, 'Mat3', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'mulScalar',
              newName: 'multiplyScalar',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }]);
            replaceProperty(Mat4, 'Mat4', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat4,
              targetName: 'Mat4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat4,
              targetName: 'Mat4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat4,
              targetName: 'Mat4'
            }]);
            replaceProperty(Mat4.prototype, 'Mat4', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'mulScalar',
              newName: 'multiplyScalar',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }]);

            class AffineTransform {
              static identity() {
                return new AffineTransform();
              }

              static clone(affineTransform) {
                return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
              }

              static concat(out, t1, t2) {
                const a = t1.a;
                const b = t1.b;
                const c = t1.c;
                const d = t1.d;
                const tx = t1.tx;
                const ty = t1.ty;
                out.a = a * t2.a + b * t2.c;
                out.b = a * t2.b + b * t2.d;
                out.c = c * t2.a + d * t2.c;
                out.d = c * t2.b + d * t2.d;
                out.tx = tx * t2.a + ty * t2.c + t2.tx;
                out.ty = tx * t2.b + ty * t2.d + t2.ty;
              }

              static invert(out, t) {
                const determinant = 1 / (t.a * t.d - t.b * t.c);
                out.a = determinant * t.d;
                out.b = -determinant * t.b;
                out.c = -determinant * t.c;
                out.d = determinant * t.a;
                out.tx = determinant * (t.c * t.ty - t.d * t.tx);
                out.ty = determinant * (t.b * t.tx - t.a * t.ty);
              }

              static fromMat4(out, mat) {
                out.a = mat.m00;
                out.b = mat.m01;
                out.c = mat.m04;
                out.d = mat.m05;
                out.tx = mat.m12;
                out.ty = mat.m13;
              }

              static transformVec2(out, point, transOrY, t) {
                let x;
                let y;

                if (t === undefined) {
                  t = transOrY;
                  x = point.x;
                  y = point.y;
                } else {
                  x = point;
                  y = transOrY;
                }

                out.x = t.a * x + t.c * y + t.tx;
                out.y = t.b * x + t.d * y + t.ty;
              }

              static transformSize(out, size, t) {
                out.width = t.a * size.width + t.c * size.height;
                out.height = t.b * size.width + t.d * size.height;
              }

              static transformRect(out, rect, t) {
                const or = rect.x + rect.width;
                const ot = rect.y + rect.height;
                const lbx = t.a * rect.x + t.c * rect.y + t.tx;
                const lby = t.b * rect.x + t.d * rect.y + t.ty;
                const rbx = t.a * or + t.c * rect.y + t.tx;
                const rby = t.b * or + t.d * rect.y + t.ty;
                const ltx = t.a * rect.x + t.c * ot + t.tx;
                const lty = t.b * rect.x + t.d * ot + t.ty;
                const rtx = t.a * or + t.c * ot + t.tx;
                const rty = t.b * or + t.d * ot + t.ty;
                const minX = Math.min(lbx, rbx, ltx, rtx);
                const maxX = Math.max(lbx, rbx, ltx, rtx);
                const minY = Math.min(lby, rby, lty, rty);
                const maxY = Math.max(lby, rby, lty, rty);
                out.x = minX;
                out.y = minY;
                out.width = maxX - minX;
                out.height = maxY - minY;
              }

              static transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
                const tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx;
                const ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty;
                const xa = anAffineTransform.a * rect.width;
                const xb = anAffineTransform.b * rect.width;
                const yc = anAffineTransform.c * rect.height;
                const yd = anAffineTransform.d * rect.height;
                out_tl.x = tx;
                out_tl.y = ty;
                out_tr.x = xa + tx;
                out_tr.y = xb + ty;
                out_bl.x = yc + tx;
                out_bl.y = yd + ty;
                out_br.x = xa + yc + tx;
                out_br.y = xb + yd + ty;
              }

              constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
                this.a = a;
                this.b = b;
                this.c = c;
                this.d = d;
                this.tx = tx;
                this.ty = ty;
              }

            } exports('f5', AffineTransform);
            legacyCC.AffineTransform = AffineTransform;

            class Size extends ValueType {
              static lerp(out, from, to, ratio) {
                out.width = from.width + (to.width - from.width) * ratio;
                out.height = from.height + (to.height - from.height) * ratio;
                return out;
              }

              set x(val) {
                this.width = val;
              }

              get x() {
                return this.width;
              }

              set y(val) {
                this.height = val;
              }

              get y() {
                return this.height;
              }

              constructor(width, height) {
                super();

                if (width && typeof width === 'object') {
                  this.width = width.width;
                  this.height = width.height;
                } else {
                  this.width = width || 0;
                  this.height = height || 0;
                }
              }

              clone() {
                return new Size(this.width, this.height);
              }

              set(width, height) {
                if (width && typeof width === 'object') {
                  this.height = width.height;
                  this.width = width.width;
                } else {
                  this.width = width || 0;
                  this.height = height || 0;
                }

                return this;
              }

              equals(other) {
                return this.width === other.width && this.height === other.height;
              }

              lerp(to, ratio) {
                this.width += (to.width - this.width) * ratio;
                this.height += (to.height - this.height) * ratio;
                return this;
              }

              toString() {
                return `(${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
              }

            } exports('dP', Size);
            Size.ZERO = Object.freeze(new Size(0, 0));
            Size.ONE = Object.freeze(new Size(1, 1));
            CCClass.fastDefine('cc.Size', Size, {
              width: 0,
              height: 0
            });
            function size(width = 0, height = 0) {
              return new Size(width, height);
            }
            legacyCC.size = size;
            legacyCC.Size = Size;

            class Rect extends ValueType {
              static fromMinMax(out, v1, v2) {
                const minX = Math.min(v1.x, v2.x);
                const minY = Math.min(v1.y, v2.y);
                const maxX = Math.max(v1.x, v2.x);
                const maxY = Math.max(v1.y, v2.y);
                out.x = minX;
                out.y = minY;
                out.width = maxX - minX;
                out.height = maxY - minY;
                return out;
              }

              static lerp(out, from, to, ratio) {
                const x = from.x;
                const y = from.y;
                const w = from.width;
                const h = from.height;
                out.x = x + (to.x - x) * ratio;
                out.y = y + (to.y - y) * ratio;
                out.width = w + (to.width - w) * ratio;
                out.height = h + (to.height - h) * ratio;
                return out;
              }

              static intersection(out, one, other) {
                const axMin = one.x;
                const ayMin = one.y;
                const axMax = one.x + one.width;
                const ayMax = one.y + one.height;
                const bxMin = other.x;
                const byMin = other.y;
                const bxMax = other.x + other.width;
                const byMax = other.y + other.height;
                out.x = Math.max(axMin, bxMin);
                out.y = Math.max(ayMin, byMin);
                out.width = Math.min(axMax, bxMax) - out.x;
                out.height = Math.min(ayMax, byMax) - out.y;
                return out;
              }

              static union(out, one, other) {
                const x = one.x;
                const y = one.y;
                const w = one.width;
                const h = one.height;
                const bx = other.x;
                const by = other.y;
                const bw = other.width;
                const bh = other.height;
                out.x = Math.min(x, bx);
                out.y = Math.min(y, by);
                out.width = Math.max(x + w, bx + bw) - out.x;
                out.height = Math.max(y + h, by + bh) - out.y;
                return out;
              }

              get xMin() {
                return this.x;
              }

              set xMin(value) {
                this.width += this.x - value;
                this.x = value;
              }

              get yMin() {
                return this.y;
              }

              set yMin(value) {
                this.height += this.y - value;
                this.y = value;
              }

              get xMax() {
                return this.x + this.width;
              }

              set xMax(value) {
                this.width = value - this.x;
              }

              get yMax() {
                return this.y + this.height;
              }

              set yMax(value) {
                this.height = value - this.y;
              }

              get center() {
                return new Vec2(this.x + this.width * 0.5, this.y + this.height * 0.5);
              }

              set center(value) {
                this.x = value.x - this.width * 0.5;
                this.y = value.y - this.height * 0.5;
              }

              get origin() {
                return new Vec2(this.x, this.y);
              }

              set origin(value) {
                this.x = value.x;
                this.y = value.y;
              }

              get size() {
                return new Size(this.width, this.height);
              }

              set size(value) {
                this.width = value.width;
                this.height = value.height;
              }

              set z(val) {
                this.width = val;
              }

              get z() {
                return this.width;
              }

              set w(val) {
                this.height = val;
              }

              get w() {
                return this.height;
              }

              constructor(x, y, width, height) {
                super();

                if (x && typeof x === 'object') {
                  this.y = x.y;
                  this.width = x.width;
                  this.height = x.height;
                  this.x = x.x;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.width = width || 0;
                  this.height = height || 0;
                }
              }

              clone() {
                return new Rect(this.x, this.y, this.width, this.height);
              }

              set(x, y, width, height) {
                if (x && typeof x === 'object') {
                  this.y = x.y;
                  this.width = x.width;
                  this.height = x.height;
                  this.x = x.x;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.width = width || 0;
                  this.height = height || 0;
                }

                return this;
              }

              equals(other) {
                return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
              }

              lerp(to, ratio) {
                const x = this.x;
                const y = this.y;
                const w = this.width;
                const h = this.height;
                this.x = x + (to.x - x) * ratio;
                this.y = y + (to.y - y) * ratio;
                this.width = w + (to.width - w) * ratio;
                this.height = h + (to.height - h) * ratio;
                return this;
              }

              toString() {
                return `(${this.x.toFixed(2)}, ${this.y.toFixed(2)}, ${this.width.toFixed(2)}, ${this.height.toFixed(2)})`;
              }

              intersects(other) {
                const maxax = this.x + this.width;
                const maxay = this.y + this.height;
                const maxbx = other.x + other.width;
                const maxby = other.y + other.height;
                return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
              }

              contains(point) {
                return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
              }

              containsRect(other) {
                return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
              }

              transformMat4(mat) {
                const ol = this.x;
                const ob = this.y;
                const or = ol + this.width;
                const ot = ob + this.height;
                const lbx = mat.m00 * ol + mat.m04 * ob + mat.m12;
                const lby = mat.m01 * ol + mat.m05 * ob + mat.m13;
                const rbx = mat.m00 * or + mat.m04 * ob + mat.m12;
                const rby = mat.m01 * or + mat.m05 * ob + mat.m13;
                const ltx = mat.m00 * ol + mat.m04 * ot + mat.m12;
                const lty = mat.m01 * ol + mat.m05 * ot + mat.m13;
                const rtx = mat.m00 * or + mat.m04 * ot + mat.m12;
                const rty = mat.m01 * or + mat.m05 * ot + mat.m13;
                const minX = Math.min(lbx, rbx, ltx, rtx);
                const maxX = Math.max(lbx, rbx, ltx, rtx);
                const minY = Math.min(lby, rby, lty, rty);
                const maxY = Math.max(lby, rby, lty, rty);
                this.x = minX;
                this.y = minY;
                this.width = maxX - minX;
                this.height = maxY - minY;
                return this;
              }

              transformMat4ToPoints(mat, out_lb, out_lt, out_rt, out_rb) {
                const ol = this.x;
                const ob = this.y;
                const or = ol + this.width;
                const ot = ob + this.height;
                out_lb.x = mat.m00 * ol + mat.m04 * ob + mat.m12;
                out_lb.y = mat.m01 * ol + mat.m05 * ob + mat.m13;
                out_rb.x = mat.m00 * or + mat.m04 * ob + mat.m12;
                out_rb.y = mat.m01 * or + mat.m05 * ob + mat.m13;
                out_lt.x = mat.m00 * ol + mat.m04 * ot + mat.m12;
                out_lt.y = mat.m01 * ol + mat.m05 * ot + mat.m13;
                out_rt.x = mat.m00 * or + mat.m04 * ot + mat.m12;
                out_rt.y = mat.m01 * or + mat.m05 * ot + mat.m13;
              }

            } exports('dI', Rect);
            CCClass.fastDefine('cc.Rect', Rect, {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            });
            legacyCC.Rect = Rect;
            function rect(x = 0, y = 0, width = 0, height = 0) {
              return new Rect(x, y, width, height);
            }
            legacyCC.rect = rect;

            var math = /*#__PURE__*/Object.freeze({
                __proto__: null,
                bits: bits,
                Vec2: Vec2,
                v2: v2,
                Vec3: Vec3,
                v3: v3,
                Vec4: Vec4,
                v4: v4,
                Quat: Quat,
                quat: quat,
                Mat3: Mat3,
                Mat4: Mat4,
                mat4: mat4,
                AffineTransform: AffineTransform,
                Size: Size,
                size: size,
                Rect: Rect,
                rect: rect,
                Color: Color,
                color: color,
                EPSILON: EPSILON,
                equals: equals,
                approx: approx,
                clamp: clamp,
                clamp01: clamp01,
                lerp: lerp,
                toRadian: toRadian,
                toDegree: toDegree,
                random: random,
                randomRange: randomRange,
                randomRangeInt: randomRangeInt,
                pseudoRandom: pseudoRandom,
                pseudoRandomRange: pseudoRandomRange,
                pseudoRandomRangeInt: pseudoRandomRangeInt,
                nextPow2: nextPow2$1,
                repeat: repeat,
                pingPong: pingPong,
                inverseLerp: inverseLerp,
                absMaxComponent: absMaxComponent,
                absMax: absMax,
                enumerableProps: enumerableProps,
                MATH_FLOAT_ARRAY: MATH_FLOAT_ARRAY,
                MathBase: MathBase
            });
            exports('eY', math);

            const NativeNode = ns.Node;
            const NativeScene = ns.Scene;
            const NativeModel = ns.Model;
            const NativeSkinningModel = exports('cK', ns.SkinningModel);
            const NativeBakedSkinningModel = exports('cQ', ns.BakedSkinningModel);
            const NativeLight = ns.light;
            const NativeDirectionalLight = ns.DirectionalLight;
            const NativeSpotLight = ns.SpotLight;
            const NativeSphereLight = ns.SphereLight;
            const NaitveSkybox = ns.Skybox;
            const NativeFog = ns.Fog;
            const NativeAmbient = ns.Ambient;
            const NativeShadow = ns.Shadow;
            const NativeOctree = ns.OctreeInfo;
            const NativeCamera = ns.Camera;
            const NativeRenderWindow = ns.RenderWindow;
            const NativeRenderScene = ns.RenderScene;
            const NativeDrawBatch2D = exports('eg', ns.DrawBatch2D);
            const NativePass = ns.Pass;
            const NativeSubModel = ns.SubModel;
            const NativeRoot = ns.Root;
            const NativePipelineSharedSceneData = ns.PipelineSharedSceneData;
            const NativeAABB = ns.AABB;
            const NativeGeometryRenderer = nr.GeometryRenderer;

            class Ambient {
              set enabled(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                }
              }

              get enabled() {
                return this._enabled;
              }

              get skyColor() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._skyColorHDR;
                } else {
                  return this._skyColorLDR;
                }
              }

              set skyColor(color) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this._skyColorHDR.set(color);
                } else {
                  this._skyColorLDR.set(color);
                }

                {
                  this._nativeObj.skyColor = isHDR ? this._skyColorHDR : this._skyColorLDR;
                }
              }

              get skyIllum() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._skyIllumHDR;
                } else {
                  return this._skyIllumLDR;
                }
              }

              set skyIllum(illum) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this._skyIllumHDR = illum;
                } else {
                  this._skyIllumLDR = illum;
                }

                {
                  this._nativeObj.skyIllum = isHDR ? this._skyIllumHDR : this._skyIllumLDR;
                }
              }

              get groundAlbedo() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._groundAlbedoHDR;
                } else {
                  return this._groundAlbedoLDR;
                }
              }

              set groundAlbedo(color) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this._groundAlbedoHDR.set(color);
                } else {
                  this._groundAlbedoLDR.set(color);
                }

                {
                  this._nativeObj.groundAlbedo = isHDR ? this._groundAlbedoHDR : this._groundAlbedoLDR;
                }
              }

              get mipmapCount() {
                return this._mipmapCount;
              }

              set mipmapCount(count) {
                this._mipmapCount = count;
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this._groundAlbedoHDR = new Vec4(0.2, 0.2, 0.2, 1.0);
                this._skyColorHDR = new Vec4(0.2, 0.5, 0.8, 1.0);
                this._skyIllumHDR = 0;
                this._groundAlbedoLDR = new Vec4(0.2, 0.2, 0.2, 1.0);
                this._skyColorLDR = new Vec4(0.2, 0.5, 0.8, 1.0);
                this._skyIllumLDR = 0;
                this._mipmapCount = 1;
                this._enabled = false;

                {
                  this._nativeObj = new NativeAmbient();
                }
              }

              initialize(ambientInfo) {
                this._skyColorHDR = ambientInfo.skyColorHDR;

                this._groundAlbedoHDR.set(ambientInfo.groundAlbedoHDR);

                this._skyIllumHDR = ambientInfo.skyIllumHDR;
                this._skyColorLDR = ambientInfo.skyColorLDR;

                this._groundAlbedoLDR.set(ambientInfo.groundAlbedoLDR);

                this._skyIllumLDR = ambientInfo.skyIllumLDR;

                {
                  this._nativeObj.skyIllum = this.skyIllum;
                  this._nativeObj.skyColor = this.skyColor;
                  this._nativeObj.groundAlbedo = this.groundAlbedo;
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();
              }

            }
            Ambient.SUN_ILLUM = 65000.0;
            Ambient.SKY_ILLUM = 20000.0;
            legacyCC.Ambient = Ambient;

            class Octree {
              set enabled(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                }
              }

              get enabled() {
                return this._enabled;
              }

              get minPos() {
                return this._minPos;
              }

              set minPos(val) {
                this._minPos = val;

                {
                  this._nativeObj.minPos = val;
                }
              }

              get maxPos() {
                return this._maxPos;
              }

              set maxPos(val) {
                this._maxPos = val;

                {
                  this._nativeObj.maxPos = val;
                }
              }

              get depth() {
                return this._depth;
              }

              set depth(val) {
                this._depth = val;

                {
                  this._nativeObj.depth = val;
                }
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this._enabled = false;
                this._minPos = new Vec3(0, 0, 0);
                this._maxPos = new Vec3(0, 0, 0);
                this._depth = 0;

                {
                  this._nativeObj = new NativeOctree();
                }
              }

              initialize(octreeInfo) {
                this._enabled = octreeInfo.enabled;
                this._minPos = octreeInfo.minPos;
                this._maxPos = octreeInfo.maxPos;
                this._depth = octreeInfo.depth;

                {
                  this._nativeObj.enabled = this._enabled;
                  this._nativeObj.minPos = this._minPos;
                  this._nativeObj.maxPos = this._maxPos;
                  this._nativeObj.depth = this._depth;
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();
              }

            }

            const X = new Vec3();
            const Y = new Vec3();
            const Z = new Vec3();
            const d = new Vec3();
            const min$1 = new Vec3();
            const max$1 = new Vec3();
            const u = new Array(3);
            const e = new Array(3);
            function point_plane(point, plane_) {
              return Vec3.dot(plane_.n, point) - plane_.d;
            }
            function pt_point_plane(out, point, plane_) {
              const t = point_plane(point, plane_);
              return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
            }
            function pt_point_aabb(out, point, aabb_) {
              Vec3.copy(out, point);
              Vec3.subtract(min$1, aabb_.center, aabb_.halfExtents);
              Vec3.add(max$1, aabb_.center, aabb_.halfExtents);
              out.x = out.x < min$1.x ? min$1.x : out.x;
              out.y = out.y < min$1.y ? min$1.y : out.y;
              out.z = out.z < min$1.z ? min$1.z : out.z;
              out.x = out.x > max$1.x ? max$1.x : out.x;
              out.y = out.y > max$1.y ? max$1.y : out.y;
              out.z = out.z > max$1.z ? max$1.z : out.z;
              return out;
            }
            function pt_point_obb(out, point, obb_) {
              Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02);
              Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05);
              Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08);
              u[0] = X;
              u[1] = Y;
              u[2] = Z;
              e[0] = obb_.halfExtents.x;
              e[1] = obb_.halfExtents.y;
              e[2] = obb_.halfExtents.z;
              Vec3.subtract(d, point, obb_.center);
              Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);

              for (let i = 0; i < 3; i++) {
                let dist = Vec3.dot(d, u[i]);

                if (dist > e[i]) {
                  dist = e[i];
                }

                if (dist < -e[i]) {
                  dist = -e[i];
                }

                out.x += dist * u[i].x;
                out.y += dist * u[i].y;
                out.z += dist * u[i].z;
              }

              return out;
            }
            function pt_point_line(out, point, linePointA, linePointB) {
              Vec3.subtract(X, linePointA, linePointB);
              const dir = X;
              const dirSquaredLength = Vec3.lengthSqr(dir);

              if (dirSquaredLength == 0) {
                Vec3.copy(out, linePointA);
              } else {
                Vec3.subtract(X, point, linePointA);
                const t = Vec3.dot(X, dir) / dirSquaredLength;

                if (t < 0) {
                  Vec3.copy(out, linePointA);
                } else if (t > 1) {
                  Vec3.copy(out, linePointB);
                } else {
                  Vec3.scaleAndAdd(out, linePointA, dir, t);
                }
              }
            }

            var distance = /*#__PURE__*/Object.freeze({
                __proto__: null,
                point_plane: point_plane,
                pt_point_plane: pt_point_plane,
                pt_point_aabb: pt_point_aabb,
                pt_point_obb: pt_point_obb,
                pt_point_line: pt_point_line
            });

            var enums = {
              SHAPE_RAY: 1 << 0,
              SHAPE_LINE: 1 << 1,
              SHAPE_SPHERE: 1 << 2,
              SHAPE_AABB: 1 << 3,
              SHAPE_OBB: 1 << 4,
              SHAPE_PLANE: 1 << 5,
              SHAPE_TRIANGLE: 1 << 6,
              SHAPE_FRUSTUM: 1 << 7,
              SHAPE_FRUSTUM_ACCURATE: 1 << 8,
              SHAPE_CAPSULE: 1 << 9
            };

            class Line {
              static create(sx, sy, sz, ex, ey, ez) {
                return new Line(sx, sy, sz, ex, ey, ez);
              }

              static clone(a) {
                return new Line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
              }

              static copy(out, a) {
                Vec3.copy(out.s, a.s);
                Vec3.copy(out.e, a.e);
                return out;
              }

              static fromPoints(out, start, end) {
                Vec3.copy(out.s, start);
                Vec3.copy(out.e, end);
                return out;
              }

              static set(out, sx, sy, sz, ex, ey, ez) {
                out.s.x = sx;
                out.s.y = sy;
                out.s.z = sz;
                out.e.x = ex;
                out.e.y = ey;
                out.e.z = ez;
                return out;
              }

              static len(a) {
                return Vec3.distance(a.s, a.e);
              }

              get type() {
                return this._type;
              }

              constructor(sx = 0, sy = 0, sz = 0, ex = 0, ey = 0, ez = -1) {
                this.s = void 0;
                this.e = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_LINE;
                this.s = new Vec3(sx, sy, sz);
                this.e = new Vec3(ex, ey, ez);
              }

              length() {
                return Vec3.distance(this.s, this.e);
              }

            }

            class Ray {
              static create(ox = 0, oy = 0, oz = 0, dx = 0, dy = 0, dz = 1) {
                return new Ray(ox, oy, oz, dx, dy, dz);
              }

              static clone(a) {
                return new Ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
              }

              static copy(out, a) {
                Vec3.copy(out.o, a.o);
                Vec3.copy(out.d, a.d);
                return out;
              }

              static fromPoints(out, origin, target) {
                Vec3.copy(out.o, origin);
                Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin));
                return out;
              }

              static set(out, ox, oy, oz, dx, dy, dz) {
                out.o.x = ox;
                out.o.y = oy;
                out.o.z = oz;
                out.d.x = dx;
                out.d.y = dy;
                out.d.z = dz;
                return out;
              }

              get type() {
                return this._type;
              }

              constructor(ox = 0, oy = 0, oz = 0, dx = 0, dy = 0, dz = -1) {
                this.o = void 0;
                this.d = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_RAY;
                this.o = new Vec3(ox, oy, oz);
                this.d = new Vec3(dx, dy, dz);
              }

              computeHit(out, distance) {
                Vec3.normalize(out, this.d);
                Vec3.scaleAndAdd(out, this.o, out, distance);
              }

            }

            const _v3_tmp = new Vec3();

            const _offset = new Vec3();

            const _min = new Vec3();

            const _max = new Vec3();

            function maxComponent(v) {
              return Math.max(Math.max(v.x, v.y), v.z);
            }

            class Sphere {
              static create(cx, cy, cz, r) {
                return new Sphere(cx, cy, cz, r);
              }

              static clone(p) {
                return new Sphere(p.center.x, p.center.y, p.center.z, p.radius);
              }

              static copy(out, p) {
                Vec3.copy(out.center, p.center);
                out.radius = p.radius;
                return out;
              }

              static fromPoints(out, minPos, maxPos) {
                Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), 0.5);
                out.radius = Vec3.subtract(_v3_tmp, maxPos, minPos).length() * 0.5;
                return out;
              }

              static set(out, cx, cy, cz, r) {
                out.center.x = cx;
                out.center.y = cy;
                out.center.z = cz;
                out.radius = r;
                return out;
              }

              get center() {
                return this._center;
              }

              set center(val) {
                this._center = val;
              }

              get radius() {
                return this._radius;
              }

              set radius(val) {
                this._radius = val;
              }

              get type() {
                return this._type;
              }

              constructor(cx = 0, cy = 0, cz = 0, r = 1) {
                this._center = new Vec3(0, 0, 0);
                this._radius = 0;
                this._type = void 0;
                this._type = enums.SHAPE_SPHERE;
                this._center = new Vec3(cx, cy, cz);
                this._radius = r;
              }

              destroy() {}

              clone() {
                return Sphere.clone(this);
              }

              copy(a) {
                return Sphere.copy(this, a);
              }

              getBoundary(minPos, maxPos) {
                Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
                Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
              }

              transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                out.radius = this.radius * maxComponent(scale);
              }

              translateAndRotate(m, rot, out) {
                Vec3.transformMat4(out.center, this.center, m);
              }

              setScale(scale, out) {
                out.radius = this.radius * maxComponent(scale);
              }

              mergePoint(point) {
                if (this.radius < 0.0) {
                  this.center.set(point);
                  this.radius = 0.0;
                }

                Vec3.subtract(_offset, point, this.center);

                const dist = _offset.length();

                if (dist > this.radius) {
                  const half = (dist - this.radius) * 0.5;
                  this.radius += half;
                  Vec3.multiplyScalar(_offset, _offset, half / dist);
                  Vec3.add(this.center, this.center, _offset);
                }
              }

              mergePoints(points) {
                const length = points.length;
                if (length < 1) return;
                this.radius = -1.0;

                for (let i = 0; i < length; i++) {
                  this.mergePoint(points[i]);
                }
              }

              mergeAABB(a) {
                a.getBoundary(_min, _max);
                this.mergePoint(_min);
                this.mergePoint(_max);
              }

            }

            class Triangle {
              static create(ax = 1, ay = 0, az = 0, bx = 0, by = 0, bz = 0, cx = 0, cy = 0, cz = 1) {
                return new Triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
              }

              static clone(t) {
                return new Triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
              }

              static copy(out, t) {
                Vec3.copy(out.a, t.a);
                Vec3.copy(out.b, t.b);
                Vec3.copy(out.c, t.c);
                return out;
              }

              static fromPoints(out, a, b, c) {
                Vec3.copy(out.a, a);
                Vec3.copy(out.b, b);
                Vec3.copy(out.c, c);
                return out;
              }

              static set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
                out.a.x = ax;
                out.a.y = ay;
                out.a.z = az;
                out.b.x = bx;
                out.b.y = by;
                out.b.z = bz;
                out.c.x = cx;
                out.c.y = cy;
                out.c.z = cz;
                return out;
              }

              get type() {
                return this._type;
              }

              constructor(ax = 0, ay = 0, az = 0, bx = 1, by = 0, bz = 0, cx = 0, cy = 1, cz = 0) {
                this.a = void 0;
                this.b = void 0;
                this.c = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_TRIANGLE;
                this.a = new Vec3(ax, ay, az);
                this.b = new Vec3(bx, by, bz);
                this.c = new Vec3(cx, cy, cz);
              }

            }

            const deepCopy = (target, source, Ctor) => {
              for (let i = 0; i < source.length; ++i) {
                if (target.length <= i) target.push(new Ctor());
                target[i].copy(source[i]);
              }

              target.length = source.length;
            };

            let ObjectType;

            (function (ObjectType) {
              ObjectType[ObjectType["UNKNOWN"] = 0] = "UNKNOWN";
              ObjectType[ObjectType["SWAPCHAIN"] = 1] = "SWAPCHAIN";
              ObjectType[ObjectType["BUFFER"] = 2] = "BUFFER";
              ObjectType[ObjectType["TEXTURE"] = 3] = "TEXTURE";
              ObjectType[ObjectType["RENDER_PASS"] = 4] = "RENDER_PASS";
              ObjectType[ObjectType["FRAMEBUFFER"] = 5] = "FRAMEBUFFER";
              ObjectType[ObjectType["SAMPLER"] = 6] = "SAMPLER";
              ObjectType[ObjectType["SHADER"] = 7] = "SHADER";
              ObjectType[ObjectType["DESCRIPTOR_SET_LAYOUT"] = 8] = "DESCRIPTOR_SET_LAYOUT";
              ObjectType[ObjectType["PIPELINE_LAYOUT"] = 9] = "PIPELINE_LAYOUT";
              ObjectType[ObjectType["PIPELINE_STATE"] = 10] = "PIPELINE_STATE";
              ObjectType[ObjectType["DESCRIPTOR_SET"] = 11] = "DESCRIPTOR_SET";
              ObjectType[ObjectType["INPUT_ASSEMBLER"] = 12] = "INPUT_ASSEMBLER";
              ObjectType[ObjectType["COMMAND_BUFFER"] = 13] = "COMMAND_BUFFER";
              ObjectType[ObjectType["QUEUE"] = 14] = "QUEUE";
              ObjectType[ObjectType["QUERY_POOL"] = 15] = "QUERY_POOL";
              ObjectType[ObjectType["GLOBAL_BARRIER"] = 16] = "GLOBAL_BARRIER";
              ObjectType[ObjectType["TEXTURE_BARRIER"] = 17] = "TEXTURE_BARRIER";
              ObjectType[ObjectType["BUFFER_BARRIER"] = 18] = "BUFFER_BARRIER";
              ObjectType[ObjectType["COUNT"] = 19] = "COUNT";
            })(ObjectType || (ObjectType = exports('O', {})));

            let Status;

            (function (Status) {
              Status[Status["UNREADY"] = 0] = "UNREADY";
              Status[Status["FAILED"] = 1] = "FAILED";
              Status[Status["SUCCESS"] = 2] = "SUCCESS";
            })(Status || (Status = exports('f', {})));

            let API;

            (function (API) {
              API[API["UNKNOWN"] = 0] = "UNKNOWN";
              API[API["GLES2"] = 1] = "GLES2";
              API[API["GLES3"] = 2] = "GLES3";
              API[API["METAL"] = 3] = "METAL";
              API[API["VULKAN"] = 4] = "VULKAN";
              API[API["WEBGL"] = 5] = "WEBGL";
              API[API["WEBGL2"] = 6] = "WEBGL2";
              API[API["WEBGPU"] = 7] = "WEBGPU";
            })(API || (API = exports('A', {})));

            let SurfaceTransform;

            (function (SurfaceTransform) {
              SurfaceTransform[SurfaceTransform["IDENTITY"] = 0] = "IDENTITY";
              SurfaceTransform[SurfaceTransform["ROTATE_90"] = 1] = "ROTATE_90";
              SurfaceTransform[SurfaceTransform["ROTATE_180"] = 2] = "ROTATE_180";
              SurfaceTransform[SurfaceTransform["ROTATE_270"] = 3] = "ROTATE_270";
            })(SurfaceTransform || (SurfaceTransform = exports('c', {})));

            let Feature$1;

            (function (Feature) {
              Feature[Feature["COLOR_FLOAT"] = 0] = "COLOR_FLOAT";
              Feature[Feature["COLOR_HALF_FLOAT"] = 1] = "COLOR_HALF_FLOAT";
              Feature[Feature["TEXTURE_FLOAT"] = 2] = "TEXTURE_FLOAT";
              Feature[Feature["TEXTURE_HALF_FLOAT"] = 3] = "TEXTURE_HALF_FLOAT";
              Feature[Feature["TEXTURE_FLOAT_LINEAR"] = 4] = "TEXTURE_FLOAT_LINEAR";
              Feature[Feature["TEXTURE_HALF_FLOAT_LINEAR"] = 5] = "TEXTURE_HALF_FLOAT_LINEAR";
              Feature[Feature["FORMAT_R11G11B10F"] = 6] = "FORMAT_R11G11B10F";
              Feature[Feature["FORMAT_SRGB"] = 7] = "FORMAT_SRGB";
              Feature[Feature["FORMAT_ETC1"] = 8] = "FORMAT_ETC1";
              Feature[Feature["FORMAT_ETC2"] = 9] = "FORMAT_ETC2";
              Feature[Feature["FORMAT_DXT"] = 10] = "FORMAT_DXT";
              Feature[Feature["FORMAT_PVRTC"] = 11] = "FORMAT_PVRTC";
              Feature[Feature["FORMAT_ASTC"] = 12] = "FORMAT_ASTC";
              Feature[Feature["FORMAT_RGB8"] = 13] = "FORMAT_RGB8";
              Feature[Feature["ELEMENT_INDEX_UINT"] = 14] = "ELEMENT_INDEX_UINT";
              Feature[Feature["INSTANCED_ARRAYS"] = 15] = "INSTANCED_ARRAYS";
              Feature[Feature["MULTIPLE_RENDER_TARGETS"] = 16] = "MULTIPLE_RENDER_TARGETS";
              Feature[Feature["BLEND_MINMAX"] = 17] = "BLEND_MINMAX";
              Feature[Feature["COMPUTE_SHADER"] = 18] = "COMPUTE_SHADER";
              Feature[Feature["INPUT_ATTACHMENT_BENEFIT"] = 19] = "INPUT_ATTACHMENT_BENEFIT";
              Feature[Feature["COUNT"] = 20] = "COUNT";
            })(Feature$1 || (Feature$1 = exports('F', {})));

            let Format;

            (function (Format) {
              Format[Format["UNKNOWN"] = 0] = "UNKNOWN";
              Format[Format["A8"] = 1] = "A8";
              Format[Format["L8"] = 2] = "L8";
              Format[Format["LA8"] = 3] = "LA8";
              Format[Format["R8"] = 4] = "R8";
              Format[Format["R8SN"] = 5] = "R8SN";
              Format[Format["R8UI"] = 6] = "R8UI";
              Format[Format["R8I"] = 7] = "R8I";
              Format[Format["R16F"] = 8] = "R16F";
              Format[Format["R16UI"] = 9] = "R16UI";
              Format[Format["R16I"] = 10] = "R16I";
              Format[Format["R32F"] = 11] = "R32F";
              Format[Format["R32UI"] = 12] = "R32UI";
              Format[Format["R32I"] = 13] = "R32I";
              Format[Format["RG8"] = 14] = "RG8";
              Format[Format["RG8SN"] = 15] = "RG8SN";
              Format[Format["RG8UI"] = 16] = "RG8UI";
              Format[Format["RG8I"] = 17] = "RG8I";
              Format[Format["RG16F"] = 18] = "RG16F";
              Format[Format["RG16UI"] = 19] = "RG16UI";
              Format[Format["RG16I"] = 20] = "RG16I";
              Format[Format["RG32F"] = 21] = "RG32F";
              Format[Format["RG32UI"] = 22] = "RG32UI";
              Format[Format["RG32I"] = 23] = "RG32I";
              Format[Format["RGB8"] = 24] = "RGB8";
              Format[Format["SRGB8"] = 25] = "SRGB8";
              Format[Format["RGB8SN"] = 26] = "RGB8SN";
              Format[Format["RGB8UI"] = 27] = "RGB8UI";
              Format[Format["RGB8I"] = 28] = "RGB8I";
              Format[Format["RGB16F"] = 29] = "RGB16F";
              Format[Format["RGB16UI"] = 30] = "RGB16UI";
              Format[Format["RGB16I"] = 31] = "RGB16I";
              Format[Format["RGB32F"] = 32] = "RGB32F";
              Format[Format["RGB32UI"] = 33] = "RGB32UI";
              Format[Format["RGB32I"] = 34] = "RGB32I";
              Format[Format["RGBA8"] = 35] = "RGBA8";
              Format[Format["BGRA8"] = 36] = "BGRA8";
              Format[Format["SRGB8_A8"] = 37] = "SRGB8_A8";
              Format[Format["RGBA8SN"] = 38] = "RGBA8SN";
              Format[Format["RGBA8UI"] = 39] = "RGBA8UI";
              Format[Format["RGBA8I"] = 40] = "RGBA8I";
              Format[Format["RGBA16F"] = 41] = "RGBA16F";
              Format[Format["RGBA16UI"] = 42] = "RGBA16UI";
              Format[Format["RGBA16I"] = 43] = "RGBA16I";
              Format[Format["RGBA32F"] = 44] = "RGBA32F";
              Format[Format["RGBA32UI"] = 45] = "RGBA32UI";
              Format[Format["RGBA32I"] = 46] = "RGBA32I";
              Format[Format["R5G6B5"] = 47] = "R5G6B5";
              Format[Format["R11G11B10F"] = 48] = "R11G11B10F";
              Format[Format["RGB5A1"] = 49] = "RGB5A1";
              Format[Format["RGBA4"] = 50] = "RGBA4";
              Format[Format["RGB10A2"] = 51] = "RGB10A2";
              Format[Format["RGB10A2UI"] = 52] = "RGB10A2UI";
              Format[Format["RGB9E5"] = 53] = "RGB9E5";
              Format[Format["DEPTH"] = 54] = "DEPTH";
              Format[Format["DEPTH_STENCIL"] = 55] = "DEPTH_STENCIL";
              Format[Format["BC1"] = 56] = "BC1";
              Format[Format["BC1_ALPHA"] = 57] = "BC1_ALPHA";
              Format[Format["BC1_SRGB"] = 58] = "BC1_SRGB";
              Format[Format["BC1_SRGB_ALPHA"] = 59] = "BC1_SRGB_ALPHA";
              Format[Format["BC2"] = 60] = "BC2";
              Format[Format["BC2_SRGB"] = 61] = "BC2_SRGB";
              Format[Format["BC3"] = 62] = "BC3";
              Format[Format["BC3_SRGB"] = 63] = "BC3_SRGB";
              Format[Format["BC4"] = 64] = "BC4";
              Format[Format["BC4_SNORM"] = 65] = "BC4_SNORM";
              Format[Format["BC5"] = 66] = "BC5";
              Format[Format["BC5_SNORM"] = 67] = "BC5_SNORM";
              Format[Format["BC6H_UF16"] = 68] = "BC6H_UF16";
              Format[Format["BC6H_SF16"] = 69] = "BC6H_SF16";
              Format[Format["BC7"] = 70] = "BC7";
              Format[Format["BC7_SRGB"] = 71] = "BC7_SRGB";
              Format[Format["ETC_RGB8"] = 72] = "ETC_RGB8";
              Format[Format["ETC2_RGB8"] = 73] = "ETC2_RGB8";
              Format[Format["ETC2_SRGB8"] = 74] = "ETC2_SRGB8";
              Format[Format["ETC2_RGB8_A1"] = 75] = "ETC2_RGB8_A1";
              Format[Format["ETC2_SRGB8_A1"] = 76] = "ETC2_SRGB8_A1";
              Format[Format["ETC2_RGBA8"] = 77] = "ETC2_RGBA8";
              Format[Format["ETC2_SRGB8_A8"] = 78] = "ETC2_SRGB8_A8";
              Format[Format["EAC_R11"] = 79] = "EAC_R11";
              Format[Format["EAC_R11SN"] = 80] = "EAC_R11SN";
              Format[Format["EAC_RG11"] = 81] = "EAC_RG11";
              Format[Format["EAC_RG11SN"] = 82] = "EAC_RG11SN";
              Format[Format["PVRTC_RGB2"] = 83] = "PVRTC_RGB2";
              Format[Format["PVRTC_RGBA2"] = 84] = "PVRTC_RGBA2";
              Format[Format["PVRTC_RGB4"] = 85] = "PVRTC_RGB4";
              Format[Format["PVRTC_RGBA4"] = 86] = "PVRTC_RGBA4";
              Format[Format["PVRTC2_2BPP"] = 87] = "PVRTC2_2BPP";
              Format[Format["PVRTC2_4BPP"] = 88] = "PVRTC2_4BPP";
              Format[Format["ASTC_RGBA_4X4"] = 89] = "ASTC_RGBA_4X4";
              Format[Format["ASTC_RGBA_5X4"] = 90] = "ASTC_RGBA_5X4";
              Format[Format["ASTC_RGBA_5X5"] = 91] = "ASTC_RGBA_5X5";
              Format[Format["ASTC_RGBA_6X5"] = 92] = "ASTC_RGBA_6X5";
              Format[Format["ASTC_RGBA_6X6"] = 93] = "ASTC_RGBA_6X6";
              Format[Format["ASTC_RGBA_8X5"] = 94] = "ASTC_RGBA_8X5";
              Format[Format["ASTC_RGBA_8X6"] = 95] = "ASTC_RGBA_8X6";
              Format[Format["ASTC_RGBA_8X8"] = 96] = "ASTC_RGBA_8X8";
              Format[Format["ASTC_RGBA_10X5"] = 97] = "ASTC_RGBA_10X5";
              Format[Format["ASTC_RGBA_10X6"] = 98] = "ASTC_RGBA_10X6";
              Format[Format["ASTC_RGBA_10X8"] = 99] = "ASTC_RGBA_10X8";
              Format[Format["ASTC_RGBA_10X10"] = 100] = "ASTC_RGBA_10X10";
              Format[Format["ASTC_RGBA_12X10"] = 101] = "ASTC_RGBA_12X10";
              Format[Format["ASTC_RGBA_12X12"] = 102] = "ASTC_RGBA_12X12";
              Format[Format["ASTC_SRGBA_4X4"] = 103] = "ASTC_SRGBA_4X4";
              Format[Format["ASTC_SRGBA_5X4"] = 104] = "ASTC_SRGBA_5X4";
              Format[Format["ASTC_SRGBA_5X5"] = 105] = "ASTC_SRGBA_5X5";
              Format[Format["ASTC_SRGBA_6X5"] = 106] = "ASTC_SRGBA_6X5";
              Format[Format["ASTC_SRGBA_6X6"] = 107] = "ASTC_SRGBA_6X6";
              Format[Format["ASTC_SRGBA_8X5"] = 108] = "ASTC_SRGBA_8X5";
              Format[Format["ASTC_SRGBA_8X6"] = 109] = "ASTC_SRGBA_8X6";
              Format[Format["ASTC_SRGBA_8X8"] = 110] = "ASTC_SRGBA_8X8";
              Format[Format["ASTC_SRGBA_10X5"] = 111] = "ASTC_SRGBA_10X5";
              Format[Format["ASTC_SRGBA_10X6"] = 112] = "ASTC_SRGBA_10X6";
              Format[Format["ASTC_SRGBA_10X8"] = 113] = "ASTC_SRGBA_10X8";
              Format[Format["ASTC_SRGBA_10X10"] = 114] = "ASTC_SRGBA_10X10";
              Format[Format["ASTC_SRGBA_12X10"] = 115] = "ASTC_SRGBA_12X10";
              Format[Format["ASTC_SRGBA_12X12"] = 116] = "ASTC_SRGBA_12X12";
              Format[Format["COUNT"] = 117] = "COUNT";
            })(Format || (Format = exports('g', {})));

            let FormatType;

            (function (FormatType) {
              FormatType[FormatType["NONE"] = 0] = "NONE";
              FormatType[FormatType["UNORM"] = 1] = "UNORM";
              FormatType[FormatType["SNORM"] = 2] = "SNORM";
              FormatType[FormatType["UINT"] = 3] = "UINT";
              FormatType[FormatType["INT"] = 4] = "INT";
              FormatType[FormatType["UFLOAT"] = 5] = "UFLOAT";
              FormatType[FormatType["FLOAT"] = 6] = "FLOAT";
            })(FormatType || (FormatType = exports('h', {})));

            let Type;

            (function (Type) {
              Type[Type["UNKNOWN"] = 0] = "UNKNOWN";
              Type[Type["BOOL"] = 1] = "BOOL";
              Type[Type["BOOL2"] = 2] = "BOOL2";
              Type[Type["BOOL3"] = 3] = "BOOL3";
              Type[Type["BOOL4"] = 4] = "BOOL4";
              Type[Type["INT"] = 5] = "INT";
              Type[Type["INT2"] = 6] = "INT2";
              Type[Type["INT3"] = 7] = "INT3";
              Type[Type["INT4"] = 8] = "INT4";
              Type[Type["UINT"] = 9] = "UINT";
              Type[Type["UINT2"] = 10] = "UINT2";
              Type[Type["UINT3"] = 11] = "UINT3";
              Type[Type["UINT4"] = 12] = "UINT4";
              Type[Type["FLOAT"] = 13] = "FLOAT";
              Type[Type["FLOAT2"] = 14] = "FLOAT2";
              Type[Type["FLOAT3"] = 15] = "FLOAT3";
              Type[Type["FLOAT4"] = 16] = "FLOAT4";
              Type[Type["MAT2"] = 17] = "MAT2";
              Type[Type["MAT2X3"] = 18] = "MAT2X3";
              Type[Type["MAT2X4"] = 19] = "MAT2X4";
              Type[Type["MAT3X2"] = 20] = "MAT3X2";
              Type[Type["MAT3"] = 21] = "MAT3";
              Type[Type["MAT3X4"] = 22] = "MAT3X4";
              Type[Type["MAT4X2"] = 23] = "MAT4X2";
              Type[Type["MAT4X3"] = 24] = "MAT4X3";
              Type[Type["MAT4"] = 25] = "MAT4";
              Type[Type["SAMPLER1D"] = 26] = "SAMPLER1D";
              Type[Type["SAMPLER1D_ARRAY"] = 27] = "SAMPLER1D_ARRAY";
              Type[Type["SAMPLER2D"] = 28] = "SAMPLER2D";
              Type[Type["SAMPLER2D_ARRAY"] = 29] = "SAMPLER2D_ARRAY";
              Type[Type["SAMPLER3D"] = 30] = "SAMPLER3D";
              Type[Type["SAMPLER_CUBE"] = 31] = "SAMPLER_CUBE";
              Type[Type["SAMPLER"] = 32] = "SAMPLER";
              Type[Type["TEXTURE1D"] = 33] = "TEXTURE1D";
              Type[Type["TEXTURE1D_ARRAY"] = 34] = "TEXTURE1D_ARRAY";
              Type[Type["TEXTURE2D"] = 35] = "TEXTURE2D";
              Type[Type["TEXTURE2D_ARRAY"] = 36] = "TEXTURE2D_ARRAY";
              Type[Type["TEXTURE3D"] = 37] = "TEXTURE3D";
              Type[Type["TEXTURE_CUBE"] = 38] = "TEXTURE_CUBE";
              Type[Type["IMAGE1D"] = 39] = "IMAGE1D";
              Type[Type["IMAGE1D_ARRAY"] = 40] = "IMAGE1D_ARRAY";
              Type[Type["IMAGE2D"] = 41] = "IMAGE2D";
              Type[Type["IMAGE2D_ARRAY"] = 42] = "IMAGE2D_ARRAY";
              Type[Type["IMAGE3D"] = 43] = "IMAGE3D";
              Type[Type["IMAGE_CUBE"] = 44] = "IMAGE_CUBE";
              Type[Type["SUBPASS_INPUT"] = 45] = "SUBPASS_INPUT";
              Type[Type["COUNT"] = 46] = "COUNT";
            })(Type || (Type = exports('i', {})));

            let BufferUsageBit;

            (function (BufferUsageBit) {
              BufferUsageBit[BufferUsageBit["NONE"] = 0] = "NONE";
              BufferUsageBit[BufferUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
              BufferUsageBit[BufferUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
              BufferUsageBit[BufferUsageBit["INDEX"] = 4] = "INDEX";
              BufferUsageBit[BufferUsageBit["VERTEX"] = 8] = "VERTEX";
              BufferUsageBit[BufferUsageBit["UNIFORM"] = 16] = "UNIFORM";
              BufferUsageBit[BufferUsageBit["STORAGE"] = 32] = "STORAGE";
              BufferUsageBit[BufferUsageBit["INDIRECT"] = 64] = "INDIRECT";
            })(BufferUsageBit || (BufferUsageBit = exports('B', {})));

            let BufferFlagBit;

            (function (BufferFlagBit) {
              BufferFlagBit[BufferFlagBit["NONE"] = 0] = "NONE";
            })(BufferFlagBit || (BufferFlagBit = exports('b', {})));

            let MemoryAccessBit;

            (function (MemoryAccessBit) {
              MemoryAccessBit[MemoryAccessBit["NONE"] = 0] = "NONE";
              MemoryAccessBit[MemoryAccessBit["READ_ONLY"] = 1] = "READ_ONLY";
              MemoryAccessBit[MemoryAccessBit["WRITE_ONLY"] = 2] = "WRITE_ONLY";
              MemoryAccessBit[MemoryAccessBit["READ_WRITE"] = 3] = "READ_WRITE";
            })(MemoryAccessBit || (MemoryAccessBit = exports('j', {})));

            let MemoryUsageBit;

            (function (MemoryUsageBit) {
              MemoryUsageBit[MemoryUsageBit["NONE"] = 0] = "NONE";
              MemoryUsageBit[MemoryUsageBit["DEVICE"] = 1] = "DEVICE";
              MemoryUsageBit[MemoryUsageBit["HOST"] = 2] = "HOST";
            })(MemoryUsageBit || (MemoryUsageBit = exports('M', {})));

            let TextureType;

            (function (TextureType) {
              TextureType[TextureType["TEX1D"] = 0] = "TEX1D";
              TextureType[TextureType["TEX2D"] = 1] = "TEX2D";
              TextureType[TextureType["TEX3D"] = 2] = "TEX3D";
              TextureType[TextureType["CUBE"] = 3] = "CUBE";
              TextureType[TextureType["TEX1D_ARRAY"] = 4] = "TEX1D_ARRAY";
              TextureType[TextureType["TEX2D_ARRAY"] = 5] = "TEX2D_ARRAY";
            })(TextureType || (TextureType = exports('k', {})));

            let TextureUsageBit;

            (function (TextureUsageBit) {
              TextureUsageBit[TextureUsageBit["NONE"] = 0] = "NONE";
              TextureUsageBit[TextureUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
              TextureUsageBit[TextureUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
              TextureUsageBit[TextureUsageBit["SAMPLED"] = 4] = "SAMPLED";
              TextureUsageBit[TextureUsageBit["STORAGE"] = 8] = "STORAGE";
              TextureUsageBit[TextureUsageBit["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
              TextureUsageBit[TextureUsageBit["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
              TextureUsageBit[TextureUsageBit["INPUT_ATTACHMENT"] = 64] = "INPUT_ATTACHMENT";
            })(TextureUsageBit || (TextureUsageBit = exports('l', {})));

            let TextureFlagBit;

            (function (TextureFlagBit) {
              TextureFlagBit[TextureFlagBit["NONE"] = 0] = "NONE";
              TextureFlagBit[TextureFlagBit["GEN_MIPMAP"] = 1] = "GEN_MIPMAP";
              TextureFlagBit[TextureFlagBit["GENERAL_LAYOUT"] = 2] = "GENERAL_LAYOUT";
            })(TextureFlagBit || (TextureFlagBit = exports('n', {})));

            let SampleCount;

            (function (SampleCount) {
              SampleCount[SampleCount["ONE"] = 0] = "ONE";
              SampleCount[SampleCount["MULTIPLE_PERFORMANCE"] = 1] = "MULTIPLE_PERFORMANCE";
              SampleCount[SampleCount["MULTIPLE_BALANCE"] = 2] = "MULTIPLE_BALANCE";
              SampleCount[SampleCount["MULTIPLE_QUALITY"] = 3] = "MULTIPLE_QUALITY";
            })(SampleCount || (SampleCount = exports('o', {})));

            let VsyncMode;

            (function (VsyncMode) {
              VsyncMode[VsyncMode["OFF"] = 0] = "OFF";
              VsyncMode[VsyncMode["ON"] = 1] = "ON";
              VsyncMode[VsyncMode["RELAXED"] = 2] = "RELAXED";
              VsyncMode[VsyncMode["MAILBOX"] = 3] = "MAILBOX";
              VsyncMode[VsyncMode["HALF"] = 4] = "HALF";
            })(VsyncMode || (VsyncMode = exports('V', {})));

            let Filter;

            (function (Filter) {
              Filter[Filter["NONE"] = 0] = "NONE";
              Filter[Filter["POINT"] = 1] = "POINT";
              Filter[Filter["LINEAR"] = 2] = "LINEAR";
              Filter[Filter["ANISOTROPIC"] = 3] = "ANISOTROPIC";
            })(Filter || (Filter = exports('p', {})));

            let Address;

            (function (Address) {
              Address[Address["WRAP"] = 0] = "WRAP";
              Address[Address["MIRROR"] = 1] = "MIRROR";
              Address[Address["CLAMP"] = 2] = "CLAMP";
              Address[Address["BORDER"] = 3] = "BORDER";
            })(Address || (Address = exports('q', {})));

            let ComparisonFunc;

            (function (ComparisonFunc) {
              ComparisonFunc[ComparisonFunc["NEVER"] = 0] = "NEVER";
              ComparisonFunc[ComparisonFunc["LESS"] = 1] = "LESS";
              ComparisonFunc[ComparisonFunc["EQUAL"] = 2] = "EQUAL";
              ComparisonFunc[ComparisonFunc["LESS_EQUAL"] = 3] = "LESS_EQUAL";
              ComparisonFunc[ComparisonFunc["GREATER"] = 4] = "GREATER";
              ComparisonFunc[ComparisonFunc["NOT_EQUAL"] = 5] = "NOT_EQUAL";
              ComparisonFunc[ComparisonFunc["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
              ComparisonFunc[ComparisonFunc["ALWAYS"] = 7] = "ALWAYS";
            })(ComparisonFunc || (ComparisonFunc = exports('r', {})));

            let StencilOp;

            (function (StencilOp) {
              StencilOp[StencilOp["ZERO"] = 0] = "ZERO";
              StencilOp[StencilOp["KEEP"] = 1] = "KEEP";
              StencilOp[StencilOp["REPLACE"] = 2] = "REPLACE";
              StencilOp[StencilOp["INCR"] = 3] = "INCR";
              StencilOp[StencilOp["DECR"] = 4] = "DECR";
              StencilOp[StencilOp["INVERT"] = 5] = "INVERT";
              StencilOp[StencilOp["INCR_WRAP"] = 6] = "INCR_WRAP";
              StencilOp[StencilOp["DECR_WRAP"] = 7] = "DECR_WRAP";
            })(StencilOp || (StencilOp = exports('s', {})));

            let BlendFactor;

            (function (BlendFactor) {
              BlendFactor[BlendFactor["ZERO"] = 0] = "ZERO";
              BlendFactor[BlendFactor["ONE"] = 1] = "ONE";
              BlendFactor[BlendFactor["SRC_ALPHA"] = 2] = "SRC_ALPHA";
              BlendFactor[BlendFactor["DST_ALPHA"] = 3] = "DST_ALPHA";
              BlendFactor[BlendFactor["ONE_MINUS_SRC_ALPHA"] = 4] = "ONE_MINUS_SRC_ALPHA";
              BlendFactor[BlendFactor["ONE_MINUS_DST_ALPHA"] = 5] = "ONE_MINUS_DST_ALPHA";
              BlendFactor[BlendFactor["SRC_COLOR"] = 6] = "SRC_COLOR";
              BlendFactor[BlendFactor["DST_COLOR"] = 7] = "DST_COLOR";
              BlendFactor[BlendFactor["ONE_MINUS_SRC_COLOR"] = 8] = "ONE_MINUS_SRC_COLOR";
              BlendFactor[BlendFactor["ONE_MINUS_DST_COLOR"] = 9] = "ONE_MINUS_DST_COLOR";
              BlendFactor[BlendFactor["SRC_ALPHA_SATURATE"] = 10] = "SRC_ALPHA_SATURATE";
              BlendFactor[BlendFactor["CONSTANT_COLOR"] = 11] = "CONSTANT_COLOR";
              BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 12] = "ONE_MINUS_CONSTANT_COLOR";
              BlendFactor[BlendFactor["CONSTANT_ALPHA"] = 13] = "CONSTANT_ALPHA";
              BlendFactor[BlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 14] = "ONE_MINUS_CONSTANT_ALPHA";
            })(BlendFactor || (BlendFactor = exports('t', {})));

            let BlendOp;

            (function (BlendOp) {
              BlendOp[BlendOp["ADD"] = 0] = "ADD";
              BlendOp[BlendOp["SUB"] = 1] = "SUB";
              BlendOp[BlendOp["REV_SUB"] = 2] = "REV_SUB";
              BlendOp[BlendOp["MIN"] = 3] = "MIN";
              BlendOp[BlendOp["MAX"] = 4] = "MAX";
            })(BlendOp || (BlendOp = exports('u', {})));

            let ColorMask;

            (function (ColorMask) {
              ColorMask[ColorMask["NONE"] = 0] = "NONE";
              ColorMask[ColorMask["R"] = 1] = "R";
              ColorMask[ColorMask["G"] = 2] = "G";
              ColorMask[ColorMask["B"] = 4] = "B";
              ColorMask[ColorMask["A"] = 8] = "A";
              ColorMask[ColorMask["ALL"] = 15] = "ALL";
            })(ColorMask || (ColorMask = exports('v', {})));

            let ShaderStageFlagBit;

            (function (ShaderStageFlagBit) {
              ShaderStageFlagBit[ShaderStageFlagBit["NONE"] = 0] = "NONE";
              ShaderStageFlagBit[ShaderStageFlagBit["VERTEX"] = 1] = "VERTEX";
              ShaderStageFlagBit[ShaderStageFlagBit["CONTROL"] = 2] = "CONTROL";
              ShaderStageFlagBit[ShaderStageFlagBit["EVALUATION"] = 4] = "EVALUATION";
              ShaderStageFlagBit[ShaderStageFlagBit["GEOMETRY"] = 8] = "GEOMETRY";
              ShaderStageFlagBit[ShaderStageFlagBit["FRAGMENT"] = 16] = "FRAGMENT";
              ShaderStageFlagBit[ShaderStageFlagBit["COMPUTE"] = 32] = "COMPUTE";
              ShaderStageFlagBit[ShaderStageFlagBit["ALL"] = 63] = "ALL";
            })(ShaderStageFlagBit || (ShaderStageFlagBit = exports('w', {})));

            let LoadOp;

            (function (LoadOp) {
              LoadOp[LoadOp["LOAD"] = 0] = "LOAD";
              LoadOp[LoadOp["CLEAR"] = 1] = "CLEAR";
              LoadOp[LoadOp["DISCARD"] = 2] = "DISCARD";
            })(LoadOp || (LoadOp = exports('L', {})));

            let StoreOp;

            (function (StoreOp) {
              StoreOp[StoreOp["STORE"] = 0] = "STORE";
              StoreOp[StoreOp["DISCARD"] = 1] = "DISCARD";
            })(StoreOp || (StoreOp = exports('x', {})));

            let AccessType;

            (function (AccessType) {
              AccessType[AccessType["NONE"] = 0] = "NONE";
              AccessType[AccessType["INDIRECT_BUFFER"] = 1] = "INDIRECT_BUFFER";
              AccessType[AccessType["INDEX_BUFFER"] = 2] = "INDEX_BUFFER";
              AccessType[AccessType["VERTEX_BUFFER"] = 3] = "VERTEX_BUFFER";
              AccessType[AccessType["VERTEX_SHADER_READ_UNIFORM_BUFFER"] = 4] = "VERTEX_SHADER_READ_UNIFORM_BUFFER";
              AccessType[AccessType["VERTEX_SHADER_READ_TEXTURE"] = 5] = "VERTEX_SHADER_READ_TEXTURE";
              AccessType[AccessType["VERTEX_SHADER_READ_OTHER"] = 6] = "VERTEX_SHADER_READ_OTHER";
              AccessType[AccessType["FRAGMENT_SHADER_READ_UNIFORM_BUFFER"] = 7] = "FRAGMENT_SHADER_READ_UNIFORM_BUFFER";
              AccessType[AccessType["FRAGMENT_SHADER_READ_TEXTURE"] = 8] = "FRAGMENT_SHADER_READ_TEXTURE";
              AccessType[AccessType["FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT"] = 9] = "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT";
              AccessType[AccessType["FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT"] = 10] = "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT";
              AccessType[AccessType["FRAGMENT_SHADER_READ_OTHER"] = 11] = "FRAGMENT_SHADER_READ_OTHER";
              AccessType[AccessType["COLOR_ATTACHMENT_READ"] = 12] = "COLOR_ATTACHMENT_READ";
              AccessType[AccessType["DEPTH_STENCIL_ATTACHMENT_READ"] = 13] = "DEPTH_STENCIL_ATTACHMENT_READ";
              AccessType[AccessType["COMPUTE_SHADER_READ_UNIFORM_BUFFER"] = 14] = "COMPUTE_SHADER_READ_UNIFORM_BUFFER";
              AccessType[AccessType["COMPUTE_SHADER_READ_TEXTURE"] = 15] = "COMPUTE_SHADER_READ_TEXTURE";
              AccessType[AccessType["COMPUTE_SHADER_READ_OTHER"] = 16] = "COMPUTE_SHADER_READ_OTHER";
              AccessType[AccessType["TRANSFER_READ"] = 17] = "TRANSFER_READ";
              AccessType[AccessType["HOST_READ"] = 18] = "HOST_READ";
              AccessType[AccessType["PRESENT"] = 19] = "PRESENT";
              AccessType[AccessType["VERTEX_SHADER_WRITE"] = 20] = "VERTEX_SHADER_WRITE";
              AccessType[AccessType["FRAGMENT_SHADER_WRITE"] = 21] = "FRAGMENT_SHADER_WRITE";
              AccessType[AccessType["COLOR_ATTACHMENT_WRITE"] = 22] = "COLOR_ATTACHMENT_WRITE";
              AccessType[AccessType["DEPTH_STENCIL_ATTACHMENT_WRITE"] = 23] = "DEPTH_STENCIL_ATTACHMENT_WRITE";
              AccessType[AccessType["COMPUTE_SHADER_WRITE"] = 24] = "COMPUTE_SHADER_WRITE";
              AccessType[AccessType["TRANSFER_WRITE"] = 25] = "TRANSFER_WRITE";
              AccessType[AccessType["HOST_PREINITIALIZED"] = 26] = "HOST_PREINITIALIZED";
              AccessType[AccessType["HOST_WRITE"] = 27] = "HOST_WRITE";
            })(AccessType || (AccessType = exports('y', {})));

            let ResolveMode;

            (function (ResolveMode) {
              ResolveMode[ResolveMode["NONE"] = 0] = "NONE";
              ResolveMode[ResolveMode["SAMPLE_ZERO"] = 1] = "SAMPLE_ZERO";
              ResolveMode[ResolveMode["AVERAGE"] = 2] = "AVERAGE";
              ResolveMode[ResolveMode["MIN"] = 3] = "MIN";
              ResolveMode[ResolveMode["MAX"] = 4] = "MAX";
            })(ResolveMode || (ResolveMode = exports('z', {})));

            let PipelineBindPoint;

            (function (PipelineBindPoint) {
              PipelineBindPoint[PipelineBindPoint["GRAPHICS"] = 0] = "GRAPHICS";
              PipelineBindPoint[PipelineBindPoint["COMPUTE"] = 1] = "COMPUTE";
              PipelineBindPoint[PipelineBindPoint["RAY_TRACING"] = 2] = "RAY_TRACING";
            })(PipelineBindPoint || (PipelineBindPoint = exports('E', {})));

            let PrimitiveMode;

            (function (PrimitiveMode) {
              PrimitiveMode[PrimitiveMode["POINT_LIST"] = 0] = "POINT_LIST";
              PrimitiveMode[PrimitiveMode["LINE_LIST"] = 1] = "LINE_LIST";
              PrimitiveMode[PrimitiveMode["LINE_STRIP"] = 2] = "LINE_STRIP";
              PrimitiveMode[PrimitiveMode["LINE_LOOP"] = 3] = "LINE_LOOP";
              PrimitiveMode[PrimitiveMode["LINE_LIST_ADJACENCY"] = 4] = "LINE_LIST_ADJACENCY";
              PrimitiveMode[PrimitiveMode["LINE_STRIP_ADJACENCY"] = 5] = "LINE_STRIP_ADJACENCY";
              PrimitiveMode[PrimitiveMode["ISO_LINE_LIST"] = 6] = "ISO_LINE_LIST";
              PrimitiveMode[PrimitiveMode["TRIANGLE_LIST"] = 7] = "TRIANGLE_LIST";
              PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP"] = 8] = "TRIANGLE_STRIP";
              PrimitiveMode[PrimitiveMode["TRIANGLE_FAN"] = 9] = "TRIANGLE_FAN";
              PrimitiveMode[PrimitiveMode["TRIANGLE_LIST_ADJACENCY"] = 10] = "TRIANGLE_LIST_ADJACENCY";
              PrimitiveMode[PrimitiveMode["TRIANGLE_STRIP_ADJACENCY"] = 11] = "TRIANGLE_STRIP_ADJACENCY";
              PrimitiveMode[PrimitiveMode["TRIANGLE_PATCH_ADJACENCY"] = 12] = "TRIANGLE_PATCH_ADJACENCY";
              PrimitiveMode[PrimitiveMode["QUAD_PATCH_LIST"] = 13] = "QUAD_PATCH_LIST";
            })(PrimitiveMode || (PrimitiveMode = exports('H', {})));

            let PolygonMode;

            (function (PolygonMode) {
              PolygonMode[PolygonMode["FILL"] = 0] = "FILL";
              PolygonMode[PolygonMode["POINT"] = 1] = "POINT";
              PolygonMode[PolygonMode["LINE"] = 2] = "LINE";
            })(PolygonMode || (PolygonMode = exports('I', {})));

            let ShadeModel;

            (function (ShadeModel) {
              ShadeModel[ShadeModel["GOURAND"] = 0] = "GOURAND";
              ShadeModel[ShadeModel["FLAT"] = 1] = "FLAT";
            })(ShadeModel || (ShadeModel = exports('J', {})));

            let CullMode;

            (function (CullMode) {
              CullMode[CullMode["NONE"] = 0] = "NONE";
              CullMode[CullMode["FRONT"] = 1] = "FRONT";
              CullMode[CullMode["BACK"] = 2] = "BACK";
            })(CullMode || (CullMode = exports('K', {})));

            let DynamicStateFlagBit;

            (function (DynamicStateFlagBit) {
              DynamicStateFlagBit[DynamicStateFlagBit["NONE"] = 0] = "NONE";
              DynamicStateFlagBit[DynamicStateFlagBit["LINE_WIDTH"] = 1] = "LINE_WIDTH";
              DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BIAS"] = 2] = "DEPTH_BIAS";
              DynamicStateFlagBit[DynamicStateFlagBit["BLEND_CONSTANTS"] = 4] = "BLEND_CONSTANTS";
              DynamicStateFlagBit[DynamicStateFlagBit["DEPTH_BOUNDS"] = 8] = "DEPTH_BOUNDS";
              DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_WRITE_MASK"] = 16] = "STENCIL_WRITE_MASK";
              DynamicStateFlagBit[DynamicStateFlagBit["STENCIL_COMPARE_MASK"] = 32] = "STENCIL_COMPARE_MASK";
            })(DynamicStateFlagBit || (DynamicStateFlagBit = exports('N', {})));

            let StencilFace;

            (function (StencilFace) {
              StencilFace[StencilFace["FRONT"] = 1] = "FRONT";
              StencilFace[StencilFace["BACK"] = 2] = "BACK";
              StencilFace[StencilFace["ALL"] = 3] = "ALL";
            })(StencilFace || (StencilFace = exports('U', {})));

            let DescriptorType;

            (function (DescriptorType) {
              DescriptorType[DescriptorType["UNKNOWN"] = 0] = "UNKNOWN";
              DescriptorType[DescriptorType["UNIFORM_BUFFER"] = 1] = "UNIFORM_BUFFER";
              DescriptorType[DescriptorType["DYNAMIC_UNIFORM_BUFFER"] = 2] = "DYNAMIC_UNIFORM_BUFFER";
              DescriptorType[DescriptorType["STORAGE_BUFFER"] = 4] = "STORAGE_BUFFER";
              DescriptorType[DescriptorType["DYNAMIC_STORAGE_BUFFER"] = 8] = "DYNAMIC_STORAGE_BUFFER";
              DescriptorType[DescriptorType["SAMPLER_TEXTURE"] = 16] = "SAMPLER_TEXTURE";
              DescriptorType[DescriptorType["SAMPLER"] = 32] = "SAMPLER";
              DescriptorType[DescriptorType["TEXTURE"] = 64] = "TEXTURE";
              DescriptorType[DescriptorType["STORAGE_IMAGE"] = 128] = "STORAGE_IMAGE";
              DescriptorType[DescriptorType["INPUT_ATTACHMENT"] = 256] = "INPUT_ATTACHMENT";
            })(DescriptorType || (DescriptorType = exports('W', {})));

            let QueueType;

            (function (QueueType) {
              QueueType[QueueType["GRAPHICS"] = 0] = "GRAPHICS";
              QueueType[QueueType["COMPUTE"] = 1] = "COMPUTE";
              QueueType[QueueType["TRANSFER"] = 2] = "TRANSFER";
            })(QueueType || (QueueType = exports('Q', {})));

            let QueryType;

            (function (QueryType) {
              QueryType[QueryType["OCCLUSION"] = 0] = "OCCLUSION";
              QueryType[QueryType["PIPELINE_STATISTICS"] = 1] = "PIPELINE_STATISTICS";
              QueryType[QueryType["TIMESTAMP"] = 2] = "TIMESTAMP";
            })(QueryType || (QueryType = exports('X', {})));

            let CommandBufferType;

            (function (CommandBufferType) {
              CommandBufferType[CommandBufferType["PRIMARY"] = 0] = "PRIMARY";
              CommandBufferType[CommandBufferType["SECONDARY"] = 1] = "SECONDARY";
            })(CommandBufferType || (CommandBufferType = exports('C', {})));

            let ClearFlagBit;

            (function (ClearFlagBit) {
              ClearFlagBit[ClearFlagBit["NONE"] = 0] = "NONE";
              ClearFlagBit[ClearFlagBit["COLOR"] = 1] = "COLOR";
              ClearFlagBit[ClearFlagBit["DEPTH"] = 2] = "DEPTH";
              ClearFlagBit[ClearFlagBit["STENCIL"] = 4] = "STENCIL";
              ClearFlagBit[ClearFlagBit["DEPTH_STENCIL"] = 6] = "DEPTH_STENCIL";
              ClearFlagBit[ClearFlagBit["ALL"] = 7] = "ALL";
            })(ClearFlagBit || (ClearFlagBit = exports('Y', {})));

            class Size$1 {
              constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
              }

              copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                return this;
              }

            } exports('Z', Size$1);
            class DeviceCaps {
              constructor(maxVertexAttributes = 0, maxVertexUniformVectors = 0, maxFragmentUniformVectors = 0, maxTextureUnits = 0, maxImageUnits = 0, maxVertexTextureUnits = 0, maxColorRenderTargets = 0, maxShaderStorageBufferBindings = 0, maxShaderStorageBlockSize = 0, maxUniformBufferBindings = 0, maxUniformBlockSize = 0, maxTextureSize = 0, maxCubeMapTextureSize = 0, uboOffsetAlignment = 1, maxComputeSharedMemorySize = 0, maxComputeWorkGroupInvocations = 0, maxComputeWorkGroupSize = new Size$1(), maxComputeWorkGroupCount = new Size$1(), supportQuery = false, clipSpaceMinZ = -1, screenSpaceSignY = 1, clipSpaceSignY = 1) {
                this.maxVertexAttributes = maxVertexAttributes;
                this.maxVertexUniformVectors = maxVertexUniformVectors;
                this.maxFragmentUniformVectors = maxFragmentUniformVectors;
                this.maxTextureUnits = maxTextureUnits;
                this.maxImageUnits = maxImageUnits;
                this.maxVertexTextureUnits = maxVertexTextureUnits;
                this.maxColorRenderTargets = maxColorRenderTargets;
                this.maxShaderStorageBufferBindings = maxShaderStorageBufferBindings;
                this.maxShaderStorageBlockSize = maxShaderStorageBlockSize;
                this.maxUniformBufferBindings = maxUniformBufferBindings;
                this.maxUniformBlockSize = maxUniformBlockSize;
                this.maxTextureSize = maxTextureSize;
                this.maxCubeMapTextureSize = maxCubeMapTextureSize;
                this.uboOffsetAlignment = uboOffsetAlignment;
                this.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
                this.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
                this.maxComputeWorkGroupSize = maxComputeWorkGroupSize;
                this.maxComputeWorkGroupCount = maxComputeWorkGroupCount;
                this.supportQuery = supportQuery;
                this.clipSpaceMinZ = clipSpaceMinZ;
                this.screenSpaceSignY = screenSpaceSignY;
                this.clipSpaceSignY = clipSpaceSignY;
              }

              copy(info) {
                this.maxVertexAttributes = info.maxVertexAttributes;
                this.maxVertexUniformVectors = info.maxVertexUniformVectors;
                this.maxFragmentUniformVectors = info.maxFragmentUniformVectors;
                this.maxTextureUnits = info.maxTextureUnits;
                this.maxImageUnits = info.maxImageUnits;
                this.maxVertexTextureUnits = info.maxVertexTextureUnits;
                this.maxColorRenderTargets = info.maxColorRenderTargets;
                this.maxShaderStorageBufferBindings = info.maxShaderStorageBufferBindings;
                this.maxShaderStorageBlockSize = info.maxShaderStorageBlockSize;
                this.maxUniformBufferBindings = info.maxUniformBufferBindings;
                this.maxUniformBlockSize = info.maxUniformBlockSize;
                this.maxTextureSize = info.maxTextureSize;
                this.maxCubeMapTextureSize = info.maxCubeMapTextureSize;
                this.uboOffsetAlignment = info.uboOffsetAlignment;
                this.maxComputeSharedMemorySize = info.maxComputeSharedMemorySize;
                this.maxComputeWorkGroupInvocations = info.maxComputeWorkGroupInvocations;
                this.maxComputeWorkGroupSize.copy(info.maxComputeWorkGroupSize);
                this.maxComputeWorkGroupCount.copy(info.maxComputeWorkGroupCount);
                this.supportQuery = info.supportQuery;
                this.clipSpaceMinZ = info.clipSpaceMinZ;
                this.screenSpaceSignY = info.screenSpaceSignY;
                this.clipSpaceSignY = info.clipSpaceSignY;
                return this;
              }

            } exports('_', DeviceCaps);
            class Offset {
              constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
              }

              copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                return this;
              }

            } exports('$', Offset);
            class Rect$1 {
              constructor(x = 0, y = 0, width = 0, height = 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
              }

              copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.width = info.width;
                this.height = info.height;
                return this;
              }

            } exports('a0', Rect$1);
            class Extent {
              constructor(width = 0, height = 0, depth = 1) {
                this.width = width;
                this.height = height;
                this.depth = depth;
              }

              copy(info) {
                this.width = info.width;
                this.height = info.height;
                this.depth = info.depth;
                return this;
              }

            } exports('a1', Extent);
            class TextureSubresLayers {
              constructor(mipLevel = 0, baseArrayLayer = 0, layerCount = 1) {
                this.mipLevel = mipLevel;
                this.baseArrayLayer = baseArrayLayer;
                this.layerCount = layerCount;
              }

              copy(info) {
                this.mipLevel = info.mipLevel;
                this.baseArrayLayer = info.baseArrayLayer;
                this.layerCount = info.layerCount;
                return this;
              }

            } exports('a2', TextureSubresLayers);
            class TextureSubresRange {
              constructor(baseMipLevel = 0, levelCount = 1, baseArrayLayer = 0, layerCount = 1) {
                this.baseMipLevel = baseMipLevel;
                this.levelCount = levelCount;
                this.baseArrayLayer = baseArrayLayer;
                this.layerCount = layerCount;
              }

              copy(info) {
                this.baseMipLevel = info.baseMipLevel;
                this.levelCount = info.levelCount;
                this.baseArrayLayer = info.baseArrayLayer;
                this.layerCount = info.layerCount;
                return this;
              }

            } exports('a3', TextureSubresRange);
            class TextureCopy {
              constructor(srcSubres = new TextureSubresLayers(), srcOffset = new Offset(), dstSubres = new TextureSubresLayers(), dstOffset = new Offset(), extent = new Extent()) {
                this.srcSubres = srcSubres;
                this.srcOffset = srcOffset;
                this.dstSubres = dstSubres;
                this.dstOffset = dstOffset;
                this.extent = extent;
              }

              copy(info) {
                this.srcSubres.copy(info.srcSubres);
                this.srcOffset.copy(info.srcOffset);
                this.dstSubres.copy(info.dstSubres);
                this.dstOffset.copy(info.dstOffset);
                this.extent.copy(info.extent);
                return this;
              }

            } exports('a4', TextureCopy);
            class TextureBlit {
              constructor(srcSubres = new TextureSubresLayers(), srcOffset = new Offset(), srcExtent = new Extent(), dstSubres = new TextureSubresLayers(), dstOffset = new Offset(), dstExtent = new Extent()) {
                this.srcSubres = srcSubres;
                this.srcOffset = srcOffset;
                this.srcExtent = srcExtent;
                this.dstSubres = dstSubres;
                this.dstOffset = dstOffset;
                this.dstExtent = dstExtent;
              }

              copy(info) {
                this.srcSubres.copy(info.srcSubres);
                this.srcOffset.copy(info.srcOffset);
                this.srcExtent.copy(info.srcExtent);
                this.dstSubres.copy(info.dstSubres);
                this.dstOffset.copy(info.dstOffset);
                this.dstExtent.copy(info.dstExtent);
                return this;
              }

            } exports('a5', TextureBlit);
            class BufferTextureCopy {
              constructor(buffStride = 0, buffTexHeight = 0, texOffset = new Offset(), texExtent = new Extent(), texSubres = new TextureSubresLayers()) {
                this.buffStride = buffStride;
                this.buffTexHeight = buffTexHeight;
                this.texOffset = texOffset;
                this.texExtent = texExtent;
                this.texSubres = texSubres;
              }

              copy(info) {
                this.buffStride = info.buffStride;
                this.buffTexHeight = info.buffTexHeight;
                this.texOffset.copy(info.texOffset);
                this.texExtent.copy(info.texExtent);
                this.texSubres.copy(info.texSubres);
                return this;
              }

            } exports('a6', BufferTextureCopy);
            class Viewport {
              constructor(left = 0, top = 0, width = 0, height = 0, minDepth = 0, maxDepth = 1) {
                this.left = left;
                this.top = top;
                this.width = width;
                this.height = height;
                this.minDepth = minDepth;
                this.maxDepth = maxDepth;
              }

              copy(info) {
                this.left = info.left;
                this.top = info.top;
                this.width = info.width;
                this.height = info.height;
                this.minDepth = info.minDepth;
                this.maxDepth = info.maxDepth;
                return this;
              }

            } exports('a7', Viewport);
            class Color$1 {
              constructor(x = 0, y = 0, z = 0, w = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
              }

              copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                this.w = info.w;
                return this;
              }

            } exports('a8', Color$1);
            class BindingMappingInfo {
              constructor(bufferOffsets = [], samplerOffsets = [], flexibleSet = 0) {
                this.bufferOffsets = bufferOffsets;
                this.samplerOffsets = samplerOffsets;
                this.flexibleSet = flexibleSet;
              }

              copy(info) {
                this.bufferOffsets = info.bufferOffsets.slice();
                this.samplerOffsets = info.samplerOffsets.slice();
                this.flexibleSet = info.flexibleSet;
                return this;
              }

            } exports('a9', BindingMappingInfo);
            class SwapchainInfo {
              constructor(windowHandle = null, vsyncMode = VsyncMode.ON, width = 0, height = 0) {
                this.windowHandle = windowHandle;
                this.vsyncMode = vsyncMode;
                this.width = width;
                this.height = height;
              }

              copy(info) {
                this.windowHandle = info.windowHandle;
                this.vsyncMode = info.vsyncMode;
                this.width = info.width;
                this.height = info.height;
                return this;
              }

            } exports('aa', SwapchainInfo);
            class DeviceInfo {
              constructor(bindingMappingInfo = new BindingMappingInfo()) {
                this.bindingMappingInfo = bindingMappingInfo;
              }

              copy(info) {
                this.bindingMappingInfo.copy(info.bindingMappingInfo);
                return this;
              }

            } exports('ab', DeviceInfo);
            class BufferInfo {
              constructor(usage = BufferUsageBit.NONE, memUsage = MemoryUsageBit.NONE, size = 0, stride = 1, flags = BufferFlagBit.NONE) {
                this.usage = usage;
                this.memUsage = memUsage;
                this.size = size;
                this.stride = stride;
                this.flags = flags;
              }

              copy(info) {
                this.usage = info.usage;
                this.memUsage = info.memUsage;
                this.size = info.size;
                this.stride = info.stride;
                this.flags = info.flags;
                return this;
              }

            } exports('ac', BufferInfo);
            class BufferViewInfo {
              constructor(buffer = null, offset = 0, range = 0) {
                this.buffer = buffer;
                this.offset = offset;
                this.range = range;
              }

              copy(info) {
                this.buffer = info.buffer;
                this.offset = info.offset;
                this.range = info.range;
                return this;
              }

            } exports('ad', BufferViewInfo);
            class DrawInfo {
              constructor(vertexCount = 0, firstVertex = 0, indexCount = 0, firstIndex = 0, vertexOffset = 0, instanceCount = 0, firstInstance = 0) {
                this.vertexCount = vertexCount;
                this.firstVertex = firstVertex;
                this.indexCount = indexCount;
                this.firstIndex = firstIndex;
                this.vertexOffset = vertexOffset;
                this.instanceCount = instanceCount;
                this.firstInstance = firstInstance;
              }

              copy(info) {
                this.vertexCount = info.vertexCount;
                this.firstVertex = info.firstVertex;
                this.indexCount = info.indexCount;
                this.firstIndex = info.firstIndex;
                this.vertexOffset = info.vertexOffset;
                this.instanceCount = info.instanceCount;
                this.firstInstance = info.firstInstance;
                return this;
              }

            } exports('d', DrawInfo);
            class DispatchInfo {
              constructor(groupCountX = 0, groupCountY = 0, groupCountZ = 0, indirectBuffer = null, indirectOffset = 0) {
                this.groupCountX = groupCountX;
                this.groupCountY = groupCountY;
                this.groupCountZ = groupCountZ;
                this.indirectBuffer = indirectBuffer;
                this.indirectOffset = indirectOffset;
              }

              copy(info) {
                this.groupCountX = info.groupCountX;
                this.groupCountY = info.groupCountY;
                this.groupCountZ = info.groupCountZ;
                this.indirectBuffer = info.indirectBuffer;
                this.indirectOffset = info.indirectOffset;
                return this;
              }

            } exports('ae', DispatchInfo);
            class IndirectBuffer {
              constructor(drawInfos = []) {
                this.drawInfos = drawInfos;
              }

              copy(info) {
                deepCopy(this.drawInfos, info.drawInfos, DrawInfo);
                return this;
              }

            } exports('af', IndirectBuffer);
            class TextureInfo {
              constructor(type = TextureType.TEX2D, usage = TextureUsageBit.NONE, format = Format.UNKNOWN, width = 0, height = 0, flags = TextureFlagBit.NONE, layerCount = 1, levelCount = 1, samples = SampleCount.ONE, depth = 1, externalRes = 0) {
                this.type = type;
                this.usage = usage;
                this.format = format;
                this.width = width;
                this.height = height;
                this.flags = flags;
                this.layerCount = layerCount;
                this.levelCount = levelCount;
                this.samples = samples;
                this.depth = depth;
                this.externalRes = externalRes;
              }

              copy(info) {
                this.type = info.type;
                this.usage = info.usage;
                this.format = info.format;
                this.width = info.width;
                this.height = info.height;
                this.flags = info.flags;
                this.layerCount = info.layerCount;
                this.levelCount = info.levelCount;
                this.samples = info.samples;
                this.depth = info.depth;
                this.externalRes = info.externalRes;
                return this;
              }

            } exports('ag', TextureInfo);
            class TextureViewInfo {
              constructor(texture = null, type = TextureType.TEX2D, format = Format.UNKNOWN, baseLevel = 0, levelCount = 1, baseLayer = 0, layerCount = 1) {
                this.texture = texture;
                this.type = type;
                this.format = format;
                this.baseLevel = baseLevel;
                this.levelCount = levelCount;
                this.baseLayer = baseLayer;
                this.layerCount = layerCount;
              }

              copy(info) {
                this.texture = info.texture;
                this.type = info.type;
                this.format = info.format;
                this.baseLevel = info.baseLevel;
                this.levelCount = info.levelCount;
                this.baseLayer = info.baseLayer;
                this.layerCount = info.layerCount;
                return this;
              }

            } exports('ah', TextureViewInfo);
            class SamplerInfo {
              constructor(minFilter = Filter.LINEAR, magFilter = Filter.LINEAR, mipFilter = Filter.NONE, addressU = Address.WRAP, addressV = Address.WRAP, addressW = Address.WRAP, maxAnisotropy = 0, cmpFunc = ComparisonFunc.ALWAYS) {
                this.minFilter = minFilter;
                this.magFilter = magFilter;
                this.mipFilter = mipFilter;
                this.addressU = addressU;
                this.addressV = addressV;
                this.addressW = addressW;
                this.maxAnisotropy = maxAnisotropy;
                this.cmpFunc = cmpFunc;
              }

              copy(info) {
                this.minFilter = info.minFilter;
                this.magFilter = info.magFilter;
                this.mipFilter = info.mipFilter;
                this.addressU = info.addressU;
                this.addressV = info.addressV;
                this.addressW = info.addressW;
                this.maxAnisotropy = info.maxAnisotropy;
                this.cmpFunc = info.cmpFunc;
                return this;
              }

            } exports('ai', SamplerInfo);
            class Uniform {
              constructor(name = '', type = Type.UNKNOWN, count = 0) {
                this.name = name;
                this.type = type;
                this.count = count;
              }

              copy(info) {
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                return this;
              }

            } exports('aj', Uniform);
            class UniformBlock {
              constructor(set = 0, binding = 0, name = '', members = [], count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.members = members;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                deepCopy(this.members, info.members, Uniform);
                this.count = info.count;
                return this;
              }

            } exports('ak', UniformBlock);
            class UniformSamplerTexture {
              constructor(set = 0, binding = 0, name = '', type = Type.UNKNOWN, count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                return this;
              }

            } exports('al', UniformSamplerTexture);
            class UniformSampler {
              constructor(set = 0, binding = 0, name = '', count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                return this;
              }

            } exports('am', UniformSampler);
            class UniformTexture {
              constructor(set = 0, binding = 0, name = '', type = Type.UNKNOWN, count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                return this;
              }

            } exports('an', UniformTexture);
            class UniformStorageImage {
              constructor(set = 0, binding = 0, name = '', type = Type.UNKNOWN, count = 0, memoryAccess = MemoryAccessBit.READ_WRITE) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
                this.memoryAccess = memoryAccess;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                this.memoryAccess = info.memoryAccess;
                return this;
              }

            } exports('ao', UniformStorageImage);
            class UniformStorageBuffer {
              constructor(set = 0, binding = 0, name = '', count = 0, memoryAccess = MemoryAccessBit.READ_WRITE) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
                this.memoryAccess = memoryAccess;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                this.memoryAccess = info.memoryAccess;
                return this;
              }

            } exports('ap', UniformStorageBuffer);
            class UniformInputAttachment {
              constructor(set = 0, binding = 0, name = '', count = 0) {
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
              }

              copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                return this;
              }

            } exports('aq', UniformInputAttachment);
            class ShaderStage {
              constructor(stage = ShaderStageFlagBit.NONE, source = '') {
                this.stage = stage;
                this.source = source;
              }

              copy(info) {
                this.stage = info.stage;
                this.source = info.source;
                return this;
              }

            } exports('ar', ShaderStage);
            class Attribute {
              constructor(name = '', format = Format.UNKNOWN, isNormalized = false, stream = 0, isInstanced = false, location = 0) {
                this.name = name;
                this.format = format;
                this.isNormalized = isNormalized;
                this.stream = stream;
                this.isInstanced = isInstanced;
                this.location = location;
              }

              copy(info) {
                this.name = info.name;
                this.format = info.format;
                this.isNormalized = info.isNormalized;
                this.stream = info.stream;
                this.isInstanced = info.isInstanced;
                this.location = info.location;
                return this;
              }

            } exports('as', Attribute);
            class ShaderInfo {
              constructor(name = '', stages = [], attributes = [], blocks = [], buffers = [], samplerTextures = [], samplers = [], textures = [], images = [], subpassInputs = []) {
                this.name = name;
                this.stages = stages;
                this.attributes = attributes;
                this.blocks = blocks;
                this.buffers = buffers;
                this.samplerTextures = samplerTextures;
                this.samplers = samplers;
                this.textures = textures;
                this.images = images;
                this.subpassInputs = subpassInputs;
              }

              copy(info) {
                this.name = info.name;
                deepCopy(this.stages, info.stages, ShaderStage);
                deepCopy(this.attributes, info.attributes, Attribute);
                deepCopy(this.blocks, info.blocks, UniformBlock);
                deepCopy(this.buffers, info.buffers, UniformStorageBuffer);
                deepCopy(this.samplerTextures, info.samplerTextures, UniformSamplerTexture);
                deepCopy(this.samplers, info.samplers, UniformSampler);
                deepCopy(this.textures, info.textures, UniformTexture);
                deepCopy(this.images, info.images, UniformStorageImage);
                deepCopy(this.subpassInputs, info.subpassInputs, UniformInputAttachment);
                return this;
              }

            } exports('at', ShaderInfo);
            class InputAssemblerInfo {
              constructor(attributes = [], vertexBuffers = [], indexBuffer = null, indirectBuffer = null) {
                this.attributes = attributes;
                this.vertexBuffers = vertexBuffers;
                this.indexBuffer = indexBuffer;
                this.indirectBuffer = indirectBuffer;
              }

              copy(info) {
                deepCopy(this.attributes, info.attributes, Attribute);
                this.vertexBuffers = info.vertexBuffers.slice();
                this.indexBuffer = info.indexBuffer;
                this.indirectBuffer = info.indirectBuffer;
                return this;
              }

            } exports('au', InputAssemblerInfo);
            class ColorAttachment {
              constructor(format = Format.UNKNOWN, sampleCount = SampleCount.ONE, loadOp = LoadOp.CLEAR, storeOp = StoreOp.STORE, beginAccesses = [], endAccesses = [AccessType.COLOR_ATTACHMENT_WRITE], isGeneralLayout = false) {
                this.format = format;
                this.sampleCount = sampleCount;
                this.loadOp = loadOp;
                this.storeOp = storeOp;
                this.beginAccesses = beginAccesses;
                this.endAccesses = endAccesses;
                this.isGeneralLayout = isGeneralLayout;
              }

              copy(info) {
                this.format = info.format;
                this.sampleCount = info.sampleCount;
                this.loadOp = info.loadOp;
                this.storeOp = info.storeOp;
                this.beginAccesses = info.beginAccesses.slice();
                this.endAccesses = info.endAccesses.slice();
                this.isGeneralLayout = info.isGeneralLayout;
                return this;
              }

            } exports('av', ColorAttachment);
            class DepthStencilAttachment {
              constructor(format = Format.UNKNOWN, sampleCount = SampleCount.ONE, depthLoadOp = LoadOp.CLEAR, depthStoreOp = StoreOp.STORE, stencilLoadOp = LoadOp.CLEAR, stencilStoreOp = StoreOp.STORE, beginAccesses = [], endAccesses = [AccessType.DEPTH_STENCIL_ATTACHMENT_WRITE], isGeneralLayout = false) {
                this.format = format;
                this.sampleCount = sampleCount;
                this.depthLoadOp = depthLoadOp;
                this.depthStoreOp = depthStoreOp;
                this.stencilLoadOp = stencilLoadOp;
                this.stencilStoreOp = stencilStoreOp;
                this.beginAccesses = beginAccesses;
                this.endAccesses = endAccesses;
                this.isGeneralLayout = isGeneralLayout;
              }

              copy(info) {
                this.format = info.format;
                this.sampleCount = info.sampleCount;
                this.depthLoadOp = info.depthLoadOp;
                this.depthStoreOp = info.depthStoreOp;
                this.stencilLoadOp = info.stencilLoadOp;
                this.stencilStoreOp = info.stencilStoreOp;
                this.beginAccesses = info.beginAccesses.slice();
                this.endAccesses = info.endAccesses.slice();
                this.isGeneralLayout = info.isGeneralLayout;
                return this;
              }

            } exports('aw', DepthStencilAttachment);
            class SubpassInfo {
              constructor(inputs = [], colors = [], resolves = [], preserves = [], depthStencil = -1, depthStencilResolve = -1, depthResolveMode = ResolveMode.NONE, stencilResolveMode = ResolveMode.NONE) {
                this.inputs = inputs;
                this.colors = colors;
                this.resolves = resolves;
                this.preserves = preserves;
                this.depthStencil = depthStencil;
                this.depthStencilResolve = depthStencilResolve;
                this.depthResolveMode = depthResolveMode;
                this.stencilResolveMode = stencilResolveMode;
              }

              copy(info) {
                this.inputs = info.inputs.slice();
                this.colors = info.colors.slice();
                this.resolves = info.resolves.slice();
                this.preserves = info.preserves.slice();
                this.depthStencil = info.depthStencil;
                this.depthStencilResolve = info.depthStencilResolve;
                this.depthResolveMode = info.depthResolveMode;
                this.stencilResolveMode = info.stencilResolveMode;
                return this;
              }

            } exports('ax', SubpassInfo);
            class SubpassDependency {
              constructor(srcSubpass = 0, dstSubpass = 0, srcAccesses = [], dstAccesses = []) {
                this.srcSubpass = srcSubpass;
                this.dstSubpass = dstSubpass;
                this.srcAccesses = srcAccesses;
                this.dstAccesses = dstAccesses;
              }

              copy(info) {
                this.srcSubpass = info.srcSubpass;
                this.dstSubpass = info.dstSubpass;
                this.srcAccesses = info.srcAccesses.slice();
                this.dstAccesses = info.dstAccesses.slice();
                return this;
              }

            } exports('ay', SubpassDependency);
            class RenderPassInfo {
              constructor(colorAttachments = [], depthStencilAttachment = new DepthStencilAttachment(), subpasses = [], dependencies = []) {
                this.colorAttachments = colorAttachments;
                this.depthStencilAttachment = depthStencilAttachment;
                this.subpasses = subpasses;
                this.dependencies = dependencies;
              }

              copy(info) {
                deepCopy(this.colorAttachments, info.colorAttachments, ColorAttachment);
                this.depthStencilAttachment.copy(info.depthStencilAttachment);
                deepCopy(this.subpasses, info.subpasses, SubpassInfo);
                deepCopy(this.dependencies, info.dependencies, SubpassDependency);
                return this;
              }

            } exports('az', RenderPassInfo);
            class GlobalBarrierInfo {
              constructor(prevAccesses = [], nextAccesses = []) {
                this.prevAccesses = prevAccesses;
                this.nextAccesses = nextAccesses;
              }

              copy(info) {
                this.prevAccesses = info.prevAccesses.slice();
                this.nextAccesses = info.nextAccesses.slice();
                return this;
              }

            } exports('e', GlobalBarrierInfo);
            class TextureBarrierInfo {
              constructor(prevAccesses = [], nextAccesses = [], discardContents = false, srcQueue = null, dstQueue = null) {
                this.prevAccesses = prevAccesses;
                this.nextAccesses = nextAccesses;
                this.discardContents = discardContents;
                this.srcQueue = srcQueue;
                this.dstQueue = dstQueue;
              }

              copy(info) {
                this.prevAccesses = info.prevAccesses.slice();
                this.nextAccesses = info.nextAccesses.slice();
                this.discardContents = info.discardContents;
                this.srcQueue = info.srcQueue;
                this.dstQueue = info.dstQueue;
                return this;
              }

            } exports('T', TextureBarrierInfo);
            class FramebufferInfo {
              constructor(renderPass = null, colorTextures = [], depthStencilTexture = null) {
                this.renderPass = renderPass;
                this.colorTextures = colorTextures;
                this.depthStencilTexture = depthStencilTexture;
              }

              copy(info) {
                this.renderPass = info.renderPass;
                this.colorTextures = info.colorTextures.slice();
                this.depthStencilTexture = info.depthStencilTexture;
                return this;
              }

            } exports('aA', FramebufferInfo);
            class DescriptorSetLayoutBinding {
              constructor(binding = -1, descriptorType = DescriptorType.UNKNOWN, count = 0, stageFlags = ShaderStageFlagBit.NONE, immutableSamplers = []) {
                this.binding = binding;
                this.descriptorType = descriptorType;
                this.count = count;
                this.stageFlags = stageFlags;
                this.immutableSamplers = immutableSamplers;
              }

              copy(info) {
                this.binding = info.binding;
                this.descriptorType = info.descriptorType;
                this.count = info.count;
                this.stageFlags = info.stageFlags;
                this.immutableSamplers = info.immutableSamplers.slice();
                return this;
              }

            } exports('aB', DescriptorSetLayoutBinding);
            class DescriptorSetLayoutInfo {
              constructor(bindings = []) {
                this.bindings = bindings;
              }

              copy(info) {
                deepCopy(this.bindings, info.bindings, DescriptorSetLayoutBinding);
                return this;
              }

            } exports('aC', DescriptorSetLayoutInfo);
            class DescriptorSetInfo {
              constructor(layout = null) {
                this.layout = layout;
              }

              copy(info) {
                this.layout = info.layout;
                return this;
              }

            } exports('aD', DescriptorSetInfo);
            class PipelineLayoutInfo {
              constructor(setLayouts = []) {
                this.setLayouts = setLayouts;
              }

              copy(info) {
                this.setLayouts = info.setLayouts.slice();
                return this;
              }

            } exports('aE', PipelineLayoutInfo);
            class InputState {
              constructor(attributes = []) {
                this.attributes = attributes;
              }

              copy(info) {
                deepCopy(this.attributes, info.attributes, Attribute);
                return this;
              }

            } exports('aF', InputState);
            class CommandBufferInfo {
              constructor(queue = null, type = CommandBufferType.PRIMARY) {
                this.queue = queue;
                this.type = type;
              }

              copy(info) {
                this.queue = info.queue;
                this.type = info.type;
                return this;
              }

            } exports('aG', CommandBufferInfo);
            class QueueInfo {
              constructor(type = QueueType.GRAPHICS) {
                this.type = type;
              }

              copy(info) {
                this.type = info.type;
                return this;
              }

            } exports('aH', QueueInfo);
            class QueryPoolInfo {
              constructor(type = QueryType.OCCLUSION, maxQueryObjects = 65536, forceWait = true) {
                this.type = type;
                this.maxQueryObjects = maxQueryObjects;
                this.forceWait = forceWait;
              }

              copy(info) {
                this.type = info.type;
                this.maxQueryObjects = info.maxQueryObjects;
                this.forceWait = info.forceWait;
                return this;
              }

            } exports('aI', QueryPoolInfo);
            class FormatInfo {
              constructor(name = '', size = 0, count = 0, type = FormatType.NONE, hasAlpha = false, hasDepth = false, hasStencil = false, isCompressed = false) {
                this.name = name;
                this.size = size;
                this.count = count;
                this.type = type;
                this.hasAlpha = hasAlpha;
                this.hasDepth = hasDepth;
                this.hasStencil = hasStencil;
                this.isCompressed = isCompressed;
              }

            } exports('aJ', FormatInfo);
            class MemoryStatus {
              constructor(bufferSize = 0, textureSize = 0) {
                this.bufferSize = bufferSize;
                this.textureSize = textureSize;
              }

              copy(info) {
                this.bufferSize = info.bufferSize;
                this.textureSize = info.textureSize;
                return this;
              }

            } exports('aK', MemoryStatus);
            class DynamicStencilStates {
              constructor(writeMask = 0, compareMask = 0, reference = 0) {
                this.writeMask = writeMask;
                this.compareMask = compareMask;
                this.reference = reference;
              }

              copy(info) {
                this.writeMask = info.writeMask;
                this.compareMask = info.compareMask;
                this.reference = info.reference;
                return this;
              }

            } exports('aL', DynamicStencilStates);
            class DynamicStates {
              constructor(viewport = new Viewport(), scissor = new Rect$1(), blendConstant = new Color$1(), lineWidth = 1, depthBiasConstant = 0, depthBiasClamp = 0, depthBiasSlope = 0, depthMinBounds = 0, depthMaxBounds = 0, stencilStatesFront = new DynamicStencilStates(), stencilStatesBack = new DynamicStencilStates()) {
                this.viewport = viewport;
                this.scissor = scissor;
                this.blendConstant = blendConstant;
                this.lineWidth = lineWidth;
                this.depthBiasConstant = depthBiasConstant;
                this.depthBiasClamp = depthBiasClamp;
                this.depthBiasSlope = depthBiasSlope;
                this.depthMinBounds = depthMinBounds;
                this.depthMaxBounds = depthMaxBounds;
                this.stencilStatesFront = stencilStatesFront;
                this.stencilStatesBack = stencilStatesBack;
              }

              copy(info) {
                this.viewport.copy(info.viewport);
                this.scissor.copy(info.scissor);
                this.blendConstant.copy(info.blendConstant);
                this.lineWidth = info.lineWidth;
                this.depthBiasConstant = info.depthBiasConstant;
                this.depthBiasClamp = info.depthBiasClamp;
                this.depthBiasSlope = info.depthBiasSlope;
                this.depthMinBounds = info.depthMinBounds;
                this.depthMaxBounds = info.depthMaxBounds;
                this.stencilStatesFront.copy(info.stencilStatesFront);
                this.stencilStatesBack.copy(info.stencilStatesBack);
                return this;
              }

            } exports('aM', DynamicStates);
            class GFXObject {
              get objectType() {
                return this._objectType;
              }

              get objectID() {
                return this._objectID;
              }

              get typedID() {
                return this._typedID;
              }

              constructor(objectType) {
                this._objectType = ObjectType.UNKNOWN;
                this._objectID = 0;
                this._typedID = 0;
                this._objectType = objectType;
                this._objectID = GFXObject._idTable[ObjectType.UNKNOWN]++;
                this._typedID = GFXObject._idTable[objectType]++;
              }

            } exports('G', GFXObject);
            GFXObject._idTable = Array(ObjectType.COUNT).fill(1 << 16);
            let AttributeName;

            (function (AttributeName) {
              AttributeName["ATTR_POSITION"] = "a_position";
              AttributeName["ATTR_NORMAL"] = "a_normal";
              AttributeName["ATTR_TANGENT"] = "a_tangent";
              AttributeName["ATTR_BITANGENT"] = "a_bitangent";
              AttributeName["ATTR_WEIGHTS"] = "a_weights";
              AttributeName["ATTR_JOINTS"] = "a_joints";
              AttributeName["ATTR_COLOR"] = "a_color";
              AttributeName["ATTR_COLOR1"] = "a_color1";
              AttributeName["ATTR_COLOR2"] = "a_color2";
              AttributeName["ATTR_TEX_COORD"] = "a_texCoord";
              AttributeName["ATTR_TEX_COORD1"] = "a_texCoord1";
              AttributeName["ATTR_TEX_COORD2"] = "a_texCoord2";
              AttributeName["ATTR_TEX_COORD3"] = "a_texCoord3";
              AttributeName["ATTR_TEX_COORD4"] = "a_texCoord4";
              AttributeName["ATTR_TEX_COORD5"] = "a_texCoord5";
              AttributeName["ATTR_TEX_COORD6"] = "a_texCoord6";
              AttributeName["ATTR_TEX_COORD7"] = "a_texCoord7";
              AttributeName["ATTR_TEX_COORD8"] = "a_texCoord8";
              AttributeName["ATTR_BATCH_ID"] = "a_batch_id";
              AttributeName["ATTR_BATCH_UV"] = "a_batch_uv";
            })(AttributeName || (AttributeName = exports('aN', {})));

            const FormatInfos = exports('aO', Object.freeze([new FormatInfo('UNKNOWN', 0, 0, FormatType.NONE, false, false, false, false), new FormatInfo('A8', 1, 1, FormatType.UNORM, true, false, false, false), new FormatInfo('L8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('LA8', 1, 2, FormatType.UNORM, true, false, false, false), new FormatInfo('R8', 1, 1, FormatType.UNORM, false, false, false, false), new FormatInfo('R8SN', 1, 1, FormatType.SNORM, false, false, false, false), new FormatInfo('R8UI', 1, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R8I', 1, 1, FormatType.INT, false, false, false, false), new FormatInfo('R16F', 2, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R16UI', 2, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R16I', 2, 1, FormatType.INT, false, false, false, false), new FormatInfo('R32F', 4, 1, FormatType.FLOAT, false, false, false, false), new FormatInfo('R32UI', 4, 1, FormatType.UINT, false, false, false, false), new FormatInfo('R32I', 4, 1, FormatType.INT, false, false, false, false), new FormatInfo('RG8', 2, 2, FormatType.UNORM, false, false, false, false), new FormatInfo('RG8SN', 2, 2, FormatType.SNORM, false, false, false, false), new FormatInfo('RG8UI', 2, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG8I', 2, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG16F', 4, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG16UI', 4, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG16I', 4, 2, FormatType.INT, false, false, false, false), new FormatInfo('RG32F', 8, 2, FormatType.FLOAT, false, false, false, false), new FormatInfo('RG32UI', 8, 2, FormatType.UINT, false, false, false, false), new FormatInfo('RG32I', 8, 2, FormatType.INT, false, false, false, false), new FormatInfo('RGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('SRGB8', 3, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('RGB8SN', 3, 3, FormatType.SNORM, false, false, false, false), new FormatInfo('RGB8UI', 3, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB8I', 3, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB16F', 6, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB16UI', 6, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB16I', 6, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGB32F', 12, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB32UI', 12, 3, FormatType.UINT, false, false, false, false), new FormatInfo('RGB32I', 12, 3, FormatType.INT, false, false, false, false), new FormatInfo('RGBA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('BGRA8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('SRGB8_A8', 4, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA8SN', 4, 4, FormatType.SNORM, true, false, false, false), new FormatInfo('RGBA8UI', 4, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA8I', 4, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA16F', 8, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA16UI', 8, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA16I', 8, 4, FormatType.INT, true, false, false, false), new FormatInfo('RGBA32F', 16, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('RGBA32UI', 16, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGBA32I', 16, 4, FormatType.INT, true, false, false, false), new FormatInfo('R5G6B5', 2, 3, FormatType.UNORM, false, false, false, false), new FormatInfo('R11G11B10F', 4, 3, FormatType.FLOAT, false, false, false, false), new FormatInfo('RGB5A1', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGBA4', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2', 2, 4, FormatType.UNORM, true, false, false, false), new FormatInfo('RGB10A2UI', 2, 4, FormatType.UINT, true, false, false, false), new FormatInfo('RGB9E5', 2, 4, FormatType.FLOAT, true, false, false, false), new FormatInfo('DEPTH', 4, 1, FormatType.FLOAT, false, true, false, false), new FormatInfo('DEPTH_STENCIL', 5, 2, FormatType.FLOAT, false, true, true, false), new FormatInfo('BC1', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC1_SRGB', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('BC1_SRGB_ALPHA', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC2_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC3_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC4', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('BC4_SNORM', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('BC5', 1, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('BC5_SNORM', 1, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('BC6H_UF16', 1, 3, FormatType.UFLOAT, false, false, false, true), new FormatInfo('BC6H_SF16', 1, 3, FormatType.FLOAT, false, false, false, true), new FormatInfo('BC7', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('BC7_SRGB', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_SRGB8', 1, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('ETC2_RGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A1', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_RGBA8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ETC2_SRGB8_A8', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('EAC_R11', 1, 1, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_R11SN', 1, 1, FormatType.SNORM, false, false, false, true), new FormatInfo('EAC_RG11', 2, 2, FormatType.UNORM, false, false, false, true), new FormatInfo('EAC_RG11SN', 2, 2, FormatType.SNORM, false, false, false, true), new FormatInfo('PVRTC_RGB2', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA2', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC_RGB4', 2, 3, FormatType.UNORM, false, false, false, true), new FormatInfo('PVRTC_RGBA4', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_2BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('PVRTC2_4BPP', 2, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_RGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_4x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x4', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_5x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_6x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_8x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x5', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x6', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x8', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_10x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x10', 1, 4, FormatType.UNORM, true, false, false, true), new FormatInfo('ASTC_SRGBA_12x12', 1, 4, FormatType.UNORM, true, false, false, true)]));
            const DESCRIPTOR_BUFFER_TYPE = exports('D', DescriptorType.UNIFORM_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER | DescriptorType.STORAGE_BUFFER | DescriptorType.DYNAMIC_STORAGE_BUFFER);
            const DESCRIPTOR_SAMPLER_TYPE = exports('a', DescriptorType.SAMPLER_TEXTURE | DescriptorType.SAMPLER | DescriptorType.TEXTURE | DescriptorType.STORAGE_IMAGE | DescriptorType.INPUT_ATTACHMENT);
            const DESCRIPTOR_DYNAMIC_TYPE = exports('aP', DescriptorType.DYNAMIC_STORAGE_BUFFER | DescriptorType.DYNAMIC_UNIFORM_BUFFER);
            const DRAW_INFO_SIZE = exports('aQ', 28);
            function IsPowerOf2(x) {
              return x > 0 && (x & x - 1) === 0;
            }
            function FormatSize(format, width, height, depth) {
              if (!FormatInfos[format].isCompressed) {
                return width * height * depth * FormatInfos[format].size;
              } else {
                switch (format) {
                  case Format.BC1:
                  case Format.BC1_ALPHA:
                  case Format.BC1_SRGB:
                  case Format.BC1_SRGB_ALPHA:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

                  case Format.BC2:
                  case Format.BC2_SRGB:
                  case Format.BC3:
                  case Format.BC3_SRGB:
                  case Format.BC4:
                  case Format.BC4_SNORM:
                  case Format.BC6H_SF16:
                  case Format.BC6H_UF16:
                  case Format.BC7:
                  case Format.BC7_SRGB:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case Format.BC5:
                  case Format.BC5_SNORM:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

                  case Format.ETC_RGB8:
                  case Format.ETC2_RGB8:
                  case Format.ETC2_SRGB8:
                  case Format.ETC2_RGB8_A1:
                  case Format.EAC_R11:
                  case Format.EAC_R11SN:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

                  case Format.ETC2_RGBA8:
                  case Format.ETC2_SRGB8_A1:
                  case Format.EAC_RG11:
                  case Format.EAC_RG11SN:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case Format.PVRTC_RGB2:
                  case Format.PVRTC_RGBA2:
                  case Format.PVRTC2_2BPP:
                    return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

                  case Format.PVRTC_RGB4:
                  case Format.PVRTC_RGBA4:
                  case Format.PVRTC2_4BPP:
                    return Math.ceil(Math.max(width, 8) * Math.max(height, 8) / 2) * depth;

                  case Format.ASTC_RGBA_4X4:
                  case Format.ASTC_SRGBA_4X4:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case Format.ASTC_RGBA_5X4:
                  case Format.ASTC_SRGBA_5X4:
                    return Math.ceil(width / 5) * Math.ceil(height / 4) * 16 * depth;

                  case Format.ASTC_RGBA_5X5:
                  case Format.ASTC_SRGBA_5X5:
                    return Math.ceil(width / 5) * Math.ceil(height / 5) * 16 * depth;

                  case Format.ASTC_RGBA_6X5:
                  case Format.ASTC_SRGBA_6X5:
                    return Math.ceil(width / 6) * Math.ceil(height / 5) * 16 * depth;

                  case Format.ASTC_RGBA_6X6:
                  case Format.ASTC_SRGBA_6X6:
                    return Math.ceil(width / 6) * Math.ceil(height / 6) * 16 * depth;

                  case Format.ASTC_RGBA_8X5:
                  case Format.ASTC_SRGBA_8X5:
                    return Math.ceil(width / 8) * Math.ceil(height / 5) * 16 * depth;

                  case Format.ASTC_RGBA_8X6:
                  case Format.ASTC_SRGBA_8X6:
                    return Math.ceil(width / 8) * Math.ceil(height / 6) * 16 * depth;

                  case Format.ASTC_RGBA_8X8:
                  case Format.ASTC_SRGBA_8X8:
                    return Math.ceil(width / 8) * Math.ceil(height / 8) * 16 * depth;

                  case Format.ASTC_RGBA_10X5:
                  case Format.ASTC_SRGBA_10X5:
                    return Math.ceil(width / 10) * Math.ceil(height / 5) * 16 * depth;

                  case Format.ASTC_RGBA_10X6:
                  case Format.ASTC_SRGBA_10X6:
                    return Math.ceil(width / 10) * Math.ceil(height / 6) * 16 * depth;

                  case Format.ASTC_RGBA_10X8:
                  case Format.ASTC_SRGBA_10X8:
                    return Math.ceil(width / 10) * Math.ceil(height / 8) * 16 * depth;

                  case Format.ASTC_RGBA_10X10:
                  case Format.ASTC_SRGBA_10X10:
                    return Math.ceil(width / 10) * Math.ceil(height / 10) * 16 * depth;

                  case Format.ASTC_RGBA_12X10:
                  case Format.ASTC_SRGBA_12X10:
                    return Math.ceil(width / 12) * Math.ceil(height / 10) * 16 * depth;

                  case Format.ASTC_RGBA_12X12:
                  case Format.ASTC_SRGBA_12X12:
                    return Math.ceil(width / 12) * Math.ceil(height / 12) * 16 * depth;

                  default:
                    {
                      return 0;
                    }
                }
              }
            }
            function FormatSurfaceSize(format, width, height, depth, mips) {
              let size = 0;

              for (let i = 0; i < mips; ++i) {
                size += FormatSize(format, width, height, depth);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
              }

              return size;
            }
            const _type2size = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];
            function GetTypeSize(type) {
              return _type2size[type] || 0;
            }
            function getTypedArrayConstructor(info) {
              const stride = info.size / info.count;

              switch (info.type) {
                case FormatType.UNORM:
                case FormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return Uint8Array;

                      case 2:
                        return Uint16Array;

                      case 4:
                        return Uint32Array;
                    }

                    break;
                  }

                case FormatType.SNORM:
                case FormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return Int8Array;

                      case 2:
                        return Int16Array;

                      case 4:
                        return Int32Array;
                    }

                    break;
                  }

                case FormatType.FLOAT:
                  {
                    return Float32Array;
                  }
              }

              return Float32Array;
            }

            var defines = /*#__PURE__*/Object.freeze({
                __proto__: null,
                get ObjectType () { return ObjectType; },
                get Status () { return Status; },
                get API () { return API; },
                get SurfaceTransform () { return SurfaceTransform; },
                get Feature () { return Feature$1; },
                get Format () { return Format; },
                get FormatType () { return FormatType; },
                get Type () { return Type; },
                get BufferUsageBit () { return BufferUsageBit; },
                get BufferFlagBit () { return BufferFlagBit; },
                get MemoryAccessBit () { return MemoryAccessBit; },
                get MemoryUsageBit () { return MemoryUsageBit; },
                get TextureType () { return TextureType; },
                get TextureUsageBit () { return TextureUsageBit; },
                get TextureFlagBit () { return TextureFlagBit; },
                get SampleCount () { return SampleCount; },
                get VsyncMode () { return VsyncMode; },
                get Filter () { return Filter; },
                get Address () { return Address; },
                get ComparisonFunc () { return ComparisonFunc; },
                get StencilOp () { return StencilOp; },
                get BlendFactor () { return BlendFactor; },
                get BlendOp () { return BlendOp; },
                get ColorMask () { return ColorMask; },
                get ShaderStageFlagBit () { return ShaderStageFlagBit; },
                get LoadOp () { return LoadOp; },
                get StoreOp () { return StoreOp; },
                get AccessType () { return AccessType; },
                get ResolveMode () { return ResolveMode; },
                get PipelineBindPoint () { return PipelineBindPoint; },
                get PrimitiveMode () { return PrimitiveMode; },
                get PolygonMode () { return PolygonMode; },
                get ShadeModel () { return ShadeModel; },
                get CullMode () { return CullMode; },
                get DynamicStateFlagBit () { return DynamicStateFlagBit; },
                get StencilFace () { return StencilFace; },
                get DescriptorType () { return DescriptorType; },
                get QueueType () { return QueueType; },
                get QueryType () { return QueryType; },
                get CommandBufferType () { return CommandBufferType; },
                get ClearFlagBit () { return ClearFlagBit; },
                Size: Size$1,
                DeviceCaps: DeviceCaps,
                Offset: Offset,
                Rect: Rect$1,
                Extent: Extent,
                TextureSubresLayers: TextureSubresLayers,
                TextureSubresRange: TextureSubresRange,
                TextureCopy: TextureCopy,
                TextureBlit: TextureBlit,
                BufferTextureCopy: BufferTextureCopy,
                Viewport: Viewport,
                Color: Color$1,
                BindingMappingInfo: BindingMappingInfo,
                SwapchainInfo: SwapchainInfo,
                DeviceInfo: DeviceInfo,
                BufferInfo: BufferInfo,
                BufferViewInfo: BufferViewInfo,
                DrawInfo: DrawInfo,
                DispatchInfo: DispatchInfo,
                IndirectBuffer: IndirectBuffer,
                TextureInfo: TextureInfo,
                TextureViewInfo: TextureViewInfo,
                SamplerInfo: SamplerInfo,
                Uniform: Uniform,
                UniformBlock: UniformBlock,
                UniformSamplerTexture: UniformSamplerTexture,
                UniformSampler: UniformSampler,
                UniformTexture: UniformTexture,
                UniformStorageImage: UniformStorageImage,
                UniformStorageBuffer: UniformStorageBuffer,
                UniformInputAttachment: UniformInputAttachment,
                ShaderStage: ShaderStage,
                Attribute: Attribute,
                ShaderInfo: ShaderInfo,
                InputAssemblerInfo: InputAssemblerInfo,
                ColorAttachment: ColorAttachment,
                DepthStencilAttachment: DepthStencilAttachment,
                SubpassInfo: SubpassInfo,
                SubpassDependency: SubpassDependency,
                RenderPassInfo: RenderPassInfo,
                GlobalBarrierInfo: GlobalBarrierInfo,
                TextureBarrierInfo: TextureBarrierInfo,
                FramebufferInfo: FramebufferInfo,
                DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
                DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
                DescriptorSetInfo: DescriptorSetInfo,
                PipelineLayoutInfo: PipelineLayoutInfo,
                InputState: InputState,
                CommandBufferInfo: CommandBufferInfo,
                QueueInfo: QueueInfo,
                QueryPoolInfo: QueryPoolInfo,
                FormatInfo: FormatInfo,
                MemoryStatus: MemoryStatus,
                DynamicStencilStates: DynamicStencilStates,
                DynamicStates: DynamicStates,
                GFXObject: GFXObject,
                get AttributeName () { return AttributeName; },
                FormatInfos: FormatInfos,
                DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
                DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
                DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
                DRAW_INFO_SIZE: DRAW_INFO_SIZE,
                IsPowerOf2: IsPowerOf2,
                FormatSize: FormatSize,
                FormatSurfaceSize: FormatSurfaceSize,
                GetTypeSize: GetTypeSize,
                getTypedArrayConstructor: getTypedArrayConstructor
            });

            class RasterizerState {
              constructor(isDiscard = false, polygonMode = PolygonMode.FILL, shadeModel = ShadeModel.GOURAND, cullMode = CullMode.BACK, isFrontFaceCCW = true, depthBiasEnabled = false, depthBias = 0, depthBiasClamp = 0.0, depthBiasSlop = 0.0, isDepthClip = true, isMultisample = false, lineWidth = 1.0) {
                this._nativeObj = void 0;
                this._isDiscard = false;
                this._polygonMode = PolygonMode.FILL;
                this._shadeModel = ShadeModel.GOURAND;
                this._cullMode = CullMode.BACK;
                this._isFrontFaceCCW = true;
                this._depthBiasEnabled = false;
                this._depthBias = 0;
                this._depthBiasClamp = 0.0;
                this._depthBiasSlop = 0.0;
                this._isDepthClip = true;
                this._isMultisample = false;
                this._lineWidth = 1.0;
                this._nativeObj = new gfx.RasterizerState();
                this.assignProperties(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth);
              }

              get native() {
                return this._nativeObj;
              }

              get isDiscard() {
                return this._isDiscard;
              }

              set isDiscard(val) {
                this._isDiscard = val;
                this._nativeObj.isDiscard = val;
              }

              get polygonMode() {
                return this._polygonMode;
              }

              set polygonMode(val) {
                this._polygonMode = val;
                this._nativeObj.polygonMode = val;
              }

              get shadeModel() {
                return this._shadeModel;
              }

              set shadeModel(val) {
                this._shadeModel = val;
                this._nativeObj.shadeModel = val;
              }

              get cullMode() {
                return this._cullMode;
              }

              set cullMode(val) {
                this._cullMode = val;
                this._nativeObj.cullMode = val;
              }

              get isFrontFaceCCW() {
                return this._isFrontFaceCCW;
              }

              set isFrontFaceCCW(val) {
                this._isFrontFaceCCW = val;
                this._nativeObj.isFrontFaceCCW = val;
              }

              get depthBiasEnabled() {
                return this._depthBiasEnabled;
              }

              set depthBiasEnabled(val) {
                this._depthBiasEnabled = val;
                this._nativeObj.depthBiasEnabled = val;
              }

              get depthBias() {
                return this._depthBias;
              }

              set depthBias(val) {
                this._depthBias = val;
                this._nativeObj.depthBias = val;
              }

              get depthBiasClamp() {
                return this._depthBiasClamp;
              }

              set depthBiasClamp(val) {
                this._depthBiasClamp = val;
                this._nativeObj.depthBiasClamp = val;
              }

              get depthBiasSlop() {
                return this._depthBiasSlop;
              }

              set depthBiasSlop(val) {
                this._depthBiasSlop = val;
                this._nativeObj.depthBiasSlop = val;
              }

              get isDepthClip() {
                return this._isDepthClip;
              }

              set isDepthClip(val) {
                this._isDepthClip = val;
                this._nativeObj.isDepthClip = val;
              }

              get isMultisample() {
                return this._isMultisample;
              }

              set isMultisample(val) {
                this._isMultisample = val;
                this._nativeObj.isMultisample = val;
              }

              get lineWidth() {
                return this._lineWidth;
              }

              set lineWidth(val) {
                this._lineWidth = val;
                this._nativeObj.lineWidth = val;
              }

              reset() {
                this.assignProperties(false, PolygonMode.FILL, ShadeModel.GOURAND, CullMode.BACK, true, false, 0, 0.0, 0.0, true, false, 1.0);
              }

              assign(rs) {
                if (!rs) return;
                this.assignProperties(rs.isDiscard, rs.polygonMode, rs.shadeModel, rs.cullMode, rs.isFrontFaceCCW, rs.depthBiasEnabled, rs.depthBias, rs.depthBiasClamp, rs.depthBiasSlop, rs.isDepthClip, rs.isMultisample, rs.lineWidth);
              }

              destroy() {
                this._nativeObj = null;
              }

              assignProperties(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth) {
                if (isDiscard !== undefined) this.isDiscard = isDiscard;
                if (polygonMode !== undefined) this.polygonMode = polygonMode;
                if (shadeModel !== undefined) this.shadeModel = shadeModel;
                if (cullMode !== undefined) this.cullMode = cullMode;
                if (isFrontFaceCCW !== undefined) this.isFrontFaceCCW = isFrontFaceCCW;
                if (depthBiasEnabled !== undefined) this.depthBiasEnabled = depthBiasEnabled;
                if (depthBias !== undefined) this.depthBias = depthBias;
                if (depthBiasClamp !== undefined) this.depthBiasClamp = depthBiasClamp;
                if (depthBiasSlop !== undefined) this.depthBiasSlop = depthBiasSlop;
                if (isDepthClip !== undefined) this.isDepthClip = isDepthClip;
                if (isMultisample !== undefined) this.isMultisample = isMultisample;
                if (lineWidth !== undefined) this.lineWidth = lineWidth;
              }

            }
            class DepthStencilState {
              constructor(depthTest = true, depthWrite = true, depthFunc = ComparisonFunc.LESS, stencilTestFront = false, stencilFuncFront = ComparisonFunc.ALWAYS, stencilReadMaskFront = 0xffff, stencilWriteMaskFront = 0xffff, stencilFailOpFront = StencilOp.KEEP, stencilZFailOpFront = StencilOp.KEEP, stencilPassOpFront = StencilOp.KEEP, stencilRefFront = 1, stencilTestBack = false, stencilFuncBack = ComparisonFunc.ALWAYS, stencilReadMaskBack = 0xffff, stencilWriteMaskBack = 0xffff, stencilFailOpBack = StencilOp.KEEP, stencilZFailOpBack = StencilOp.KEEP, stencilPassOpBack = StencilOp.KEEP, stencilRefBack = 1) {
                this._nativeObj = void 0;
                this._depthTest = true;
                this._depthWrite = true;
                this._depthFunc = ComparisonFunc.LESS;
                this._stencilTestFront = false;
                this._stencilFuncFront = ComparisonFunc.ALWAYS;
                this._stencilReadMaskFront = 0xffff;
                this._stencilWriteMaskFront = 0xffff;
                this._stencilFailOpFront = StencilOp.KEEP;
                this._stencilZFailOpFront = StencilOp.KEEP;
                this._stencilPassOpFront = StencilOp.KEEP;
                this._stencilRefFront = 1;
                this._stencilTestBack = false;
                this._stencilFuncBack = ComparisonFunc.ALWAYS;
                this._stencilReadMaskBack = 0xffff;
                this._stencilWriteMaskBack = 0xffff;
                this._stencilFailOpBack = StencilOp.KEEP;
                this._stencilZFailOpBack = StencilOp.KEEP;
                this._stencilPassOpBack = StencilOp.KEEP;
                this._stencilRefBack = 1;
                this._nativeObj = new gfx.DepthStencilState();
                this.assignProperties(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack);
              }

              get native() {
                return this._nativeObj;
              }

              get depthTest() {
                return this._depthTest;
              }

              set depthTest(val) {
                this._depthTest = val;
                this._nativeObj.depthTest = val;
              }

              get depthWrite() {
                return this._depthWrite;
              }

              set depthWrite(val) {
                this._depthWrite = val;
                this._nativeObj.depthWrite = val;
              }

              get depthFunc() {
                return this._depthFunc;
              }

              set depthFunc(val) {
                this._depthFunc = val;
                this._nativeObj.depthFunc = val;
              }

              get stencilTestFront() {
                return this._stencilTestFront;
              }

              set stencilTestFront(val) {
                this._stencilTestFront = val;
                this._nativeObj.stencilTestFront = val;
              }

              get stencilFuncFront() {
                return this._stencilFuncFront;
              }

              set stencilFuncFront(val) {
                this._stencilFuncFront = val;
                this._nativeObj.stencilFuncFront = val;
              }

              get stencilReadMaskFront() {
                return this._stencilReadMaskFront;
              }

              set stencilReadMaskFront(val) {
                this._stencilReadMaskFront = val;
                this._nativeObj.stencilReadMaskFront = val;
              }

              get stencilWriteMaskFront() {
                return this._stencilWriteMaskFront;
              }

              set stencilWriteMaskFront(val) {
                this._stencilWriteMaskFront = val;
                this._nativeObj.stencilWriteMaskFront = val;
              }

              get stencilFailOpFront() {
                return this._stencilFailOpFront;
              }

              set stencilFailOpFront(val) {
                this._stencilFailOpFront = val;
                this._nativeObj.stencilFailOpFront = val;
              }

              get stencilZFailOpFront() {
                return this._stencilZFailOpFront;
              }

              set stencilZFailOpFront(val) {
                this._stencilZFailOpFront = val;
                this._nativeObj.stencilZFailOpFront = val;
              }

              get stencilPassOpFront() {
                return this._stencilPassOpFront;
              }

              set stencilPassOpFront(val) {
                this._stencilPassOpFront = val;
                this._nativeObj.stencilPassOpFront = val;
              }

              get stencilRefFront() {
                return this._stencilRefFront;
              }

              set stencilRefFront(val) {
                this._stencilRefFront = val;
                this._nativeObj.stencilRefFront = val;
              }

              get stencilTestBack() {
                return this._stencilTestBack;
              }

              set stencilTestBack(val) {
                this._stencilTestBack = val;
                this._nativeObj.stencilTestBack = val;
              }

              get stencilFuncBack() {
                return this._stencilFuncBack;
              }

              set stencilFuncBack(val) {
                this._stencilFuncBack = val;
                this._nativeObj.stencilFuncBack = val;
              }

              get stencilReadMaskBack() {
                return this._stencilReadMaskBack;
              }

              set stencilReadMaskBack(val) {
                this._stencilReadMaskBack = val;
                this._nativeObj.stencilReadMaskBack = val;
              }

              get stencilWriteMaskBack() {
                return this._stencilWriteMaskBack;
              }

              set stencilWriteMaskBack(val) {
                this._stencilWriteMaskBack = val;
                this._nativeObj.stencilWriteMaskBack = val;
              }

              get stencilFailOpBack() {
                return this._stencilFailOpBack;
              }

              set stencilFailOpBack(val) {
                this._stencilFailOpBack = val;
                this._nativeObj.stencilFailOpBack = val;
              }

              get stencilZFailOpBack() {
                return this._stencilZFailOpBack;
              }

              set stencilZFailOpBack(val) {
                this._stencilZFailOpBack = val;
                this._nativeObj.stencilZFailOpBack = val;
              }

              get stencilPassOpBack() {
                return this._stencilPassOpBack;
              }

              set stencilPassOpBack(val) {
                this._stencilPassOpBack = val;
                this._nativeObj.stencilPassOpBack = val;
              }

              get stencilRefBack() {
                return this._stencilRefBack;
              }

              set stencilRefBack(val) {
                this._stencilRefBack = val;
                this._nativeObj.stencilRefBack = val;
              }

              reset() {
                this.assignProperties(true, true, ComparisonFunc.LESS, false, ComparisonFunc.ALWAYS, 0xffff, 0xffff, StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP, 1, false, ComparisonFunc.ALWAYS, 0xffff, 0xffff, StencilOp.KEEP, StencilOp.KEEP, StencilOp.KEEP, 1);
              }

              assign(dss) {
                if (!dss) return;
                this.assignProperties(dss.depthTest, dss.depthWrite, dss.depthFunc, dss.stencilTestFront, dss.stencilFuncFront, dss.stencilReadMaskFront, dss.stencilWriteMaskFront, dss.stencilFailOpFront, dss.stencilZFailOpFront, dss.stencilPassOpFront, dss.stencilRefFront, dss.stencilTestBack, dss.stencilFuncBack, dss.stencilReadMaskBack, dss.stencilWriteMaskBack, dss.stencilFailOpBack, dss.stencilZFailOpBack, dss.stencilPassOpBack, dss.stencilRefBack);
              }

              destroy() {
                this._nativeObj = null;
              }

              assignProperties(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack) {
                if (depthTest !== undefined) this.depthTest = depthTest;
                if (depthWrite !== undefined) this.depthWrite = depthWrite;
                if (depthFunc !== undefined) this.depthFunc = depthFunc;
                if (stencilTestFront !== undefined) this.stencilTestFront = stencilTestFront;
                if (stencilFuncFront !== undefined) this.stencilFuncFront = stencilFuncFront;
                if (stencilReadMaskFront !== undefined) this.stencilReadMaskFront = stencilReadMaskFront;
                if (stencilWriteMaskFront !== undefined) this.stencilWriteMaskFront = stencilWriteMaskFront;
                if (stencilFailOpFront !== undefined) this.stencilFailOpFront = stencilFailOpFront;
                if (stencilZFailOpFront !== undefined) this.stencilZFailOpFront = stencilZFailOpFront;
                if (stencilPassOpFront !== undefined) this.stencilPassOpFront = stencilPassOpFront;
                if (stencilRefFront !== undefined) this.stencilRefFront = stencilRefFront;
                if (stencilTestBack !== undefined) this.stencilTestBack = stencilTestBack;
                if (stencilFuncBack !== undefined) this.stencilFuncBack = stencilFuncBack;
                if (stencilReadMaskBack !== undefined) this.stencilReadMaskBack = stencilReadMaskBack;
                if (stencilWriteMaskBack !== undefined) this.stencilWriteMaskBack = stencilWriteMaskBack;
                if (stencilFailOpBack !== undefined) this.stencilFailOpBack = stencilFailOpBack;
                if (stencilZFailOpBack !== undefined) this.stencilZFailOpBack = stencilZFailOpBack;
                if (stencilPassOpBack !== undefined) this.stencilPassOpBack = stencilPassOpBack;
                if (stencilRefBack !== undefined) this.stencilRefBack = stencilRefBack;
              }

            }
            class BlendTarget {
              get native() {
                return this._nativeObj;
              }

              constructor(blend = false, blendSrc = BlendFactor.ONE, blendDst = BlendFactor.ZERO, blendEq = BlendOp.ADD, blendSrcAlpha = BlendFactor.ONE, blendDstAlpha = BlendFactor.ZERO, blendAlphaEq = BlendOp.ADD, blendColorMask = ColorMask.ALL) {
                this._nativeObj = void 0;
                this._blend = false;
                this._blendSrc = BlendFactor.ONE;
                this._blendDst = BlendFactor.ZERO;
                this._blendEq = BlendOp.ADD;
                this._blendSrcAlpha = BlendFactor.ONE;
                this._blendDstAlpha = BlendFactor.ZERO;
                this._blendAlphaEq = BlendOp.ADD;
                this._blendColorMask = ColorMask.ALL;
                this._nativeObj = new gfx.BlendTarget();
                this.assignProperties(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask);
              }

              get blend() {
                return this._blend;
              }

              set blend(val) {
                this._blend = val;
                this._nativeObj.blend = val;
              }

              get blendSrc() {
                return this._blendSrc;
              }

              set blendSrc(val) {
                this._blendSrc = val;
                this._nativeObj.blendSrc = val;
              }

              get blendDst() {
                return this._blendDst;
              }

              set blendDst(val) {
                this._blendDst = val;
                this._nativeObj.blendDst = val;
              }

              get blendEq() {
                return this._blendEq;
              }

              set blendEq(val) {
                this._blendEq = val;
                this._nativeObj.blendEq = val;
              }

              get blendSrcAlpha() {
                return this._blendSrcAlpha;
              }

              set blendSrcAlpha(val) {
                this._blendSrcAlpha = val;
                this._nativeObj.blendSrcAlpha = val;
              }

              get blendDstAlpha() {
                return this._blendDstAlpha;
              }

              set blendDstAlpha(val) {
                this._blendDstAlpha = val;
                this._nativeObj.blendDstAlpha = val;
              }

              get blendAlphaEq() {
                return this._blendAlphaEq;
              }

              set blendAlphaEq(val) {
                this._blendAlphaEq = val;
                this._nativeObj.blendAlphaEq = val;
              }

              get blendColorMask() {
                return this._blendColorMask;
              }

              set blendColorMask(val) {
                this._blendColorMask = val;
                this._nativeObj.blendColorMask = val;
              }

              reset() {
                this.assignProperties(false, BlendFactor.ONE, BlendFactor.ZERO, BlendOp.ADD, BlendFactor.ONE, BlendFactor.ZERO, BlendOp.ADD, ColorMask.ALL);
              }

              destroy() {
                this._nativeObj = null;
              }

              assign(target) {
                if (!target) return;
                this.assignProperties(target.blend, target.blendSrc, target.blendDst, target.blendEq, target.blendSrcAlpha, target.blendDstAlpha, target.blendAlphaEq, target.blendColorMask);
              }

              assignProperties(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask) {
                if (blend !== undefined) this.blend = blend;
                if (blendSrc !== undefined) this.blendSrc = blendSrc;
                if (blendDst !== undefined) this.blendDst = blendDst;
                if (blendEq !== undefined) this.blendEq = blendEq;
                if (blendSrcAlpha !== undefined) this.blendSrcAlpha = blendSrcAlpha;
                if (blendDstAlpha !== undefined) this.blendDstAlpha = blendDstAlpha;
                if (blendAlphaEq !== undefined) this.blendAlphaEq = blendAlphaEq;
                if (blendColorMask !== undefined) this.blendColorMask = blendColorMask;
              }

            }

            function watchArrayElementsField(self, list, eleField, cachedFieldName, callback) {
              for (let i = 0, l = list.length; i < l; i++) {
                let ele = list[i];
                let originField = ele[eleField][cachedFieldName] || ele[eleField];
                ele[eleField] = new Proxy(originField, {
                  get: (originTarget, key) => {
                    if (key === cachedFieldName) {
                      return originTarget;
                    }

                    return Reflect.get(originTarget, key);
                  },
                  set: (originTarget, prop, value) => {
                    Reflect.set(originTarget, prop, value);
                    callback(self, i, originTarget, prop, value);
                    return true;
                  }
                });
              }
            }

            class BlendState {
              _setTargets(targets) {
                this.targets = targets;
                const CACHED_FIELD_NAME = `$__nativeObj`;

                this._syncTargetsToNativeObj(CACHED_FIELD_NAME);

                watchArrayElementsField(this, this.targets, "_nativeObj", CACHED_FIELD_NAME, (self, _idx, _originTarget, _prop, _value) => {
                  self._syncTargetsToNativeObj(CACHED_FIELD_NAME);
                });
              }

              _syncTargetsToNativeObj(cachedFieldName) {
                const nativeTars = this.targets.map(target => {
                  return target.native[cachedFieldName] || target.native;
                });
                this._nativeObj.targets = nativeTars;
              }

              get native() {
                return this._nativeObj;
              }

              constructor(isA2C = false, isIndepend = false, blendColor = new Color$1(), targets = [new BlendTarget()]) {
                this.targets = void 0;
                this._blendColor = void 0;
                this._nativeObj = void 0;
                this._isA2C = false;
                this._isIndepend = false;
                this._nativeObj = new gfx.BlendState();

                this._setTargets(targets);

                this.blendColor = blendColor;
                this.isA2c = isA2C;
                this.isIndepend = isIndepend;
              }

              get isA2c() {
                return this._isA2C;
              }

              set isA2c(val) {
                this._isA2C = val;
                this._nativeObj.isA2C = val;
              }

              get isIndepend() {
                return this._isIndepend;
              }

              set isIndepend(val) {
                this._isIndepend = val;
                this._nativeObj.isIndepend = val;
              }

              get blendColor() {
                return this._blendColor;
              }

              set blendColor(color) {
                this._blendColor = color;
                this._nativeObj.blendColor = color;
              }

              setTarget(index, target) {
                let tg = this.targets[index];

                if (!tg) {
                  tg = this.targets[index] = new BlendTarget();
                }

                tg.assign(target);

                this._setTargets(this.targets);
              }

              reset() {
                this.isA2c = false;
                this.isIndepend = false;
                this.blendColor = new Color$1(0, 0, 0, 0);
                const targets = this.targets;

                for (let i = 1, len = targets.length; i < len; ++i) {
                  targets[i].destroy();
                }

                targets.length = 1;
                targets[0].reset();

                this._setTargets(targets);
              }

              destroy() {
                for (let i = 0, len = this.targets.length; i < len; ++i) {
                  this.targets[i].destroy();
                }

                this.targets = null;
                this._nativeObj = null;
              }

            }
            const PipelineState = gfx.PipelineState;
            const PipelineStateInfo = gfx.PipelineStateInfo;

            class Device {
              constructor() {
                this._gfxAPI = API.UNKNOWN;
                this._renderer = '';
                this._vendor = '';
                this._features = new Array(Feature$1.COUNT);
                this._queue = null;
                this._cmdBuff = null;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
                this._memoryStatus = new MemoryStatus();
                this._caps = new DeviceCaps();
                this._bindingMappingInfo = new BindingMappingInfo();
                this._samplers = new Map();
                this._globalBarriers = new Map();
                this._textureBarriers = new Map();
              }

              get gfxAPI() {
                return this._gfxAPI;
              }

              get queue() {
                return this._queue;
              }

              get commandBuffer() {
                return this._cmdBuff;
              }

              get renderer() {
                return this._renderer;
              }

              get vendor() {
                return this._vendor;
              }

              get numDrawCalls() {
                return this._numDrawCalls;
              }

              get numInstances() {
                return this._numInstances;
              }

              get numTris() {
                return this._numTris;
              }

              get memoryStatus() {
                return this._memoryStatus;
              }

              get capabilities() {
                return this._caps;
              }

              get bindingMappingInfo() {
                return this._bindingMappingInfo;
              }

              hasFeature(feature) {
                return this._features[feature];
              }

            } exports('aW', Device);
            Device.canvas = void 0;

            const getUint8ForString = String.prototype.charCodeAt;

            function getUint8ForArray(idx) {
              return this[idx];
            }

            function murmurhash2_32_gc(input, seed) {
              let l = input.length;
              let h = seed ^ l;
              let i = 0;
              const getUint8 = typeof input === 'string' ? getUint8ForString : getUint8ForArray;

              while (l >= 4) {
                let k = getUint8.call(input, i) & 0xff | (getUint8.call(input, ++i) & 0xff) << 8 | (getUint8.call(input, ++i) & 0xff) << 16 | (getUint8.call(input, ++i) & 0xff) << 24;
                k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                k ^= k >>> 24;
                k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
                l -= 4;
                ++i;
              }

              switch (l) {
                case 3:
                  h ^= (getUint8.call(input, i + 2) & 0xff) << 16;

                case 2:
                  h ^= (getUint8.call(input, i + 1) & 0xff) << 8;

                case 1:
                  h ^= getUint8.call(input, i) & 0xff;
                  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
              }

              h ^= h >>> 13;
              h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
              h ^= h >>> 15;
              return h >>> 0;
            }

            class Texture extends GFXObject {
              get type() {
                return this._type;
              }

              get usage() {
                return this._usage;
              }

              get format() {
                return this._format;
              }

              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              get depth() {
                return this._depth;
              }

              get layerCount() {
                return this._layerCount;
              }

              get levelCount() {
                return this._levelCount;
              }

              get samples() {
                return this._samples;
              }

              get flags() {
                return this._flags;
              }

              get size() {
                return this._size;
              }

              constructor() {
                super(ObjectType.TEXTURE);
                this._type = TextureType.TEX2D;
                this._usage = TextureUsageBit.NONE;
                this._format = Format.UNKNOWN;
                this._width = 0;
                this._height = 0;
                this._depth = 1;
                this._layerCount = 1;
                this._levelCount = 1;
                this._samples = SampleCount.ONE;
                this._flags = TextureFlagBit.NONE;
                this._isPowerOf2 = false;
                this._size = 0;
              }

            } exports('aX', Texture);

            class Sampler extends GFXObject {
              get info() {
                return this._info;
              }

              get hash() {
                return this._hash;
              }

              constructor(info, hash) {
                super(ObjectType.SAMPLER);
                this._info = new SamplerInfo();
                this._hash = 0;

                this._info.copy(info);

                this._hash = hash;
              }

              static computeHash(info) {
                let hash = info.minFilter;
                hash |= info.magFilter << 2;
                hash |= info.mipFilter << 4;
                hash |= info.addressU << 6;
                hash |= info.addressV << 8;
                hash |= info.addressW << 10;
                hash |= info.maxAnisotropy << 12;
                hash |= info.cmpFunc << 16;
                return hash;
              }

              static unpackFromHash(hash) {
                const info = new SamplerInfo();
                info.minFilter = (hash & (1 << 2) - 1) >> 0;
                info.magFilter = (hash & (1 << 2) - 1) >> 2;
                info.mipFilter = (hash & (1 << 2) - 1) >> 4;
                info.addressU = (hash & (1 << 2) - 1) >> 6;
                info.addressV = (hash & (1 << 2) - 1) >> 8;
                info.addressW = (hash & (1 << 2) - 1) >> 10;
                info.maxAnisotropy = (hash & (1 << 4) - 1) >> 12;
                info.cmpFunc = (hash & (1 << 3) - 1) >> 16;
                return info;
              }

            } exports('aY', Sampler);

            const customMappings = {
              Obj: 'GFXObject',
              DRAW_INFO_SIZE: 'GFX_DRAW_INFO_SIZE',
              DESCRIPTOR_BUFFER_TYPE: '',
              DESCRIPTOR_SAMPLER_TYPE: '',
              DESCRIPTOR_DYNAMIC_TYPE: '',
              getTypedArrayConstructor: ''
            };

            for (const api in legacyCC.gfx) {
              if (api === '__esModule') continue;
              let deprecated = customMappings[api];

              if (deprecated === '') {
                deprecated = api;
              } else if (deprecated === undefined) {
                deprecated = `GFX${api}`;
              }

              replaceProperty(legacyCC, 'cc', [{
                name: deprecated,
                newName: api,
                target: legacyCC.gfx,
                targetName: 'cc.gfx'
              }]);
            }

            const polyfillCC = Object.assign({}, defines);
            polyfillCC.Device = gfx.Device;
            polyfillCC.Swapchain = gfx.Swapchain;
            polyfillCC.Buffer = gfx.Buffer;
            polyfillCC.Texture = gfx.Texture;
            polyfillCC.Sampler = gfx.Sampler;
            polyfillCC.Shader = gfx.Shader;
            polyfillCC.InputAssembler = gfx.InputAssembler;
            polyfillCC.RenderPass = gfx.RenderPass;
            polyfillCC.Framebuffer = gfx.Framebuffer;
            polyfillCC.DescriptorSet = gfx.DescriptorSet;
            polyfillCC.DescriptorSetLayout = gfx.DescriptorSetLayout;
            polyfillCC.PipelineLayout = gfx.PipelineLayout;
            polyfillCC.PipelineState = gfx.PipelineState;
            polyfillCC.CommandBuffer = gfx.CommandBuffer;
            polyfillCC.Queue = gfx.Queue;
            legacyCC.gfx = polyfillCC;
            const BlendTarget$1 = exports('aZ', BlendTarget);
            const BlendState$1 = exports('a_', BlendState);
            const RasterizerState$1 = exports('a$', RasterizerState);
            const DepthStencilState$1 = exports('b0', DepthStencilState);
            const PipelineState$1 = exports('b1', PipelineState);
            const PipelineStateInfo$1 = exports('b2', PipelineStateInfo);
            polyfillCC.BlendTarget = BlendTarget;
            polyfillCC.BlendState = BlendState;
            polyfillCC.RasterizerState = RasterizerState;
            polyfillCC.DepthStencilState = DepthStencilState;
            polyfillCC.PipelineStateInfo = PipelineStateInfo;

            let ERaycastMode;

            (function (ERaycastMode) {
              ERaycastMode[ERaycastMode["ALL"] = 0] = "ALL";
              ERaycastMode[ERaycastMode["CLOSEST"] = 1] = "CLOSEST";
              ERaycastMode[ERaycastMode["ANY"] = 2] = "ANY";
            })(ERaycastMode || (ERaycastMode = {}));

            const rayPlane = function () {
              const pt = new Vec3(0, 0, 0);
              return function (ray, plane) {
                const denom = Vec3.dot(ray.d, plane.n);

                if (Math.abs(denom) < Number.EPSILON) {
                  return 0;
                }

                Vec3.multiplyScalar(pt, plane.n, plane.d);
                const t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;

                if (t < 0) {
                  return 0;
                }

                return t;
              };
            }();

            const rayTriangle = function () {
              const ab = new Vec3(0, 0, 0);
              const ac = new Vec3(0, 0, 0);
              const pvec = new Vec3(0, 0, 0);
              const tvec = new Vec3(0, 0, 0);
              const qvec = new Vec3(0, 0, 0);
              return function (ray, triangle, doubleSided) {
                Vec3.subtract(ab, triangle.b, triangle.a);
                Vec3.subtract(ac, triangle.c, triangle.a);
                Vec3.cross(pvec, ray.d, ac);
                const det = Vec3.dot(ab, pvec);

                if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) {
                  return 0;
                }

                const inv_det = 1 / det;
                Vec3.subtract(tvec, ray.o, triangle.a);
                const u = Vec3.dot(tvec, pvec) * inv_det;

                if (u < 0 || u > 1) {
                  return 0;
                }

                Vec3.cross(qvec, tvec, ab);
                const v = Vec3.dot(ray.d, qvec) * inv_det;

                if (v < 0 || u + v > 1) {
                  return 0;
                }

                const t = Vec3.dot(ac, qvec) * inv_det;
                return t < 0 ? 0 : t;
              };
            }();

            const raySphere = function () {
              const e = new Vec3(0, 0, 0);
              return function (ray, sphere) {
                const r = sphere.radius;
                const c = sphere.center;
                const o = ray.o;
                const d = ray.d;
                const rSq = r * r;
                Vec3.subtract(e, c, o);
                const eSq = e.lengthSqr();
                const aLength = Vec3.dot(e, d);
                const fSq = rSq - (eSq - aLength * aLength);

                if (fSq < 0) {
                  return 0;
                }

                const f = Math.sqrt(fSq);
                const t = eSq < rSq ? aLength + f : aLength - f;

                if (t < 0) {
                  return 0;
                }

                return t;
              };
            }();

            const rayAABB = function () {
              const min = new Vec3();
              const max = new Vec3();
              return function (ray, aabb) {
                Vec3.subtract(min, aabb.center, aabb.halfExtents);
                Vec3.add(max, aabb.center, aabb.halfExtents);
                return rayAABB2(ray, min, max);
              };
            }();

            function rayAABB2(ray, min, max) {
              const o = ray.o;
              const d = ray.d;
              const ix = 1 / d.x;
              const iy = 1 / d.y;
              const iz = 1 / d.z;
              const t1 = (min.x - o.x) * ix;
              const t2 = (max.x - o.x) * ix;
              const t3 = (min.y - o.y) * iy;
              const t4 = (max.y - o.y) * iy;
              const t5 = (min.z - o.z) * iz;
              const t6 = (max.z - o.z) * iz;
              const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
              const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

              if (tmax < 0 || tmin > tmax) {
                return 0;
              }

              return tmin > 0 ? tmin : tmax;
            }

            const rayOBB = function () {
              let center = new Vec3();
              let o = new Vec3();
              let d = new Vec3();
              const X = new Vec3();
              const Y = new Vec3();
              const Z = new Vec3();
              const p = new Vec3();
              const size = new Array(3);
              const f = new Array(3);
              const e = new Array(3);
              const t = new Array(6);
              return function (ray, obb) {
                size[0] = obb.halfExtents.x;
                size[1] = obb.halfExtents.y;
                size[2] = obb.halfExtents.z;
                center = obb.center;
                o = ray.o;
                d = ray.d;
                Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
                Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
                Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
                Vec3.subtract(p, center, o);
                f[0] = Vec3.dot(X, d);
                f[1] = Vec3.dot(Y, d);
                f[2] = Vec3.dot(Z, d);
                e[0] = Vec3.dot(X, p);
                e[1] = Vec3.dot(Y, p);
                e[2] = Vec3.dot(Z, p);

                for (let i = 0; i < 3; ++i) {
                  if (f[i] === 0) {
                    if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
                      return 0;
                    }

                    f[i] = 0.0000001;
                  }

                  t[i * 2 + 0] = (e[i] + size[i]) / f[i];
                  t[i * 2 + 1] = (e[i] - size[i]) / f[i];
                }

                const tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5]));
                const tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));

                if (tmax < 0 || tmin > tmax) {
                  return 0;
                }

                return tmin > 0 ? tmin : tmax;
              };
            }();

            const rayCapsule = function () {
              const v3_0 = new Vec3();
              const v3_1 = new Vec3();
              const v3_2 = new Vec3();
              const v3_3 = new Vec3();
              const v3_4 = new Vec3();
              const v3_5 = new Vec3();
              const v3_6 = new Vec3();
              const sphere_0 = new Sphere();
              return function (ray, capsule) {
                const radiusSqr = capsule.radius * capsule.radius;
                const vRayNorm = Vec3.normalize(v3_0, ray.d);
                const A = capsule.ellipseCenter0;
                const B = capsule.ellipseCenter1;
                const BA = Vec3.subtract(v3_1, B, A);

                if (BA.equals(Vec3.ZERO)) {
                  sphere_0.radius = capsule.radius;
                  sphere_0.center.set(capsule.ellipseCenter0);
                  return intersect.raySphere(ray, sphere_0);
                }

                const O = ray.o;
                const OA = Vec3.subtract(v3_2, O, A);
                const VxBA = Vec3.cross(v3_3, vRayNorm, BA);
                const a = VxBA.lengthSqr();

                if (a === 0) {
                  sphere_0.radius = capsule.radius;
                  const BO = Vec3.subtract(v3_4, B, O);

                  if (OA.lengthSqr() < BO.lengthSqr()) {
                    sphere_0.center.set(capsule.ellipseCenter0);
                  } else {
                    sphere_0.center.set(capsule.ellipseCenter1);
                  }

                  return intersect.raySphere(ray, sphere_0);
                }

                const OAxBA = Vec3.cross(v3_4, OA, BA);
                const ab2 = BA.lengthSqr();
                const b = 2 * Vec3.dot(VxBA, OAxBA);
                const c = OAxBA.lengthSqr() - radiusSqr * ab2;
                const d = b * b - 4 * a * c;

                if (d < 0) {
                  return 0;
                }

                const t = (-b - Math.sqrt(d)) / (2 * a);

                if (t < 0) {
                  sphere_0.radius = capsule.radius;
                  const BO = Vec3.subtract(v3_5, B, O);

                  if (OA.lengthSqr() < BO.lengthSqr()) {
                    sphere_0.center.set(capsule.ellipseCenter0);
                  } else {
                    sphere_0.center.set(capsule.ellipseCenter1);
                  }

                  return intersect.raySphere(ray, sphere_0);
                } else {
                  const iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t);
                  const iPosLen = Vec3.subtract(v3_6, iPos, A);
                  const tLimit = Vec3.dot(iPosLen, BA) / ab2;

                  if (tLimit >= 0 && tLimit <= 1) {
                    return t;
                  } else if (tLimit < 0) {
                    sphere_0.radius = capsule.radius;
                    sphere_0.center.set(capsule.ellipseCenter0);
                    return intersect.raySphere(ray, sphere_0);
                  } else if (tLimit > 1) {
                    sphere_0.radius = capsule.radius;
                    sphere_0.center.set(capsule.ellipseCenter1);
                    return intersect.raySphere(ray, sphere_0);
                  } else {
                    return 0;
                  }
                }
              };
            }();

            const raySubMesh = function () {
              const tri = Triangle.create();
              const deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              let minDis = 0;

              const fillResult = (m, d, i0, i1, i2, r) => {
                if (m === ERaycastMode.CLOSEST) {
                  if (minDis > d || minDis === 0) {
                    minDis = d;

                    if (r) {
                      if (r.length === 0) {
                        r.push({
                          distance: d,
                          vertexIndex0: i0 / 3,
                          vertexIndex1: i1 / 3,
                          vertexIndex2: i2 / 3
                        });
                      } else {
                        r[0].distance = d;
                        r[0].vertexIndex0 = i0 / 3;
                        r[0].vertexIndex1 = i1 / 3;
                        r[0].vertexIndex2 = i2 / 3;
                      }
                    }
                  }
                } else {
                  minDis = d;
                  if (r) r.push({
                    distance: d,
                    vertexIndex0: i0 / 3,
                    vertexIndex1: i1 / 3,
                    vertexIndex2: i2 / 3
                  });
                }
              };

              const narrowphase = (vb, ib, pm, ray, opt) => {
                if (pm === PrimitiveMode.TRIANGLE_LIST) {
                  const cnt = ib.length;

                  for (let j = 0; j < cnt; j += 3) {
                    const i0 = ib[j] * 3;
                    const i1 = ib[j + 1] * 3;
                    const i2 = ib[j + 2] * 3;
                    Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return dist;
                  }
                } else if (pm === PrimitiveMode.TRIANGLE_STRIP) {
                  const cnt = ib.length - 2;
                  let rev = 0;

                  for (let j = 0; j < cnt; j += 1) {
                    const i0 = ib[j - rev] * 3;
                    const i1 = ib[j + rev + 1] * 3;
                    const i2 = ib[j + 2] * 3;
                    Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    rev = ~rev;
                    const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return dist;
                  }
                } else if (pm === PrimitiveMode.TRIANGLE_FAN) {
                  const cnt = ib.length - 1;
                  const i0 = ib[0] * 3;
                  Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);

                  for (let j = 1; j < cnt; j += 1) {
                    const i1 = ib[j] * 3;
                    const i2 = ib[j + 1] * 3;
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    const dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return dist;
                  }
                }

                return minDis;
              };

              return function (ray, submesh, options) {
                minDis = 0;
                if (submesh.geometricInfo.positions.length === 0) return minDis;
                const opt = options === undefined ? deOpt : options;
                const min = submesh.geometricInfo.boundingBox.min;
                const max = submesh.geometricInfo.boundingBox.max;

                if (rayAABB2(ray, min, max)) {
                  const pm = submesh.primitiveMode;
                  const {
                    positions: vb,
                    indices: ib
                  } = submesh.geometricInfo;
                  narrowphase(vb, ib, pm, ray, opt);
                }

                return minDis;
              };
            }();

            const rayMesh = function () {
              let minDis = 0;
              const deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              return function (ray, mesh, options) {
                minDis = 0;
                const opt = options === undefined ? deOpt : options;
                const length = mesh.renderingSubMeshes.length;
                const min = mesh.struct.minPosition;
                const max = mesh.struct.maxPosition;
                if (min && max && !rayAABB2(ray, min, max)) return minDis;

                for (let i = 0; i < length; i++) {
                  const sm = mesh.renderingSubMeshes[i];
                  const dis = raySubMesh(ray, sm, opt);

                  if (dis) {
                    if (opt.mode === ERaycastMode.CLOSEST) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);

                      if (opt.mode === ERaycastMode.ANY) {
                        return dis;
                      }
                    }
                  }
                }

                if (minDis && opt.mode === ERaycastMode.CLOSEST) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }

                  if (opt.subIndices) opt.subIndices.length = 1;
                }

                return minDis;
              };
            }();

            const rayModel = function () {
              let minDis = 0;
              const deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              const modelRay = new Ray();
              const m4 = new Mat4();
              return function (r, model, options) {
                minDis = 0;
                const opt = options === undefined ? deOpt : options;
                const wb = model.worldBounds;
                if (wb && !rayAABB(r, wb)) return minDis;
                Ray.copy(modelRay, r);

                if (model.node) {
                  Mat4.invert(m4, model.node.getWorldMatrix(m4));
                  Vec3.transformMat4(modelRay.o, r.o, m4);
                  Vec3.transformMat4Normal(modelRay.d, r.d, m4);
                }

                const subModels = model.subModels;

                for (let i = 0; i < subModels.length; i++) {
                  const subMesh = subModels[i].subMesh;
                  const dis = raySubMesh(modelRay, subMesh, opt);

                  if (dis) {
                    if (opt.mode === ERaycastMode.CLOSEST) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);

                      if (opt.mode === ERaycastMode.ANY) {
                        return dis;
                      }
                    }
                  }
                }

                if (minDis && opt.mode === ERaycastMode.CLOSEST) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }

                  if (opt.subIndices) opt.subIndices.length = 1;
                }

                return minDis;
              };
            }();

            const linePlane = function () {
              const ab = new Vec3(0, 0, 0);
              return function (line, plane) {
                Vec3.subtract(ab, line.e, line.s);
                const t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);

                if (t < 0 || t > 1) {
                  return 0;
                }

                return t;
              };
            }();

            const lineTriangle = function () {
              const ab = new Vec3(0, 0, 0);
              const ac = new Vec3(0, 0, 0);
              const qp = new Vec3(0, 0, 0);
              const ap = new Vec3(0, 0, 0);
              const n = new Vec3(0, 0, 0);
              const e = new Vec3(0, 0, 0);
              return function (line, triangle, outPt) {
                Vec3.subtract(ab, triangle.b, triangle.a);
                Vec3.subtract(ac, triangle.c, triangle.a);
                Vec3.subtract(qp, line.s, line.e);
                Vec3.cross(n, ab, ac);
                const det = Vec3.dot(qp, n);

                if (det <= 0.0) {
                  return 0;
                }

                Vec3.subtract(ap, line.s, triangle.a);
                const t = Vec3.dot(ap, n);

                if (t < 0 || t > det) {
                  return 0;
                }

                Vec3.cross(e, qp, ap);
                let v = Vec3.dot(ac, e);

                if (v < 0 || v > det) {
                  return 0;
                }

                let w = -Vec3.dot(ab, e);

                if (w < 0.0 || v + w > det) {
                  return 0;
                }

                if (outPt) {
                  const invDet = 1.0 / det;
                  v *= invDet;
                  w *= invDet;
                  const u = 1.0 - v - w;
                  Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
                }

                return 1;
              };
            }();

            const r_t = new Ray();

            function lineAABB(line, aabb) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              const min = rayAABB(r_t, aabb);
              const len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }

            function lineOBB(line, obb) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              const min = rayOBB(r_t, obb);
              const len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }

            function lineSphere(line, sphere) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              const min = raySphere(r_t, sphere);
              const len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }

            const aabbWithAABB = function () {
              const aMin = new Vec3();
              const aMax = new Vec3();
              const bMin = new Vec3();
              const bMax = new Vec3();
              return function (aabb1, aabb2) {
                Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
                Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
                Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
                Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
                return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
              };
            }();

            function getAABBVertices(min, max, out) {
              Vec3.set(out[0], min.x, max.y, max.z);
              Vec3.set(out[1], min.x, max.y, min.z);
              Vec3.set(out[2], min.x, min.y, max.z);
              Vec3.set(out[3], min.x, min.y, min.z);
              Vec3.set(out[4], max.x, max.y, max.z);
              Vec3.set(out[5], max.x, max.y, min.z);
              Vec3.set(out[6], max.x, min.y, max.z);
              Vec3.set(out[7], max.x, min.y, min.z);
            }

            function getOBBVertices(c, e, a1, a2, a3, out) {
              Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
              Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
              Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
              Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
              Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
              Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
              Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
              Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
            }

            function getInterval(vertices, axis) {
              let min = Vec3.dot(axis, vertices[0]);
              let max = min;

              for (let i = 1; i < 8; ++i) {
                const projection = Vec3.dot(axis, vertices[i]);
                min = projection < min ? projection : min;
                max = projection > max ? projection : max;
              }

              return [min, max];
            }

            const aabbWithOBB = function () {
              const test = new Array(15);

              for (let i = 0; i < 15; i++) {
                test[i] = new Vec3(0, 0, 0);
              }

              const vertices = new Array(8);
              const vertices2 = new Array(8);

              for (let i = 0; i < 8; i++) {
                vertices[i] = new Vec3(0, 0, 0);
                vertices2[i] = new Vec3(0, 0, 0);
              }

              const min = new Vec3();
              const max = new Vec3();
              return function (aabb, obb) {
                Vec3.set(test[0], 1, 0, 0);
                Vec3.set(test[1], 0, 1, 0);
                Vec3.set(test[2], 0, 0, 1);
                Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
                Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
                Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

                for (let i = 0; i < 3; ++i) {
                  Vec3.cross(test[6 + i * 3 + 0], test[i], test[3]);
                  Vec3.cross(test[6 + i * 3 + 1], test[i], test[4]);
                  Vec3.cross(test[6 + i * 3 + 1], test[i], test[5]);
                }

                Vec3.subtract(min, aabb.center, aabb.halfExtents);
                Vec3.add(max, aabb.center, aabb.halfExtents);
                getAABBVertices(min, max, vertices);
                getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);

                for (let j = 0; j < 15; ++j) {
                  const a = getInterval(vertices, test[j]);
                  const b = getInterval(vertices2, test[j]);

                  if (b[0] > a[1] || a[0] > b[1]) {
                    return 0;
                  }
                }

                return 1;
              };
            }();

            const aabbPlane = function (aabb, plane) {
              const r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z);
              const dot = Vec3.dot(plane.n, aabb.center);

              if (dot + r < plane.d) {
                return -1;
              } else if (dot - r > plane.d) {
                return 0;
              }

              return 1;
            };

            const aabbFrustum = function (aabb, frustum) {
              for (let i = 0; i < frustum.planes.length; i++) {
                if (aabbPlane(aabb, frustum.planes[i]) === -1) {
                  return 0;
                }
              }

              return 1;
            };

            const aabbFrustumAccurate = function () {
              const tmp = new Array(8);
              let out1 = 0;
              let out2 = 0;

              for (let i = 0; i < tmp.length; i++) {
                tmp[i] = new Vec3(0, 0, 0);
              }

              return function (aabb, frustum) {
                let result = 0;
                let intersects = false;

                for (let i = 0; i < frustum.planes.length; i++) {
                  result = aabbPlane(aabb, frustum.planes[i]);
                  if (result === -1) return 0;else if (result === 1) {
                      intersects = true;
                    }
                }

                if (!intersects) {
                  return 1;
                }

                for (let i = 0; i < frustum.vertices.length; i++) {
                  Vec3.subtract(tmp[i], frustum.vertices[i], aabb.center);
                }

                out1 = 0, out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  if (tmp[i].x > aabb.halfExtents.x) {
                    out1++;
                  } else if (tmp[i].x < -aabb.halfExtents.x) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  if (tmp[i].y > aabb.halfExtents.y) {
                    out1++;
                  } else if (tmp[i].y < -aabb.halfExtents.y) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  if (tmp[i].z > aabb.halfExtents.z) {
                    out1++;
                  } else if (tmp[i].z < -aabb.halfExtents.z) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                return 1;
              };
            }();

            const obbPoint = function () {
              const tmp = new Vec3(0, 0, 0);
              const m3 = new Mat3();

              const lessThan = function (a, b) {
                return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
              };

              return function (obb, point) {
                Vec3.subtract(tmp, point, obb.center);
                Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation));
                return lessThan(tmp, obb.halfExtents);
              };
            }();

            const obbPlane = function () {
              const absDot = function (n, x, y, z) {
                return Math.abs(n.x * x + n.y * y + n.z * z);
              };

              return function (obb, plane) {
                const r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
                const dot = Vec3.dot(plane.n, obb.center);

                if (dot + r < plane.d) {
                  return -1;
                } else if (dot - r > plane.d) {
                  return 0;
                }

                return 1;
              };
            }();

            const obbFrustum = function (obb, frustum) {
              for (let i = 0; i < frustum.planes.length; i++) {
                if (obbPlane(obb, frustum.planes[i]) === -1) {
                  return 0;
                }
              }

              return 1;
            };

            const obbFrustumAccurate = function () {
              const tmp = new Array(8);
              let dist = 0;
              let out1 = 0;
              let out2 = 0;

              for (let i = 0; i < tmp.length; i++) {
                tmp[i] = new Vec3(0, 0, 0);
              }

              const dot = function (n, x, y, z) {
                return n.x * x + n.y * y + n.z * z;
              };

              return function (obb, frustum) {
                let result = 0;
                let intersects = false;

                for (let i = 0; i < frustum.planes.length; i++) {
                  result = obbPlane(obb, frustum.planes[i]);
                  if (result === -1) return 0;else if (result === 1) {
                      intersects = true;
                    }
                }

                if (!intersects) {
                  return 1;
                }

                for (let i = 0; i < frustum.vertices.length; i++) {
                  Vec3.subtract(tmp[i], frustum.vertices[i], obb.center);
                }

                out1 = 0, out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  dist = dot(tmp[i], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);

                  if (dist > obb.halfExtents.x) {
                    out1++;
                  } else if (dist < -obb.halfExtents.x) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  dist = dot(tmp[i], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);

                  if (dist > obb.halfExtents.y) {
                    out1++;
                  } else if (dist < -obb.halfExtents.y) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (let i = 0; i < frustum.vertices.length; i++) {
                  dist = dot(tmp[i], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

                  if (dist > obb.halfExtents.z) {
                    out1++;
                  } else if (dist < -obb.halfExtents.z) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                return 1;
              };
            }();

            const obbWithOBB = function () {
              const test = new Array(15);

              for (let i = 0; i < 15; i++) {
                test[i] = new Vec3(0, 0, 0);
              }

              const vertices = new Array(8);
              const vertices2 = new Array(8);

              for (let i = 0; i < 8; i++) {
                vertices[i] = new Vec3(0, 0, 0);
                vertices2[i] = new Vec3(0, 0, 0);
              }

              return function (obb1, obb2) {
                Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02);
                Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05);
                Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08);
                Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02);
                Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05);
                Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);

                for (let i = 0; i < 3; ++i) {
                  Vec3.cross(test[6 + i * 3 + 0], test[i], test[3]);
                  Vec3.cross(test[6 + i * 3 + 1], test[i], test[4]);
                  Vec3.cross(test[6 + i * 3 + 2], test[i], test[5]);
                }

                getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
                getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);

                for (let i = 0; i < 15; ++i) {
                  const a = getInterval(vertices, test[i]);
                  const b = getInterval(vertices2, test[i]);

                  if (b[0] > a[1] || a[0] > b[1]) {
                    return 0;
                  }
                }

                return 1;
              };
            }();

            const obbCapsule = function () {
              const sphere_0 = new Sphere();
              const v3_0 = new Vec3();
              const v3_1 = new Vec3();
              const v3_2 = new Vec3();
              const v3_verts8 = new Array(8);

              for (let i = 0; i < 8; i++) {
                v3_verts8[i] = new Vec3();
              }

              const v3_axis8 = new Array(8);

              for (let i = 0; i < 8; i++) {
                v3_axis8[i] = new Vec3();
              }

              return function (obb, capsule) {
                const h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

                if (h === 0) {
                  sphere_0.radius = capsule.radius;
                  sphere_0.center.set(capsule.ellipseCenter0);
                  return intersect.sphereOBB(sphere_0, obb);
                } else {
                  v3_0.x = obb.orientation.m00;
                  v3_0.y = obb.orientation.m01;
                  v3_0.z = obb.orientation.m02;
                  v3_1.x = obb.orientation.m03;
                  v3_1.y = obb.orientation.m04;
                  v3_1.z = obb.orientation.m05;
                  v3_2.x = obb.orientation.m06;
                  v3_2.y = obb.orientation.m07;
                  v3_2.z = obb.orientation.m08;
                  getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
                  const axes = v3_axis8;
                  const a0 = Vec3.copy(axes[0], v3_0);
                  const a1 = Vec3.copy(axes[1], v3_1);
                  const a2 = Vec3.copy(axes[2], v3_2);
                  const C = Vec3.subtract(axes[3], capsule.center, obb.center);
                  C.normalize();
                  const B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
                  B.normalize();
                  Vec3.cross(axes[5], a0, B);
                  Vec3.cross(axes[6], a1, B);
                  Vec3.cross(axes[7], a2, B);

                  for (let i = 0; i < 8; ++i) {
                    const a = getInterval(v3_verts8, axes[i]);
                    const d0 = Vec3.dot(axes[i], capsule.ellipseCenter0);
                    const d1 = Vec3.dot(axes[i], capsule.ellipseCenter1);
                    const max_d = Math.max(d0, d1);
                    const min_d = Math.min(d0, d1);
                    const d_min = min_d - capsule.radius;
                    const d_max = max_d + capsule.radius;

                    if (d_min > a[1] || a[0] > d_max) {
                      return 0;
                    }
                  }

                  return 1;
                }
              };
            }();

            const spherePlane = function (sphere, plane) {
              const dot = Vec3.dot(plane.n, sphere.center);
              const r = sphere.radius * plane.n.length();

              if (dot + r < plane.d) {
                return -1;
              } else if (dot - r > plane.d) {
                return 0;
              }

              return 1;
            };

            const sphereFrustum = function (sphere, frustum) {
              for (let i = 0; i < frustum.planes.length; i++) {
                if (spherePlane(sphere, frustum.planes[i]) === -1) {
                  return 0;
                }
              }

              return 1;
            };

            const sphereFrustumAccurate = function () {
              const pt = new Vec3(0, 0, 0);
              const map = [1, -1, 1, -1, 1, -1];
              return function (sphere, frustum) {
                for (let i = 0; i < 6; i++) {
                  const plane = frustum.planes[i];
                  const r = sphere.radius;
                  const c = sphere.center;
                  const n = plane.n;
                  const d = plane.d;
                  const dot = Vec3.dot(n, c);
                  if (dot + r < d) return 0;else if (dot - r > d) {
                      continue;
                    }
                  Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));

                  for (let j = 0; j < 6; j++) {
                    if (j === i || j === i + map[i]) {
                      continue;
                    }

                    const test = frustum.planes[j];

                    if (Vec3.dot(test.n, pt) < test.d) {
                      return 0;
                    }
                  }
                }

                return 1;
              };
            }();

            const sphereWithSphere = function (sphere0, sphere1) {
              const r = sphere0.radius + sphere1.radius;
              return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
            };

            const sphereAABB = function () {
              const pt = new Vec3();
              return function (sphere, aabb) {
                pt_point_aabb(pt, sphere.center, aabb);
                return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
              };
            }();

            const sphereOBB = function () {
              const pt = new Vec3();
              return function (sphere, obb) {
                pt_point_obb(pt, sphere.center, obb);
                return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
              };
            }();

            const sphereCapsule = function () {
              const v3_0 = new Vec3();
              const v3_1 = new Vec3();
              return function (sphere, capsule) {
                const r = sphere.radius + capsule.radius;
                const squaredR = r * r;
                const h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

                if (h === 0) {
                  return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
                } else {
                  Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0);
                  Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
                  const t = Vec3.dot(v3_0, v3_1) / h;

                  if (t < 0) {
                    return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR;
                  } else if (t > 1) {
                    return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR;
                  } else {
                    Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t);
                    return Vec3.squaredDistance(sphere.center, v3_0) < squaredR;
                  }
                }
              };
            }();

            const capsuleWithCapsule = function () {
              const v3_0 = new Vec3();
              const v3_1 = new Vec3();
              const v3_2 = new Vec3();
              const v3_3 = new Vec3();
              const v3_4 = new Vec3();
              const v3_5 = new Vec3();
              return function capsuleWithCapsule(capsuleA, capsuleB) {
                const u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0);
                const v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0);
                const w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0);
                const a = Vec3.dot(u, u);
                const b = Vec3.dot(u, v);
                const c = Vec3.dot(v, v);
                const d = Vec3.dot(u, w);
                const e = Vec3.dot(v, w);
                const D = a * c - b * b;
                let sN;
                let sD = D;
                let tN;
                let tD = D;

                if (D < EPSILON) {
                  sN = 0.0;
                  sD = 1.0;
                  tN = e;
                  tD = c;
                } else {
                  sN = b * e - c * d;
                  tN = a * e - b * d;

                  if (sN < 0.0) {
                    sN = 0.0;
                    tN = e;
                    tD = c;
                  } else if (sN > sD) {
                    sN = sD;
                    tN = e + b;
                    tD = c;
                  }
                }

                if (tN < 0.0) {
                  tN = 0.0;

                  if (-d < 0.0) {
                    sN = 0.0;
                  } else if (-d > a) {
                    sN = sD;
                  } else {
                    sN = -d;
                    sD = a;
                  }
                } else if (tN > tD) {
                  tN = tD;

                  if (-d + b < 0.0) {
                    sN = 0;
                  } else if (-d + b > a) {
                    sN = sD;
                  } else {
                    sN = -d + b;
                    sD = a;
                  }
                }

                const sc = Math.abs(sN) < EPSILON ? 0.0 : sN / sD;
                const tc = Math.abs(tN) < EPSILON ? 0.0 : tN / tD;
                const dP = v3_3;
                dP.set(w);
                dP.add(Vec3.multiplyScalar(v3_4, u, sc));
                dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
                const radius = capsuleA.radius + capsuleB.radius;
                return dP.lengthSqr() < radius * radius;
              };
            }();

            const intersect = exports('dl', {
              raySphere,
              rayAABB,
              rayOBB,
              rayPlane,
              rayTriangle,
              rayCapsule,
              raySubMesh,
              rayMesh,
              rayModel,
              lineSphere,
              lineAABB,
              lineOBB,
              linePlane,
              lineTriangle,
              sphereWithSphere,
              sphereAABB,
              sphereOBB,
              spherePlane,
              sphereFrustum,
              sphereFrustumAccurate,
              sphereCapsule,
              aabbWithAABB,
              aabbWithOBB,
              aabbPlane,
              aabbFrustum,
              aabbFrustumAccurate,
              obbWithOBB,
              obbPlane,
              obbFrustum,
              obbFrustumAccurate,
              obbPoint,
              obbCapsule,
              capsuleWithCapsule,

              resolve(g1, g2, outPt = null) {
                const type1 = g1._type;
                const type2 = g2._type;
                const resolver = this[type1 | type2];
                return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
              }

            });
            intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = raySphere;
            intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = rayAABB;
            intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = rayOBB;
            intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = rayPlane;
            intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = rayTriangle;
            intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = rayCapsule;
            intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = lineSphere;
            intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = lineAABB;
            intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = lineOBB;
            intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = linePlane;
            intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = lineTriangle;
            intersect[enums.SHAPE_SPHERE] = sphereWithSphere;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphereAABB;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphereOBB;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = spherePlane;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphereFrustum;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphereFrustumAccurate;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphereCapsule;
            intersect[enums.SHAPE_AABB] = aabbWithAABB;
            intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabbWithOBB;
            intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabbPlane;
            intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabbFrustum;
            intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabbFrustumAccurate;
            intersect[enums.SHAPE_OBB] = obbWithOBB;
            intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obbPlane;
            intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obbFrustum;
            intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obbFrustumAccurate;
            intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obbCapsule;
            intersect[enums.SHAPE_CAPSULE] = capsuleWithCapsule;

            replaceProperty(Line.prototype, 'line', [{
              name: 'mag',
              newName: 'len'
            }, {
              name: 'magnitude',
              newName: 'len'
            }]);
            removeProperty(intersect, 'intersect', [{
              name: 'line_quad'
            }]);

            const v1 = new Vec3(0, 0, 0);
            const v2$1 = new Vec3(0, 0, 0);
            const temp_mat = legacyCC.mat4();
            const temp_vec4 = legacyCC.v4();
            class Plane {
              static create(nx, ny, nz, d) {
                return new Plane(nx, ny, nz, d);
              }

              static clone(p) {
                return new Plane(p.n.x, p.n.y, p.n.z, p.d);
              }

              static copy(out, p) {
                Vec3.copy(out.n, p.n);
                out.d = p.d;
                return out;
              }

              static fromPoints(out, a, b, c) {
                Vec3.subtract(v1, b, a);
                Vec3.subtract(v2$1, c, a);
                Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2$1));
                out.d = Vec3.dot(out.n, a);
                return out;
              }

              static set(out, nx, ny, nz, d) {
                out.n.x = nx;
                out.n.y = ny;
                out.n.z = nz;
                out.d = d;
                return out;
              }

              static fromNormalAndPoint(out, normal, point) {
                Vec3.copy(out.n, normal);
                out.d = Vec3.dot(normal, point);
                return out;
              }

              static normalize(out, a) {
                const len = a.n.length();
                Vec3.normalize(out.n, a.n);

                if (len > 0) {
                  out.d = a.d / len;
                }

                return out;
              }

              get type() {
                return this._type;
              }

              set x(val) {
                this.n.x = val;
              }

              get x() {
                return this.n.x;
              }

              set y(val) {
                this.n.y = val;
              }

              get y() {
                return this.n.y;
              }

              set z(val) {
                this.n.z = val;
              }

              get z() {
                return this.n.z;
              }

              set w(val) {
                this.d = val;
              }

              get w() {
                return this.d;
              }

              constructor(nx = 0, ny = 1, nz = 0, d = 0) {
                this.n = void 0;
                this.d = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_PLANE;
                this.n = new Vec3(nx, ny, nz);
                this.d = d;
              }

              transform(mat) {
                Mat4.invert(temp_mat, mat);
                Mat4.transpose(temp_mat, temp_mat);
                Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d);
                Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
                Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
                this.d = temp_vec4.w;
              }

            }

            const NativeBufferPool = jsb.NativeBufferPool;
            const NativeObjectPool = jsb.NativeObjectPool;
            const NativeBufferAllocator = jsb.NativeBufferAllocator;

            const contains$2 = (a, t) => {
              for (let i = 0; i < a.length; ++i) {
                if (a[i] === t) return true;
              }

              return false;
            };

            var BufferDataType;

            (function (BufferDataType) {
              BufferDataType[BufferDataType["UINT32"] = 0] = "UINT32";
              BufferDataType[BufferDataType["FLOAT32"] = 1] = "FLOAT32";
              BufferDataType[BufferDataType["NEVER"] = 2] = "NEVER";
            })(BufferDataType || (BufferDataType = {}));

            class BufferPool {
              constructor(poolType, dataType, dataMembers, enumType, entryBits = 8) {
                this._dataType = void 0;
                this._dataMembers = void 0;
                this._elementCount = void 0;
                this._entryBits = void 0;
                this._stride = void 0;
                this._entriesPerChunk = void 0;
                this._entryMask = void 0;
                this._chunkMask = void 0;
                this._poolFlag = void 0;
                this._arrayBuffers = [];
                this._freeLists = [];
                this._uint32BufferViews = [];
                this._float32BufferViews = [];
                this._hasUint32 = false;
                this._hasFloat32 = false;
                this._nativePool = void 0;
                this._elementCount = enumType.COUNT;
                this._entryBits = entryBits;
                this._dataType = dataType;
                this._dataMembers = dataMembers;
                const bytesPerElement = 4;
                this._stride = bytesPerElement * this._elementCount;
                this._entriesPerChunk = 1 << entryBits;
                this._entryMask = this._entriesPerChunk - 1;
                this._poolFlag = 1 << 30;
                this._chunkMask = ~(this._entryMask | this._poolFlag);
                this._nativePool = new NativeBufferPool(poolType, entryBits, this._stride);
                let type = BufferDataType.NEVER;
                let hasFloat32 = false;
                let hasUint32 = false;

                for (const e in dataType) {
                  hasFloat32 = this._hasFloat32;
                  hasUint32 = this._hasUint32;

                  if (hasUint32 && hasFloat32) {
                    break;
                  }

                  type = dataType[e];

                  if (!hasFloat32 && type === BufferDataType.FLOAT32) {
                    this._hasFloat32 = true;
                  } else if (!hasUint32 && type === BufferDataType.UINT32) {
                    this._hasUint32 = true;
                  }
                }
              }

              alloc() {
                let i = 0;

                for (; i < this._freeLists.length; i++) {
                  const list = this._freeLists[i];

                  if (list.length) {
                    const j = list[list.length - 1];
                    list.length--;
                    return (i << this._entryBits) + j + this._poolFlag;
                  }
                }

                const buffer = this._nativePool.allocateNewChunk();

                const float32BufferViews = [];
                const uint32BufferViews = [];
                const freeList = [];
                const hasFloat32 = this._hasFloat32;
                const hasUint32 = this._hasUint32;

                for (let j = 0; j < this._entriesPerChunk; j++) {
                  if (hasFloat32) {
                    float32BufferViews.push(new Float32Array(buffer, this._stride * j, this._elementCount));
                  }

                  if (hasUint32) {
                    uint32BufferViews.push(new Uint32Array(buffer, this._stride * j, this._elementCount));
                  }

                  if (j) {
                    freeList.push(j);
                  }
                }

                if (hasUint32) {
                  this._uint32BufferViews.push(uint32BufferViews);
                }

                if (hasFloat32) {
                  this._float32BufferViews.push(float32BufferViews);
                }

                this._freeLists.push(freeList);

                this._arrayBuffers.push(buffer);

                const handle = (i << this._entryBits) + this._poolFlag;
                return handle;
              }

              getBuffer(handle) {
                const chunk = (this._chunkMask & handle) >> this._entryBits;
                const entry = this._entryMask & handle;
                const bufferViews = this._hasFloat32 ? this._float32BufferViews : this._uint32BufferViews;

                if ( (!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
                  console.warn('invalid buffer pool handle');
                  return [];
                }

                return bufferViews[chunk][entry];
              }

              getTypedArray(handle, element) {
                const chunk = (this._chunkMask & handle) >> this._entryBits;
                const entry = this._entryMask & handle;
                const bufferViews = this._dataType[element] === BufferDataType.UINT32 ? this._uint32BufferViews : this._float32BufferViews;

                if ( (!handle || chunk < 0 || chunk >= bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
                  console.warn('invalid buffer pool handle');
                  return [];
                }

                const index = element;
                const view = bufferViews[chunk][entry];
                const count = this._dataMembers[element];
                return view.subarray(index, index + count);
              }

              free(handle) {
                const chunk = (this._chunkMask & handle) >> this._entryBits;
                const entry = this._entryMask & handle;

                if ( (!handle || chunk < 0 || chunk >= this._freeLists.length || entry < 0 || entry >= this._entriesPerChunk || contains$2(this._freeLists[chunk], entry))) {
                  console.warn('invalid buffer pool handle');
                  return;
                }

                const bufferViews = this._hasUint32 ? this._uint32BufferViews : this._float32BufferViews;
                bufferViews[chunk][entry].fill(0);

                this._freeLists[chunk].push(entry);
              }

            }

            let PoolType;

            (function (PoolType) {
              PoolType[PoolType["NODE"] = 0] = "NODE";
              PoolType[PoolType["PASS"] = 1] = "PASS";
              PoolType[PoolType["AABB"] = 2] = "AABB";
            })(PoolType || (PoolType = {}));

            const NULL_HANDLE = 0;
            let NodeView;

            (function (NodeView) {
              NodeView[NodeView["DIRTY_FLAG"] = 0] = "DIRTY_FLAG";
              NodeView[NodeView["LAYER"] = 1] = "LAYER";
              NodeView[NodeView["WORLD_SCALE"] = 2] = "WORLD_SCALE";
              NodeView[NodeView["WORLD_POSITION"] = 5] = "WORLD_POSITION";
              NodeView[NodeView["WORLD_ROTATION"] = 8] = "WORLD_ROTATION";
              NodeView[NodeView["WORLD_MATRIX"] = 12] = "WORLD_MATRIX";
              NodeView[NodeView["LOCAL_SCALE"] = 28] = "LOCAL_SCALE";
              NodeView[NodeView["LOCAL_POSITION"] = 31] = "LOCAL_POSITION";
              NodeView[NodeView["LOCAL_ROTATION"] = 34] = "LOCAL_ROTATION";
              NodeView[NodeView["COUNT"] = 38] = "COUNT";
            })(NodeView || (NodeView = {}));

            const NodeViewDataType = {
              [NodeView.DIRTY_FLAG]: BufferDataType.UINT32,
              [NodeView.LAYER]: BufferDataType.UINT32,
              [NodeView.WORLD_SCALE]: BufferDataType.FLOAT32,
              [NodeView.WORLD_POSITION]: BufferDataType.FLOAT32,
              [NodeView.WORLD_ROTATION]: BufferDataType.FLOAT32,
              [NodeView.WORLD_MATRIX]: BufferDataType.FLOAT32,
              [NodeView.LOCAL_SCALE]: BufferDataType.FLOAT32,
              [NodeView.LOCAL_POSITION]: BufferDataType.FLOAT32,
              [NodeView.LOCAL_ROTATION]: BufferDataType.FLOAT32,
              [NodeView.COUNT]: BufferDataType.NEVER
            };
            const NodeViewDataMembers = {
              [NodeView.DIRTY_FLAG]: NodeView.LAYER - NodeView.DIRTY_FLAG,
              [NodeView.LAYER]: NodeView.WORLD_SCALE - NodeView.LAYER,
              [NodeView.WORLD_SCALE]: NodeView.WORLD_POSITION - NodeView.WORLD_SCALE,
              [NodeView.WORLD_POSITION]: NodeView.WORLD_ROTATION - NodeView.WORLD_POSITION,
              [NodeView.WORLD_ROTATION]: NodeView.WORLD_MATRIX - NodeView.WORLD_ROTATION,
              [NodeView.WORLD_MATRIX]: NodeView.LOCAL_SCALE - NodeView.WORLD_MATRIX,
              [NodeView.LOCAL_SCALE]: NodeView.LOCAL_POSITION - NodeView.LOCAL_SCALE,
              [NodeView.LOCAL_POSITION]: NodeView.LOCAL_ROTATION - NodeView.LOCAL_POSITION,
              [NodeView.LOCAL_ROTATION]: NodeView.COUNT - NodeView.LOCAL_ROTATION,
              [NodeView.COUNT]: 1
            };
            const NodePool = new BufferPool(PoolType.NODE, NodeViewDataType, NodeViewDataMembers, NodeView);
            let PassView;

            (function (PassView) {
              PassView[PassView["PRIORITY"] = 0] = "PRIORITY";
              PassView[PassView["STAGE"] = 1] = "STAGE";
              PassView[PassView["PHASE"] = 2] = "PHASE";
              PassView[PassView["PRIMITIVE"] = 3] = "PRIMITIVE";
              PassView[PassView["BATCHING_SCHEME"] = 4] = "BATCHING_SCHEME";
              PassView[PassView["DYNAMIC_STATE"] = 5] = "DYNAMIC_STATE";
              PassView[PassView["HASH"] = 6] = "HASH";
              PassView[PassView["COUNT"] = 7] = "COUNT";
            })(PassView || (PassView = {}));

            const PassViewDataType = {
              [PassView.PRIORITY]: BufferDataType.UINT32,
              [PassView.STAGE]: BufferDataType.UINT32,
              [PassView.PHASE]: BufferDataType.UINT32,
              [PassView.PRIMITIVE]: BufferDataType.UINT32,
              [PassView.BATCHING_SCHEME]: BufferDataType.UINT32,
              [PassView.DYNAMIC_STATE]: BufferDataType.UINT32,
              [PassView.HASH]: BufferDataType.UINT32,
              [PassView.COUNT]: BufferDataType.NEVER
            };
            const PassViewDataMembers = {
              [PassView.PRIORITY]: PassView.STAGE - PassView.PRIORITY,
              [PassView.STAGE]: PassView.PHASE - PassView.STAGE,
              [PassView.PHASE]: PassView.PRIMITIVE - PassView.PHASE,
              [PassView.PRIMITIVE]: PassView.BATCHING_SCHEME - PassView.PRIMITIVE,
              [PassView.BATCHING_SCHEME]: PassView.DYNAMIC_STATE - PassView.BATCHING_SCHEME,
              [PassView.DYNAMIC_STATE]: PassView.HASH - PassView.DYNAMIC_STATE,
              [PassView.HASH]: PassView.COUNT - PassView.HASH,
              [PassView.COUNT]: 1
            };
            const PassPool = new BufferPool(PoolType.PASS, PassViewDataType, PassViewDataMembers, PassView);
            let AABBView;

            (function (AABBView) {
              AABBView[AABBView["CENTER"] = 0] = "CENTER";
              AABBView[AABBView["HALFEXTENTS"] = 3] = "HALFEXTENTS";
              AABBView[AABBView["COUNT"] = 6] = "COUNT";
            })(AABBView || (AABBView = {}));

            const AABBViewDataType = {
              [AABBView.CENTER]: BufferDataType.FLOAT32,
              [AABBView.HALFEXTENTS]: BufferDataType.FLOAT32,
              [AABBView.COUNT]: BufferDataType.NEVER
            };
            const AABBViewDataMembers = {
              [AABBView.CENTER]: AABBView.HALFEXTENTS - AABBView.CENTER,
              [AABBView.HALFEXTENTS]: AABBView.COUNT - AABBView.HALFEXTENTS,
              [AABBView.COUNT]: 1
            };
            const AABBPool = new BufferPool(PoolType.AABB, AABBViewDataType, AABBViewDataMembers, AABBView);

            const _v3_tmp$1 = new Vec3();

            const _v3_tmp2 = new Vec3();

            const _v3_tmp3 = new Vec3();

            const _v3_tmp4 = new Vec3();

            const _m3_tmp = new Mat3();

            const transform_extent_m4 = (out, extent, m4) => {
              _m3_tmp.m00 = Math.abs(m4.m00);
              _m3_tmp.m01 = Math.abs(m4.m01);
              _m3_tmp.m02 = Math.abs(m4.m02);
              _m3_tmp.m03 = Math.abs(m4.m04);
              _m3_tmp.m04 = Math.abs(m4.m05);
              _m3_tmp.m05 = Math.abs(m4.m06);
              _m3_tmp.m06 = Math.abs(m4.m08);
              _m3_tmp.m07 = Math.abs(m4.m09);
              _m3_tmp.m08 = Math.abs(m4.m10);
              Vec3.transformMat3(out, extent, _m3_tmp);
            };

            class AABB {
              static create(px, py, pz, hw, hh, hl) {
                return new AABB(px, py, pz, hw, hh, hl);
              }

              static clone(a) {
                return new AABB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
              }

              static copy(out, a) {
                Vec3.copy(out.center, a.center);
                Vec3.copy(out.halfExtents, a.halfExtents);
                return out;
              }

              static fromPoints(out, minPos, maxPos) {
                Vec3.add(_v3_tmp$1, maxPos, minPos);
                Vec3.subtract(_v3_tmp2, maxPos, minPos);
                Vec3.multiplyScalar(out.center, _v3_tmp$1, 0.5);
                Vec3.multiplyScalar(out.halfExtents, _v3_tmp2, 0.5);
                return out;
              }

              static set(out, px, py, pz, hw, hh, hl) {
                out.center.set(px, py, pz);
                out.halfExtents.set(hw, hh, hl);
                return out;
              }

              static merge(out, a, b) {
                Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents);
                Vec3.subtract(_v3_tmp2, b.center, b.halfExtents);
                Vec3.add(_v3_tmp3, a.center, a.halfExtents);
                Vec3.add(_v3_tmp4, b.center, b.halfExtents);
                Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4);
                Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2);
                return AABB.fromPoints(out, _v3_tmp3, _v3_tmp4);
              }

              static toBoundingSphere(out, a) {
                out.center.set(a.center);
                out.radius = a.halfExtents.length();
                return out;
              }

              static transform(out, a, matrix) {
                Vec3.transformMat4(out.center, a.center, matrix);
                transform_extent_m4(out.halfExtents, a.halfExtents, matrix);
                return out;
              }

              get type() {
                return this._type;
              }

              constructor(px = 0, py = 0, pz = 0, hw = 1, hh = 1, hl = 1) {
                this.center = void 0;
                this.halfExtents = void 0;
                this._type = void 0;
                this._aabbHandle = NULL_HANDLE;
                this._type = enums.SHAPE_AABB;

                {
                  this._aabbHandle = AABBPool.alloc();
                  this.center = new Vec3(AABBPool.getTypedArray(this._aabbHandle, AABBView.CENTER));
                  this.halfExtents = new Vec3(AABBPool.getTypedArray(this._aabbHandle, AABBView.HALFEXTENTS));
                  this.center.set(px, py, pz);
                  this.halfExtents.set(hw, hh, hl);
                  this._nativeObj = new NativeAABB();

                  this._nativeObj.initWithData(AABBPool.getBuffer(this._aabbHandle));

                  return;
                }
              }

              get native() {
                return this._nativeObj;
              }

              getBoundary(minPos, maxPos) {
                Vec3.subtract(minPos, this.center, this.halfExtents);
                Vec3.add(maxPos, this.center, this.halfExtents);
              }

              transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                transform_extent_m4(out.halfExtents, this.halfExtents, m);
              }

              clone() {
                return AABB.clone(this);
              }

              copy(a) {
                return AABB.copy(this, a);
              }

              mergePoint(point) {
                this.getBoundary(_v3_tmp$1, _v3_tmp2);

                if (point.x < _v3_tmp$1.x) {
                  _v3_tmp$1.x = point.x;
                }

                if (point.y < _v3_tmp$1.y) {
                  _v3_tmp$1.y = point.y;
                }

                if (point.z < _v3_tmp$1.z) {
                  _v3_tmp$1.z = point.z;
                }

                if (point.x > _v3_tmp2.x) {
                  _v3_tmp2.x = point.x;
                }

                if (point.y > _v3_tmp2.y) {
                  _v3_tmp2.y = point.y;
                }

                if (point.z > _v3_tmp2.z) {
                  _v3_tmp2.z = point.z;
                }

                Vec3.add(_v3_tmp3, _v3_tmp$1, _v3_tmp2);
                this.center.set(Vec3.multiplyScalar(_v3_tmp3, _v3_tmp3, 0.5));
                this.halfExtents.set(_v3_tmp2.x - _v3_tmp3.x, _v3_tmp2.y - _v3_tmp3.y, _v3_tmp2.z - _v3_tmp3.z);
              }

              mergePoints(points) {
                if (points.length < 1) {
                  return;
                }

                for (let i = 0; i < points.length; i++) {
                  this.mergePoint(points[i]);
                }
              }

              mergeFrustum(frustum) {
                return this.mergePoints(frustum.vertices);
              }

            } exports('cE', AABB);

            const _v3_tmp$2 = new Vec3();

            const _v3_tmp2$1 = new Vec3();

            const _m3_tmp$1 = new Mat3();

            const transform_extent_m3 = (out, extent, m3) => {
              _m3_tmp$1.m00 = Math.abs(m3.m00);
              _m3_tmp$1.m01 = Math.abs(m3.m01);
              _m3_tmp$1.m02 = Math.abs(m3.m02);
              _m3_tmp$1.m03 = Math.abs(m3.m03);
              _m3_tmp$1.m04 = Math.abs(m3.m04);
              _m3_tmp$1.m05 = Math.abs(m3.m05);
              _m3_tmp$1.m06 = Math.abs(m3.m06);
              _m3_tmp$1.m07 = Math.abs(m3.m07);
              _m3_tmp$1.m08 = Math.abs(m3.m08);
              Vec3.transformMat3(out, extent, _m3_tmp$1);
            };

            class OBB {
              static create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                return new OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
              }

              static clone(a) {
                return new OBB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
              }

              static copy(out, a) {
                Vec3.copy(out.center, a.center);
                Vec3.copy(out.halfExtents, a.halfExtents);
                Mat3.copy(out.orientation, a.orientation);
                return out;
              }

              static fromPoints(out, minPos, maxPos) {
                Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), 0.5);
                Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), 0.5);
                Mat3.identity(out.orientation);
                return out;
              }

              static set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                Vec3.set(out.center, cx, cy, cz);
                Vec3.set(out.halfExtents, hw, hh, hl);
                Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
                return out;
              }

              get type() {
                return this._type;
              }

              constructor(cx = 0, cy = 0, cz = 0, hw = 1, hh = 1, hl = 1, ox_1 = 1, ox_2 = 0, ox_3 = 0, oy_1 = 0, oy_2 = 1, oy_3 = 0, oz_1 = 0, oz_2 = 0, oz_3 = 1) {
                this.center = void 0;
                this.halfExtents = void 0;
                this.orientation = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_OBB;
                this.center = new Vec3(cx, cy, cz);
                this.halfExtents = new Vec3(hw, hh, hl);
                this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
              }

              getBoundary(minPos, maxPos) {
                transform_extent_m3(_v3_tmp$2, this.halfExtents, this.orientation);
                Vec3.subtract(minPos, this.center, _v3_tmp$2);
                Vec3.add(maxPos, this.center, _v3_tmp$2);
              }

              transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                Mat3.fromQuat(out.orientation, rot);
                Vec3.multiply(out.halfExtents, this.halfExtents, scale);
              }

              translateAndRotate(m, rot, out) {
                Vec3.transformMat4(out.center, this.center, m);
                Mat3.fromQuat(out.orientation, rot);
              }

              setScale(scale, out) {
                Vec3.multiply(out.halfExtents, this.halfExtents, scale);
              }

            }

            class Capsule {
              get type() {
                return this._type;
              }

              constructor(radius = 0.5, halfHeight = 0.5, axis = 1) {
                this._type = void 0;
                this.radius = void 0;
                this.halfHeight = void 0;
                this.axis = void 0;
                this.center = void 0;
                this.rotation = void 0;
                this.ellipseCenter0 = void 0;
                this.ellipseCenter1 = void 0;
                this._type = enums.SHAPE_CAPSULE;
                this.radius = radius;
                this.halfHeight = halfHeight;
                this.axis = axis;
                this.center = new Vec3();
                this.rotation = new Quat();
                this.ellipseCenter0 = new Vec3(0, halfHeight, 0);
                this.ellipseCenter1 = new Vec3(0, -halfHeight, 0);
                this.updateCache();
              }

              transform(m, pos, rot, scale, out) {
                const ws = scale;
                const s = absMaxComponent(ws);
                out.radius = this.radius * Math.abs(s);
                const halfTotalWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y);
                let halfWorldHeight = halfTotalWorldHeight - out.radius;
                if (halfWorldHeight < 0) halfWorldHeight = 0;
                out.halfHeight = halfWorldHeight;
                Vec3.transformMat4(out.center, this.center, m);
                Quat.multiply(out.rotation, this.rotation, rot);
                out.updateCache();
              }

              updateCache() {
                this.updateLocalCenter();
                Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation);
                Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation);
                this.ellipseCenter0.add(this.center);
                this.ellipseCenter1.add(this.center);
              }

              updateLocalCenter() {
                const halfHeight = this.halfHeight;
                const axis = this.axis;

                switch (axis) {
                  case 0:
                    this.ellipseCenter0.set(halfHeight, 0, 0);
                    this.ellipseCenter1.set(-halfHeight, 0, 0);
                    break;

                  case 1:
                    this.ellipseCenter0.set(0, halfHeight, 0);
                    this.ellipseCenter1.set(0, -halfHeight, 0);
                    break;

                  case 2:
                    this.ellipseCenter0.set(0, 0, halfHeight);
                    this.ellipseCenter1.set(0, 0, -halfHeight);
                    break;
                }
              }

            }

            const _v = new Array(8);

            _v[0] = new Vec3(1, 1, 1);
            _v[1] = new Vec3(-1, 1, 1);
            _v[2] = new Vec3(-1, -1, 1);
            _v[3] = new Vec3(1, -1, 1);
            _v[4] = new Vec3(1, 1, -1);
            _v[5] = new Vec3(-1, 1, -1);
            _v[6] = new Vec3(-1, -1, -1);
            _v[7] = new Vec3(1, -1, -1);

            const _nearTemp = new Vec3();

            const _farTemp = new Vec3();

            const _temp_v3 = new Vec3();

            class Frustum {
              set accurate(b) {
                this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
              }

              static createFromAABB(out, aabb) {
                const vec3_min = new Vec3();
                const vec3_max = new Vec3();
                Vec3.subtract(vec3_min, aabb.center, aabb.halfExtents);
                Vec3.add(vec3_max, aabb.center, aabb.halfExtents);
                out.vertices[0].set(vec3_min.x, vec3_max.y, vec3_min.z);
                out.vertices[1].set(vec3_max.x, vec3_max.y, vec3_min.z);
                out.vertices[2].set(vec3_max.x, vec3_min.y, vec3_min.z);
                out.vertices[3].set(vec3_min.x, vec3_min.y, vec3_min.z);
                out.vertices[4].set(vec3_min.x, vec3_max.y, vec3_max.z);
                out.vertices[5].set(vec3_max.x, vec3_max.y, vec3_max.z);
                out.vertices[6].set(vec3_max.x, vec3_min.y, vec3_max.z);
                out.vertices[7].set(vec3_min.x, vec3_min.y, vec3_max.z);

                if (out._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
                  return out;
                }

                out.updatePlanes();
                return out;
              }

              static split(out, camera, m, start, end) {
                const h = Math.tan(camera.fov * 0.5);
                const w = h * camera.aspect;

                _nearTemp.set(start * w, start * h, start);

                _farTemp.set(end * w, end * h, end);

                const vertexes = out.vertices;

                _temp_v3.set(_nearTemp.x, _nearTemp.y, _nearTemp.z);

                Vec3.transformMat4(vertexes[0], _temp_v3, m);

                _temp_v3.set(-_nearTemp.x, _nearTemp.y, _nearTemp.z);

                Vec3.transformMat4(vertexes[1], _temp_v3, m);

                _temp_v3.set(-_nearTemp.x, -_nearTemp.y, _nearTemp.z);

                Vec3.transformMat4(vertexes[2], _temp_v3, m);

                _temp_v3.set(_nearTemp.x, -_nearTemp.y, _nearTemp.z);

                Vec3.transformMat4(vertexes[3], _temp_v3, m);

                _temp_v3.set(_farTemp.x, _farTemp.y, _farTemp.z);

                Vec3.transformMat4(vertexes[4], _temp_v3, m);

                _temp_v3.set(-_farTemp.x, _farTemp.y, _farTemp.z);

                Vec3.transformMat4(vertexes[5], _temp_v3, m);

                _temp_v3.set(-_farTemp.x, -_farTemp.y, _farTemp.z);

                Vec3.transformMat4(vertexes[6], _temp_v3, m);

                _temp_v3.set(_farTemp.x, -_farTemp.y, _farTemp.z);

                Vec3.transformMat4(vertexes[7], _temp_v3, m);
                out.updatePlanes();
                return out;
              }

              static create() {
                return new Frustum();
              }

              static clone(f) {
                return Frustum.copy(new Frustum(), f);
              }

              static copy(out, f) {
                out._type = f._type;

                for (let i = 0; i < 6; ++i) {
                  Plane.copy(out.planes[i], f.planes[i]);
                }

                for (let i = 0; i < 8; ++i) {
                  Vec3.copy(out.vertices[i], f.vertices[i]);
                }

                return out;
              }

              get type() {
                return this._type;
              }

              constructor() {
                this._type = void 0;
                this.planes = void 0;
                this.vertices = void 0;
                this._type = enums.SHAPE_FRUSTUM;
                this.planes = new Array(6);

                for (let i = 0; i < 6; ++i) {
                  this.planes[i] = Plane.create(0, 0, 0, 0);
                }

                this.vertices = new Array(8);

                for (let i = 0; i < 8; ++i) {
                  this.vertices[i] = new Vec3();
                }
              }

              update(m, inv) {
                Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
                this.planes[0].d = -(m.m15 + m.m12);
                Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
                this.planes[1].d = -(m.m15 - m.m12);
                Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
                this.planes[2].d = -(m.m15 + m.m13);
                Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
                this.planes[3].d = -(m.m15 - m.m13);
                Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
                this.planes[4].d = -(m.m15 + m.m14);
                Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
                this.planes[5].d = -(m.m15 - m.m14);

                if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
                  return;
                }

                for (let i = 0; i < 6; i++) {
                  const pl = this.planes[i];
                  const invDist = 1 / pl.n.length();
                  Vec3.multiplyScalar(pl.n, pl.n, invDist);
                  pl.d *= invDist;
                }

                for (let i = 0; i < 8; i++) {
                  Vec3.transformMat4(this.vertices[i], _v[i], inv);
                }
              }

              transform(mat) {
                if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
                  return;
                }

                for (let i = 0; i < 8; i++) {
                  Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
                }

                Plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[6], this.vertices[5]);
                Plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[4], this.vertices[7]);
                Plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[3], this.vertices[7]);
                Plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[5], this.vertices[4]);
                Plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[0], this.vertices[3]);
                Plane.fromPoints(this.planes[5], this.vertices[7], this.vertices[5], this.vertices[6]);
              }

              updatePlanes() {
                Plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[6], this.vertices[5]);
                Plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[4], this.vertices[7]);
                Plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[3], this.vertices[7]);
                Plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[5], this.vertices[4]);
                Plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[0], this.vertices[3]);
                Plane.fromPoints(this.planes[5], this.vertices[7], this.vertices[5], this.vertices[6]);
              }

            }

            Frustum.createOrtho = (() => (out, width, height, near, far, transform) => {
              const halfWidth = width / 2;
              const halfHeight = height / 2;
              Vec3.set(_temp_v3, halfWidth, halfHeight, -near);
              Vec3.transformMat4(out.vertices[0], _temp_v3, transform);
              Vec3.set(_temp_v3, -halfWidth, halfHeight, -near);
              Vec3.transformMat4(out.vertices[1], _temp_v3, transform);
              Vec3.set(_temp_v3, -halfWidth, -halfHeight, -near);
              Vec3.transformMat4(out.vertices[2], _temp_v3, transform);
              Vec3.set(_temp_v3, halfWidth, -halfHeight, -near);
              Vec3.transformMat4(out.vertices[3], _temp_v3, transform);
              Vec3.set(_temp_v3, halfWidth, halfHeight, -far);
              Vec3.transformMat4(out.vertices[4], _temp_v3, transform);
              Vec3.set(_temp_v3, -halfWidth, halfHeight, -far);
              Vec3.transformMat4(out.vertices[5], _temp_v3, transform);
              Vec3.set(_temp_v3, -halfWidth, -halfHeight, -far);
              Vec3.transformMat4(out.vertices[6], _temp_v3, transform);
              Vec3.set(_temp_v3, halfWidth, -halfHeight, -far);
              Vec3.transformMat4(out.vertices[7], _temp_v3, transform);
              Plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]);
              Plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]);
              Plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]);
              Plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]);
              Plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]);
              Plane.fromPoints(out.planes[5], out.vertices[7], out.vertices[5], out.vertices[6]);
            })();

            function _initializerDefineProperty(target, property, descriptor, context) {
              if (!descriptor) return;
              Object.defineProperty(target, property, {
                enumerable: descriptor.enumerable,
                configurable: descriptor.configurable,
                writable: descriptor.writable,
                value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
              });
            }

            function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
              var desc = {};
              Object.keys(descriptor).forEach(function (key) {
                desc[key] = descriptor[key];
              });
              desc.enumerable = !!desc.enumerable;
              desc.configurable = !!desc.configurable;

              if ('value' in desc || desc.initializer) {
                desc.writable = true;
              }

              desc = decorators.slice().reverse().reduce(function (desc, decorator) {
                return decorator(target, property, desc) || desc;
              }, desc);

              if (context && desc.initializer !== void 0) {
                desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                desc.initializer = undefined;
              }

              if (desc.initializer === void 0) {
                Object.defineProperty(target, property, desc);
                desc = null;
              }

              return desc;
            }

            let WrapModeMask;

            (function (WrapModeMask) {
              WrapModeMask[WrapModeMask["Default"] = 0] = "Default";
              WrapModeMask[WrapModeMask["Normal"] = 1] = "Normal";
              WrapModeMask[WrapModeMask["Loop"] = 2] = "Loop";
              WrapModeMask[WrapModeMask["ShouldWrap"] = 4] = "ShouldWrap";
              WrapModeMask[WrapModeMask["Clamp"] = 8] = "Clamp";
              WrapModeMask[WrapModeMask["PingPong"] = 22] = "PingPong";
              WrapModeMask[WrapModeMask["Reverse"] = 36] = "Reverse";
            })(WrapModeMask || (WrapModeMask = {}));

            let WrapMode;

            (function (WrapMode) {
              WrapMode[WrapMode["Default"] = WrapModeMask.Default] = "Default";
              WrapMode[WrapMode["Normal"] = WrapModeMask.Normal] = "Normal";
              WrapMode[WrapMode["Reverse"] = WrapModeMask.Reverse] = "Reverse";
              WrapMode[WrapMode["Loop"] = WrapModeMask.Loop] = "Loop";
              WrapMode[WrapMode["LoopReverse"] = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse";
              WrapMode[WrapMode["PingPong"] = WrapModeMask.PingPong] = "PingPong";
              WrapMode[WrapMode["PingPongReverse"] = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
            })(WrapMode || (WrapMode = {}));

            ccenum(WrapMode);
            class WrappedInfo {
              constructor(info) {
                this.ratio = 0;
                this.time = 0;
                this.direction = 1;
                this.stopped = true;
                this.iterations = 0;
                this.frameIndex = undefined;

                if (info) {
                  this.set(info);
                }
              }

              set(info) {
                this.ratio = info.ratio;
                this.time = info.time;
                this.direction = info.direction;
                this.stopped = info.stopped;
                this.iterations = info.iterations;
                this.frameIndex = info.frameIndex;
              }

            }
            function isLerpable(object) {
              return typeof object.lerp === 'function';
            }

            function binarySearchEpsilon(array, value, EPSILON = 1e-6) {
              let low = 0;
              let high = array.length - 1;
              let middle = high >>> 1;

              for (; low <= high; middle = low + high >>> 1) {
                const test = array[middle];

                if (test > value + EPSILON) {
                  high = middle - 1;
                } else if (test < value - EPSILON) {
                  low = middle + 1;
                } else {
                  return middle;
                }
              }

              return ~low;
            }

            const emptyDecorator = () => {};
            const emptyDecoratorFn = () => emptyDecorator;
            const emptySmartClassDecorator = makeSmartClassDecorator(() => {});
            function makeSmartClassDecorator(decorate) {
              return proxyFn;

              function proxyFn(target) {
                if (typeof target === 'function') {
                  return decorate(target);
                } else {
                  return function (constructor) {
                    return decorate(constructor, target);
                  };
                }
              }
            }

            function writeEditorClassProperty(constructor, propertyName, value) {
              const cache = getClassCache(constructor);

              if (cache) {
                const proto = getSubDict(cache, 'proto');
                getSubDict(proto, 'editor')[propertyName] = value;
              }
            }

            function makeEditorClassDecoratorFn(propertyName) {
              return value => constructor => {
                writeEditorClassProperty(constructor, propertyName, value);
              };
            }
            const CACHE_KEY = '__ccclassCache__';
            function getClassCache(ctor, decoratorName) {

              return getSubDict(ctor, CACHE_KEY);
            }
            function getSubDict(obj, key) {
              return obj[key] || (obj[key] = {});
            }

            const ccclass = exports('bD', makeSmartClassDecorator((constructor, name) => {
              let base = js.getSuper(constructor);

              if (base === Object) {
                base = null;
              }

              const proto = {
                name,
                extends: base,
                ctor: constructor
              };
              const cache = constructor[CACHE_KEY];

              if (cache) {
                const decoratedProto = cache.proto;

                if (decoratedProto) {
                  js.mixin(proto, decoratedProto);
                }

                constructor[CACHE_KEY] = undefined;
              }

              const res = CCClass(proto);

              return res;
            }));

            const requireComponent = exports('e6', makeEditorClassDecoratorFn('requireComponent'));
            const executionOrder = exports('bN', makeEditorClassDecoratorFn('executionOrder'));
            const disallowMultiple = exports('dO',  emptySmartClassDecorator);
            const allowReplicated = ctor => {
              CCClass.Attr.setClassAttr(ctor, 'replicated', 'visible', true);
            };

            function property(target, propertyKey, descriptor) {
              let options = null;

              function normalized(target, propertyKey, descriptor) {
                const classStash = getOrCreateClassStash(target);
                const propertyStash = getOrCreateEmptyPropertyStash(target, propertyKey);
                const classConstructor = target.constructor;
                mergePropertyOptions(classStash, propertyStash, classConstructor, propertyKey, options, descriptor);
              }

              if (target === undefined) {
                return property({
                  type: undefined
                });
              } else if (typeof propertyKey === 'undefined') {
                options = target;
                return normalized;
              } else {
                normalized(target, propertyKey, descriptor);
                return undefined;
              }
            }

            function getDefaultFromInitializer(initializer) {
              let value;

              try {
                value = initializer();
              } catch (e) {
                return initializer;
              }

              if (typeof value !== 'object' || value === null) {
                return value;
              } else {
                return initializer;
              }
            }

            function extractActualDefaultValues(classConstructor) {
              let dummyObj;

              try {
                dummyObj = new classConstructor();
              } catch (e) {

                return {};
              }

              return dummyObj;
            }

            function getOrCreateClassStash(target) {
              const cache = getClassCache(target.constructor);
              return cache;
            }

            function getOrCreateEmptyPropertyStash(target, propertyKey) {
              var _ref, _properties$_ref;

              const classStash = getClassCache(target.constructor);
              const ccclassProto = getSubDict(classStash, 'proto');
              const properties = getSubDict(ccclassProto, 'properties');
              const propertyStash = (_properties$_ref = properties[_ref = propertyKey]) !== null && _properties$_ref !== void 0 ? _properties$_ref : properties[_ref] = {};
              return propertyStash;
            }

            function getOrCreatePropertyStash(target, propertyKey, descriptor) {
              var _ref2, _properties$_ref2;

              const classStash = getClassCache(target.constructor);
              const ccclassProto = getSubDict(classStash, 'proto');
              const properties = getSubDict(ccclassProto, 'properties');
              const propertyStash = (_properties$_ref2 = properties[_ref2 = propertyKey]) !== null && _properties$_ref2 !== void 0 ? _properties$_ref2 : properties[_ref2] = {};
              propertyStash.__internalFlags |= PropertyStashInternalFlag.STANDALONE;

              if (descriptor && (descriptor.get || descriptor.set)) {
                if (descriptor.get) {
                  propertyStash.get = descriptor.get;
                }

                if (descriptor.set) {
                  propertyStash.set = descriptor.set;
                }
              } else {
                setDefaultValue(classStash, propertyStash, target.constructor, propertyKey, descriptor);
              }

              return propertyStash;
            }

            function mergePropertyOptions(cache, propertyStash, ctor, propertyKey, options, descriptor) {
              let fullOptions;
              const isGetset = descriptor && (descriptor.get || descriptor.set);

              if (options) {
                fullOptions = getFullFormOfProperty(options, isGetset);
              }

              const propertyRecord = js.mixin(propertyStash, fullOptions || options || {});

              if (isGetset) {

                if (descriptor.get) {
                  propertyRecord.get = descriptor.get;
                }

                if (descriptor.set) {
                  propertyRecord.set = descriptor.set;
                }
              } else {

                setDefaultValue(cache, propertyRecord, ctor, propertyKey, descriptor);
              }
            }

            function setDefaultValue(classStash, propertyStash, classConstructor, propertyKey, descriptor) {
              if (descriptor) {
                if (descriptor.initializer) {
                  propertyStash.default = getDefaultFromInitializer(descriptor.initializer);
                }
              } else {
                const actualDefaultValues = classStash.default || (classStash.default = extractActualDefaultValues(classConstructor));

                if (actualDefaultValues.hasOwnProperty(propertyKey)) {
                  propertyStash.default = actualDefaultValues[propertyKey];
                }
              }
            }

            const sMetadataTag = Symbol('cc:SerializationMetadata');
            function getSerializationMetadata(constructor) {
              return constructor[sMetadataTag];
            }
            function getOrCreateSerializationMetadata(constructor) {
              var _ref, _ref$sMetadataTag;

              return (_ref$sMetadataTag = (_ref = constructor)[sMetadataTag]) !== null && _ref$sMetadataTag !== void 0 ? _ref$sMetadataTag : _ref[sMetadataTag] = {};
            }

            const serializable = exports('bK', (target, propertyKey, descriptor) => {
              const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptor);
              setImplicitSerializable(propertyStash);
            });
            function formerlySerializedAs(name) {
              return (target, propertyKey, descriptor) => {
                const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptor);
                propertyStash.formerlySerializedAs = name;
                setImplicitSerializable(propertyStash);
              };
            }
            const editorOnly = exports('eE', (target, propertyKey, descriptor) => {
              const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptor);
              propertyStash.editorOnly = true;
              setImplicitSerializable(propertyStash);
            });

            function setImplicitSerializable(propertyStash) {
              propertyStash.__internalFlags |= PropertyStashInternalFlag.IMPLICIT_SERIALIZABLE;
            }

            const uniquelyReferenced =  emptyDecorator ;

            const executeInEditMode = exports('bI',  emptySmartClassDecorator);
            const menu = exports('bO',  emptyDecoratorFn);
            const playOnFocus = exports('eR',  emptySmartClassDecorator);
            const inspector =  emptyDecoratorFn;
            const icon =  emptyDecoratorFn;
            const help = exports('bM',  emptyDecoratorFn);
            const editable = exports('bF',  emptyDecorator );
            const visible = exports('bQ',  emptyDecoratorFn );
            const readOnly =  emptyDecorator ;
            const displayName = exports('dk',  emptyDecoratorFn );
            const tooltip = exports('bP',  emptyDecoratorFn );
            const range = exports('cd',  emptyDecoratorFn );
            const rangeMin = exports('es',  emptyDecoratorFn );
            const rangeMax = exports('et',  emptyDecoratorFn );
            const rangeStep =  emptyDecoratorFn ;
            const slide = exports('ct',  emptyDecorator );
            const displayOrder = exports('d9',  emptyDecoratorFn );
            const radian = exports('dg',  emptyDecorator );
            const multiline = exports('e8',  emptyDecorator );
            const disallowAnimation = exports('bJ',  emptyDecorator );

            const integer = type(CCInteger);
            const float = type(CCFloat);
            const boolean = type(CCBoolean);
            const string = exports('e0', type(CCString));
            function type(type) {
              return property({
                type
              });
            }

            const override = exports('c8', (target, propertyKey, descriptor) => {
              const propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptor);
              propertyStash.override = true;
            });

            let _Symbol$iterator;

            var _dec, _class, _class2, _descriptor, _descriptor2, _temp;
            let KeyframeCurve = (_dec = ccclass('cc.KeyframeCurve'), _dec(_class = (_class2 = (_temp = (_Symbol$iterator = Symbol.iterator, class KeyframeCurve {
              constructor() {
                _initializerDefineProperty(this, "_times", _descriptor, this);

                _initializerDefineProperty(this, "_values", _descriptor2, this);
              }

              get keyFramesCount() {
                return this._times.length;
              }

              get rangeMin() {
                return this._times[0];
              }

              get rangeMax() {
                return this._times[this._values.length - 1];
              }

              [_Symbol$iterator]() {
                let index = 0;
                return {
                  next: () => {
                    if (index >= this._times.length) {
                      return {
                        done: true,
                        value: undefined
                      };
                    } else {
                      const value = [this._times[index], this._values[index]];
                      ++index;
                      return {
                        done: false,
                        value
                      };
                    }
                  }
                };
              }

              keyframes() {
                return this;
              }

              times() {
                return this._times;
              }

              values() {
                return this._values;
              }

              getKeyframeTime(index) {
                return this._times[index];
              }

              getKeyframeValue(index) {
                return this._values[index];
              }

              addKeyFrame(time, keyframeValue) {
                return this._insertNewKeyframe(time, keyframeValue);
              }

              removeKeyframe(index) {
                this._times.splice(index, 1);

                this._values.splice(index, 1);
              }

              indexOfKeyframe(time) {
                return binarySearchEpsilon(this._times, time);
              }

              updateTime(index, time) {
                const value = this._values[index];
                this.removeKeyframe(index);

                this._insertNewKeyframe(time, value);
              }

              assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.slice());
                } else {
                  const keyframes = Array.from(times);
                  this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => value));
                }
              }

              clear() {
                this._times.length = 0;
                this._values.length = 0;
              }

              searchKeyframe(time) {
                return binarySearchEpsilon(this._times, time);
              }

              setKeyframes(times, values) {
                assertIsTrue(times.length === values.length);
                assertIsTrue(isSorted(times));
                this._times = times;
                this._values = values;
              }

              _insertNewKeyframe(time, value) {
                const times = this._times;
                const values = this._values;
                const nFrames = times.length;
                const index = binarySearchEpsilon(times, time);

                if (index >= 0) {
                  return index;
                }

                const iNext = ~index;

                if (iNext === 0) {
                  times.unshift(time);
                  values.unshift(value);
                } else if (iNext === nFrames) {
                  times.push(time);
                  values.push(value);
                } else {
                  assertIsTrue(nFrames > 1);
                  times.splice(iNext - 1, 0, time);
                  values.splice(iNext - 1, 0, value);
                }

                return iNext;
              }

            }), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_times", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_values", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2)) || _class);

            function isSorted(values) {
              return values.every((value, index, array) => index === 0 || value > array[index - 1] || approx(value, array[index - 1], 1e-6));
            }

            let RealInterpolationMode;

            (function (RealInterpolationMode) {
              RealInterpolationMode[RealInterpolationMode["LINEAR"] = 0] = "LINEAR";
              RealInterpolationMode[RealInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
              RealInterpolationMode[RealInterpolationMode["CUBIC"] = 2] = "CUBIC";
            })(RealInterpolationMode || (RealInterpolationMode = exports('gA', {})));

            let ExtrapolationMode;

            (function (ExtrapolationMode) {
              ExtrapolationMode[ExtrapolationMode["LINEAR"] = 0] = "LINEAR";
              ExtrapolationMode[ExtrapolationMode["CLAMP"] = 1] = "CLAMP";
              ExtrapolationMode[ExtrapolationMode["LOOP"] = 2] = "LOOP";
              ExtrapolationMode[ExtrapolationMode["PING_PONG"] = 3] = "PING_PONG";
            })(ExtrapolationMode || (ExtrapolationMode = exports('gB', {})));

            let TangentWeightMode;

            (function (TangentWeightMode) {
              TangentWeightMode[TangentWeightMode["NONE"] = 0] = "NONE";
              TangentWeightMode[TangentWeightMode["LEFT"] = 1] = "LEFT";
              TangentWeightMode[TangentWeightMode["RIGHT"] = 2] = "RIGHT";
              TangentWeightMode[TangentWeightMode["BOTH"] = 3] = "BOTH";
            })(TangentWeightMode || (TangentWeightMode = exports('gC', {})));

            function solveCubic(coeff0, coeff1, coeff2, coeff3, solutions) {
              const a = coeff2 / coeff3;
              const b = coeff1 / coeff3;
              const c = coeff0 / coeff3;
              const sqrA = a * a;
              const p = 1.0 / 3.0 * (-1.0 / 3 * sqrA + b);
              const q = 1.0 / 2.0 * (2.0 / 27.0 * a * sqrA - 1.0 / 3 * a * b + c);
              const cubicP = p * p * p;
              const d = q * q + cubicP;
              let nSolutions = 0;

              if (isZero(d)) {
                if (isZero(q)) {
                  solutions[0] = 0;
                  return 1;
                } else {
                  const u = Math.cbrt(-q);
                  solutions[0] = 2 * u;
                  solutions[1] = -u;
                  return 2;
                }
              } else if (d < 0) {
                const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cubicP));
                const t = 2 * Math.sqrt(-p);
                solutions[0] = t * Math.cos(phi);
                solutions[1] = -t * Math.cos(phi + Math.PI / 3);
                solutions[2] = -t * Math.cos(phi - Math.PI / 3);
                nSolutions = 3;
              } else {
                const sqrtD = Math.sqrt(d);
                const u = Math.cbrt(sqrtD - q);
                const v = -Math.cbrt(sqrtD + q);
                solutions[0] = u + v;
                nSolutions = 1;
              }

              const sub = 1.0 / 3 * a;

              for (let i = 0; i < nSolutions; ++i) {
                solutions[i] -= sub;
              }

              return nSolutions;
            }
            const EQN_EPS = 1e-9;

            function isZero(x) {
              return x > -EQN_EPS && x < EQN_EPS;
            }

            class Empty$1 {}

            const EditorExtendable = editorExtendableInternal();
            assertIsTrue(editorExtrasTag === '__editorExtras__', 'editorExtrasTag needs to be updated.');

            function editorExtendableInternal(Base, className) {
              {
                return Base !== null && Base !== void 0 ? Base : Empty$1;
              }
            }

            var _decorator = /*#__PURE__*/Object.freeze({
                __proto__: null,
                uniquelyReferenced: uniquelyReferenced,
                ccclass: ccclass,
                property: property,
                requireComponent: requireComponent,
                executionOrder: executionOrder,
                disallowMultiple: disallowMultiple,
                allowReplicated: allowReplicated,
                executeInEditMode: executeInEditMode,
                menu: menu,
                playOnFocus: playOnFocus,
                inspector: inspector,
                icon: icon,
                help: help,
                type: type,
                integer: integer,
                float: float,
                boolean: boolean,
                string: string
            });
            exports('eN', _decorator);

            class Cache {
              constructor(map) {
                this._map = null;
                this._count = 0;

                if (map) {
                  this._map = map;
                  this._count = Object.keys(map).length;
                } else {
                  this._map = js.createMap(true);
                  this._count = 0;
                }
              }

              add(key, val) {
                if (!(key in this._map)) {
                  this._count++;
                }

                return this._map[key] = val;
              }

              get(key) {
                return this._map[key];
              }

              has(key) {
                return key in this._map;
              }

              remove(key) {
                const out = this._map[key];

                if (key in this._map) {
                  delete this._map[key];
                  this._count--;
                }

                return out;
              }

              clear() {
                if (this._count !== 0) {
                  this._map = js.createMap(true);
                  this._count = 0;
                }
              }

              forEach(func) {
                for (const key in this._map) {
                  func(this._map[key], key);
                }
              }

              find(predicate) {
                for (const key in this._map) {
                  if (predicate(this._map[key], key)) {
                    return this._map[key];
                  }
                }

                return null;
              }

              get count() {
                return this._count;
              }

              destroy() {
                this._map = null;
              }

            }

            class Pipeline {
              constructor(name, funcs) {
                this.id = Pipeline._pipelineId++;
                this.name = '';
                this.pipes = [];
                this.name = name;

                for (let i = 0, l = funcs.length; i < l; i++) {
                  this.pipes.push(funcs[i]);
                }
              }

              insert(func, index) {
                if (index > this.pipes.length) {
                  warnID(4921);
                  return this;
                }

                this.pipes.splice(index, 0, func);
                return this;
              }

              append(func) {
                this.pipes.push(func);
                return this;
              }

              remove(index) {
                this.pipes.splice(index, 1);
                return this;
              }

              sync(task) {
                const pipes = this.pipes;

                if (pipes.length === 0) {
                  return null;
                }

                task.isFinish = false;

                for (let i = 0, l = pipes.length; i < l;) {
                  const pipe = pipes[i];
                  const result = pipe(task);

                  if (result) {
                    task.isFinish = true;
                    return result;
                  }

                  i++;

                  if (i !== l) {
                    task.input = task.output;
                    task.output = null;
                  }
                }

                task.isFinish = true;
                return task.output;
              }

              async(task) {
                const pipes = this.pipes;

                if (pipes.length === 0) {
                  return;
                }

                task.isFinish = false;

                this._flow(0, task);
              }

              _flow(index, task) {
                const pipe = this.pipes[index];
                pipe(task, result => {
                  if (result) {
                    task.isFinish = true;
                    task.dispatch('complete', result);
                  } else {
                    index++;

                    if (index < this.pipes.length) {
                      task.input = task.output;
                      task.output = null;

                      this._flow(index, task);
                    } else {
                      task.isFinish = true;
                      task.dispatch('complete', result, task.output);
                    }
                  }
                });
              }

            }
            Pipeline._pipelineId = 0;

            const assets =  new Cache();
            const files = new Cache();
            const parsed = new Cache();
            const bundles = new Cache();
            const pipeline = new Pipeline('normal load', []);
            const fetchPipeline = new Pipeline('fetch', []);
            const transformPipeline = new Pipeline('transform url', []);
            const references =  null;
            let RequestType;

            (function (RequestType) {
              RequestType["UUID"] = "uuid";
              RequestType["PATH"] = "path";
              RequestType["DIR"] = "dir";
              RequestType["URL"] = "url";
              RequestType["SCENE"] = "scene";
            })(RequestType || (RequestType = {}));

            const presets = {
              default: {
                priority: 0
              },
              preload: {
                maxConcurrency: 6,
                maxRequestsPerFrame: 2,
                priority: -1
              },
              scene: {
                maxConcurrency: 20,
                maxRequestsPerFrame: 20,
                priority: 1
              },
              bundle: {
                maxConcurrency: 20,
                maxRequestsPerFrame: 20,
                priority: 2
              },
              remote: {
                maxRetryCount: 4
              }
            };
            let BuiltinBundleName;

            (function (BuiltinBundleName) {
              BuiltinBundleName["RESOURCES"] = "resources";
              BuiltinBundleName["MAIN"] = "main";
              BuiltinBundleName["START_SCENE"] = "start-scene";
            })(BuiltinBundleName || (BuiltinBundleName = {}));

            class Task {
              static create(options) {
                let out;

                if (Task._deadPool.length !== 0) {
                  out = Task._deadPool.pop();
                  out.set(options);
                } else {
                  out = new Task(options);
                }

                return out;
              }

              constructor(options) {
                this.id = Task._taskId++;
                this.onComplete = null;
                this.onProgress = null;
                this.onError = null;
                this.source = null;
                this.output = null;
                this.input = null;
                this.progress = null;
                this.options = null;
                this.isFinish = true;
                this.set(options);
              }

              set(options = Object.create(null)) {
                this.onComplete = options.onComplete || null;
                this.onProgress = options.onProgress || null;
                this.onError = options.onError || null;
                this.source = this.input = options.input;
                this.output = null;
                this.progress = options.progress;
                this.options = options.options || Object.create(null);
              }

              dispatch(event, param1, param2, param3, param4) {
                switch (event) {
                  case 'complete':
                    if (this.onComplete) {
                      this.onComplete(param1, param2);
                    }

                    break;

                  case 'progress':
                    if (this.onProgress) {
                      this.onProgress(param1, param2, param3, param4);
                    }

                    break;

                  case 'error':
                    if (this.onError) {
                      this.onError(param1, param2, param3, param4);
                    }

                    break;

                  default:
                    {
                      const str = `on${event[0].toUpperCase()}${event.substr(1)}`;

                      if (typeof this[str] === 'function') {
                        this[str](param1, param2, param3, param4);
                      }

                      break;
                    }
                }
              }

              recycle() {
                if (Task._deadPool.length === Task.MAX_DEAD_NUM) {
                  return;
                }

                this.onComplete = null;
                this.onProgress = null;
                this.onError = null;
                this.source = this.output = this.input = null;
                this.progress = null;
                this.options = null;

                Task._deadPool.push(this);
              }

            }
            Task.MAX_DEAD_NUM = 500;
            Task._taskId = 0;
            Task._deadPool = [];

            const HexChars = '0123456789abcdef'.split('');
            const _t = ['', '', '', ''];

            const UuidTemplate = _t.concat(_t, '-', _t, '-', _t, '-', _t, '-', _t, _t, _t);

            const Indices = UuidTemplate.map((x, i) => x === '-' ? NaN : i).filter(isFinite);
            function decodeUuid(base64) {
              const strs = base64.split('@');
              const uuid = strs[0];

              if (uuid.length !== 22) {
                return base64;
              }

              UuidTemplate[0] = base64[0];
              UuidTemplate[1] = base64[1];

              for (let i = 2, j = 2; i < 22; i += 2) {
                const lhs = BASE64_VALUES[base64.charCodeAt(i)];
                const rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
                UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
                UuidTemplate[Indices[j++]] = HexChars[(lhs & 3) << 2 | rhs >> 4];
                UuidTemplate[Indices[j++]] = HexChars[rhs & 0xF];
              }

              return base64.replace(uuid, UuidTemplate.join(''));
            }

            const _uuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
            function getUuidFromURL(url) {
              const matches = _uuidRegex.exec(url);

              if (matches) {
                return matches[1];
              }

              return '';
            }
            function getUrlWithUuid(uuid, options) {
              options = options || Object.create(null);
              options.__isNative__ = options.isNative;
              options.ext = options.nativeExt;
              const bundle = bundles.find(b => !!b.getAssetInfo(uuid));

              if (bundle) {
                options.bundle = bundle.name;
              }

              return transform(uuid, options);
            }
            function isScene(asset) {
              return !!asset && (asset instanceof legacyCC.SceneAsset || asset instanceof legacyCC.Scene);
            }
            function normalize(url) {
              if (url) {
                if (url.charCodeAt(0) === 46 && url.charCodeAt(1) === 47) {
                  url = url.slice(2);
                } else if (url.charCodeAt(0) === 47) {
                  url = url.slice(1);
                }
              }

              return url;
            }
            function transform(input, options) {
              const subTask = Task.create({
                input,
                options
              });
              const urls = [];

              try {
                const result = transformPipeline.sync(subTask);

                for (const requestItem of result) {
                  const url = requestItem.url;
                  requestItem.recycle();
                  urls.push(url);
                }
              } catch (e) {
                for (const item of subTask.output) {
                  item.recycle();
                }

                error(e.message, e.stack);
              }

              subTask.recycle();
              return urls.length > 1 ? urls : urls[0];
            }

            var helper = /*#__PURE__*/Object.freeze({
                __proto__: null,
                getUuidFromURL: getUuidFromURL,
                getUrlWithUuid: getUrlWithUuid,
                isScene: isScene,
                normalize: normalize,
                transform: transform,
                decodeUuid: decodeUuid
            });

            class GarbageCollectionManager {
              constructor() {
                this._finalizationRegistry =  null;
              }

              registerGCObject(gcObject) {
                {
                  return gcObject;
                }
              }

              unregisterGCObject(gcObject) {
              }

              init() {}

              finalizationRegistryCallback(gcObject) {
                if (gcObject.isValid) {
                  gcObject.destroy();
                }
              }

              destroy() {}

            }

            const garbageCollectionManager = new GarbageCollectionManager();

            var _dec$1, _class$1;
            let GCObject = (_dec$1 = ccclass('cc.GCObject'), _dec$1(_class$1 = class GCObject extends CCObject {
              constructor(...arg) {
                super(...arg);
                return garbageCollectionManager.registerGCObject(this);
              }

              equals(gcObject) {
                if (!gcObject) {
                  return false;
                }

                {
                  return gcObject === this;
                }
              }

              destroy() {
                garbageCollectionManager.unregisterGCObject(this);
                return super.destroy();
              }

            }) || _class$1);

            var _dec$2, _class$2, _class2$1, _descriptor$1, _temp$1;
            let Asset = exports('c9', (_dec$2 = ccclass('cc.Asset'), _dec$2(_class$2 = (_class2$1 = (_temp$1 = class Asset extends Eventify(GCObject) {
              static deserialize(data) {
                return legacyCC.deserialize(data);
              }

              get nativeUrl() {
                if (!this._nativeUrl) {
                  if (!this._native) return '';
                  const name = this._native;

                  if (name.charCodeAt(0) === 47) {
                    return name.slice(1);
                  }

                  if (name.charCodeAt(0) === 46) {
                    this._nativeUrl = getUrlWithUuid(this._uuid, {
                      nativeExt: name,
                      isNative: true
                    });
                  } else {
                    this._nativeUrl = getUrlWithUuid(this._uuid, {
                      __nativeName__: name,
                      nativeExt: extname(name),
                      isNative: true
                    });
                  }
                }

                return this._nativeUrl;
              }

              get _nativeAsset() {
                return this._file;
              }

              set _nativeAsset(obj) {
                this._file = obj;
              }

              constructor(...args) {
                super(...args);
                this.loaded = true;

                _initializerDefineProperty(this, "_native", _descriptor$1, this);

                this._nativeUrl = '';
                this._file = null;
                this._ref = 0;
                Object.defineProperty(this, '_uuid', {
                  value: '',
                  writable: true
                });
              }

              toString() {
                return this.nativeUrl;
              }

              serialize() {}

              _setRawAsset(filename, inLibrary = true) {
                if (inLibrary !== false) {
                  this._native = filename || '';
                } else {
                  this._native = `/${filename}`;
                }
              }

              get _nativeDep() {
                if (this._native) {
                  return {
                    __isNative__: true,
                    uuid: this._uuid,
                    ext: this._native
                  };
                }

                return undefined;
              }

              get refCount() {
                return this._ref;
              }

              addRef() {
                this._ref++;
                return this;
              }

              decRef(autoRelease = true) {
                if (this._ref > 0) {
                  this._ref--;
                }

                if (autoRelease) {
                  legacyCC.assetManager._releaseManager.tryRelease(this);
                }

                return this;
              }

              onLoaded() {}

              initDefault(uuid) {
                if (uuid) {
                  this._uuid = uuid;
                }

                this.isDefault = true;
              }

              validate() {
                return true;
              }

              destroy() {
                debug(getError(12101, this._uuid));
                return super.destroy();
              }

            }, _temp$1), (_descriptor$1 = _applyDecoratedDescriptor(_class2$1.prototype, "_native", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _applyDecoratedDescriptor(_class2$1.prototype, "_nativeAsset", [property], Object.getOwnPropertyDescriptor(_class2$1.prototype, "_nativeAsset"), _class2$1.prototype)), _class2$1)) || _class$2));
            Asset.prototype.createNode = null;
            legacyCC.Asset = Asset;

            var _dec$3, _class$3, _dec2, _class2$2, _dec3, _class3;
            let Script = exports('fG', (_dec$3 = ccclass('cc.Script'), _dec$3(_class$3 = class Script extends Asset {}) || _class$3));
            legacyCC._Script = Script;
            let JavaScript = exports('fH', (_dec2 = ccclass('cc.JavaScript'), _dec2(_class2$2 = class JavaScript extends Script {}) || _class2$2));
            legacyCC._JavaScript = JavaScript;
            let TypeScript = exports('fI', (_dec3 = ccclass('cc.TypeScript'), _dec3(_class3 = class TypeScript extends Script {}) || _class3));
            legacyCC._TypeScript = TypeScript;

            var _dec$4, _dec2$1, _dec3$1, _dec4, _class$4, _class2$3, _descriptor$2, _descriptor2$1, _descriptor3, _class3$1, _temp$2;
            const idGenerator = new IDGenerator('Comp');
            const IsOnLoadCalled$1 = CCObject.Flags.IsOnLoadCalled;
            const NullNode = null;
            let Component = exports('ce', (_dec$4 = ccclass('cc.Component'), _dec2$1 = displayName(), _dec3$1 = type(Script), _dec4 = tooltip(), _dec$4(_class$4 = (_class2$3 = (_temp$2 = _class3$1 = class Component extends CCObject {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "node", _descriptor$2, this);

                _initializerDefineProperty(this, "_enabled", _descriptor2$1, this);

                _initializerDefineProperty(this, "__prefab", _descriptor3, this);

                this._sceneGetter = null;
                this._id = idGenerator.getNewId();
              }

              get name() {
                if (this._name) {
                  return this._name;
                }

                let className = getClassName(this);
                const trimLeft = className.lastIndexOf('.');

                if (trimLeft >= 0) {
                  className = className.slice(trimLeft + 1);
                }

                if (this.node) {
                  return `${this.node.name}<${className}>`;
                } else {
                  return className;
                }
              }

              set name(value) {
                this._name = value;
              }

              get uuid() {
                return this._id;
              }

              get __scriptAsset() {
                return null;
              }

              get enabled() {
                return this._enabled;
              }

              set enabled(value) {
                if (this._enabled !== value) {
                  this._enabled = value;

                  if (this.node.activeInHierarchy) {
                    const compScheduler = legacyCC.director._compScheduler;

                    if (value) {
                      compScheduler.enableComp(this);
                    } else {
                      compScheduler.disableComp(this);
                    }
                  }
                }
              }

              get enabledInHierarchy() {
                return this._enabled && this.node && this.node.activeInHierarchy;
              }

              get _isOnLoadCalled() {
                return this._objFlags & IsOnLoadCalled$1;
              }

              _getRenderScene() {
                if (this._sceneGetter) {
                  return this._sceneGetter();
                }

                return this.node.scene.renderScene;
              }

              addComponent(typeOrClassName) {
                return this.node.addComponent(typeOrClassName);
              }

              getComponent(typeOrClassName) {
                return this.node.getComponent(typeOrClassName);
              }

              getComponents(typeOrClassName) {
                return this.node.getComponents(typeOrClassName);
              }

              getComponentInChildren(typeOrClassName) {
                return this.node.getComponentInChildren(typeOrClassName);
              }

              getComponentsInChildren(typeOrClassName) {
                return this.node.getComponentsInChildren(typeOrClassName);
              }

              destroy() {

                if (super.destroy()) {
                  if (this._enabled && this.node.activeInHierarchy) {
                    legacyCC.director._compScheduler.disableComp(this);
                  }

                  return true;
                }

                return false;
              }

              _onPreDestroy() {
                this.unscheduleAllCallbacks();

                legacyCC.director._nodeActivator.destroyComp(this);

                this.node._removeComponent(this);
              }

              _instantiate(cloned) {
                if (!cloned) {
                  cloned = legacyCC.instantiate._clone(this, this);
                }

                if (cloned) {
                  cloned.node = NullNode;
                }

                return cloned;
              }

              schedule(callback, interval = 0, repeat = legacyCC.macro.REPEAT_FOREVER, delay = 0) {
                assertID(callback, 1619);
                interval = interval || 0;
                assertID(interval >= 0, 1620);
                repeat = Number.isNaN(repeat) ? legacyCC.macro.REPEAT_FOREVER : repeat;
                delay = delay || 0;
                const scheduler = legacyCC.director.getScheduler();
                const paused = scheduler.isTargetPaused(this);
                scheduler.schedule(callback, this, interval, repeat, delay, paused);
              }

              scheduleOnce(callback, delay = 0) {
                this.schedule(callback, 0, 0, delay);
              }

              unschedule(callback_fn) {
                if (!callback_fn) {
                  return;
                }

                legacyCC.director.getScheduler().unschedule(callback_fn, this);
              }

              unscheduleAllCallbacks() {
                legacyCC.director.getScheduler().unscheduleAllForTarget(this);
              }

            }, _class3$1.system = null, _temp$2), (_applyDecoratedDescriptor(_class2$3.prototype, "__scriptAsset", [_dec2$1, _dec3$1, _dec4, disallowAnimation], Object.getOwnPropertyDescriptor(_class2$3.prototype, "__scriptAsset"), _class2$3.prototype), _descriptor$2 = _applyDecoratedDescriptor(_class2$3.prototype, "node", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return NullNode;
              }
            }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor3 = _applyDecoratedDescriptor(_class2$3.prototype, "__prefab", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$3)) || _class$4));
            const proto = Component.prototype;
            proto.update = null;
            proto.lateUpdate = null;
            proto.__preload = null;
            proto.onLoad = null;
            proto.start = null;
            proto.onEnable = null;
            proto.onDisable = null;
            proto.onDestroy = null;
            proto.onFocusInEditor = null;
            proto.onLostFocusInEditor = null;
            proto.resetInEditor = null;
            proto._getLocalBounds = null;
            proto.onRestore = null;
            Component._requireComponent = null;
            Component._executionOrder = 0;

            value(Component, '_registerEditorProps', (cls, props) => {
              let reqComp = props.requireComponent;

              if (reqComp) {
                if (Array.isArray(reqComp)) {
                  reqComp = reqComp.filter(Boolean);
                }

                cls._requireComponent = reqComp;
              }

              const order = props.executionOrder;

              if (order && typeof order === 'number') {
                cls._executionOrder = order;
              }
            });
            legacyCC.Component = Component;

            var _dec$5, _dec2$2, _class$5, _class2$4, _descriptor$3, _temp$3;
            let MissingScript = exports('gh', (_dec$5 = ccclass('cc.MissingScript'), _dec2$2 = inspector(), _dec$5(_class$5 = _dec2$2(_class$5 = (_class2$4 = (_temp$3 = class MissingScript extends Component {
              static safeFindClass(id) {
                const cls = _getClassById(id);

                if (cls) {
                  return cls;
                }

                legacyCC.deserialize.reportMissingClass(id);
                return undefined;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_$erialized", _descriptor$3, this);
              }

              onLoad() {
                warnID(4600, this.node.name);
              }

            }, _temp$3), (_descriptor$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_$erialized", [serializable, editorOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$4)) || _class$5) || _class$5));
            legacyCC._MissingScript = MissingScript;

            try {
              const props = MissingScript.__values__;

              if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
                error(`The '_$erialized' prop in MissingScript is missing. Please contact jare.`);
                error(`    Error props: ['${props}']`);
              }
            } catch (e) {
              error(`Error when checking MissingScript 5, ${e}`);
            }

            const _PORTRAIT = 1;

            const _PORTRAIT_UPSIDE_DOWN = _PORTRAIT << 1;

            const _LEFT = _PORTRAIT << 2;

            const _RIGHT = _PORTRAIT << 3;

            const _LANDSCAPE = _LEFT | _RIGHT;

            const _AUTO = _PORTRAIT | _LANDSCAPE;

            let Orientation;

            (function (Orientation) {
              Orientation[Orientation["PORTRAIT"] = _PORTRAIT] = "PORTRAIT";
              Orientation[Orientation["PORTRAIT_UPSIDE_DOWN"] = _PORTRAIT_UPSIDE_DOWN] = "PORTRAIT_UPSIDE_DOWN";
              Orientation[Orientation["LANDSCAPE_LEFT"] = _LEFT] = "LANDSCAPE_LEFT";
              Orientation[Orientation["LANDSCAPE_RIGHT"] = _RIGHT] = "LANDSCAPE_RIGHT";
              Orientation[Orientation["LANDSCAPE"] = _LANDSCAPE] = "LANDSCAPE";
              Orientation[Orientation["AUTO"] = _AUTO] = "AUTO";
            })(Orientation || (Orientation = {}));

            const orientationMap = {
              0: Orientation.PORTRAIT,
              '-90': Orientation.LANDSCAPE_LEFT,
              90: Orientation.LANDSCAPE_RIGHT,
              180: Orientation.PORTRAIT_UPSIDE_DOWN
            };

            class ScreenAdapter extends EventTarget {
              get supportFullScreen() {
                return false;
              }

              get isFullScreen() {
                return false;
              }

              get devicePixelRatio() {
                return jsb.device.getDevicePixelRatio() || 1;
              }

              get windowSize() {
                const dpr = this.devicePixelRatio;
                const roundWidth = Math.round(window.innerWidth);
                const roundHeight = Math.round(window.innerHeight);
                return new Size(roundWidth * dpr, roundHeight * dpr);
              }

              set windowSize(size) {
                console.warn('Setting window size is not supported yet.');
              }

              get resolution() {
                const windowSize = this.windowSize;
                const resolutionScale = this.resolutionScale;
                return new Size(windowSize.width * resolutionScale, windowSize.height * resolutionScale);
              }

              get resolutionScale() {
                return this._resolutionScale;
              }

              set resolutionScale(v) {
                var _this$_cbToUpdateFram;

                if (v === this._resolutionScale) {
                  return;
                }

                this._resolutionScale = v;
                (_this$_cbToUpdateFram = this._cbToUpdateFrameBuffer) === null || _this$_cbToUpdateFram === void 0 ? void 0 : _this$_cbToUpdateFram.call(this);
              }

              get orientation() {
                return orientationMap[jsb.device.getDeviceOrientation()];
              }

              set orientation(value) {
                console.warn('Setting orientation is not supported yet.');
              }

              get safeAreaEdge() {
                const nativeSafeArea = jsb.device.getSafeAreaEdge();
                const dpr = this.devicePixelRatio;
                let topEdge = nativeSafeArea.x * dpr;
                let bottomEdge = nativeSafeArea.z * dpr;
                let leftEdge = nativeSafeArea.y * dpr;
                let rightEdge = nativeSafeArea.w * dpr;
                const orientation = this.orientation;

                if (orientation === Orientation.PORTRAIT) {
                  if (topEdge < bottomEdge) {
                    topEdge = bottomEdge;
                  } else {
                    bottomEdge = topEdge;
                  }
                } else if (leftEdge < rightEdge) {
                  leftEdge = rightEdge;
                } else {
                  rightEdge = leftEdge;
                }

                return {
                  top: topEdge,
                  bottom: bottomEdge,
                  left: leftEdge,
                  right: rightEdge
                };
              }

              get isProportionalToFrame() {
                return this._isProportionalToFrame;
              }

              set isProportionalToFrame(v) {}

              constructor() {
                super();
                this.isFrameRotated = false;
                this.handleResizeEvent = true;
                this._cbToUpdateFrameBuffer = void 0;
                this._resolutionScale = 1;
                this._isProportionalToFrame = false;

                this._registerEvent();
              }

              init(options, cbToRebuildFrameBuffer) {
                this._cbToUpdateFrameBuffer = cbToRebuildFrameBuffer;

                this._cbToUpdateFrameBuffer();
              }

              requestFullScreen() {
                return Promise.reject(new Error('request fullscreen has not been supported yet on this platform.'));
              }

              exitFullScreen() {
                return Promise.reject(new Error('exit fullscreen has not been supported yet on this platform.'));
              }

              _registerEvent() {
                jsb.onResize = size => {
                  if (size.width === 0 || size.height === 0) return;
                  size.width /= this.devicePixelRatio;
                  size.height /= this.devicePixelRatio;
                  window.resize(size.width, size.height);
                  this.emit('window-resize');
                };

                jsb.onOrientationChanged = event => {
                  this.emit('orientation-change');
                };
              }

            }

            const screenAdapter = exports('ev', new ScreenAdapter());

            class Screen {
              _init(options) {
                screenAdapter.init(options, () => {
                  var _director$root;

                  const director = legacyCC.director;

                  if (!((_director$root = director.root) === null || _director$root === void 0 ? void 0 : _director$root.pipeline)) {
                    warnID(1220);
                    return;
                  }

                  director.root.pipeline.pipelineSceneData.shadingScale = screenAdapter.resolutionScale;
                });
              }

              get windowSize() {
                return screenAdapter.windowSize;
              }

              set windowSize(size) {
                screenAdapter.windowSize = size;
              }

              get resolution() {
                return screenAdapter.resolution;
              }

              get supportsFullScreen() {
                return screenAdapter.supportFullScreen;
              }

              fullScreen() {
                return screenAdapter.isFullScreen;
              }

              requestFullScreen(element, onFullScreenChange, onFullScreenError) {
                if (arguments.length > 0) {
                  warnID(1400, 'screen.requestFullScreen(element, onFullScreenChange?, onFullScreenError?)', 'screen.requestFullScreen(): Promise');
                }

                return screenAdapter.requestFullScreen().then(() => {
                  onFullScreenChange === null || onFullScreenChange === void 0 ? void 0 : onFullScreenChange();
                }).catch(err => {
                  console.error(err);
                  onFullScreenError === null || onFullScreenError === void 0 ? void 0 : onFullScreenError();
                });
              }

              exitFullScreen() {
                return screenAdapter.exitFullScreen();
              }

              autoFullScreen(element, onFullScreenChange) {
                var _this$requestFullScre;

                (_this$requestFullScre = this.requestFullScreen(element, onFullScreenChange)) === null || _this$requestFullScre === void 0 ? void 0 : _this$requestFullScre.catch(e => {});
              }

              disableAutoFullScreen(element) {}

            }

            const screen = exports('ee', new Screen());
            legacyCC.screen = screen;

            const sys = exports('eo', {
              Feature,

              hasFeature(feature) {
                return systemInfo.hasFeature(feature);
              },

              NetworkType,
              Language,
              OS,
              Platform,
              BrowserType,
              isNative: systemInfo.isNative,
              isBrowser: systemInfo.isBrowser,
              isMobile: systemInfo.isMobile,
              isLittleEndian: systemInfo.isLittleEndian,
              platform: systemInfo.platform,
              language: systemInfo.language,
              languageCode: systemInfo.nativeLanguage,
              os: systemInfo.os,
              osVersion: systemInfo.osVersion,
              osMainVersion: systemInfo.osMainVersion,
              browserType: systemInfo.browserType,
              browserVersion: systemInfo.browserVersion,
              windowPixelResolution: screen.windowSize,
              capabilities: {
                canvas: true,
                opengl: true,
                webp: systemInfo.hasFeature(Feature.WEBP),
                imageBitmap: systemInfo.hasFeature(Feature.IMAGE_BITMAP),
                touches: systemInfo.hasFeature(Feature.INPUT_TOUCH),
                mouse: systemInfo.hasFeature(Feature.EVENT_MOUSE),
                keyboard: systemInfo.hasFeature(Feature.EVENT_KEYBOARD),
                accelerometer: systemInfo.hasFeature(Feature.EVENT_ACCELEROMETER)
              },
              localStorage: {},

              getNetworkType() {
                return systemInfo.networkType;
              },

              getBatteryLevel() {
                return systemInfo.getBatteryLevel();
              },

              garbageCollect() {
                systemInfo.triggerGC();
              },

              isObjectValid(obj) {
                if (obj === null || obj === undefined) {
                  return false;
                }

                return true;
              },

              dump() {
                let str = '';
                str += `isMobile : ${this.isMobile}\r\n`;
                str += `language : ${this.language}\r\n`;
                str += `browserType : ${this.browserType}\r\n`;
                str += `browserVersion : ${this.browserVersion}\r\n`;
                str += `capabilities : ${JSON.stringify(this.capabilities)}\r\n`;
                str += `os : ${this.os}\r\n`;
                str += `osVersion : ${this.osVersion}\r\n`;
                str += `platform : ${this.platform}\r\n`;
                str += `Using ${legacyCC.game.renderType === legacyCC.game.RENDER_TYPE_WEBGL ? 'WEBGL' : 'CANVAS'} renderer.\r\n`;
                log(str);
              },

              openURL(url) {
                systemInfo.openURL(url);
              },

              now() {
                return systemInfo.now();
              },

              restartVM() {
                systemInfo.restartJSVM();
              },

              getSafeAreaRect() {
                const locView = legacyCC.view;
                const edge = screenAdapter.safeAreaEdge;
                const windowSize = screenAdapter.windowSize;
                const leftBottom = new Vec2(edge.left, edge.bottom);
                const rightTop = new Vec2(windowSize.width - edge.right, windowSize.height - edge.top);

                locView._convertToUISpace(leftBottom);

                locView._convertToUISpace(rightTop);

                const x = leftBottom.x;
                const y = leftBottom.y;
                const width = rightTop.x - leftBottom.x;
                const height = rightTop.y - leftBottom.y;
                return new Rect(x, y, width, height);
              }

            });

            (function initSys() {
              try {
                let localStorage = sys.localStorage = window.localStorage;
                localStorage.setItem('storage', '');
                localStorage.removeItem('storage');
                localStorage = null;
              } catch (e) {
                const warn = function () {
                  warnID(5200);
                };

                sys.localStorage = {
                  getItem: warn,
                  setItem: warn,
                  clear: warn,
                  removeItem: warn
                };
              }

              sys.__isWebIOS14OrIPadOS14Env = (sys.os === OS.IOS || sys.os === OS.OSX) && systemInfo.isBrowser && /(OS 1[4-9])|(Version\/1[4-9])/.test(window.navigator.userAgent);
            })();

            legacyCC.sys = sys;

            const serializeTag = exports('fA', Symbol('[[Serialize]]'));
            const deserializeTag = exports('fz', Symbol('[[Deserialize]]'));

            const VERSION = 1;
            const MAGIC = 0x4E4F4343;
            const CHUNK_ALIGN_AS = 8;
            class CCON {
              constructor(document, chunks) {
                this._document = void 0;
                this._chunks = void 0;
                this._document = document;
                this._chunks = chunks;
              }

              get document() {
                return this._document;
              }

              get chunks() {
                return this._chunks;
              }

            }
            function parseCCONJson(json) {
              const cconPreface = json;
              return {
                chunks: cconPreface.chunks,
                document: cconPreface.document
              };
            }
            function decodeCCONBinary(bytes) {
              if (bytes.length < 16) {
                throw new InvalidCCONError(getError(13102));
              }

              const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
              const magic = dataView.getUint32(0, true);

              if (magic !== MAGIC) {
                throw new InvalidCCONError(getError(13100));
              }

              const version = dataView.getUint32(4, true);

              if (version !== VERSION) {
                throw new InvalidCCONError(getError(13101, version));
              }

              const dataByteLength = dataView.getUint32(8, true);

              if (dataByteLength !== dataView.byteLength) {
                throw new InvalidCCONError(getError(13102));
              }

              let chunksStart = 12;
              const jsonDataLength = dataView.getUint32(chunksStart, true);
              chunksStart += 4;
              const jsonData = new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, jsonDataLength);
              chunksStart += jsonDataLength;
              const jsonString = decodeJson(jsonData);
              let json;

              try {
                json = JSON.parse(jsonString);
              } catch (err) {
                throw new InvalidCCONError(err);
              }

              const chunks = [];

              while (chunksStart < dataView.byteLength) {
                if (chunksStart % CHUNK_ALIGN_AS !== 0) {
                  const padding = CHUNK_ALIGN_AS - chunksStart % CHUNK_ALIGN_AS;
                  chunksStart += padding;
                }

                const chunkDataLength = dataView.getUint32(chunksStart, true);
                chunksStart += 4;
                chunks.push(new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, chunkDataLength));
                chunksStart += chunkDataLength;
              }

              if (chunksStart !== dataView.byteLength) {
                throw new InvalidCCONError(getError(13102));
              }

              return new CCON(json, chunks);
            }

            function decodeJson(data) {
              if (typeof TextDecoder !== 'undefined') {
                return new TextDecoder().decode(data);
              } else if ('Buffer' in globalThis) {
                const {
                  Buffer
                } = globalThis;
                return Buffer.from(data.buffer, data.byteOffset, data.byteLength).toString();
              } else {
                throw new Error(getError(13104));
              }
            }

            class InvalidCCONError extends Error {}
            legacyCC.internal.parseCCONJson = parseCCONJson;
            legacyCC.internal.decodeCCONBinary = decodeCCONBinary;
            legacyCC.internal.CCON = CCON;

            function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue) {
              if (defaultValue instanceof legacyCC.ValueType) {
                if (!assumeHavePropIfIsValue) {
                  sources.push('if(prop){');
                }

                const ctorCode = getClassName(defaultValue);
                sources.push(`s._deserializeFastDefinedObject(o${accessorToSet},prop,${ctorCode});`);

                if (!assumeHavePropIfIsValue) {
                  sources.push(`}else o${accessorToSet}=null;`);
                }
              } else {
                sources.push(`
if (prop) {
    s._deserializeAndAssignField(o, prop, ${propNameLiteralToSet});
} else {
    o${accessorToSet}=null;
}
`);
              }
            }

            const compileDeserialize =  compileDeserializeJIT ;
            const DELIMITER = DELIMETER;
            const POSTFIX_TYPE = `${DELIMITER}type`;
            const POSTFIX_DEFAULT = `${DELIMITER}default`;
            const POSTFIX_FORMERLY_SERIALIZED_AS = `${DELIMITER}formerlySerializedAs`;

            function compileDeserializeJIT(self, klass) {
              const attrs = getClassAttrs(klass);
              const props = klass.__values__;
              const sources = ['var prop;'];
              const fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass));

              for (let p = 0; p < props.length; p++) {
                const propName = props[p];

                let accessorToSet;
                let propNameLiteralToSet;

                if (CCClass.IDENTIFIER_RE.test(propName)) {
                  propNameLiteralToSet = `"${propName}"`;
                  accessorToSet = `.${propName}`;
                } else {
                  propNameLiteralToSet = CCClass.escapeForJS(propName);
                  accessorToSet = `[${propNameLiteralToSet}]`;
                }

                let accessorToGet = accessorToSet;

                if (attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS]) {
                  const propNameToRead = attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS];

                  if (CCClass.IDENTIFIER_RE.test(propNameToRead)) {
                    accessorToGet = `.${propNameToRead}`;
                  } else {
                    accessorToGet = `[${CCClass.escapeForJS(propNameToRead)}]`;
                  }
                }

                sources.push(`prop=d${accessorToGet};`);
                sources.push(`if(typeof ${ '(prop)' }!=="undefined"){`);
                const defaultValue = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);

                if (fastMode) {
                  let isPrimitiveType;
                  const userType = attrs[propName + POSTFIX_TYPE];

                  if (defaultValue === undefined && userType) {
                    isPrimitiveType = userType instanceof PrimitiveType;
                  } else {
                    const defaultType = typeof defaultValue;
                    isPrimitiveType = defaultType === 'string' || defaultType === 'number' || defaultType === 'boolean';
                  }

                  if (isPrimitiveType) {
                    sources.push(`o${accessorToSet}=prop;`);
                  } else {
                    compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true);
                  }
                } else {
                  sources.push(`${`if(typeof ${ '(prop)' }!=="object"){` + 'o'}${accessorToSet}=prop;` + `}else{`);
                  compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false);
                  sources.push('}');
                }

                sources.push('}');
              }

              if (legacyCC.js.isChildClassOf(klass, legacyCC._BaseNode) || legacyCC.js.isChildClassOf(klass, legacyCC.Component)) {
                {
                  sources.push('d._id&&(o._id=d._id);');
                }
              }

              if (props[props.length - 1] === '_$erialized') {
                sources.push('o._$erialized=JSON.parse(JSON.stringify(d));');
                sources.push('s._fillPlainObject(o._$erialized,d);');
              }

              return Function('s', 'o', 'd', 'k', sources.join(''));
            }

            class DeserializerPool extends Pool$1 {
              constructor() {
                super(deserializer => {
                  deserializer.clear();
                }, 1);
              }

              get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
                const cache = this._get();

                if (cache) {
                  cache.reset(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
                  return cache;
                } else {
                  return new _Deserializer(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
                }
              }

            }

            class _Deserializer {
              constructor(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
                this.deserializedList = void 0;
                this.deserializedData = void 0;
                this._ignoreEditorOnly = void 0;
                this.result = result;
                this.customEnv = customEnv;
                this.deserializedList = [];
                this.deserializedData = null;
                this._classFinder = classFinder;
                this._reportMissingClass = reportMissingClass;
                this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
              }

              reset(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
                this.result = result;
                this.customEnv = customEnv;
                this._classFinder = classFinder;
                this._reportMissingClass = reportMissingClass;
                this._onDereferenced = classFinder === null || classFinder === void 0 ? void 0 : classFinder.onDereferenced;
              }

              clear() {
                this.result = null;
                this.customEnv = null;
                this.deserializedList.length = 0;
                this.deserializedData = null;
                this._classFinder = null;
                this._reportMissingClass = null;
                this._onDereferenced = null;
              }

              deserialize(serializedData) {
                let fromCCON = false;
                let jsonObj;

                if (serializedData instanceof CCON) {
                  fromCCON = true;
                  jsonObj = serializedData.document;

                  if (serializedData.chunks.length > 0) {
                    assertIsTrue(serializedData.chunks.length === 1);
                    this._mainBinChunk = serializedData.chunks[0];
                  }
                } else {
                  jsonObj = serializedData;
                }

                this._serializedData = jsonObj;
                this._context = {
                  fromCCON
                };
                const serializedRootObject = Array.isArray(jsonObj) ? jsonObj[0] : jsonObj;

                {
                  this.deserializedData = this._deserializeObject(serializedRootObject, 0);
                }

                this._serializedData = undefined;
                this._mainBinChunk = undefined;
                this._context = undefined;
                return this.deserializedData;
              }

              _deserializeObject(serialized, globalIndex, owner, propName) {
                switch (serialized.__type__) {
                  case 'TypedArray':
                    return this._deserializeTypedArrayView(serialized);

                  case 'TypedArrayRef':
                    return this._deserializeTypedArrayViewRef(serialized);

                  default:
                    if (serialized.__type__) {
                      return this._deserializeTypeTaggedObject(serialized, globalIndex, owner, propName);
                    } else if (!Array.isArray(serialized)) {
                      return this._deserializePlainObject(serialized);
                    } else {
                      return this._deserializeArray(serialized);
                    }

                }
              }

              _deserializeTypedArrayView(value) {
                return globalThis[value.ctor].from(value.array);
              }

              _deserializeTypedArrayViewRef(value) {
                const {
                  offset,
                  length,
                  ctor: constructorName
                } = value;
                const obj = new globalThis[constructorName](this._mainBinChunk.buffer, this._mainBinChunk.byteOffset + offset, length);
                return obj;
              }

              _deserializeArray(value) {
                const obj = new Array(value.length);
                let prop;

                for (let i = 0; i < value.length; i++) {
                  prop = value[i];

                  if (typeof prop === 'object' && prop) {
                    const isAssetType = this._deserializeAndAssignField(obj, prop, `${i}`);

                    if (isAssetType) {
                      obj[i] = null;
                    }
                  } else {
                    obj[i] = prop;
                  }
                }

                return obj;
              }

              _deserializePlainObject(value) {
                const obj = {};

                this._fillPlainObject(obj, value);

                return obj;
              }

              _deserializeTypeTaggedObject(value, globalIndex, owner, propName) {
                const type = value.__type__;

                const klass = this._classFinder(type, value, owner, propName);

                if (!klass) {
                  const notReported = this._classFinder === _getClassById;

                  if (notReported) {
                    this._reportMissingClass(type);
                  }

                  return null;
                }

                const createObject = constructor => {
                  const obj = new constructor();

                  if (globalIndex >= 0) {
                    this.deserializedList[globalIndex] = obj;
                  }

                  return obj;
                };

                {
                  const obj = createObject(klass);

                  this._deserializeInto(value, obj, klass);

                  return obj;
                }
              }

              _deserializeInto(value, object, constructor, skipCustomized = false) {
                if (!skipCustomized && object[deserializeTag]) {
                  this._runCustomizedDeserialize(value, object, constructor);

                  return;
                }

                if (object._deserialize) {
                  object._deserialize(value.content, this);

                  return;
                }

                if (legacyCC.Class._isCCClass(constructor)) {
                  this._deserializeFireClass(object, value, constructor);
                } else {
                  this._deserializeFastDefinedObject(object, value, constructor);
                }
              }

              _runCustomizedDeserialize(value, object, constructor) {
                const serializationInput = {
                  readProperty: name => {
                    const serializedField = value[name];

                    if (typeof serializedField !== 'object' || !serializedField) {
                      return serializedField;
                    } else {
                      return this._deserializeObjectField(serializedField);
                    }
                  },
                  readThis: () => {
                    this._deserializeInto(value, object, constructor, true);
                  },
                  readSuper: () => {
                    const superConstructor = getSuper(constructor);

                    if (superConstructor) {
                      this._deserializeInto(value, object, superConstructor);
                    }
                  }
                };
                object[deserializeTag](serializationInput, this._context);
              }

              _deserializeFireClass(obj, serialized, klass) {
                let deserialize;

                if (klass.hasOwnProperty('__deserialize__')) {
                  deserialize = klass.__deserialize__;
                } else {
                  deserialize = compileDeserialize(this, klass);

                  try {
                    if (klass === MissingScript) {
                      const props = klass.__values__;

                      if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
                        error(`The '_$erialized' prop of MissingScript is missing. Will force the raw data to be save.`);
                        error(`    Error props: ['${props}']. Please contact jare.`);
                      }

                      const rawDeserialize = deserialize;

                      deserialize = function (deserializer, object, deserialized, constructor) {
                        try {
                          if (!JSON.parse(JSON.stringify(deserialized._$erialized))) {
                            error(`Unable to load previously serialized data. ${JSON.stringify(deserialized)}`);
                          }
                        } catch (e) {
                          error(`Error when checking MissingScript 7, ${e}`);
                        }

                        rawDeserialize(deserializer, object, deserialized, constructor);
                      };
                    }
                  } catch (e) {
                    error(`Error when checking MissingScript 6, ${e}`);
                  }

                  value(klass, '__deserialize__', deserialize, true);
                }

                deserialize(this, obj, serialized, klass);
              }

              _deserializeAndAssignField(obj, serializedField, propName) {
                const id = serializedField.__id__;

                if (typeof id === 'number') {
                  const field = this.deserializedList[id];

                  if (field) {
                    obj[propName] = field;
                  } else {
                    var _this$_onDereferenced;

                    const source = this._serializedData[id];

                    {
                      obj[propName] = this._deserializeObject(source, id, undefined, propName);
                    }

                    (_this$_onDereferenced = this._onDereferenced) === null || _this$_onDereferenced === void 0 ? void 0 : _this$_onDereferenced.call(this, this.deserializedList, id, obj, propName);
                  }
                } else {
                  const uuid = serializedField.__uuid__;

                  if (uuid) {
                    const expectedType = serializedField.__expectedType__;
                    this.result.push(obj, propName, uuid, expectedType);
                  } else {
                    obj[propName] = this._deserializeObject(serializedField, -1);
                  }
                }

                return false;
              }

              _deserializeObjectField(serializedField) {
                const id = serializedField.__id__;

                if (typeof id === 'number') {
                  const field = this.deserializedList[id];

                  if (field) {
                    return field;
                  } else {
                    const source = this._serializedData[id];

                    const field = this._deserializeObject(source, id, undefined, undefined);

                    return field;
                  }
                } else {
                  const uuid = serializedField.__uuid__;

                  if (uuid) {
                    const _expectedType = serializedField.__expectedType__;
                    throw new Error(`Asset reference field serialization is currently not supported in custom serialization.`);
                  } else {
                    return this._deserializeObject(serializedField, -1);
                  }
                }
              }

              _fillPlainObject(instance, serialized) {
                for (const propName in serialized) {
                  if (!serialized.hasOwnProperty(propName)) {
                    continue;
                  }

                  const prop = serialized[propName];

                  if (typeof prop !== 'object') {
                    if (propName !== '__type__') {
                        instance[propName] = prop;
                      }
                  } else if (prop) {
                    const isAssetType = this._deserializeAndAssignField(instance, prop, propName);

                    if (isAssetType) {
                      instance[propName] = null;
                    }
                  } else {
                    instance[propName] = null;
                  }
                }
              }

              _deserializeFastDefinedObject(instance, serialized, klass) {
                if (klass === legacyCC.Vec2) {
                  instance.x = serialized.x || 0;
                  instance.y = serialized.y || 0;
                  return;
                } else if (klass === legacyCC.Vec3) {
                  instance.x = serialized.x || 0;
                  instance.y = serialized.y || 0;
                  instance.z = serialized.z || 0;
                  return;
                } else if (klass === legacyCC.Color) {
                  instance.r = serialized.r || 0;
                  instance.g = serialized.g || 0;
                  instance.b = serialized.b || 0;
                  const a = serialized.a;
                  instance.a = a === undefined ? 255 : a;
                  return;
                } else if (klass === legacyCC.Size) {
                  instance.width = serialized.width || 0;
                  instance.height = serialized.height || 0;
                  return;
                }

                const attrs = getClassAttrs(klass);
                const props = klass.__values__;

                if ( !props) {
                  error(`Unable to deserialize ${getClassName(klass)}. ` + 'For non-CCClass types, they can only be marked as serializable by `CCClass.fastDefine`.');
                }

                for (let i = 0; i < props.length; i++) {
                  const propName = props[i];
                  let value = serialized[propName];
                  const exists = value !== undefined || serialized.hasOwnProperty(propName);

                  if (!exists) {
                    value = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
                  }

                  if (typeof value !== 'object') {
                    instance[propName] = value;
                  } else if (value) {
                    this._deserializeAndAssignField(instance, value, propName);
                  } else {
                    instance[propName] = null;
                  }
                }
              }

            }

            _Deserializer.pool = new DeserializerPool();
            function deserializeDynamic(data, details, options) {
              var _options$reportMissin;

              options = options || {};
              const classFinder = options.classFinder || _getClassById;
              const createAssetRefs = options.createAssetRefs || sys.platform === Platform.EDITOR_CORE;
              const customEnv = options.customEnv;
              const ignoreEditorOnly = options.ignoreEditorOnly;
              const reportMissingClass = (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : legacyCC.deserialize.reportMissingClass;
              details.init();

              const deserializer = _Deserializer.pool.get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);

              legacyCC.game._isCloning = true;
              const res = deserializer.deserialize(data);
              legacyCC.game._isCloning = false;

              _Deserializer.pool.put(deserializer);

              if (createAssetRefs) {
                details.assignAssetsBy(EditorExtends.serialize.asAsset);
              }

              return res;
            }

            function reportMissingClass(id) {
              {
                errorID(5302, id);
              }
            }

            const SUPPORT_MIN_FORMAT_VERSION = 1;
            const EMPTY_PLACEHOLDER = 0;
            const BuiltinValueTypes = [Vec2, Vec3, Vec4, Quat, Color, Size, Rect, Mat4];

            function BuiltinValueTypeParsers_xyzw(obj, data) {
              obj.x = data[1];
              obj.y = data[2];
              obj.z = data[3];
              obj.w = data[4];
            }

            const BuiltinValueTypeSetters = [(obj, data) => {
              obj.x = data[1];
              obj.y = data[2];
            }, (obj, data) => {
              obj.x = data[1];
              obj.y = data[2];
              obj.z = data[3];
            }, BuiltinValueTypeParsers_xyzw, BuiltinValueTypeParsers_xyzw, (obj, data) => {
              obj._val = data[1];
            }, (obj, data) => {
              obj.width = data[1];
              obj.height = data[2];
            }, (obj, data) => {
              obj.x = data[1];
              obj.y = data[2];
              obj.width = data[3];
              obj.height = data[4];
            }, (obj, data) => {
              Mat4.fromArray(obj, data, 1);
            }];

            const DataTypeID = {
              SimpleType: 0,
              InstanceRef: 1,
              Array_InstanceRef: 2,
              Array_AssetRefByInnerObj: 3,
              Class: 4,
              ValueTypeCreated: 5,
              AssetRefByInnerObj: 6,
              TRS: 7,
              ValueType: 8,
              Array_Class: 9,
              CustomizedClass: 10,
              Dict: 11,
              Array: 12,
              ARRAY_LENGTH: 13
            };
            const CLASS_TYPE = 0;
            const CLASS_KEYS = 1;
            const CLASS_PROP_TYPE_OFFSET = 2;
            const MASK_CLASS = 0;
            const OBJ_DATA_MASK = 0;
            const CUSTOM_OBJ_DATA_CLASS = 0;
            const CUSTOM_OBJ_DATA_CONTENT = 1;
            const VALUETYPE_SETTER = 0;
            const DICT_JSON_LAYOUT = 0;
            const ARRAY_ITEM_VALUES = 0;
            const Refs = {
              EACH_RECORD_LENGTH: 3,
              OWNER_OFFSET: 0,
              KEY_OFFSET: 1,
              TARGET_OFFSET: 2
            };
            const File = {
              Version: 0,
              Context: 0,
              SharedUuids: 1,
              SharedStrings: 2,
              SharedClasses: 3,
              SharedMasks: 4,
              Instances: 5,
              InstanceTypes: 6,
              Refs: 7,
              DependObjs: 8,
              DependKeys: 9,
              DependUuidIndices: 10,
              ARRAY_LENGTH: 11
            };
            const PACKED_SECTIONS = File.Instances;
            class Details {
              constructor() {
                this.uuidObjList = null;
                this.uuidPropList = null;
                this.uuidList = null;
                this.uuidTypeList = [];
              }

              init(data) {
                if ( data) {
                  this.uuidObjList = data[File.DependObjs];
                  this.uuidPropList = data[File.DependKeys];
                  this.uuidList = data[File.DependUuidIndices];
                } else {
                  const used = this.uuidList;

                  if (!used) {
                    this.uuidList = [];
                    this.uuidObjList = [];
                    this.uuidPropList = [];
                    this.uuidTypeList = [];
                  }
                }
              }

              reset() {
                {
                  const used = this.uuidList;

                  if (used) {
                    this.uuidList.length = 0;
                    this.uuidObjList.length = 0;
                    this.uuidPropList.length = 0;
                    this.uuidTypeList.length = 0;
                  }
                }
              }

              push(obj, propName, uuid, type) {
                this.uuidObjList.push(obj);
                this.uuidPropList.push(propName);
                this.uuidList.push(uuid);
                this.uuidTypeList.push(type || '');
              }

            } exports('fv', Details);
            Details.pool = new Pool$1(obj => {
              obj.reset();
            }, 5);

            Details.pool.get = function () {
              return this._get() || new Details();
            };

            function dereference(refs, instances, strings) {
              const dataLength = refs.length - 1;
              let i = 0;
              const instanceOffset = refs[dataLength] * Refs.EACH_RECORD_LENGTH;

              for (; i < instanceOffset; i += Refs.EACH_RECORD_LENGTH) {
                const owner = refs[i];
                const target = instances[refs[i + Refs.TARGET_OFFSET]];
                const keyIndex = refs[i + Refs.KEY_OFFSET];

                if (keyIndex >= 0) {
                  owner[strings[keyIndex]] = target;
                } else {
                  owner[~keyIndex] = target;
                }
              }

              for (; i < dataLength; i += Refs.EACH_RECORD_LENGTH) {
                const owner = instances[refs[i]];
                const target = instances[refs[i + Refs.TARGET_OFFSET]];
                const keyIndex = refs[i + Refs.KEY_OFFSET];

                if (keyIndex >= 0) {
                  owner[strings[keyIndex]] = target;
                } else {
                  owner[~keyIndex] = target;
                }
              }
            }

            function deserializeCCObject(data, objectData) {
              const mask = data[File.SharedMasks][objectData[OBJ_DATA_MASK]];
              const clazz = mask[MASK_CLASS];
              const ctor = clazz[CLASS_TYPE];
              const obj = new ctor();
              const keys = clazz[CLASS_KEYS];
              const classTypeOffset = clazz[CLASS_PROP_TYPE_OFFSET];
              const maskTypeOffset = mask[mask.length - 1];
              let i = MASK_CLASS + 1;

              for (; i < maskTypeOffset; ++i) {
                const key = keys[mask[i]];
                obj[key] = objectData[i];
              }

              for (; i < objectData.length; ++i) {
                const key = keys[mask[i]];
                const type = clazz[mask[i] + classTypeOffset];
                const op = ASSIGNMENTS[type];
                op(data, obj, key, objectData[i]);
              }

              return obj;
            }

            function deserializeCustomCCObject(data, ctor, value) {
              const obj = new ctor();

              if (obj._deserialize) {
                obj._deserialize(value, data[File.Context]);
              } else {
                errorID(5303, getClassName(ctor));
              }

              return obj;
            }

            function assignSimple(data, owner, key, value) {
              owner[key] = value;
            }

            function assignInstanceRef(data, owner, key, value) {
              if (value >= 0) {
                owner[key] = data[File.Instances][value];
              } else {
                data[File.Refs][~value * Refs.EACH_RECORD_LENGTH] = owner;
              }
            }

            function genArrayParser(parser) {
              return (data, owner, key, value) => {
                owner[key] = value;

                for (let i = 0; i < value.length; ++i) {
                  parser(data, value, i, value[i]);
                }
              };
            }

            function parseAssetRefByInnerObj(data, owner, key, value) {
              owner[key] = null;
              data[File.DependObjs][value] = owner;
            }

            function parseClass(data, owner, key, value) {
              owner[key] = deserializeCCObject(data, value);
            }

            function parseCustomClass(data, owner, key, value) {
              const ctor = data[File.SharedClasses][value[CUSTOM_OBJ_DATA_CLASS]];
              owner[key] = deserializeCustomCCObject(data, ctor, value[CUSTOM_OBJ_DATA_CONTENT]);
            }

            function parseValueTypeCreated(data, owner, key, value) {
              BuiltinValueTypeSetters[value[VALUETYPE_SETTER]](owner[key], value);
            }

            function parseValueType(data, owner, key, value) {
              const val = new BuiltinValueTypes[value[VALUETYPE_SETTER]]();
              BuiltinValueTypeSetters[value[VALUETYPE_SETTER]](val, value);
              owner[key] = val;
            }

            function parseTRS(data, owner, key, value) {
              const typedArray = owner[key];
              typedArray.set(value);
            }

            function parseDict(data, owner, key, value) {
              const dict = value[DICT_JSON_LAYOUT];
              owner[key] = dict;

              for (let i = DICT_JSON_LAYOUT + 1; i < value.length; i += 3) {
                const subKey = value[i];
                const subType = value[i + 1];
                const subValue = value[i + 2];
                const op = ASSIGNMENTS[subType];
                op(data, dict, subKey, subValue);
              }
            }

            function parseArray(data, owner, key, value) {
              const array = value[ARRAY_ITEM_VALUES];
              owner[key] = array;

              for (let i = 0; i < array.length; ++i) {
                const subValue = array[i];
                const type = value[i + 1];

                if (type !== DataTypeID.SimpleType) {
                  const op = ASSIGNMENTS[type];
                  op(data, array, i, subValue);
                }
              }
            }

            const ASSIGNMENTS = new Array(DataTypeID.ARRAY_LENGTH);
            ASSIGNMENTS[DataTypeID.SimpleType] = assignSimple;
            ASSIGNMENTS[DataTypeID.InstanceRef] = assignInstanceRef;
            ASSIGNMENTS[DataTypeID.Array_InstanceRef] = genArrayParser(assignInstanceRef);
            ASSIGNMENTS[DataTypeID.Array_AssetRefByInnerObj] = genArrayParser(parseAssetRefByInnerObj);
            ASSIGNMENTS[DataTypeID.Class] = parseClass;
            ASSIGNMENTS[DataTypeID.ValueTypeCreated] = parseValueTypeCreated;
            ASSIGNMENTS[DataTypeID.AssetRefByInnerObj] = parseAssetRefByInnerObj;
            ASSIGNMENTS[DataTypeID.TRS] = parseTRS;
            ASSIGNMENTS[DataTypeID.ValueType] = parseValueType;
            ASSIGNMENTS[DataTypeID.Array_Class] = genArrayParser(parseClass);
            ASSIGNMENTS[DataTypeID.CustomizedClass] = parseCustomClass;
            ASSIGNMENTS[DataTypeID.Dict] = parseDict;
            ASSIGNMENTS[DataTypeID.Array] = parseArray;

            function parseInstances(data) {
              const instances = data[File.Instances];
              const instanceTypes = data[File.InstanceTypes];
              const instanceTypesLen = instanceTypes === EMPTY_PLACEHOLDER ? 0 : instanceTypes.length;
              let rootIndex = instances[instances.length - 1];
              let normalObjectCount = instances.length - instanceTypesLen;

              if (typeof rootIndex !== 'number') {
                rootIndex = 0;
              } else {
                if (rootIndex < 0) {
                  rootIndex = ~rootIndex;
                }

                --normalObjectCount;
              }

              let insIndex = 0;

              for (; insIndex < normalObjectCount; ++insIndex) {
                instances[insIndex] = deserializeCCObject(data, instances[insIndex]);
              }

              const classes = data[File.SharedClasses];

              for (let typeIndex = 0; typeIndex < instanceTypesLen; ++typeIndex, ++insIndex) {
                let type = instanceTypes[typeIndex];
                const eachData = instances[insIndex];

                if (type >= 0) {
                  const ctor = classes[type];
                  instances[insIndex] = deserializeCustomCCObject(data, ctor, eachData);
                } else {
                  type = ~type;
                  const op = ASSIGNMENTS[type];
                  op(data, instances, insIndex, eachData);
                }
              }

              return rootIndex;
            }

            function getMissingClass(hasCustomFinder, type, reportMissingClass) {
              if (!hasCustomFinder) {
                reportMissingClass(type);
              }

              return Object;
            }

            function doLookupClass(classFinder, type, container, index, silent, hasCustomFinder, reportMissingClass) {
              let klass = classFinder(type);

              if (!klass) {
                if (silent) {
                  container[index] = ((c, i, t) => function proxy() {
                    const actualClass = classFinder(t) || getMissingClass(hasCustomFinder, t, reportMissingClass);
                    c[i] = actualClass;
                    return new actualClass();
                  })(container, index, type);

                  return;
                } else {
                  klass = getMissingClass(hasCustomFinder, type, reportMissingClass);
                }
              }

              container[index] = klass;
            }

            function lookupClasses(data, silent, customFinder, reportMissingClass) {
              const classFinder = customFinder || _getClassById;
              const classes = data[File.SharedClasses];

              for (let i = 0; i < classes.length; ++i) {
                const klassLayout = classes[i];

                if (typeof klassLayout !== 'string') {
                  {
                    if (typeof klassLayout[CLASS_TYPE] === 'function') {
                      throw new Error('Can not deserialize the same JSON data again.');
                    }
                  }

                  const type = klassLayout[CLASS_TYPE];
                  doLookupClass(classFinder, type, klassLayout, CLASS_TYPE, silent, customFinder, reportMissingClass);
                } else {
                  doLookupClass(classFinder, klassLayout, classes, i, silent, customFinder, reportMissingClass);
                }
              }
            }

            function cacheMasks(data) {
              const masks = data[File.SharedMasks];

              if (masks) {
                const classes = data[File.SharedClasses];

                for (let i = 0; i < masks.length; ++i) {
                  const mask = masks[i];
                  mask[MASK_CLASS] = classes[mask[MASK_CLASS]];
                }
              }
            }

            function parseResult(data) {
              const instances = data[File.Instances];
              const sharedStrings = data[File.SharedStrings];
              const dependSharedUuids = data[File.SharedUuids];
              const dependObjs = data[File.DependObjs];
              const dependKeys = data[File.DependKeys];
              const dependUuids = data[File.DependUuidIndices];

              for (let i = 0; i < dependObjs.length; ++i) {
                const obj = dependObjs[i];

                if (typeof obj === 'number') {
                  dependObjs[i] = instances[obj];
                }

                let key = dependKeys[i];

                if (typeof key === 'number') {
                  if (key >= 0) {
                    key = sharedStrings[key];
                  } else {
                    key = ~key;
                  }

                  dependKeys[i] = key;
                }

                const uuid = dependUuids[i];

                if (typeof uuid === 'number') {
                  dependUuids[i] = dependSharedUuids[uuid];
                }
              }
            }

            function isCompiledJson(json) {
              if (Array.isArray(json)) {
                const version = json[0];
                return typeof version === 'number' || version instanceof FileInfo;
              } else {
                return false;
              }
            }
            function deserialize(data, details, options) {
              if (typeof data === 'string') {
                data = JSON.parse(data);
              }

              const borrowDetails = !details;
              details = details || Details.pool.get();
              let res;

              if ( !isCompiledJson(data)) {
                res = deserializeDynamic(data, details, options);
              } else {
                details.init(data);
                options = options || {};
                let version = data[File.Version];
                let preprocessed = false;

                if (typeof version === 'object') {
                  preprocessed = version.preprocessed;
                  version = version.version;
                }

                if (version < SUPPORT_MIN_FORMAT_VERSION) {
                  throw new Error(getError(5304, version));
                }

                options._version = version;
                options.result = details;
                data[File.Context] = options;

                if (!preprocessed) {
                  var _options$reportMissin;

                  lookupClasses(data, false, options.classFinder, (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== void 0 ? _options$reportMissin : deserialize.reportMissingClass);
                  cacheMasks(data);
                }

                legacyCC.game._isCloning = true;
                const instances = data[File.Instances];
                const rootIndex = parseInstances(data);
                legacyCC.game._isCloning = false;

                if (data[File.Refs]) {
                  dereference(data[File.Refs], instances, data[File.SharedStrings]);
                }

                parseResult(data);
                res = instances[rootIndex];
              }

              if (borrowDetails) {
                Details.pool.put(details);
              }

              return res;
            }
            deserialize.Details = Details;
            deserialize.reportMissingClass = reportMissingClass;

            class FileInfo {
              constructor(version) {
                this.preprocessed = true;
                this.version = version;
              }

            }

            function unpackJSONs(data, classFinder, reportMissingClass) {
              if (data[File.Version] < SUPPORT_MIN_FORMAT_VERSION) {
                throw new Error(getError(5304, data[File.Version]));
              }

              lookupClasses(data, true, classFinder, reportMissingClass !== null && reportMissingClass !== void 0 ? reportMissingClass : deserialize.reportMissingClass);
              cacheMasks(data);
              const version = new FileInfo(data[File.Version]);
              const sharedUuids = data[File.SharedUuids];
              const sharedStrings = data[File.SharedStrings];
              const sharedClasses = data[File.SharedClasses];
              const sharedMasks = data[File.SharedMasks];
              const sections = data[PACKED_SECTIONS];

              for (let i = 0; i < sections.length; ++i) {
                sections[i].unshift(version, sharedUuids, sharedStrings, sharedClasses, sharedMasks);
              }

              return sections;
            }
            function packCustomObjData(type, data, hasNativeDep) {
              return [SUPPORT_MIN_FORMAT_VERSION, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, [type], EMPTY_PLACEHOLDER, hasNativeDep ? [data, ~0] : [data], [0], EMPTY_PLACEHOLDER, [], [], []];
            }
            function hasNativeDep(data) {
              const instances = data[File.Instances];
              const rootInfo = instances[instances.length - 1];

              if (typeof rootInfo !== 'number') {
                return false;
              } else {
                return rootInfo < 0;
              }
            }

            function getDependUuidList(json) {
              const sharedUuids = json[File.SharedUuids];
              return json[File.DependUuidIndices].map(index => sharedUuids[index]);
            }

            function parseUuidDependencies(serialized) {
              {
                return getDependUuidList(serialized);
              }
            }

            legacyCC.deserialize = deserialize;

            const Destroyed$1 = CCObject.Flags.Destroyed;
            const PersistentMask$1 = CCObject.Flags.PersistentMask;
            const objsToClearTmpVar = [];
            function instantiate(original, internalForce) {

              let clone;

              if (original instanceof CCObject) {
                if (original._instantiate) {
                  legacyCC.game._isCloning = true;
                  clone = original._instantiate(null, true);
                  legacyCC.game._isCloning = false;
                  return clone;
                } else if (original instanceof legacyCC.Asset) {
                  throw new TypeError(getError(6903));
                }
              }

              legacyCC.game._isCloning = true;
              clone = doInstantiate(original);
              legacyCC.game._isCloning = false;
              return clone;
            }

            function doInstantiate(obj, parent) {

              let clone;

              if (obj._iN$t) {
                clone = obj._iN$t;
              } else if (obj.constructor) {
                const klass = obj.constructor;
                clone = new klass();
              } else {
                clone = Object.create(null);
              }

              enumerateObject(obj, clone, parent);

              for (let i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
                objsToClearTmpVar[i]._iN$t = null;
              }

              objsToClearTmpVar.length = 0;
              return clone;
            }

            function enumerateCCClass(klass, obj, clone, parent) {
              const props = klass.__values__;

              for (let p = 0; p < props.length; p++) {
                const key = props[p];
                const value = obj[key];

                if (typeof value === 'object' && value) {
                  const initValue = clone[key];

                  if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
                    initValue.set(value);
                  } else {
                    clone[key] = value._iN$t || instantiateObj(value, parent);
                  }
                } else {
                  clone[key] = value;
                }
              }
            }

            function enumerateObject(obj, clone, parent) {
              js.value(obj, '_iN$t', clone, true);
              objsToClearTmpVar.push(obj);
              const klass = obj.constructor;

              if (legacyCC.Class._isCCClass(klass)) {
                enumerateCCClass(klass, obj, clone, parent);
              } else {
                for (const key in obj) {
                  if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__' && key !== '__prefab') {
                    continue;
                  }

                  const value = obj[key];

                  if (typeof value === 'object' && value) {
                    if (value === clone) {
                      continue;
                    }

                    clone[key] = value._iN$t || instantiateObj(value, parent);
                  } else {
                    clone[key] = value;
                  }
                }
              }

              if (obj instanceof CCObject) {
                clone._objFlags &= PersistentMask$1;
              }
            }

            function instantiateObj(obj, parent) {
              if (obj instanceof ValueType) {
                return obj.clone();
              }

              if (obj instanceof legacyCC.Asset) {
                return obj;
              }

              let clone;

              if (ArrayBuffer.isView(obj)) {
                const len = obj.length;
                clone = new obj.constructor(len);
                obj._iN$t = clone;
                objsToClearTmpVar.push(obj);

                for (let i = 0; i < len; ++i) {
                  clone[i] = obj[i];
                }

                return clone;
              }

              if (Array.isArray(obj)) {
                const len = obj.length;
                clone = new Array(len);
                obj._iN$t = clone;
                objsToClearTmpVar.push(obj);

                for (let i = 0; i < len; ++i) {
                  const value = obj[i];

                  if (typeof value === 'object' && value) {
                    clone[i] = value._iN$t || instantiateObj(value, parent);
                  } else {
                    clone[i] = value;
                  }
                }

                return clone;
              } else if (obj._objFlags & Destroyed$1) {
                return null;
              }

              const ctor = obj.constructor;

              if (legacyCC.Class._isCCClass(ctor)) {
                if (parent) {
                  if (parent instanceof legacyCC.Component) {
                    if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
                      return obj;
                    }
                  } else if (parent instanceof legacyCC._BaseNode) {
                    if (obj instanceof legacyCC._BaseNode) {
                      if (!obj.isChildOf(parent)) {
                        return obj;
                      }
                    } else if (obj instanceof legacyCC.Component) {
                      if (obj.node && !obj.node.isChildOf(parent)) {
                        return obj;
                      }
                    }
                  }
                }

                clone = new ctor();
              } else if (ctor === Object) {
                clone = {};
              } else if (!ctor) {
                clone = Object.create(null);
              } else {
                return obj;
              }

              enumerateObject(obj, clone, parent);
              return clone;
            }

            instantiate._clone = doInstantiate;
            legacyCC.instantiate = instantiate;

            var _dec$6, _class$6, _class2$5, _descriptor$4, _descriptor2$2, _descriptor3$1, _descriptor4, _class3$2, _temp$4;
            let StorageUnit;

            (function (StorageUnit) {
              StorageUnit[StorageUnit["Uint8"] = 0] = "Uint8";
              StorageUnit[StorageUnit["Uint16"] = 1] = "Uint16";
              StorageUnit[StorageUnit["Uint32"] = 2] = "Uint32";
              StorageUnit[StorageUnit["Int8"] = 3] = "Int8";
              StorageUnit[StorageUnit["Int16"] = 4] = "Int16";
              StorageUnit[StorageUnit["Int32"] = 5] = "Int32";
              StorageUnit[StorageUnit["Float32"] = 6] = "Float32";
              StorageUnit[StorageUnit["Float64"] = 7] = "Float64";
            })(StorageUnit || (StorageUnit = {}));

            let ElementType;

            (function (ElementType) {
              ElementType[ElementType["Scalar"] = 0] = "Scalar";
              ElementType[ElementType["Vec2"] = 1] = "Vec2";
              ElementType[ElementType["Vec3"] = 2] = "Vec3";
              ElementType[ElementType["Vec4"] = 3] = "Vec4";
              ElementType[ElementType["Quat"] = 4] = "Quat";
              ElementType[ElementType["Mat4"] = 5] = "Mat4";
            })(ElementType || (ElementType = {}));

            const elementTypeBits = 3;
            function combineStorageUnitElementType(unit, elementType) {
              return (elementType << elementTypeBits) + unit;
            }
            function extractStorageUnitElementType(combined) {
              return {
                storageUnit: ~(-1 << elementTypeBits) & combined,
                elementType: combined >> elementTypeBits
              };
            }
            let CompactValueTypeArray = exports('fx', (_dec$6 = ccclass('cc.CompactValueTypeArray'), _dec$6(_class$6 = (_class2$5 = (_temp$4 = _class3$2 = class CompactValueTypeArray {
              constructor() {
                _initializerDefineProperty(this, "_byteOffset", _descriptor$4, this);

                _initializerDefineProperty(this, "_unitCount", _descriptor2$2, this);

                _initializerDefineProperty(this, "_unitElement", _descriptor3$1, this);

                _initializerDefineProperty(this, "_length", _descriptor4, this);
              }

              static lengthFor(values, elementType, unit) {
                const elementTraits = getElementTraits(elementType);
                return elementTraits.requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
              }

              static compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
                const elementTraits = getElementTraits(elementType);
                const storageConstructor = getStorageConstructor(unit);
                const unitCount = elementTraits.requiredUnits * values.length;
                const storage = new storageConstructor(arrayBuffer, byteOffset, unitCount);

                for (let i = 0; i < values.length; ++i) {
                  elementTraits.compress(storage, i, values[i]);
                }

                const result = new CompactValueTypeArray();
                result._unitElement = combineStorageUnitElementType(unit, elementType);
                result._byteOffset = presumedByteOffset;
                result._unitCount = unitCount;
                result._length = values.length;
                return result;
              }

              decompress(arrayBuffer) {
                const {
                  storageUnit,
                  elementType
                } = extractStorageUnitElementType(this._unitElement);
                const elementTraits = getElementTraits(elementType);
                const storageConstructor = getStorageConstructor(storageUnit);
                const storage = new storageConstructor(arrayBuffer, this._byteOffset, this._unitCount);
                const result = new Array(this._length);

                for (let i = 0; i < this._length; ++i) {
                  result[i] = elementTraits.decompress(storage, i);
                }

                return result;
              }

            }, _class3$2.StorageUnit = StorageUnit, _class3$2.ElementType = ElementType, _temp$4), (_descriptor$4 = _applyDecoratedDescriptor(_class2$5.prototype, "_byteOffset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_unitCount", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$5.prototype, "_unitElement", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
              }
            }), _descriptor4 = _applyDecoratedDescriptor(_class2$5.prototype, "_length", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$5)) || _class$6));

            function getElementTraits(elementType) {
              return BuiltinElementTypeTraits[elementType];
            }

            function getStorageConstructor(unit) {
              switch (unit) {
                case StorageUnit.Uint8:
                  return Uint8Array;

                case StorageUnit.Uint16:
                  return Uint16Array;

                case StorageUnit.Uint32:
                  return Uint32Array;

                case StorageUnit.Int8:
                  return Int8Array;

                case StorageUnit.Int16:
                  return Int16Array;

                case StorageUnit.Int32:
                  return Int32Array;

                case StorageUnit.Float32:
                  return Float32Array;

                case StorageUnit.Float64:
                  return Float64Array;
              }
            }

            const BuiltinElementTypeTraits = {
              [ElementType.Scalar]: {
                requiredUnits: 1,

                compress(storage, index, value) {
                  storage[index] = value;
                },

                decompress(storage, index) {
                  return storage[index];
                }

              },
              [ElementType.Vec2]: {
                requiredUnits: 2,

                compress(storage, index, value) {
                  storage[index * 2] = value.x;
                  storage[index * 2 + 1] = value.y;
                },

                decompress(storage, index) {
                  return new Vec3(storage[index * 2], storage[index * 2 + 1]);
                }

              },
              [ElementType.Vec3]: {
                requiredUnits: 3,

                compress(storage, index, value) {
                  storage[index * 3] = value.x;
                  storage[index * 3 + 1] = value.y;
                  storage[index * 3 + 2] = value.z;
                },

                decompress(storage, index) {
                  return new Vec3(storage[index * 3], storage[index * 3 + 1], storage[index * 3 + 2]);
                }

              },
              [ElementType.Vec4]: {
                requiredUnits: 4,

                compress(storage, index, value) {
                  storage[index * 4] = value.x;
                  storage[index * 4 + 1] = value.y;
                  storage[index * 4 + 2] = value.z;
                  storage[index * 4 + 3] = value.w;
                },

                decompress(storage, index) {
                  return new Vec4(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
                }

              },
              [ElementType.Quat]: {
                requiredUnits: 4,

                compress(storage, index, value) {
                  storage[index * 4] = value.x;
                  storage[index * 4 + 1] = value.y;
                  storage[index * 4 + 2] = value.z;
                  storage[index * 4 + 3] = value.w;
                },

                decompress(storage, index) {
                  return new Quat(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
                }

              },
              [ElementType.Mat4]: {
                requiredUnits: 16,

                compress(storage, index, value) {
                  Mat4.toArray(storage, value, index * 16);
                },

                decompress(storage, index) {
                  return Mat4.fromArray(new Mat4(), storage, index * 16);
                }

              }
            };

            legacyCC._decorator = _decorator;

            function constant() {
              return 0;
            }
            function linear(k) {
              return k;
            }
            function quadIn(k) {
              return k * k;
            }
            function quadOut(k) {
              return k * (2 - k);
            }
            function quadInOut(k) {
              k *= 2;

              if (k < 1) {
                return 0.5 * k * k;
              }

              return -0.5 * (--k * (k - 2) - 1);
            }
            function cubicIn(k) {
              return k * k * k;
            }
            function cubicOut(k) {
              return --k * k * k + 1;
            }
            function cubicInOut(k) {
              k *= 2;

              if (k < 1) {
                return 0.5 * k * k * k;
              }

              return 0.5 * ((k -= 2) * k * k + 2);
            }
            function quartIn(k) {
              return k * k * k * k;
            }
            function quartOut(k) {
              return 1 - --k * k * k * k;
            }
            function quartInOut(k) {
              k *= 2;

              if (k < 1) {
                return 0.5 * k * k * k * k;
              }

              return -0.5 * ((k -= 2) * k * k * k - 2);
            }
            function quintIn(k) {
              return k * k * k * k * k;
            }
            function quintOut(k) {
              return --k * k * k * k * k + 1;
            }
            function quintInOut(k) {
              k *= 2;

              if (k < 1) {
                return 0.5 * k * k * k * k * k;
              }

              return 0.5 * ((k -= 2) * k * k * k * k + 2);
            }
            function sineIn(k) {
              if (k === 1) {
                return 1;
              }

              return 1 - Math.cos(k * Math.PI / 2);
            }
            function sineOut(k) {
              return Math.sin(k * Math.PI / 2);
            }
            function sineInOut(k) {
              return 0.5 * (1 - Math.cos(Math.PI * k));
            }
            function expoIn(k) {
              return k === 0 ? 0 : Math.pow(1024, k - 1);
            }
            function expoOut(k) {
              return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            }
            function expoInOut(k) {
              if (k === 0) {
                return 0;
              }

              if (k === 1) {
                return 1;
              }

              k *= 2;

              if (k < 1) {
                return 0.5 * Math.pow(1024, k - 1);
              }

              return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            }
            function circIn(k) {
              return 1 - Math.sqrt(1 - k * k);
            }
            function circOut(k) {
              return Math.sqrt(1 - --k * k);
            }
            function circInOut(k) {
              k *= 2;

              if (k < 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
              }

              return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            }
            function elasticIn(k) {
              let s;
              let a = 0.1;
              const p = 0.4;

              if (k === 0) {
                return 0;
              }

              if (k === 1) {
                return 1;
              }

              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }

              return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            }
            function elasticOut(k) {
              let s;
              let a = 0.1;
              const p = 0.4;

              if (k === 0) {
                return 0;
              }

              if (k === 1) {
                return 1;
              }

              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }

              return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
            }
            function elasticInOut(k) {
              let s;
              let a = 0.1;
              const p = 0.4;

              if (k === 0) {
                return 0;
              }

              if (k === 1) {
                return 1;
              }

              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }

              k *= 2;

              if (k < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
              }

              return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
            }
            function backIn(k) {
              if (k === 1) {
                return 1;
              }

              const s = 1.70158;
              return k * k * ((s + 1) * k - s);
            }
            function backOut(k) {
              if (k === 0) {
                return 0;
              }

              const s = 1.70158;
              return --k * k * ((s + 1) * k + s) + 1;
            }
            function backInOut(k) {
              const s = 1.70158 * 1.525;
              k *= 2;

              if (k < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
              }

              return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            }
            function bounceIn(k) {
              return 1 - bounceOut(1 - k);
            }
            function bounceOut(k) {
              if (k < 1 / 2.75) {
                return 7.5625 * k * k;
              } else if (k < 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
              } else if (k < 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
              } else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
              }
            }
            function bounceInOut(k) {
              if (k < 0.5) {
                return bounceIn(k * 2) * 0.5;
              }

              return bounceOut(k * 2 - 1) * 0.5 + 0.5;
            }
            function smooth(k) {
              if (k <= 0) {
                return 0;
              }

              if (k >= 1) {
                return 1;
              }

              return k * k * (3 - 2 * k);
            }
            function fade(k) {
              if (k <= 0) {
                return 0;
              }

              if (k >= 1) {
                return 1;
              }

              return k * k * k * (k * (k * 6 - 15) + 10);
            }
            const quadOutIn = _makeOutIn(quadIn, quadOut);
            const cubicOutIn = _makeOutIn(cubicIn, cubicOut);
            const quartOutIn = _makeOutIn(quartIn, quartOut);
            const quintOutIn = _makeOutIn(quintIn, quintOut);
            const sineOutIn = _makeOutIn(sineIn, sineOut);
            const expoOutIn = _makeOutIn(expoIn, expoOut);
            const circOutIn = _makeOutIn(circIn, circOut);
            const elasticOutIn = _makeOutIn(elasticIn, elasticOut);
            const backOutIn = _makeOutIn(backIn, backOut);
            const bounceOutIn = _makeOutIn(bounceIn, bounceOut);

            function _makeOutIn(fnIn, fnOut) {
              return k => {
                if (k < 0.5) {
                  return fnOut(k * 2) / 2;
                }

                return fnIn(2 * k - 1) / 2 + 0.5;
              };
            }

            var easing = /*#__PURE__*/Object.freeze({
                __proto__: null,
                constant: constant,
                linear: linear,
                quadIn: quadIn,
                quadOut: quadOut,
                quadInOut: quadInOut,
                cubicIn: cubicIn,
                cubicOut: cubicOut,
                cubicInOut: cubicInOut,
                quartIn: quartIn,
                quartOut: quartOut,
                quartInOut: quartInOut,
                quintIn: quintIn,
                quintOut: quintOut,
                quintInOut: quintInOut,
                sineIn: sineIn,
                sineOut: sineOut,
                sineInOut: sineInOut,
                expoIn: expoIn,
                expoOut: expoOut,
                expoInOut: expoInOut,
                circIn: circIn,
                circOut: circOut,
                circInOut: circInOut,
                elasticIn: elasticIn,
                elasticOut: elasticOut,
                elasticInOut: elasticInOut,
                backIn: backIn,
                backOut: backOut,
                backInOut: backInOut,
                bounceIn: bounceIn,
                bounceOut: bounceOut,
                bounceInOut: bounceInOut,
                smooth: smooth,
                fade: fade,
                quadOutIn: quadOutIn,
                cubicOutIn: cubicOutIn,
                quartOutIn: quartOutIn,
                quintOutIn: quintOutIn,
                sineOutIn: sineOutIn,
                expoOutIn: expoOutIn,
                circOutIn: circOutIn,
                elasticOutIn: elasticOutIn,
                backOutIn: backOutIn,
                bounceOutIn: bounceOutIn
            });
            exports('co', easing);

            let EasingMethod;

            (function (EasingMethod) {
              EasingMethod[EasingMethod["LINEAR"] = 0] = "LINEAR";
              EasingMethod[EasingMethod["CONSTANT"] = 1] = "CONSTANT";
              EasingMethod[EasingMethod["QUAD_IN"] = 2] = "QUAD_IN";
              EasingMethod[EasingMethod["QUAD_OUT"] = 3] = "QUAD_OUT";
              EasingMethod[EasingMethod["QUAD_IN_OUT"] = 4] = "QUAD_IN_OUT";
              EasingMethod[EasingMethod["QUAD_OUT_IN"] = 5] = "QUAD_OUT_IN";
              EasingMethod[EasingMethod["CUBIC_IN"] = 6] = "CUBIC_IN";
              EasingMethod[EasingMethod["CUBIC_OUT"] = 7] = "CUBIC_OUT";
              EasingMethod[EasingMethod["CUBIC_IN_OUT"] = 8] = "CUBIC_IN_OUT";
              EasingMethod[EasingMethod["CUBIC_OUT_IN"] = 9] = "CUBIC_OUT_IN";
              EasingMethod[EasingMethod["QUART_IN"] = 10] = "QUART_IN";
              EasingMethod[EasingMethod["QUART_OUT"] = 11] = "QUART_OUT";
              EasingMethod[EasingMethod["QUART_IN_OUT"] = 12] = "QUART_IN_OUT";
              EasingMethod[EasingMethod["QUART_OUT_IN"] = 13] = "QUART_OUT_IN";
              EasingMethod[EasingMethod["QUINT_IN"] = 14] = "QUINT_IN";
              EasingMethod[EasingMethod["QUINT_OUT"] = 15] = "QUINT_OUT";
              EasingMethod[EasingMethod["QUINT_IN_OUT"] = 16] = "QUINT_IN_OUT";
              EasingMethod[EasingMethod["QUINT_OUT_IN"] = 17] = "QUINT_OUT_IN";
              EasingMethod[EasingMethod["SINE_IN"] = 18] = "SINE_IN";
              EasingMethod[EasingMethod["SINE_OUT"] = 19] = "SINE_OUT";
              EasingMethod[EasingMethod["SINE_IN_OUT"] = 20] = "SINE_IN_OUT";
              EasingMethod[EasingMethod["SINE_OUT_IN"] = 21] = "SINE_OUT_IN";
              EasingMethod[EasingMethod["EXPO_IN"] = 22] = "EXPO_IN";
              EasingMethod[EasingMethod["EXPO_OUT"] = 23] = "EXPO_OUT";
              EasingMethod[EasingMethod["EXPO_IN_OUT"] = 24] = "EXPO_IN_OUT";
              EasingMethod[EasingMethod["EXPO_OUT_IN"] = 25] = "EXPO_OUT_IN";
              EasingMethod[EasingMethod["CIRC_IN"] = 26] = "CIRC_IN";
              EasingMethod[EasingMethod["CIRC_OUT"] = 27] = "CIRC_OUT";
              EasingMethod[EasingMethod["CIRC_IN_OUT"] = 28] = "CIRC_IN_OUT";
              EasingMethod[EasingMethod["CIRC_OUT_IN"] = 29] = "CIRC_OUT_IN";
              EasingMethod[EasingMethod["ELASTIC_IN"] = 30] = "ELASTIC_IN";
              EasingMethod[EasingMethod["ELASTIC_OUT"] = 31] = "ELASTIC_OUT";
              EasingMethod[EasingMethod["ELASTIC_IN_OUT"] = 32] = "ELASTIC_IN_OUT";
              EasingMethod[EasingMethod["ELASTIC_OUT_IN"] = 33] = "ELASTIC_OUT_IN";
              EasingMethod[EasingMethod["BACK_IN"] = 34] = "BACK_IN";
              EasingMethod[EasingMethod["BACK_OUT"] = 35] = "BACK_OUT";
              EasingMethod[EasingMethod["BACK_IN_OUT"] = 36] = "BACK_IN_OUT";
              EasingMethod[EasingMethod["BACK_OUT_IN"] = 37] = "BACK_OUT_IN";
              EasingMethod[EasingMethod["BOUNCE_IN"] = 38] = "BOUNCE_IN";
              EasingMethod[EasingMethod["BOUNCE_OUT"] = 39] = "BOUNCE_OUT";
              EasingMethod[EasingMethod["BOUNCE_IN_OUT"] = 40] = "BOUNCE_IN_OUT";
              EasingMethod[EasingMethod["BOUNCE_OUT_IN"] = 41] = "BOUNCE_OUT_IN";
              EasingMethod[EasingMethod["SMOOTH"] = 42] = "SMOOTH";
              EasingMethod[EasingMethod["FADE"] = 43] = "FADE";
            })(EasingMethod || (EasingMethod = {}));

            const easingMethodFnMap = {
              [EasingMethod.CONSTANT]: constant,
              [EasingMethod.LINEAR]: linear,
              [EasingMethod.QUAD_IN]: quadIn,
              [EasingMethod.QUAD_OUT]: quadOut,
              [EasingMethod.QUAD_IN_OUT]: quadInOut,
              [EasingMethod.QUAD_OUT_IN]: quadOutIn,
              [EasingMethod.CUBIC_IN]: cubicIn,
              [EasingMethod.CUBIC_OUT]: cubicOut,
              [EasingMethod.CUBIC_IN_OUT]: cubicInOut,
              [EasingMethod.CUBIC_OUT_IN]: cubicOutIn,
              [EasingMethod.QUART_IN]: quartIn,
              [EasingMethod.QUART_OUT]: quartOut,
              [EasingMethod.QUART_IN_OUT]: quartInOut,
              [EasingMethod.QUART_OUT_IN]: quartOutIn,
              [EasingMethod.QUINT_IN]: quintIn,
              [EasingMethod.QUINT_OUT]: quintOut,
              [EasingMethod.QUINT_IN_OUT]: quintInOut,
              [EasingMethod.QUINT_OUT_IN]: quintOutIn,
              [EasingMethod.SINE_IN]: sineIn,
              [EasingMethod.SINE_OUT]: sineOut,
              [EasingMethod.SINE_IN_OUT]: sineInOut,
              [EasingMethod.SINE_OUT_IN]: sineOutIn,
              [EasingMethod.EXPO_IN]: expoIn,
              [EasingMethod.EXPO_OUT]: expoOut,
              [EasingMethod.EXPO_IN_OUT]: expoInOut,
              [EasingMethod.EXPO_OUT_IN]: expoOutIn,
              [EasingMethod.CIRC_IN]: circIn,
              [EasingMethod.CIRC_OUT]: circOut,
              [EasingMethod.CIRC_IN_OUT]: circInOut,
              [EasingMethod.CIRC_OUT_IN]: circOutIn,
              [EasingMethod.ELASTIC_IN]: elasticIn,
              [EasingMethod.ELASTIC_OUT]: elasticOut,
              [EasingMethod.ELASTIC_IN_OUT]: elasticInOut,
              [EasingMethod.ELASTIC_OUT_IN]: elasticOutIn,
              [EasingMethod.BACK_IN]: backIn,
              [EasingMethod.BACK_OUT]: backOut,
              [EasingMethod.BACK_IN_OUT]: backInOut,
              [EasingMethod.BACK_OUT_IN]: backOutIn,
              [EasingMethod.BOUNCE_IN]: bounceIn,
              [EasingMethod.BOUNCE_OUT]: bounceOut,
              [EasingMethod.BOUNCE_IN_OUT]: bounceInOut,
              [EasingMethod.BOUNCE_OUT_IN]: bounceOutIn,
              [EasingMethod.SMOOTH]: smooth,
              [EasingMethod.FADE]: fade
            };
            function getEasingFn(easingMethod) {
              assertIsTrue(easingMethod in easingMethodFnMap);
              return easingMethodFnMap[easingMethod];
            }

            var _dec$7, _class$7, _class2$6, _descriptor$5, _descriptor2$3, _temp$5;

            class RealKeyframeValue extends EditorExtendable {
              constructor(...args) {
                super(...args);
                this.interpolationMode = RealInterpolationMode.LINEAR;
                this.tangentWeightMode = TangentWeightMode.NONE;
                this.value = 0.0;
                this.rightTangent = 0.0;
                this.rightTangentWeight = 0.0;
                this.leftTangent = 0.0;
                this.leftTangentWeight = 0.0;
                this.easingMethod = EasingMethod.LINEAR;
              }

            }

            CCClass.fastDefine('cc.RealKeyframeValue', RealKeyframeValue, {
              interpolationMode: RealInterpolationMode.LINEAR,
              tangentWeightMode: TangentWeightMode.NONE,
              value: 0.0,
              rightTangent: 0.0,
              rightTangentWeight: 0.0,
              leftTangent: 0.0,
              leftTangentWeight: 0.0,
              easingMethod: EasingMethod.LINEAR,
              [editorExtrasTag]: undefined
            });
            CCClass.Attr.setClassAttr(RealKeyframeValue, editorExtrasTag, 'editorOnly', true);
            getOrCreateSerializationMetadata(RealKeyframeValue).uniquelyReferenced = true;

            function createRealKeyframeValue(params) {
              const realKeyframeValue = new RealKeyframeValue();

              if (typeof params === 'number') {
                realKeyframeValue.value = params;
              } else {
                const {
                  interpolationMode,
                  tangentWeightMode,
                  value,
                  rightTangent,
                  rightTangentWeight,
                  leftTangent,
                  leftTangentWeight,
                  easingMethod,
                  [editorExtrasTag]: editorExtras
                } = params;
                realKeyframeValue.value = value !== null && value !== void 0 ? value : realKeyframeValue.value;
                realKeyframeValue.rightTangent = rightTangent !== null && rightTangent !== void 0 ? rightTangent : realKeyframeValue.rightTangent;
                realKeyframeValue.rightTangentWeight = rightTangentWeight !== null && rightTangentWeight !== void 0 ? rightTangentWeight : realKeyframeValue.rightTangentWeight;
                realKeyframeValue.leftTangent = leftTangent !== null && leftTangent !== void 0 ? leftTangent : realKeyframeValue.leftTangent;
                realKeyframeValue.leftTangentWeight = leftTangentWeight !== null && leftTangentWeight !== void 0 ? leftTangentWeight : realKeyframeValue.leftTangentWeight;
                realKeyframeValue.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : realKeyframeValue.interpolationMode;
                realKeyframeValue.tangentWeightMode = tangentWeightMode !== null && tangentWeightMode !== void 0 ? tangentWeightMode : realKeyframeValue.tangentWeightMode;
                realKeyframeValue.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : realKeyframeValue.easingMethod;

                if (editorExtras) {
                  realKeyframeValue[editorExtrasTag] = editorExtras;
                }
              }

              return realKeyframeValue;
            }

            let RealCurve = exports('d2', (_dec$7 = ccclass('cc.RealCurve'), _dec$7(_class$7 = (_class2$6 = (_temp$5 = class RealCurve extends KeyframeCurve {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "preExtrapolation", _descriptor$5, this);

                _initializerDefineProperty(this, "postExtrapolation", _descriptor2$3, this);
              }

              evaluate(time) {
                const {
                  _times: times,
                  _values: values
                } = this;
                const nFrames = times.length;

                if (nFrames === 0) {
                  return 0.0;
                }

                const firstTime = times[0];
                const lastTime = times[nFrames - 1];

                if (time < firstTime) {
                  const {
                    preExtrapolation
                  } = this;
                  const preValue = values[0];

                  if (preExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
                    return preValue.value;
                  }

                  switch (preExtrapolation) {
                    case ExtrapolationMode.LINEAR:
                      return linearTrend(firstTime, values[0].value, times[1], values[1].value, time);

                    case ExtrapolationMode.LOOP:
                      time = wrapRepeat(time, firstTime, lastTime);
                      break;

                    case ExtrapolationMode.PING_PONG:
                      time = wrapPingPong(time, firstTime, lastTime);
                      break;

                    default:
                      return preValue.value;
                  }
                } else if (time > lastTime) {
                  const {
                    postExtrapolation
                  } = this;
                  const preFrame = values[nFrames - 1];

                  if (postExtrapolation === ExtrapolationMode.CLAMP || nFrames < 2) {
                    return preFrame.value;
                  }

                  switch (postExtrapolation) {
                    case ExtrapolationMode.LINEAR:
                      return linearTrend(lastTime, preFrame.value, times[nFrames - 2], values[nFrames - 2].value, time);

                    case ExtrapolationMode.LOOP:
                      time = wrapRepeat(time, firstTime, lastTime);
                      break;

                    case ExtrapolationMode.PING_PONG:
                      time = wrapPingPong(time, firstTime, lastTime);
                      break;

                    default:
                      return preFrame.value;
                  }
                }

                const index = binarySearchEpsilon(times, time);

                if (index >= 0) {
                  return values[index].value;
                }

                const iNext = ~index;
                assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
                const iPre = iNext - 1;
                const preTime = times[iPre];
                const preValue = values[iPre];
                const nextTime = times[iNext];
                const nextValue = values[iNext];
                assertIsTrue(nextTime > time && time > preTime);
                const dt = nextTime - preTime;
                const ratio = (time - preTime) / dt;
                return evalBetweenTwoKeyFrames(preTime, preValue, nextTime, nextValue, ratio);
              }

              addKeyFrame(time, value) {
                return super.addKeyFrame(time, createRealKeyframeValue(value));
              }

              assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.map(value => createRealKeyframeValue(value)));
                } else {
                  const keyframes = Array.from(times);
                  this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => createRealKeyframeValue(value)));
                }
              }

              isConstant(tolerance) {
                if (this._values.length <= 1) {
                  return true;
                }

                const firstVal = this._values[0].value;
                return this._values.every(frame => approx(frame.value, firstVal, tolerance));
              }

              [serializeTag](output, context) {
                if (!context.toCCON) {
                  output.writeThis();
                  return;
                }

                const {
                  _times: times,
                  _values: keyframeValues
                } = this;
                const nKeyframes = times.length;
                const dataSize = 0 + OVERFLOW_BYTES + OVERFLOW_BYTES + FRAME_COUNT_BYTES + TIME_BYTES * nKeyframes + REAL_KEY_FRAME_VALUE_MAX_SIZE * nKeyframes;
                const dataView = new DataView(new ArrayBuffer(dataSize));
                let currentOffset = 0;
                dataView.setUint8(currentOffset, this.preExtrapolation);
                currentOffset += OVERFLOW_BYTES;
                dataView.setUint8(currentOffset, this.postExtrapolation);
                currentOffset += OVERFLOW_BYTES;
                dataView.setUint32(currentOffset, nKeyframes, true);
                currentOffset += FRAME_COUNT_BYTES;
                times.forEach((time, index) => dataView.setFloat32(currentOffset + TIME_BYTES * index, time, true));
                currentOffset += TIME_BYTES * nKeyframes;

                for (const keyframeValue of keyframeValues) {
                  currentOffset = saveRealKeyFrameValue(dataView, keyframeValue, currentOffset);
                }

                const bytes = new Uint8Array(dataView.buffer, 0, currentOffset);
                output.writeProperty('bytes', bytes);
                const keyframeValueEditorExtras = keyframeValues.map(keyframeValue => keyframeValue[editorExtrasTag]);

                if (keyframeValueEditorExtras.some(extras => extras !== undefined)) {
                  output.writeProperty(`keyframeValueEditorExtras`, keyframeValueEditorExtras);
                }
              }

              [deserializeTag](input, context) {
                if (!context.fromCCON) {
                  input.readThis();
                  return;
                }

                const bytes = input.readProperty('bytes');
                const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
                let currentOffset = 0;
                this.preExtrapolation = dataView.getUint8(currentOffset);
                currentOffset += OVERFLOW_BYTES;
                this.postExtrapolation = dataView.getUint8(currentOffset);
                currentOffset += OVERFLOW_BYTES;
                const nKeyframes = dataView.getUint32(currentOffset, true);
                currentOffset += FRAME_COUNT_BYTES;
                const times = Array.from({
                  length: nKeyframes
                }, (_, index) => dataView.getFloat32(currentOffset + TIME_BYTES * index, true));
                currentOffset += TIME_BYTES * nKeyframes;
                const keyframeValues = new Array(nKeyframes);

                for (let iKeyFrame = 0; iKeyFrame < nKeyframes; ++iKeyFrame) {
                  const keyframeValue = createRealKeyframeValue({});
                  currentOffset = loadRealKeyFrameValue(dataView, keyframeValue, currentOffset);
                  keyframeValues[iKeyFrame] = keyframeValue;
                }

                assertIsTrue(currentOffset === bytes.byteLength);
                const keyframeValueEditorExtras = input.readProperty(`keyframeValueEditorExtras`);

                if (keyframeValueEditorExtras) {
                  assertIsTrue(keyframeValueEditorExtras.length === nKeyframes);
                  keyframeValueEditorExtras.forEach((extras, index) => keyframeValues[index][editorExtrasTag] = extras);
                }

                this._times = times;
                this._values = keyframeValues;
              }

            }, _temp$5), (_descriptor$5 = _applyDecoratedDescriptor(_class2$6.prototype, "preExtrapolation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ExtrapolationMode.CLAMP;
              }
            }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$6.prototype, "postExtrapolation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ExtrapolationMode.CLAMP;
              }
            })), _class2$6)) || _class$7));
            const FLAGS_EASING_METHOD_BITS_START = 8;
            const FLAG_EASING_METHOD_MASK = 0xFF << FLAGS_EASING_METHOD_BITS_START;
            var KeyframeValueFlagMask;

            (function (KeyframeValueFlagMask) {
              KeyframeValueFlagMask[KeyframeValueFlagMask["VALUE"] = 1] = "VALUE";
              KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 2] = "INTERPOLATION_MODE";
              KeyframeValueFlagMask[KeyframeValueFlagMask["TANGENT_WEIGHT_MODE"] = 4] = "TANGENT_WEIGHT_MODE";
              KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT"] = 8] = "LEFT_TANGENT";
              KeyframeValueFlagMask[KeyframeValueFlagMask["LEFT_TANGENT_WEIGHT"] = 16] = "LEFT_TANGENT_WEIGHT";
              KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT"] = 32] = "RIGHT_TANGENT";
              KeyframeValueFlagMask[KeyframeValueFlagMask["RIGHT_TANGENT_WEIGHT"] = 64] = "RIGHT_TANGENT_WEIGHT";
            })(KeyframeValueFlagMask || (KeyframeValueFlagMask = {}));

            const OVERFLOW_BYTES = 1;
            const FRAME_COUNT_BYTES = 4;
            const TIME_BYTES = 4;
            const KEY_FRAME_VALUE_FLAGS_BYTES = 4;
            const VALUE_BYTES = 4;
            const INTERPOLATION_MODE_BYTES = 1;
            const TANGENT_WEIGHT_MODE_BYTES = 1;
            const LEFT_TANGENT_BYTES = 4;
            const LEFT_TANGENT_WEIGHT_BYTES = 4;
            const RIGHT_TANGENT_BYTES = 4;
            const RIGHT_TANGENT_WEIGHT_BYTES = 4;
            const {
              interpolationMode: DEFAULT_INTERPOLATION_MODE,
              tangentWeightMode: DEFAULT_TANGENT_WEIGHT_MODE,
              leftTangent: DEFAULT_LEFT_TANGENT,
              leftTangentWeight: DEFAULT_LEFT_TANGENT_WEIGHT,
              rightTangent: DEFAULT_RIGHT_TANGENT,
              rightTangentWeight: DEFAULT_RIGHT_TANGENT_WEIGHT
            } = createRealKeyframeValue({});
            const REAL_KEY_FRAME_VALUE_MAX_SIZE = KEY_FRAME_VALUE_FLAGS_BYTES + VALUE_BYTES + INTERPOLATION_MODE_BYTES + TANGENT_WEIGHT_MODE_BYTES + LEFT_TANGENT_BYTES + LEFT_TANGENT_WEIGHT_BYTES + RIGHT_TANGENT_BYTES + RIGHT_TANGENT_WEIGHT_BYTES + 0;

            function saveRealKeyFrameValue(dataView, keyframeValue, offset) {
              let flags = 0;
              let currentOffset = offset;
              const pFlags = currentOffset;
              currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
              const {
                value,
                interpolationMode,
                tangentWeightMode,
                rightTangent,
                rightTangentWeight,
                leftTangent,
                leftTangentWeight,
                easingMethod
              } = keyframeValue;
              dataView.setFloat32(currentOffset, value, true);
              currentOffset += VALUE_BYTES;

              if (interpolationMode !== DEFAULT_INTERPOLATION_MODE) {
                flags |= KeyframeValueFlagMask.INTERPOLATION_MODE;
                dataView.setUint8(currentOffset, interpolationMode);
                currentOffset += INTERPOLATION_MODE_BYTES;
              }

              if (tangentWeightMode !== DEFAULT_TANGENT_WEIGHT_MODE) {
                flags |= KeyframeValueFlagMask.TANGENT_WEIGHT_MODE;
                dataView.setUint8(currentOffset, tangentWeightMode);
                currentOffset += TANGENT_WEIGHT_MODE_BYTES;
              }

              if (leftTangent !== DEFAULT_LEFT_TANGENT) {
                flags |= KeyframeValueFlagMask.LEFT_TANGENT;
                dataView.setFloat32(currentOffset, leftTangent, true);
                currentOffset += LEFT_TANGENT_BYTES;
              }

              if (leftTangentWeight !== DEFAULT_LEFT_TANGENT_WEIGHT) {
                flags |= KeyframeValueFlagMask.LEFT_TANGENT_WEIGHT;
                dataView.setFloat32(currentOffset, leftTangentWeight, true);
                currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
              }

              if (rightTangent !== DEFAULT_RIGHT_TANGENT) {
                flags |= KeyframeValueFlagMask.RIGHT_TANGENT;
                dataView.setFloat32(currentOffset, rightTangent, true);
                currentOffset += RIGHT_TANGENT_BYTES;
              }

              if (rightTangentWeight !== DEFAULT_RIGHT_TANGENT_WEIGHT) {
                flags |= KeyframeValueFlagMask.RIGHT_TANGENT_WEIGHT;
                dataView.setFloat32(currentOffset, rightTangentWeight, true);
                currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
              }

              flags |= easingMethod << FLAGS_EASING_METHOD_BITS_START;
              dataView.setUint32(pFlags, flags, true);
              return currentOffset;
            }

            function loadRealKeyFrameValue(dataView, keyframeValue, offset) {
              let currentOffset = offset;
              const flags = dataView.getUint32(currentOffset, true);
              currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
              keyframeValue.value = dataView.getFloat32(currentOffset, true);
              currentOffset += VALUE_BYTES;

              if (flags & KeyframeValueFlagMask.INTERPOLATION_MODE) {
                keyframeValue.interpolationMode = dataView.getUint8(currentOffset);
                currentOffset += INTERPOLATION_MODE_BYTES;
              }

              if (flags & KeyframeValueFlagMask.TANGENT_WEIGHT_MODE) {
                keyframeValue.tangentWeightMode = dataView.getUint8(currentOffset);
                currentOffset += TANGENT_WEIGHT_MODE_BYTES;
              }

              if (flags & KeyframeValueFlagMask.LEFT_TANGENT) {
                keyframeValue.leftTangent = dataView.getFloat32(currentOffset, true);
                currentOffset += LEFT_TANGENT_BYTES;
              }

              if (flags & KeyframeValueFlagMask.LEFT_TANGENT_WEIGHT) {
                keyframeValue.leftTangentWeight = dataView.getFloat32(currentOffset, true);
                currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
              }

              if (flags & KeyframeValueFlagMask.RIGHT_TANGENT) {
                keyframeValue.rightTangent = dataView.getFloat32(currentOffset, true);
                currentOffset += RIGHT_TANGENT_BYTES;
              }

              if (flags & KeyframeValueFlagMask.RIGHT_TANGENT_WEIGHT) {
                keyframeValue.rightTangentWeight = dataView.getFloat32(currentOffset, true);
                currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
              }

              const easingMethod = (flags & FLAG_EASING_METHOD_MASK) >> FLAGS_EASING_METHOD_BITS_START;
              keyframeValue.easingMethod = easingMethod;
              return currentOffset;
            }

            function wrapRepeat(time, prevTime, nextTime) {
              return prevTime + repeat(time - prevTime, nextTime - prevTime);
            }

            function wrapPingPong(time, prevTime, nextTime) {
              return prevTime + pingPong(time - prevTime, nextTime - prevTime);
            }

            function linearTrend(prevTime, prevValue, nextTime, nextValue, time) {
              const slope = (nextValue - prevValue) / (nextTime - prevTime);
              return prevValue + (time - prevTime) * slope;
            }

            function evalBetweenTwoKeyFrames(prevTime, prevValue, nextTime, nextValue, ratio) {
              const dt = nextTime - prevTime;

              switch (prevValue.interpolationMode) {
                default:
                case RealInterpolationMode.CONSTANT:
                  return prevValue.value;

                case RealInterpolationMode.LINEAR:
                  {
                    const transformedRatio = prevValue.easingMethod === EasingMethod.LINEAR ? ratio : getEasingFn(prevValue.easingMethod)(ratio);
                    return lerp(prevValue.value, nextValue.value, transformedRatio);
                  }

                case RealInterpolationMode.CUBIC:
                  {
                    const ONE_THIRD = 1.0 / 3.0;
                    const {
                      rightTangent: prevTangent,
                      rightTangentWeight: prevTangentWeightSpecified
                    } = prevValue;
                    const prevTangentWeightEnabled = isRightTangentWeightEnabled(prevValue.tangentWeightMode);
                    const {
                      leftTangent: nextTangent,
                      leftTangentWeight: nextTangentWeightSpecified
                    } = nextValue;
                    const nextTangentWeightEnabled = isLeftTangentWeightEnabled(nextValue.tangentWeightMode);

                    if (!prevTangentWeightEnabled && !nextTangentWeightEnabled) {
                      const p1 = prevValue.value + ONE_THIRD * prevTangent * dt;
                      const p2 = nextValue.value - ONE_THIRD * nextTangent * dt;
                      return bezierInterpolate(prevValue.value, p1, p2, nextValue.value, ratio);
                    } else {
                      let prevTangentWeight = 0.0;

                      if (prevTangentWeightEnabled) {
                        prevTangentWeight = prevTangentWeightSpecified;
                      } else {
                        const x = dt;
                        const y = dt * prevTangent;
                        prevTangentWeight = Math.sqrt(x * x + y * y) * ONE_THIRD;
                      }

                      const angle0 = Math.atan(prevTangent);
                      const tx0 = Math.cos(angle0) * prevTangentWeight + prevTime;
                      const ty0 = Math.sin(angle0) * prevTangentWeight + prevValue.value;
                      let nextTangentWeight = 0.0;

                      if (nextTangentWeightEnabled) {
                        nextTangentWeight = nextTangentWeightSpecified;
                      } else {
                        const x = dt;
                        const y = dt * nextTangent;
                        nextTangentWeight = Math.sqrt(x * x + y * y) * ONE_THIRD;
                      }

                      const angle1 = Math.atan(nextTangent);
                      const tx1 = -Math.cos(angle1) * nextTangentWeight + nextTime;
                      const ty1 = -Math.sin(angle1) * nextTangentWeight + nextValue.value;
                      const dx = dt;
                      const u0x = (tx0 - prevTime) / dx;
                      const u1x = (tx1 - prevTime) / dx;
                      const u0y = ty0;
                      const u1y = ty1;
                      const coeff0 = 0.0;
                      const coeff1 = 3.0 * u0x;
                      const coeff2 = 3.0 * u1x - 6.0 * u0x;
                      const coeff3 = 3.0 * (u0x - u1x) + 1.0;
                      const solutions = [0.0, 0.0, 0.0];
                      const nSolutions = solveCubic(coeff0 - ratio, coeff1, coeff2, coeff3, solutions);
                      const param = getParamFromCubicSolution(solutions, nSolutions, ratio);
                      const y = bezierInterpolate(prevValue.value, u0y, u1y, nextValue.value, param);
                      return y;
                    }
                  }
              }
            }

            function isLeftTangentWeightEnabled(tangentWeightMode) {
              return (tangentWeightMode & TangentWeightMode.LEFT) !== 0;
            }

            function isRightTangentWeightEnabled(tangentWeightMode) {
              return (tangentWeightMode & TangentWeightMode.RIGHT) !== 0;
            }

            function bezierInterpolate(p0, p1, p2, p3, t) {
              const u = 1 - t;
              const coeff0 = u * u * u;
              const coeff1 = 3 * u * u * t;
              const coeff2 = 3 * u * t * t;
              const coeff3 = t * t * t;
              return coeff0 * p0 + coeff1 * p1 + coeff2 * p2 + coeff3 * p3;
            }

            function getParamFromCubicSolution(solutions, solutionsCount, x) {
              let param = x;

              if (solutionsCount === 1) {
                param = solutions[0];
              } else {
                param = -Infinity;

                for (let iSolution = 0; iSolution < solutionsCount; ++iSolution) {
                  const solution = solutions[iSolution];

                  if (solution >= 0.0 && solution <= 1.0) {
                    if (solution > param) {
                      param = solution;
                    }
                  }
                }

                if (param === -Infinity) {
                  param = 0.0;
                }
              }

              return param;
            }

            function bezier(C1, C2, C3, C4, t) {
              const t1 = 1 - t;
              return t1 * (t1 * (C1 + (C2 * 3 - C1) * t) + C3 * 3 * t * t) + C4 * t * t * t;
            }
            legacyCC.bezier = bezier;
            const cos = Math.cos;
            const acos = Math.acos;
            const max$2 = Math.max;
            const pi = Math.PI;
            const tau = 2 * pi;
            const sqrt = Math.sqrt;

            function crt(v) {
              if (v < 0) {
                return -Math.pow(-v, 1 / 3);
              } else {
                return Math.pow(v, 1 / 3);
              }
            }

            function cardano(curve, x) {
              const pa = x - 0;
              const pb = x - curve[0];
              const pc = x - curve[2];
              const pd = x - 1;
              const pa3 = pa * 3;
              const pb3 = pb * 3;
              const pc3 = pc * 3;
              const d = -pa + pb3 - pc3 + pd;
              const rd = 1 / d;
              const r3 = 1 / 3;
              const a = (pa3 - 6 * pb + pc3) * rd;
              const a3 = a * r3;
              const b = (-pa3 + pb3) * rd;
              const c = pa * rd;
              const p = (3 * b - a * a) * r3;
              const p3 = p * r3;
              const q = (2 * a * a * a - 9 * a * b + 27 * c) / 27;
              const q2 = q / 2;
              const discriminant = q2 * q2 + p3 * p3 * p3;
              let u1;
              let v1;
              let x1;
              let x2;
              let x3;

              if (discriminant < 0) {
                const mp3 = -p * r3;
                const mp33 = mp3 * mp3 * mp3;
                const r = sqrt(mp33);
                const t = -q / (2 * r);
                const cosphi = t < -1 ? -1 : t > 1 ? 1 : t;
                const phi = acos(cosphi);
                const crtr = crt(r);
                const t1 = 2 * crtr;
                x1 = t1 * cos(phi * r3) - a3;
                x2 = t1 * cos((phi + tau) * r3) - a3;
                x3 = t1 * cos((phi + 2 * tau) * r3) - a3;

                if (x1 >= 0 && x1 <= 1) {
                  if (x2 >= 0 && x2 <= 1) {
                    if (x3 >= 0 && x3 <= 1) {
                      return max$2(x1, x2, x3);
                    } else {
                      return max$2(x1, x2);
                    }
                  } else if (x3 >= 0 && x3 <= 1) {
                    return max$2(x1, x3);
                  } else {
                    return x1;
                  }
                } else if (x2 >= 0 && x2 <= 1) {
                  if (x3 >= 0 && x3 <= 1) {
                    return max$2(x2, x3);
                  } else {
                    return x2;
                  }
                } else {
                  return x3;
                }
              } else if (discriminant === 0) {
                u1 = q2 < 0 ? crt(-q2) : -crt(q2);
                x1 = 2 * u1 - a3;
                x2 = -u1 - a3;

                if (x1 >= 0 && x1 <= 1) {
                  if (x2 >= 0 && x2 <= 1) {
                    return max$2(x1, x2);
                  } else {
                    return x1;
                  }
                } else {
                  return x2;
                }
              } else {
                  const sd = sqrt(discriminant);
                  u1 = crt(-q2 + sd);
                  v1 = crt(q2 + sd);
                  x1 = u1 - v1 - a3;
                  return x1;
                }
            }

            function bezierByTime(controlPoints, x) {
              const percent = cardano(controlPoints, x);
              const p1y = controlPoints[1];
              const p2y = controlPoints[3];
              return ((1 - percent) * (p1y + (p2y - p1y) * percent) * 3 + percent * percent) * percent;
            }
            legacyCC.bezierByTime = bezierByTime;

            var _dec$8, _class$8, _class2$7, _descriptor$6, _descriptor2$4, _descriptor3$2, _temp$6, _dec2$3, _class4, _class5, _descriptor4$1, _descriptor5, _temp2;
            let QuatInterpolationMode;

            (function (QuatInterpolationMode) {
              QuatInterpolationMode[QuatInterpolationMode["SLERP"] = 0] = "SLERP";
              QuatInterpolationMode[QuatInterpolationMode["CONSTANT"] = 1] = "CONSTANT";
            })(QuatInterpolationMode || (QuatInterpolationMode = exports('gE', {})));

            let QuatKeyframeValue = (_dec$8 = ccclass('cc.QuatKeyframeValue'), _dec$8(_class$8 = uniquelyReferenced(_class$8 = (_class2$7 = (_temp$6 = class QuatKeyframeValue {
              constructor({
                value,
                interpolationMode,
                easingMethod
              } = {}) {
                _initializerDefineProperty(this, "interpolationMode", _descriptor$6, this);

                _initializerDefineProperty(this, "value", _descriptor2$4, this);

                _initializerDefineProperty(this, "easingMethod", _descriptor3$2, this);

                this.value = value ? Quat.clone(value) : this.value;
                this.interpolationMode = interpolationMode !== null && interpolationMode !== void 0 ? interpolationMode : this.interpolationMode;
                this.easingMethod = easingMethod !== null && easingMethod !== void 0 ? easingMethod : this.easingMethod;
              }

            }, _temp$6), (_descriptor$6 = _applyDecoratedDescriptor(_class2$7.prototype, "interpolationMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return QuatInterpolationMode.SLERP;
              }
            }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$7.prototype, "value", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Quat.clone(Quat.IDENTITY);
              }
            }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$7.prototype, "easingMethod", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return EasingMethod.LINEAR;
              }
            })), _class2$7)) || _class$8) || _class$8);

            function createQuatKeyframeValue(params) {
              return new QuatKeyframeValue(params);
            }

            let QuatCurve = exports('gD', (_dec2$3 = ccclass('cc.QuatCurve'), _dec2$3(_class4 = (_class5 = (_temp2 = class QuatCurve extends KeyframeCurve {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "preExtrapolation", _descriptor4$1, this);

                _initializerDefineProperty(this, "postExtrapolation", _descriptor5, this);
              }

              evaluate(time, quat) {
                var _quat;

                (_quat = quat) !== null && _quat !== void 0 ? _quat : quat = new Quat();
                const {
                  _times: times,
                  _values: values,
                  postExtrapolation,
                  preExtrapolation
                } = this;
                const nFrames = times.length;

                if (nFrames === 0) {
                  return quat;
                }

                const firstTime = times[0];
                const lastTime = times[nFrames - 1];

                if (time < firstTime) {
                  const preValue = values[0];

                  switch (preExtrapolation) {
                    case ExtrapolationMode.LOOP:
                      time = firstTime + repeat(time - firstTime, lastTime - firstTime);
                      break;

                    case ExtrapolationMode.PING_PONG:
                      time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                      break;

                    case ExtrapolationMode.CLAMP:
                    default:
                      return Quat.copy(quat, preValue.value);
                  }
                } else if (time > lastTime) {
                  const preValue = values[nFrames - 1];

                  switch (postExtrapolation) {
                    case ExtrapolationMode.LOOP:
                      time = firstTime + repeat(time - firstTime, lastTime - firstTime);
                      break;

                    case ExtrapolationMode.PING_PONG:
                      time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                      break;

                    case ExtrapolationMode.CLAMP:
                    default:
                      return Quat.copy(quat, preValue.value);
                  }
                }

                const index = binarySearchEpsilon(times, time);

                if (index >= 0) {
                  return Quat.copy(quat, values[index].value);
                }

                const iNext = ~index;
                assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
                const iPre = iNext - 1;
                const preTime = times[iPre];
                const preValue = values[iPre];
                const nextTime = times[iNext];
                const nextValue = values[iNext];
                assertIsTrue(nextTime > time && time > preTime);
                const dt = nextTime - preTime;
                const ratio = (time - preTime) / dt;

                switch (preValue.interpolationMode) {
                  default:
                  case QuatInterpolationMode.CONSTANT:
                    return Quat.copy(quat, preValue.value);

                  case QuatInterpolationMode.SLERP:
                    {
                      const {
                        easingMethod
                      } = preValue;
                      const transformedRatio = easingMethod === EasingMethod.LINEAR ? ratio : Array.isArray(easingMethod) ? bezierByTime(easingMethod, ratio) : getEasingFn(easingMethod)(ratio);
                      return Quat.slerp(quat, preValue.value, nextValue.value, transformedRatio);
                    }
                }
              }

              addKeyFrame(time, value) {
                const keyframeValue = new QuatKeyframeValue(value);
                return super.addKeyFrame(time, keyframeValue);
              }

              assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.map(value => createQuatKeyframeValue(value)));
                } else {
                  const keyframes = Array.from(times);
                  this.setKeyframes(keyframes.map(([time]) => time), keyframes.map(([, value]) => createQuatKeyframeValue(value)));
                }
              }

              [serializeTag](output, context) {
                if (!context.toCCON) {
                  output.writeThis();
                  return;
                }

                const {
                  _times: times,
                  _values: keyframeValues
                } = this;
                let interpolationModeRepeated = true;
                keyframeValues.forEach((keyframeValue, _index, [firstKeyframeValue]) => {
                  if (interpolationModeRepeated && keyframeValue.interpolationMode !== firstKeyframeValue.interpolationMode) {
                    interpolationModeRepeated = false;
                  }
                });
                const nKeyframes = times.length;
                const nFrames = nKeyframes;
                const interpolationModesSize = INTERPOLATION_MODE_BYTES$1 * (interpolationModeRepeated ? 1 : nFrames);
                const easingMethodsSize = keyframeValues.reduce((result, {
                  easingMethod
                }) => result += Array.isArray(easingMethod) ? EASING_METHOD_BYTES + EASING_METHOD_BEZIER_COMPONENT_BYTES * 4 : EASING_METHOD_BYTES, 0);
                let dataSize = 0;
                dataSize += FLAGS_BYTES + FRAME_COUNT_BYTES$1 + TIME_BYTES$1 * nFrames + VALUE_BYTES$1 * 4 * nFrames + easingMethodsSize + interpolationModesSize + 0;
                const dataView = new DataView(new ArrayBuffer(dataSize));
                let P = 0;
                let flags = 0;

                if (interpolationModeRepeated) {
                  flags |= KeyframeValueFlagMask$1.INTERPOLATION_MODE;
                }

                dataView.setUint32(P, flags, true);
                P += FLAGS_BYTES;
                dataView.setUint32(P, nFrames, true);
                P += FRAME_COUNT_BYTES$1;
                times.forEach((time, index) => dataView.setFloat32(P + TIME_BYTES$1 * index, time, true));
                P += TIME_BYTES$1 * nFrames;
                keyframeValues.forEach(({
                  value: {
                    x,
                    y,
                    z,
                    w
                  }
                }, index) => {
                  const pQuat = P + VALUE_BYTES$1 * 4 * index;
                  dataView.setFloat32(pQuat + VALUE_BYTES$1 * 0, x, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES$1 * 1, y, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES$1 * 2, z, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES$1 * 3, w, true);
                });
                P += VALUE_BYTES$1 * 4 * nFrames;
                keyframeValues.forEach(({
                  easingMethod
                }, index) => {
                  if (!Array.isArray(easingMethod)) {
                    dataView.setUint8(P, easingMethod);
                    ++P;
                  } else {
                    dataView.setUint8(P, EASING_METHOD_BEZIER_TAG);
                    ++P;
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, easingMethod[0], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, easingMethod[1], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, easingMethod[2], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, easingMethod[3], true);
                    P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
                  }
                });
                const INTERPOLATION_MODES_START = P;
                P += interpolationModesSize;
                let pInterpolationMode = INTERPOLATION_MODES_START;
                keyframeValues.forEach(({
                  interpolationMode
                }) => {
                  dataView.setUint8(pInterpolationMode, interpolationMode);

                  if (!interpolationModeRepeated) {
                    pInterpolationMode += INTERPOLATION_MODE_BYTES$1;
                  }
                });
                const bytes = new Uint8Array(dataView.buffer);
                output.writeProperty('bytes', bytes);
              }

              [deserializeTag](input, context) {
                if (!context.fromCCON) {
                  input.readThis();
                  return;
                }

                const bytes = input.readProperty('bytes');
                const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
                let P = 0;
                const flags = dataView.getUint32(P, true);
                P += FLAGS_BYTES;
                const interpolationModeRepeated = flags & KeyframeValueFlagMask$1.INTERPOLATION_MODE;
                const nFrames = dataView.getUint32(P, true);
                P += FRAME_COUNT_BYTES$1;
                const times = Array.from({
                  length: nFrames
                }, (_, index) => dataView.getFloat32(P + TIME_BYTES$1 * index, true));
                P += TIME_BYTES$1 * nFrames;
                const P_VALUES = P;
                P += VALUE_BYTES$1 * 4 * nFrames;
                const keyframeValues = Array.from({
                  length: nFrames
                }, (_, index) => {
                  const pQuat = P_VALUES + VALUE_BYTES$1 * 4 * index;
                  const x = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 0, true);
                  const y = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 1, true);
                  const z = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 2, true);
                  const w = dataView.getFloat32(pQuat + VALUE_BYTES$1 * 3, true);
                  const easingMethod = dataView.getUint8(P);
                  ++P;
                  const keyframeValue = createQuatKeyframeValue({
                    value: {
                      x,
                      y,
                      z,
                      w
                    }
                  });

                  if (easingMethod !== EASING_METHOD_BEZIER_TAG) {
                    keyframeValue.easingMethod = easingMethod;
                  } else {
                    keyframeValue.easingMethod = [dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, true)];
                    P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
                  }

                  return keyframeValue;
                });

                if (interpolationModeRepeated) {
                  const interpolationMode = dataView.getUint8(P);
                  ++P;

                  for (let iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
                    keyframeValues[iKeyframe].interpolationMode = interpolationMode;
                  }
                } else {
                  for (let iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
                    const interpolationMode = dataView.getUint8(P + iKeyframe);
                    keyframeValues[iKeyframe].interpolationMode = interpolationMode;
                  }

                  P += nFrames;
                }

                this._times = times;
                this._values = keyframeValues;
              }

            }, _temp2), (_descriptor4$1 = _applyDecoratedDescriptor(_class5.prototype, "preExtrapolation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ExtrapolationMode.CLAMP;
              }
            }), _descriptor5 = _applyDecoratedDescriptor(_class5.prototype, "postExtrapolation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ExtrapolationMode.CLAMP;
              }
            })), _class5)) || _class4));
            var KeyframeValueFlagMask$1;

            (function (KeyframeValueFlagMask) {
              KeyframeValueFlagMask[KeyframeValueFlagMask["INTERPOLATION_MODE"] = 1] = "INTERPOLATION_MODE";
            })(KeyframeValueFlagMask$1 || (KeyframeValueFlagMask$1 = {}));

            const FLAGS_BYTES = 1;
            const FRAME_COUNT_BYTES$1 = 4;
            const TIME_BYTES$1 = 4;
            const VALUE_BYTES$1 = 4;
            const INTERPOLATION_MODE_BYTES$1 = 1;
            const EASING_METHOD_BYTES = 1;
            const EASING_METHOD_BEZIER_TAG = 255;
            const EASING_METHOD_BEZIER_COMPONENT_BYTES = 4;

            var _dec$9, _class$9;
            let ObjectCurve = exports('gF', (_dec$9 = ccclass('cc.ObjectCurve'), _dec$9(_class$9 = class ObjectCurve extends KeyframeCurve {
              evaluate(time) {
                const iSearch = this.searchKeyframe(time);

                if (iSearch >= 0) {
                  return this._values[iSearch];
                }

                const iPrev = clamp(~iSearch - 1, 0, this._values.length - 1);
                return this._values[iPrev];
              }

            }) || _class$9));

            var _dec$a, _class$a, _class2$8, _descriptor$7, _class3$3, _temp$7;
            const LOOK_FORWARD = 3;
            class Keyframe {
              constructor() {
                this.time = 0;
                this.value = 0;
                this.inTangent = 0;
                this.outTangent = 0;
              }

            }
            CCClass.fastDefine('cc.Keyframe', Keyframe, {
              time: 0,
              value: 0,
              inTangent: 0,
              outTangent: 0
            });
            class OptimizedKey {
              constructor() {
                this.index = void 0;
                this.time = void 0;
                this.endTime = void 0;
                this.coefficient = void 0;
                this.index = -1;
                this.time = 0;
                this.endTime = 0;
                this.coefficient = new Float32Array(4);
              }

              evaluate(T) {
                const t = T - this.time;
                return evalOptCurve(t, this.coefficient);
              }

            }
            function evalOptCurve(t, coefs) {
              return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
            }
            let AnimationCurve = exports('d3', (_dec$a = ccclass('cc.AnimationCurve'), _dec$a(_class$a = (_class2$8 = (_temp$7 = _class3$3 = class AnimationCurve {
              get _internalCurve() {
                return this._curve;
              }

              get keyFrames() {
                return Array.from(this._curve.keyframes()).map(([time, value]) => {
                  const legacyKeyframe = new Keyframe();
                  legacyKeyframe.time = time;
                  legacyKeyframe.value = value.value;
                  legacyKeyframe.inTangent = value.leftTangent;
                  legacyKeyframe.outTangent = value.rightTangent;
                  return legacyKeyframe;
                });
              }

              set keyFrames(value) {
                this._curve.assignSorted(value.map(legacyCurve => [legacyCurve.time, {
                  interpolationMode: RealInterpolationMode.CUBIC,
                  value: legacyCurve.value,
                  leftTangent: legacyCurve.inTangent,
                  rightTangent: legacyCurve.outTangent
                }]));
              }

              get preWrapMode() {
                return toLegacyWrapMode(this._curve.preExtrapolation);
              }

              set preWrapMode(value) {
                this._curve.preExtrapolation = fromLegacyWrapMode(value);
              }

              get postWrapMode() {
                return toLegacyWrapMode(this._curve.postExtrapolation);
              }

              set postWrapMode(value) {
                this._curve.postExtrapolation = fromLegacyWrapMode(value);
              }

              constructor(keyFrames = null) {
                _initializerDefineProperty(this, "_curve", _descriptor$7, this);

                this.cachedKey = void 0;

                if (keyFrames instanceof RealCurve) {
                  this._curve = keyFrames;
                } else {
                  const curve = new RealCurve();
                  this._curve = curve;
                  curve.preExtrapolation = ExtrapolationMode.LOOP;
                  curve.postExtrapolation = ExtrapolationMode.CLAMP;

                  if (!keyFrames) {
                    curve.assignSorted([[0.0, {
                      interpolationMode: RealInterpolationMode.CUBIC,
                      value: 1.0
                    }], [1.0, {
                      interpolationMode: RealInterpolationMode.CUBIC,
                      value: 1.0
                    }]]);
                  } else {
                    curve.assignSorted(keyFrames.map(legacyKeyframe => [legacyKeyframe.time, {
                      interpolationMode: RealInterpolationMode.CUBIC,
                      value: legacyKeyframe.value,
                      leftTangent: legacyKeyframe.inTangent,
                      rightTangent: legacyKeyframe.outTangent
                    }]));
                  }
                }

                this.cachedKey = new OptimizedKey();
              }

              addKey(keyFrame) {
                if (!keyFrame) {
                  this._curve.clear();
                } else {
                  this._curve.addKeyFrame(keyFrame.time, {
                    interpolationMode: RealInterpolationMode.CUBIC,
                    value: keyFrame.value,
                    leftTangent: keyFrame.inTangent,
                    rightTangent: keyFrame.outTangent
                  });
                }
              }

              evaluate_slow(time) {
                return this._curve.evaluate(time);
              }

              evaluate(time) {
                const {
                  cachedKey,
                  _curve: curve
                } = this;
                const nKeyframes = curve.keyFramesCount;
                const lastKeyframeIndex = nKeyframes - 1;
                let wrappedTime = time;
                const extrapolationMode = time < 0 ? curve.preExtrapolation : curve.postExtrapolation;
                const startTime = curve.getKeyframeTime(0);
                const endTime = curve.getKeyframeTime(lastKeyframeIndex);

                switch (extrapolationMode) {
                  case ExtrapolationMode.LOOP:
                    wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                    break;

                  case ExtrapolationMode.PING_PONG:
                    wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                    break;

                  case ExtrapolationMode.CLAMP:
                  default:
                    wrappedTime = clamp(time, startTime, endTime);
                    break;
                }

                if (wrappedTime >= cachedKey.time && wrappedTime < cachedKey.endTime) {
                  return cachedKey.evaluate(wrappedTime);
                }

                const leftIndex = this.findIndex(cachedKey, wrappedTime);
                const rightIndex = Math.min(leftIndex + 1, lastKeyframeIndex);
                this.calcOptimizedKey(cachedKey, leftIndex, rightIndex);
                return cachedKey.evaluate(wrappedTime);
              }

              calcOptimizedKey(optKey, leftIndex, rightIndex) {
                const lhsTime = this._curve.getKeyframeTime(leftIndex);

                const rhsTime = this._curve.getKeyframeTime(rightIndex);

                const {
                  value: lhsValue,
                  leftTangent: lhsOutTangent
                } = this._curve.getKeyframeValue(leftIndex);

                const {
                  value: rhsValue,
                  rightTangent: rhsInTangent
                } = this._curve.getKeyframeValue(rightIndex);

                optKey.index = leftIndex;
                optKey.time = lhsTime;
                optKey.endTime = rhsTime;
                const dx = rhsTime - lhsTime;
                const dy = rhsValue - lhsValue;
                const length = 1 / (dx * dx);
                const d1 = lhsOutTangent * dx;
                const d2 = rhsInTangent * dx;
                optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
                optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
                optKey.coefficient[2] = lhsOutTangent;
                optKey.coefficient[3] = lhsValue;
              }

              findIndex(optKey, t) {
                const {
                  _curve: curve
                } = this;
                const nKeyframes = curve.keyFramesCount;
                const cachedIndex = optKey.index;

                if (cachedIndex !== -1) {
                  const cachedTime = curve.getKeyframeTime(cachedIndex);

                  if (t > cachedTime) {
                    for (let i = 0; i < LOOK_FORWARD; i++) {
                      const currIndex = cachedIndex + i;

                      if (currIndex + 1 < nKeyframes && curve.getKeyframeTime(currIndex + 1) > t) {
                        return currIndex;
                      }
                    }
                  } else {
                    for (let i = 0; i < LOOK_FORWARD; i++) {
                      const currIndex = cachedIndex - i;

                      if (currIndex >= 0 && curve.getKeyframeTime(currIndex - 1) <= t) {
                        return currIndex - 1;
                      }
                    }
                  }
                }

                let left = 0;
                let right = nKeyframes;
                let mid;

                while (right - left > 1) {
                  mid = Math.floor((left + right) / 2);

                  if (curve.getKeyframeTime(mid) >= t) {
                    right = mid;
                  } else {
                    left = mid;
                  }
                }

                return left;
              }

            }, _class3$3.defaultKF = [{
              time: 0,
              value: 1,
              inTangent: 0,
              outTangent: 0
            }, {
              time: 1,
              value: 1,
              inTangent: 0,
              outTangent: 0
            }], _temp$7), (_descriptor$7 = _applyDecoratedDescriptor(_class2$8.prototype, "_curve", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class2$8)) || _class$a));

            function fromLegacyWrapMode(legacyWrapMode) {
              switch (legacyWrapMode) {
                default:
                case WrapModeMask.Default:
                case WrapModeMask.Normal:
                case WrapModeMask.Clamp:
                  return ExtrapolationMode.CLAMP;

                case WrapModeMask.PingPong:
                  return ExtrapolationMode.PING_PONG;

                case WrapModeMask.Loop:
                  return ExtrapolationMode.LOOP;
              }
            }

            function toLegacyWrapMode(extrapolationMode) {
              switch (extrapolationMode) {
                default:
                case ExtrapolationMode.LINEAR:
                case ExtrapolationMode.CLAMP:
                  return WrapModeMask.Clamp;

                case ExtrapolationMode.PING_PONG:
                  return WrapModeMask.PingPong;

                case ExtrapolationMode.LOOP:
                  return WrapModeMask.Loop;
              }
            }

            function constructLegacyCurveAndConvert() {
              const curve = new RealCurve();
              curve.assignSorted([[0.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }], [1.0, {
                interpolationMode: RealInterpolationMode.CUBIC,
                value: 1.0
              }]]);
              return curve;
            }

            replaceProperty(intersect, 'intersect', [{
              name: 'ray_aabb',
              newName: 'rayAABB'
            }, {
              name: 'ray_plane',
              newName: 'rayPlane'
            }, {
              name: 'ray_triangle',
              newName: 'rayTriangle'
            }, {
              name: 'ray_sphere',
              newName: 'raySphere'
            }, {
              name: 'ray_obb',
              newName: 'rayOBB'
            }, {
              name: 'ray_capsule',
              newName: 'rayCapsule'
            }, {
              name: 'ray_subMesh',
              newName: 'raySubMesh'
            }, {
              name: 'ray_mesh',
              newName: 'rayMesh'
            }, {
              name: 'ray_model',
              newName: 'rayModel'
            }, {
              name: 'line_plane',
              newName: 'linePlane'
            }, {
              name: 'line_triangle',
              newName: 'lineTriangle'
            }, {
              name: 'line_aabb',
              newName: 'lineAABB'
            }, {
              name: 'line_obb',
              newName: 'lineOBB'
            }, {
              name: 'line_sphere',
              newName: 'lineSphere'
            }, {
              name: 'aabb_aabb',
              newName: 'aabbWithAABB'
            }, {
              name: 'aabb_obb',
              newName: 'aabbWithOBB'
            }, {
              name: 'aabb_plane',
              newName: 'aabbPlane'
            }, {
              name: 'aabb_frustum',
              newName: 'aabbFrustum'
            }, {
              name: 'aabbFrustum_accurate',
              newName: 'aabbFrustumAccurate'
            }, {
              name: 'obb_point',
              newName: 'obbPoint'
            }, {
              name: 'obb_plane',
              newName: 'obbPlane'
            }, {
              name: 'obb_frustum',
              newName: 'obbFrustum'
            }, {
              name: 'obbFrustum_accurate',
              newName: 'obbFrustumAccurate'
            }, {
              name: 'obb_obb',
              newName: 'obbWithOBB'
            }, {
              name: 'obb_capsule',
              newName: 'obbCapsule'
            }, {
              name: 'sphere_plane',
              newName: 'spherePlane'
            }, {
              name: 'sphere_frustum',
              newName: 'sphereFrustum'
            }, {
              name: 'sphereFrustum_accurate',
              newName: 'sphereFrustumAccurate'
            }, {
              name: 'sphere_sphere',
              newName: 'sphereWithSphere'
            }, {
              name: 'sphere_aabb',
              newName: 'sphereAABB'
            }, {
              name: 'sphere_obb',
              newName: 'sphereOBB'
            }, {
              name: 'sphere_capsule',
              newName: 'sphereCapsule'
            }, {
              name: 'capsule_capsule',
              newName: 'capsuleWithCapsule'
            }]);

            function deprecatedClassMessage(oldClassName, newClassName) {
              console.warn(`${oldClassName} is deprecated, please use ${newClassName} instead.`);
            }

            class line extends Line {
              constructor() {
                super();
                deprecatedClassMessage('line', 'Line');
              }

            }
            class plane extends Plane {
              constructor() {
                super();
                deprecatedClassMessage('plane', 'Plane');
              }

            }
            class ray extends Ray {
              constructor() {
                super();
                deprecatedClassMessage('ray', 'Ray');
              }

            }
            class triangle extends Triangle {
              constructor() {
                super();
                deprecatedClassMessage('triangle', 'Triangle');
              }

            }
            class sphere extends Sphere {
              constructor() {
                super();
                deprecatedClassMessage('sphere', 'Sphere');
              }

            }
            class aabb extends AABB {
              constructor() {
                super();
                deprecatedClassMessage('aabb', 'AABB');
              }

            }
            class obb extends OBB {
              constructor() {
                super();
                deprecatedClassMessage('obb', 'OBB');
              }

            }
            class capsule extends Capsule {
              constructor() {
                super();
                deprecatedClassMessage('capsule', 'Capsule');
              }

            }
            class frustum extends Frustum {
              constructor() {
                super();
                deprecatedClassMessage('frustum', 'Frustum');
              }

            }

            var geometry = /*#__PURE__*/Object.freeze({
                __proto__: null,
                distance: distance,
                enums: enums,
                intersect: intersect,
                Line: Line,
                Plane: Plane,
                Ray: Ray,
                Triangle: Triangle,
                Sphere: Sphere,
                AABB: AABB,
                OBB: OBB,
                Capsule: Capsule,
                Frustum: Frustum,
                Keyframe: Keyframe,
                AnimationCurve: AnimationCurve,
                get ERaycastMode () { return ERaycastMode; },
                line: line,
                plane: plane,
                ray: ray,
                triangle: triangle,
                sphere: sphere,
                aabb: aabb,
                obb: obb,
                capsule: capsule,
                frustum: frustum
            });
            exports('eZ', geometry);

            const layerList = {
              NONE: 0,
              IGNORE_RAYCAST: 1 << 20,
              GIZMOS: 1 << 21,
              EDITOR: 1 << 22,
              UI_3D: 1 << 23,
              SCENE_GIZMO: 1 << 24,
              UI_2D: 1 << 25,
              PROFILER: 1 << 28,
              DEFAULT: 1 << 30,
              ALL: 0xffffffff
            };
            class Layers {
              static makeMaskInclude(includes) {
                let mask = 0;

                for (const inc of includes) {
                  mask |= inc;
                }

                return mask;
              }

              static makeMaskExclude(excludes) {
                return ~Layers.makeMaskInclude(excludes);
              }

              static addLayer(name, bitNum) {
                if (bitNum === undefined) {
                  console.warn('bitNum can\'t be undefined');
                  return;
                }

                if (bitNum > 19 || bitNum < 0) {
                  console.warn('maximum layers reached.');
                  return;
                }

                const val = 1 << bitNum;
                assertIsTrue(!Layers.Enum[name], getError(2104, name));
                Layers.Enum[name] = val;
                js.value(Layers.Enum, String(val), name);
                Layers.BitMask[name] = val;
                js.value(Layers.BitMask, String(val), name);
              }

              static deleteLayer(bitNum) {
                if (bitNum > 19 || bitNum < 0) {
                  console.warn('do not change buildin layers.');
                  return;
                }

                const val = 1 << bitNum;
                delete Layers.Enum[Layers.Enum[val]];
                delete Layers.Enum[val];
                delete Layers.BitMask[Layers.BitMask[val]];
                delete Layers.BitMask[val];
              }

              static nameToLayer(name) {
                if (name === undefined) {
                  console.warn('name can\'t be undefined');
                  return -1;
                }

                return log2(Layers.Enum[name]);
              }

              static layerToName(bitNum) {
                if (bitNum > 31 || bitNum < 0) {
                  console.warn('Unable to access unknown layer.');
                  return '';
                }

                return Layers.Enum[1 << bitNum];
              }

            } exports('c3', Layers);
            Layers.Enum = Enum(layerList);
            Layers.BitMask = BitMask({ ...layerList
            });
            legacyCC.Layers = Layers;

            let RenderPassStage;

            (function (RenderPassStage) {
              RenderPassStage[RenderPassStage["DEFAULT"] = 100] = "DEFAULT";
              RenderPassStage[RenderPassStage["UI"] = 200] = "UI";
            })(RenderPassStage || (RenderPassStage = {}));

            legacyCC.RenderPassStage = RenderPassStage;
            let RenderPriority;

            (function (RenderPriority) {
              RenderPriority[RenderPriority["MIN"] = 0] = "MIN";
              RenderPriority[RenderPriority["MAX"] = 255] = "MAX";
              RenderPriority[RenderPriority["DEFAULT"] = 128] = "DEFAULT";
            })(RenderPriority || (RenderPriority = exports('ef', {})));

            const globalDescriptorSetLayout = {
              bindings: [],
              layouts: {}
            };
            const localDescriptorSetLayout = {
              bindings: [],
              layouts: {}
            };
            let PipelineGlobalBindings;

            (function (PipelineGlobalBindings) {
              PipelineGlobalBindings[PipelineGlobalBindings["UBO_GLOBAL"] = 0] = "UBO_GLOBAL";
              PipelineGlobalBindings[PipelineGlobalBindings["UBO_CAMERA"] = 1] = "UBO_CAMERA";
              PipelineGlobalBindings[PipelineGlobalBindings["UBO_SHADOW"] = 2] = "UBO_SHADOW";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SHADOWMAP"] = 3] = "SAMPLER_SHADOWMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_ENVIRONMENT"] = 4] = "SAMPLER_ENVIRONMENT";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SPOT_LIGHTING_MAP"] = 5] = "SAMPLER_SPOT_LIGHTING_MAP";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_DIFFUSEMAP"] = 6] = "SAMPLER_DIFFUSEMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["COUNT"] = 7] = "COUNT";
            })(PipelineGlobalBindings || (PipelineGlobalBindings = {}));

            const GLOBAL_UBO_COUNT = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
            const GLOBAL_SAMPLER_COUNT = PipelineGlobalBindings.COUNT - GLOBAL_UBO_COUNT;
            let ModelLocalBindings;

            (function (ModelLocalBindings) {
              ModelLocalBindings[ModelLocalBindings["UBO_LOCAL"] = 0] = "UBO_LOCAL";
              ModelLocalBindings[ModelLocalBindings["UBO_FORWARD_LIGHTS"] = 1] = "UBO_FORWARD_LIGHTS";
              ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_ANIMATION"] = 2] = "UBO_SKINNING_ANIMATION";
              ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_TEXTURE"] = 3] = "UBO_SKINNING_TEXTURE";
              ModelLocalBindings[ModelLocalBindings["UBO_MORPH"] = 4] = "UBO_MORPH";
              ModelLocalBindings[ModelLocalBindings["UBO_UI_LOCAL"] = 5] = "UBO_UI_LOCAL";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_JOINTS"] = 6] = "SAMPLER_JOINTS";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_POSITION"] = 7] = "SAMPLER_MORPH_POSITION";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_NORMAL"] = 8] = "SAMPLER_MORPH_NORMAL";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_TANGENT"] = 9] = "SAMPLER_MORPH_TANGENT";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_LIGHTMAP"] = 10] = "SAMPLER_LIGHTMAP";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_SPRITE"] = 11] = "SAMPLER_SPRITE";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_REFLECTION"] = 12] = "SAMPLER_REFLECTION";
              ModelLocalBindings[ModelLocalBindings["STORAGE_REFLECTION"] = 13] = "STORAGE_REFLECTION";
              ModelLocalBindings[ModelLocalBindings["COUNT"] = 14] = "COUNT";
            })(ModelLocalBindings || (ModelLocalBindings = exports('ep', {})));

            const LOCAL_UBO_COUNT = ModelLocalBindings.SAMPLER_JOINTS;
            const LOCAL_SAMPLER_COUNT = ModelLocalBindings.COUNT - LOCAL_UBO_COUNT;
            let SetIndex;

            (function (SetIndex) {
              SetIndex[SetIndex["GLOBAL"] = 0] = "GLOBAL";
              SetIndex[SetIndex["MATERIAL"] = 1] = "MATERIAL";
              SetIndex[SetIndex["LOCAL"] = 2] = "LOCAL";
            })(SetIndex || (SetIndex = {}));

            const bindingMappingInfo = new BindingMappingInfo();
            bindingMappingInfo.bufferOffsets = [0, GLOBAL_UBO_COUNT + LOCAL_UBO_COUNT, GLOBAL_UBO_COUNT];
            bindingMappingInfo.samplerOffsets = [-GLOBAL_UBO_COUNT, GLOBAL_SAMPLER_COUNT + LOCAL_SAMPLER_COUNT, GLOBAL_SAMPLER_COUNT - LOCAL_UBO_COUNT];
            bindingMappingInfo.flexibleSet = 1;
            class UBOGlobal {}
            UBOGlobal.TIME_OFFSET = 0;
            UBOGlobal.NATIVE_SIZE_OFFSET = UBOGlobal.TIME_OFFSET + 4;
            UBOGlobal.SCREEN_SIZE_OFFSET = UBOGlobal.NATIVE_SIZE_OFFSET + 4;
            UBOGlobal.COUNT = UBOGlobal.SCREEN_SIZE_OFFSET + 4;
            UBOGlobal.SIZE = UBOGlobal.COUNT * 4;
            UBOGlobal.NAME = 'CCGlobal';
            UBOGlobal.BINDING = PipelineGlobalBindings.UBO_GLOBAL;
            UBOGlobal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOGlobal.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
            UBOGlobal.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOGlobal.BINDING, UBOGlobal.NAME, [new Uniform('cc_time', Type.FLOAT4, 1), new Uniform('cc_screenSize', Type.FLOAT4, 1), new Uniform('cc_nativeSize', Type.FLOAT4, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOGlobal.NAME] = UBOGlobal.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOGlobal.BINDING] = UBOGlobal.DESCRIPTOR;
            class UBOCamera {}
            UBOCamera.MAT_VIEW_OFFSET = 0;
            UBOCamera.MAT_VIEW_INV_OFFSET = UBOCamera.MAT_VIEW_OFFSET + 16;
            UBOCamera.MAT_PROJ_OFFSET = UBOCamera.MAT_VIEW_INV_OFFSET + 16;
            UBOCamera.MAT_PROJ_INV_OFFSET = UBOCamera.MAT_PROJ_OFFSET + 16;
            UBOCamera.MAT_VIEW_PROJ_OFFSET = UBOCamera.MAT_PROJ_INV_OFFSET + 16;
            UBOCamera.MAT_VIEW_PROJ_INV_OFFSET = UBOCamera.MAT_VIEW_PROJ_OFFSET + 16;
            UBOCamera.CAMERA_POS_OFFSET = UBOCamera.MAT_VIEW_PROJ_INV_OFFSET + 16;
            UBOCamera.SCREEN_SCALE_OFFSET = UBOCamera.CAMERA_POS_OFFSET + 4;
            UBOCamera.EXPOSURE_OFFSET = UBOCamera.SCREEN_SCALE_OFFSET + 4;
            UBOCamera.MAIN_LIT_DIR_OFFSET = UBOCamera.EXPOSURE_OFFSET + 4;
            UBOCamera.MAIN_LIT_COLOR_OFFSET = UBOCamera.MAIN_LIT_DIR_OFFSET + 4;
            UBOCamera.AMBIENT_SKY_OFFSET = UBOCamera.MAIN_LIT_COLOR_OFFSET + 4;
            UBOCamera.AMBIENT_GROUND_OFFSET = UBOCamera.AMBIENT_SKY_OFFSET + 4;
            UBOCamera.GLOBAL_FOG_COLOR_OFFSET = UBOCamera.AMBIENT_GROUND_OFFSET + 4;
            UBOCamera.GLOBAL_FOG_BASE_OFFSET = UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 4;
            UBOCamera.GLOBAL_FOG_ADD_OFFSET = UBOCamera.GLOBAL_FOG_BASE_OFFSET + 4;
            UBOCamera.NEAR_FAR_OFFSET = UBOCamera.GLOBAL_FOG_ADD_OFFSET + 4;
            UBOCamera.VIEW_PORT_OFFSET = UBOCamera.NEAR_FAR_OFFSET + 4;
            UBOCamera.COUNT = UBOCamera.VIEW_PORT_OFFSET + 4;
            UBOCamera.SIZE = UBOCamera.COUNT * 4;
            UBOCamera.NAME = 'CCCamera';
            UBOCamera.BINDING = PipelineGlobalBindings.UBO_CAMERA;
            UBOCamera.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOCamera.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
            UBOCamera.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOCamera.BINDING, UBOCamera.NAME, [new Uniform('cc_matView', Type.MAT4, 1), new Uniform('cc_matViewInv', Type.MAT4, 1), new Uniform('cc_matProj', Type.MAT4, 1), new Uniform('cc_matProjInv', Type.MAT4, 1), new Uniform('cc_matViewProj', Type.MAT4, 1), new Uniform('cc_matViewProjInv', Type.MAT4, 1), new Uniform('cc_cameraPos', Type.FLOAT4, 1), new Uniform('cc_screenScale', Type.FLOAT4, 1), new Uniform('cc_exposure', Type.FLOAT4, 1), new Uniform('cc_mainLitDir', Type.FLOAT4, 1), new Uniform('cc_mainLitColor', Type.FLOAT4, 1), new Uniform('cc_ambientSky', Type.FLOAT4, 1), new Uniform('cc_ambientGround', Type.FLOAT4, 1), new Uniform('cc_fogColor', Type.FLOAT4, 1), new Uniform('cc_fogBase', Type.FLOAT4, 1), new Uniform('cc_fogAdd', Type.FLOAT4, 1), new Uniform('cc_nearFar', Type.FLOAT4, 1), new Uniform('cc_viewPort', Type.FLOAT4, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOCamera.NAME] = UBOCamera.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOCamera.BINDING] = UBOCamera.DESCRIPTOR;
            class UBOShadow {}
            UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0;
            UBOShadow.MAT_LIGHT_VIEW_OFFSET = UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET + 16;
            UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET = UBOShadow.MAT_LIGHT_VIEW_OFFSET + 16;
            UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET = UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET + 16;
            UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET = UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 4;
            UBOShadow.SHADOW_PROJ_INFO_OFFSET = UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 4;
            UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET = UBOShadow.SHADOW_PROJ_INFO_OFFSET + 4;
            UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET = UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 4;
            UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET = UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 4;
            UBOShadow.SHADOW_COLOR_OFFSET = UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 4;
            UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET = UBOShadow.SHADOW_COLOR_OFFSET + 4;
            UBOShadow.COUNT = UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 4;
            UBOShadow.SIZE = UBOShadow.COUNT * 4;
            UBOShadow.NAME = 'CCShadow';
            UBOShadow.BINDING = PipelineGlobalBindings.UBO_SHADOW;
            UBOShadow.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOShadow.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.ALL);
            UBOShadow.LAYOUT = new UniformBlock(SetIndex.GLOBAL, UBOShadow.BINDING, UBOShadow.NAME, [new Uniform('cc_matLightPlaneProj', Type.MAT4, 1), new Uniform('cc_matLightView', Type.MAT4, 1), new Uniform('cc_matLightViewProj', Type.MAT4, 1), new Uniform('cc_shadowInvProjDepthInfo', Type.FLOAT4, 1), new Uniform('cc_shadowProjDepthInfo', Type.FLOAT4, 1), new Uniform('cc_shadowProjInfo', Type.FLOAT4, 1), new Uniform('cc_shadowNFLSInfo', Type.FLOAT4, 1), new Uniform('cc_shadowWHPBInfo', Type.FLOAT4, 1), new Uniform('cc_shadowLPNNInfo', Type.FLOAT4, 1), new Uniform('cc_shadowColor', Type.FLOAT4, 1), new Uniform('cc_planarNDInfo', Type.FLOAT4, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOShadow.NAME] = UBOShadow.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOShadow.BINDING] = UBOShadow.DESCRIPTOR;
            const UNIFORM_SHADOWMAP_NAME = 'cc_shadowMap';
            const UNIFORM_SHADOWMAP_BINDING = PipelineGlobalBindings.SAMPLER_SHADOWMAP;
            const UNIFORM_SHADOWMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SHADOWMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_SHADOWMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SHADOWMAP_BINDING, UNIFORM_SHADOWMAP_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_SHADOWMAP_NAME] = UNIFORM_SHADOWMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_SHADOWMAP_BINDING] = UNIFORM_SHADOWMAP_DESCRIPTOR;
            const UNIFORM_ENVIRONMENT_NAME = 'cc_environment';
            const UNIFORM_ENVIRONMENT_BINDING = PipelineGlobalBindings.SAMPLER_ENVIRONMENT;
            const UNIFORM_ENVIRONMENT_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_ENVIRONMENT_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_ENVIRONMENT_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_ENVIRONMENT_BINDING, UNIFORM_ENVIRONMENT_NAME, Type.SAMPLER_CUBE, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_ENVIRONMENT_NAME] = UNIFORM_ENVIRONMENT_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_ENVIRONMENT_BINDING] = UNIFORM_ENVIRONMENT_DESCRIPTOR;
            const UNIFORM_DIFFUSEMAP_NAME = 'cc_diffuseMap';
            const UNIFORM_DIFFUSEMAP_BINDING = PipelineGlobalBindings.SAMPLER_DIFFUSEMAP;
            const UNIFORM_DIFFUSEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_DIFFUSEMAP_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_DIFFUSEMAP_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_DIFFUSEMAP_BINDING, UNIFORM_DIFFUSEMAP_NAME, Type.SAMPLER_CUBE, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_DIFFUSEMAP_NAME] = UNIFORM_DIFFUSEMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_DIFFUSEMAP_BINDING] = UNIFORM_DIFFUSEMAP_DESCRIPTOR;
            const UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME = 'cc_spotLightingMap';
            const UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING = PipelineGlobalBindings.SAMPLER_SPOT_LIGHTING_MAP;
            const UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.GLOBAL, UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME, Type.SAMPLER2D, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_NAME] = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING] = UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_DESCRIPTOR;
            class UBOLocal {} exports('eq', UBOLocal);
            UBOLocal.MAT_WORLD_OFFSET = 0;
            UBOLocal.MAT_WORLD_IT_OFFSET = UBOLocal.MAT_WORLD_OFFSET + 16;
            UBOLocal.LIGHTINGMAP_UVPARAM = UBOLocal.MAT_WORLD_IT_OFFSET + 16;
            UBOLocal.COUNT = UBOLocal.LIGHTINGMAP_UVPARAM + 4;
            UBOLocal.SIZE = UBOLocal.COUNT * 4;
            UBOLocal.NAME = 'CCLocal';
            UBOLocal.BINDING = ModelLocalBindings.UBO_LOCAL;
            UBOLocal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOLocal.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
            UBOLocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOLocal.BINDING, UBOLocal.NAME, [new Uniform('cc_matWorld', Type.MAT4, 1), new Uniform('cc_matWorldIT', Type.MAT4, 1), new Uniform('cc_lightingMapUVParam', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOLocal.NAME] = UBOLocal.LAYOUT;
            localDescriptorSetLayout.bindings[UBOLocal.BINDING] = UBOLocal.DESCRIPTOR;
            class UBOWorldBound {}
            UBOWorldBound.WORLD_BOUND_CENTER = 0;
            UBOWorldBound.WORLD_BOUND_HALF_EXTENTS = UBOWorldBound.WORLD_BOUND_CENTER + 4;
            UBOWorldBound.COUNT = UBOWorldBound.WORLD_BOUND_HALF_EXTENTS + 4;
            UBOWorldBound.SIZE = UBOWorldBound.COUNT * 4;
            UBOWorldBound.NAME = 'CCWorldBound';
            UBOWorldBound.BINDING = ModelLocalBindings.UBO_LOCAL;
            UBOWorldBound.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOWorldBound.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
            UBOWorldBound.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOWorldBound.BINDING, UBOWorldBound.NAME, [new Uniform('cc_worldBoundCenter', Type.FLOAT4, 1), new Uniform('cc_worldBoundHalfExtents', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOWorldBound.NAME] = UBOWorldBound.LAYOUT;
            localDescriptorSetLayout.bindings[UBOWorldBound.BINDING] = UBOWorldBound.DESCRIPTOR;
            const INST_MAT_WORLD = 'a_matWorld0';
            class UBOLocalBatched {}
            UBOLocalBatched.BATCHING_COUNT = 10;
            UBOLocalBatched.MAT_WORLDS_OFFSET = 0;
            UBOLocalBatched.COUNT = 16 * UBOLocalBatched.BATCHING_COUNT;
            UBOLocalBatched.SIZE = UBOLocalBatched.COUNT * 4;
            UBOLocalBatched.NAME = 'CCLocalBatched';
            UBOLocalBatched.BINDING = ModelLocalBindings.UBO_LOCAL;
            UBOLocalBatched.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOLocalBatched.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX | ShaderStageFlagBit.COMPUTE);
            UBOLocalBatched.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOLocalBatched.BINDING, UBOLocalBatched.NAME, [new Uniform('cc_matWorlds', Type.MAT4, UBOLocalBatched.BATCHING_COUNT)], 1);
            localDescriptorSetLayout.layouts[UBOLocalBatched.NAME] = UBOLocalBatched.LAYOUT;
            localDescriptorSetLayout.bindings[UBOLocalBatched.BINDING] = UBOLocalBatched.DESCRIPTOR;
            class UBOForwardLight {}
            UBOForwardLight.LIGHTS_PER_PASS = 1;
            UBOForwardLight.LIGHT_POS_OFFSET = 0;
            UBOForwardLight.LIGHT_COLOR_OFFSET = UBOForwardLight.LIGHT_POS_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET = UBOForwardLight.LIGHT_COLOR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.LIGHT_DIR_OFFSET = UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.COUNT = UBOForwardLight.LIGHT_DIR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.SIZE = UBOForwardLight.COUNT * 4;
            UBOForwardLight.NAME = 'CCForwardLight';
            UBOForwardLight.BINDING = ModelLocalBindings.UBO_FORWARD_LIGHTS;
            UBOForwardLight.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOForwardLight.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.FRAGMENT);
            UBOForwardLight.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOForwardLight.BINDING, UBOForwardLight.NAME, [new Uniform('cc_lightPos', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightColor', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightSizeRangeAngle', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS), new Uniform('cc_lightDir', Type.FLOAT4, UBOForwardLight.LIGHTS_PER_PASS)], 1);
            localDescriptorSetLayout.layouts[UBOForwardLight.NAME] = UBOForwardLight.LAYOUT;
            localDescriptorSetLayout.bindings[UBOForwardLight.BINDING] = UBOForwardLight.DESCRIPTOR;
            const JOINT_UNIFORM_CAPACITY = 30;
            class UBOSkinningTexture {} exports('cR', UBOSkinningTexture);
            UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0;
            UBOSkinningTexture.COUNT = UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET + 4;
            UBOSkinningTexture.SIZE = UBOSkinningTexture.COUNT * 4;
            UBOSkinningTexture.NAME = 'CCSkinningTexture';
            UBOSkinningTexture.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
            UBOSkinningTexture.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinningTexture.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOSkinningTexture.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinningTexture.BINDING, UBOSkinningTexture.NAME, [new Uniform('cc_jointTextureInfo', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOSkinningTexture.NAME] = UBOSkinningTexture.LAYOUT;
            localDescriptorSetLayout.bindings[UBOSkinningTexture.BINDING] = UBOSkinningTexture.DESCRIPTOR;
            class UBOSkinningAnimation {} exports('cI', UBOSkinningAnimation);
            UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0;
            UBOSkinningAnimation.COUNT = UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET + 4;
            UBOSkinningAnimation.SIZE = UBOSkinningAnimation.COUNT * 4;
            UBOSkinningAnimation.NAME = 'CCSkinningAnimation';
            UBOSkinningAnimation.BINDING = ModelLocalBindings.UBO_SKINNING_ANIMATION;
            UBOSkinningAnimation.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinningAnimation.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOSkinningAnimation.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinningAnimation.BINDING, UBOSkinningAnimation.NAME, [new Uniform('cc_jointAnimInfo', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOSkinningAnimation.NAME] = UBOSkinningAnimation.LAYOUT;
            localDescriptorSetLayout.bindings[UBOSkinningAnimation.BINDING] = UBOSkinningAnimation.DESCRIPTOR;
            const INST_JOINT_ANIM_INFO = exports('cT', 'a_jointAnimInfo');
            class UBOSkinning {} exports('cP', UBOSkinning);
            UBOSkinning.JOINTS_OFFSET = 0;
            UBOSkinning.COUNT = UBOSkinning.JOINTS_OFFSET + JOINT_UNIFORM_CAPACITY * 12;
            UBOSkinning.SIZE = UBOSkinning.COUNT * 4;
            UBOSkinning.NAME = 'CCSkinning';
            UBOSkinning.BINDING = ModelLocalBindings.UBO_SKINNING_TEXTURE;
            UBOSkinning.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOSkinning.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOSkinning.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOSkinning.BINDING, UBOSkinning.NAME, [new Uniform('cc_joints', Type.FLOAT4, JOINT_UNIFORM_CAPACITY * 3)], 1);
            localDescriptorSetLayout.layouts[UBOSkinning.NAME] = UBOSkinning.LAYOUT;
            localDescriptorSetLayout.bindings[UBOSkinning.BINDING] = UBOSkinning.DESCRIPTOR;
            class UBOMorph {}
            UBOMorph.MAX_MORPH_TARGET_COUNT = 60;
            UBOMorph.OFFSET_OF_WEIGHTS = 0;
            UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * UBOMorph.MAX_MORPH_TARGET_COUNT;
            UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH + 4;
            UBOMorph.OFFSET_OF_VERTICES_COUNT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT + 4;
            UBOMorph.COUNT_BASE_4_BYTES = 4 * Math.ceil(UBOMorph.MAX_MORPH_TARGET_COUNT / 4) + 4;
            UBOMorph.SIZE = UBOMorph.COUNT_BASE_4_BYTES * 4;
            UBOMorph.NAME = 'CCMorph';
            UBOMorph.BINDING = ModelLocalBindings.UBO_MORPH;
            UBOMorph.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOMorph.BINDING, DescriptorType.UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOMorph.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOMorph.BINDING, UBOMorph.NAME, [new Uniform('cc_displacementWeights', Type.FLOAT4, UBOMorph.MAX_MORPH_TARGET_COUNT / 4), new Uniform('cc_displacementTextureInfo', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOMorph.NAME] = UBOMorph.LAYOUT;
            localDescriptorSetLayout.bindings[UBOMorph.BINDING] = UBOMorph.DESCRIPTOR;
            class UBOUILocal {}
            UBOUILocal.NAME = 'CCUILocal';
            UBOUILocal.BINDING = ModelLocalBindings.UBO_UI_LOCAL;
            UBOUILocal.DESCRIPTOR = new DescriptorSetLayoutBinding(UBOUILocal.BINDING, DescriptorType.DYNAMIC_UNIFORM_BUFFER, 1, ShaderStageFlagBit.VERTEX);
            UBOUILocal.LAYOUT = new UniformBlock(SetIndex.LOCAL, UBOUILocal.BINDING, UBOUILocal.NAME, [new Uniform('cc_local_data', Type.FLOAT4, 1)], 1);
            localDescriptorSetLayout.layouts[UBOUILocal.NAME] = UBOUILocal.LAYOUT;
            localDescriptorSetLayout.bindings[UBOUILocal.BINDING] = UBOUILocal.DESCRIPTOR;
            const UNIFORM_JOINT_TEXTURE_NAME = 'cc_jointTexture';
            const UNIFORM_JOINT_TEXTURE_BINDING = exports('cS', ModelLocalBindings.SAMPLER_JOINTS);
            const UNIFORM_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_JOINT_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
            const UNIFORM_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_JOINT_TEXTURE_BINDING, UNIFORM_JOINT_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_JOINT_TEXTURE_NAME] = UNIFORM_JOINT_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_JOINT_TEXTURE_BINDING] = UNIFORM_JOINT_TEXTURE_DESCRIPTOR;
            const UNIFORM_POSITION_MORPH_TEXTURE_NAME = 'cc_PositionDisplacements';
            const UNIFORM_POSITION_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_POSITION;
            const UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_POSITION_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
            const UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_POSITION_MORPH_TEXTURE_NAME] = UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_POSITION_MORPH_TEXTURE_BINDING] = UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR;
            const UNIFORM_NORMAL_MORPH_TEXTURE_NAME = 'cc_NormalDisplacements';
            const UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_NORMAL;
            const UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
            const UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_NORMAL_MORPH_TEXTURE_NAME] = UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_NORMAL_MORPH_TEXTURE_BINDING] = UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR;
            const UNIFORM_TANGENT_MORPH_TEXTURE_NAME = 'cc_TangentDisplacements';
            const UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_MORPH_TANGENT;
            const UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.VERTEX);
            const UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_TANGENT_MORPH_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_TANGENT_MORPH_TEXTURE_NAME] = UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_TANGENT_MORPH_TEXTURE_BINDING] = UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR;
            const UNIFORM_LIGHTMAP_TEXTURE_NAME = 'cc_lightingMap';
            const UNIFORM_LIGHTMAP_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_LIGHTMAP;
            const UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTMAP_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_LIGHTMAP_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_LIGHTMAP_TEXTURE_BINDING, UNIFORM_LIGHTMAP_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_LIGHTMAP_TEXTURE_NAME] = UNIFORM_LIGHTMAP_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_LIGHTMAP_TEXTURE_BINDING] = UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR;
            const UNIFORM_SPRITE_TEXTURE_NAME = 'cc_spriteTexture';
            const UNIFORM_SPRITE_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_SPRITE;
            const UNIFORM_SPRITE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPRITE_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_SPRITE_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_SPRITE_TEXTURE_BINDING, UNIFORM_SPRITE_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_SPRITE_TEXTURE_NAME] = UNIFORM_SPRITE_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_SPRITE_TEXTURE_BINDING] = UNIFORM_SPRITE_TEXTURE_DESCRIPTOR;
            const UNIFORM_REFLECTION_TEXTURE_NAME = 'cc_reflectionTexture';
            const UNIFORM_REFLECTION_TEXTURE_BINDING = ModelLocalBindings.SAMPLER_REFLECTION;
            const UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_TEXTURE_BINDING, DescriptorType.SAMPLER_TEXTURE, 1, ShaderStageFlagBit.FRAGMENT);
            const UNIFORM_REFLECTION_TEXTURE_LAYOUT = new UniformSamplerTexture(SetIndex.LOCAL, UNIFORM_REFLECTION_TEXTURE_BINDING, UNIFORM_REFLECTION_TEXTURE_NAME, Type.SAMPLER2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_TEXTURE_NAME] = UNIFORM_REFLECTION_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_TEXTURE_BINDING] = UNIFORM_REFLECTION_TEXTURE_DESCRIPTOR;
            const UNIFORM_REFLECTION_STORAGE_NAME = 'cc_reflectionStorage';
            const UNIFORM_REFLECTION_STORAGE_BINDING = ModelLocalBindings.STORAGE_REFLECTION;
            const UNIFORM_REFLECTION_STORAGE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_STORAGE_BINDING, DescriptorType.STORAGE_IMAGE, 1, ShaderStageFlagBit.COMPUTE);
            const UNIFORM_REFLECTION_STORAGE_LAYOUT = new UniformStorageImage(SetIndex.LOCAL, UNIFORM_REFLECTION_STORAGE_BINDING, UNIFORM_REFLECTION_STORAGE_NAME, Type.IMAGE2D, 1);
            localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_STORAGE_NAME] = UNIFORM_REFLECTION_STORAGE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_STORAGE_BINDING] = UNIFORM_REFLECTION_STORAGE_DESCRIPTOR;
            const CAMERA_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]);
            const CAMERA_EDITOR_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.PROFILER]);
            const MODEL_ALWAYS_MASK = Layers.Enum.ALL;
            function supportsFloatTexture(device) {
              return device.hasFeature(Feature$1.COLOR_FLOAT) && device.hasFeature(Feature$1.TEXTURE_FLOAT) && !(device.gfxAPI === API.WEBGL);
            }

            let CameraFOVAxis;

            (function (CameraFOVAxis) {
              CameraFOVAxis[CameraFOVAxis["VERTICAL"] = 0] = "VERTICAL";
              CameraFOVAxis[CameraFOVAxis["HORIZONTAL"] = 1] = "HORIZONTAL";
            })(CameraFOVAxis || (CameraFOVAxis = {}));

            let CameraProjection;

            (function (CameraProjection) {
              CameraProjection[CameraProjection["ORTHO"] = 0] = "ORTHO";
              CameraProjection[CameraProjection["PERSPECTIVE"] = 1] = "PERSPECTIVE";
            })(CameraProjection || (CameraProjection = {}));

            let CameraAperture;

            (function (CameraAperture) {
              CameraAperture[CameraAperture["F1_8"] = 0] = "F1_8";
              CameraAperture[CameraAperture["F2_0"] = 1] = "F2_0";
              CameraAperture[CameraAperture["F2_2"] = 2] = "F2_2";
              CameraAperture[CameraAperture["F2_5"] = 3] = "F2_5";
              CameraAperture[CameraAperture["F2_8"] = 4] = "F2_8";
              CameraAperture[CameraAperture["F3_2"] = 5] = "F3_2";
              CameraAperture[CameraAperture["F3_5"] = 6] = "F3_5";
              CameraAperture[CameraAperture["F4_0"] = 7] = "F4_0";
              CameraAperture[CameraAperture["F4_5"] = 8] = "F4_5";
              CameraAperture[CameraAperture["F5_0"] = 9] = "F5_0";
              CameraAperture[CameraAperture["F5_6"] = 10] = "F5_6";
              CameraAperture[CameraAperture["F6_3"] = 11] = "F6_3";
              CameraAperture[CameraAperture["F7_1"] = 12] = "F7_1";
              CameraAperture[CameraAperture["F8_0"] = 13] = "F8_0";
              CameraAperture[CameraAperture["F9_0"] = 14] = "F9_0";
              CameraAperture[CameraAperture["F10_0"] = 15] = "F10_0";
              CameraAperture[CameraAperture["F11_0"] = 16] = "F11_0";
              CameraAperture[CameraAperture["F13_0"] = 17] = "F13_0";
              CameraAperture[CameraAperture["F14_0"] = 18] = "F14_0";
              CameraAperture[CameraAperture["F16_0"] = 19] = "F16_0";
              CameraAperture[CameraAperture["F18_0"] = 20] = "F18_0";
              CameraAperture[CameraAperture["F20_0"] = 21] = "F20_0";
              CameraAperture[CameraAperture["F22_0"] = 22] = "F22_0";
            })(CameraAperture || (CameraAperture = {}));

            let CameraISO;

            (function (CameraISO) {
              CameraISO[CameraISO["ISO100"] = 0] = "ISO100";
              CameraISO[CameraISO["ISO200"] = 1] = "ISO200";
              CameraISO[CameraISO["ISO400"] = 2] = "ISO400";
              CameraISO[CameraISO["ISO800"] = 3] = "ISO800";
            })(CameraISO || (CameraISO = {}));

            let CameraShutter;

            (function (CameraShutter) {
              CameraShutter[CameraShutter["D1"] = 0] = "D1";
              CameraShutter[CameraShutter["D2"] = 1] = "D2";
              CameraShutter[CameraShutter["D4"] = 2] = "D4";
              CameraShutter[CameraShutter["D8"] = 3] = "D8";
              CameraShutter[CameraShutter["D15"] = 4] = "D15";
              CameraShutter[CameraShutter["D30"] = 5] = "D30";
              CameraShutter[CameraShutter["D60"] = 6] = "D60";
              CameraShutter[CameraShutter["D125"] = 7] = "D125";
              CameraShutter[CameraShutter["D250"] = 8] = "D250";
              CameraShutter[CameraShutter["D500"] = 9] = "D500";
              CameraShutter[CameraShutter["D1000"] = 10] = "D1000";
              CameraShutter[CameraShutter["D2000"] = 11] = "D2000";
              CameraShutter[CameraShutter["D4000"] = 12] = "D4000";
            })(CameraShutter || (CameraShutter = {}));

            const FSTOPS = [1.8, 2.0, 2.2, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0, 5.6, 6.3, 7.1, 8.0, 9.0, 10.0, 11.0, 13.0, 14.0, 16.0, 18.0, 20.0, 22.0];
            const SHUTTERS = [1.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 15.0, 1.0 / 30.0, 1.0 / 60.0, 1.0 / 125.0, 1.0 / 250.0, 1.0 / 500.0, 1.0 / 1000.0, 1.0 / 2000.0, 1.0 / 4000.0];
            const ISOS = [100.0, 200.0, 400.0, 800.0];
            const v_a = new Vec3();
            const v_b = new Vec3();

            const _tempMat1 = new Mat4();

            const SKYBOX_FLAG = ClearFlagBit.STENCIL << 1;
            const correctionMatrices = [];
            class Camera {
              constructor(device) {
                this.isWindowSize = true;
                this.screenScale = void 0;
                this._device = void 0;
                this._scene = null;
                this._node = null;
                this._name = null;
                this._enabled = false;
                this._proj = -1;
                this._aspect = void 0;
                this._orthoHeight = 10.0;
                this._fovAxis = CameraFOVAxis.VERTICAL;
                this._fov = toRadian(45);
                this._nearClip = 1.0;
                this._farClip = 1000.0;
                this._clearColor = new Color$1(0.2, 0.2, 0.2, 1);
                this._viewport = new Rect(0, 0, 1, 1);
                this._orientedViewport = new Rect(0, 0, 1, 1);
                this._curTransform = SurfaceTransform.IDENTITY;
                this._isProjDirty = true;
                this._matView = new Mat4();
                this._matProj = new Mat4();
                this._matProjInv = new Mat4();
                this._matViewProj = new Mat4();
                this._matViewProjInv = new Mat4();
                this._frustum = new Frustum();
                this._forward = new Vec3();
                this._position = new Vec3();
                this._priority = 0;
                this._aperture = CameraAperture.F16_0;
                this._apertureValue = void 0;
                this._shutter = CameraShutter.D125;
                this._shutterValue = 0.0;
                this._iso = CameraISO.ISO100;
                this._isoValue = 0.0;
                this._ec = 0.0;
                this._window = null;
                this._width = 1;
                this._height = 1;
                this._clearFlag = ClearFlagBit.NONE;
                this._clearDepth = 1.0;
                this._visibility = CAMERA_DEFAULT_MASK;
                this._exposure = 0;
                this._clearStencil = 0;
                this._device = device;
                this._apertureValue = FSTOPS[this._aperture];
                this._shutterValue = SHUTTERS[this._shutter];
                this._isoValue = ISOS[this._iso];
                this._aspect = this.screenScale = 1;
                this._frustum.accurate = true;

                if (!correctionMatrices.length) {
                  const ySign = device.capabilities.clipSpaceSignY;
                  correctionMatrices[SurfaceTransform.IDENTITY] = new Mat4(1, 0, 0, 0, 0, ySign);
                  correctionMatrices[SurfaceTransform.ROTATE_90] = new Mat4(0, 1, 0, 0, -ySign, 0);
                  correctionMatrices[SurfaceTransform.ROTATE_180] = new Mat4(-1, 0, 0, 0, 0, -ySign);
                  correctionMatrices[SurfaceTransform.ROTATE_270] = new Mat4(0, -1, 0, 0, ySign, 0);
                }
              }

              _setWidth(val) {
                this._width = val;

                {
                  this._nativeObj.width = val;
                }
              }

              _setHeight(val) {
                this._height = val;

                {
                  this._nativeObj.height = val;
                }
              }

              _setScene(scene) {
                this._scene = scene;

                {
                  this._nativeObj.scene = scene ? scene.native : null;
                }
              }

              _updateAspect(oriented = true) {
                this._aspect = this.window.width * this._viewport.width / (this.window.height * this._viewport.height);

                if (oriented) {
                  const swapchain = this.window.swapchain;
                  const orientation = swapchain && swapchain.surfaceTransform || SurfaceTransform.IDENTITY;
                  if (orientation % 2) this._aspect = 1 / this._aspect;
                }

                this._isProjDirty = true;
                this._nativeObj.aspect = this._aspect;
              }

              _init(info) {
                {
                  this._nativeObj = new NativeCamera();
                  if (this._scene) this._nativeObj.scene = this._scene.native;
                  this._nativeObj.frustum = this._frustum;
                }
              }

              static get standardExposureValue() {
                return 1.0 / 38400.0;
              }

              static get standardLightMeterScale() {
                return 10000.0;
              }

              initialize(info) {
                this._init(info);

                this.node = info.node;

                this._setWidth(1);

                this._setHeight(1);

                this.clearFlag = ClearFlagBit.NONE;
                this.clearDepth = 1.0;
                this.visibility = CAMERA_DEFAULT_MASK;
                this._name = info.name;
                this._proj = info.projection;
                this._priority = info.priority || 0;
                this._aspect = this.screenScale = 1;
                this.updateExposure();
                this.changeTargetWindow(info.window);
              }

              _destroy() {
                this._nativeObj = null;
              }

              destroy() {
                if (this._window) {
                  this._window.detachCamera(this);

                  this.window = null;
                }

                this._name = null;

                this._destroy();
              }

              attachToScene(scene) {
                this._enabled = true;

                this._setScene(scene);
              }

              detachFromScene() {
                this._enabled = false;

                this._setScene(null);
              }

              resize(width, height) {
                if (!this._window) return;

                this._setWidth(width);

                this._setHeight(height);

                this._updateAspect();
              }

              setFixedSize(width, height) {
                this._setWidth(width);

                this._setHeight(height);

                this._updateAspect(false);

                this.isWindowSize = false;
              }

              syncCameraEditor(camera) {
              }

              update(forceUpdate = false) {
                var _this$window;

                if (!this._node) return;
                let viewProjDirty = false;

                if (this._node.hasChangedFlags || forceUpdate) {
                  Mat4.invert(this._matView, this._node.worldMatrix);

                  {
                    this._nativeObj.matView = this._matView;
                  }

                  this._forward.x = -this._matView.m02;
                  this._forward.y = -this._matView.m06;
                  this._forward.z = -this._matView.m10;

                  this._node.getWorldPosition(this._position);

                  {
                    this._nativeObj.position = this._position;
                    this._nativeObj.forward = this._forward;
                  }

                  viewProjDirty = true;
                }

                const swapchain = (_this$window = this.window) === null || _this$window === void 0 ? void 0 : _this$window.swapchain;
                const orientation = swapchain && swapchain.surfaceTransform || SurfaceTransform.IDENTITY;

                if (this._isProjDirty || this._curTransform !== orientation) {
                  this._curTransform = orientation;
                  const projectionSignY = this._device.capabilities.clipSpaceSignY;

                  if (this._proj === CameraProjection.PERSPECTIVE) {
                    Mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip, this._fovAxis === CameraFOVAxis.VERTICAL, this._device.capabilities.clipSpaceMinZ, projectionSignY, orientation);
                  } else {
                    const x = this._orthoHeight * this._aspect;
                    const y = this._orthoHeight;
                    Mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip, this._device.capabilities.clipSpaceMinZ, projectionSignY, orientation);
                  }

                  {
                    this._nativeObj.aspect = this._aspect;
                  }

                  Mat4.invert(this._matProjInv, this._matProj);

                  {
                    this._nativeObj.matProj = this._matProj;
                    this._nativeObj.matProjInv = this._matProjInv;
                  }

                  viewProjDirty = true;
                  this._isProjDirty = false;
                }

                if (viewProjDirty) {
                  Mat4.multiply(this._matViewProj, this._matProj, this._matView);
                  Mat4.invert(this._matViewProjInv, this._matViewProj);

                  this._frustum.update(this._matViewProj, this._matViewProjInv);

                  {
                    this._nativeObj.matViewProj = this._matViewProj;
                    this._nativeObj.matViewProjInv = this._matViewProjInv;
                    this._nativeObj.frustum = this._frustum;
                  }
                }
              }

              set node(val) {
                this._node = val;

                {
                  this._nativeObj.node = this._node.native;
                }
              }

              get node() {
                return this._node;
              }

              set enabled(val) {
                this._enabled = val;
              }

              get enabled() {
                return this._enabled;
              }

              set orthoHeight(val) {
                this._orthoHeight = val;
                this._isProjDirty = true;
              }

              get orthoHeight() {
                return this._orthoHeight;
              }

              set projectionType(val) {
                this._proj = val;
                this._isProjDirty = true;
              }

              get projectionType() {
                return this._proj;
              }

              set fovAxis(axis) {
                this._fovAxis = axis;
                this._isProjDirty = true;
              }

              get fovAxis() {
                return this._fovAxis;
              }

              set fov(fov) {
                this._fov = fov;

                {
                  this._nativeObj.fov = fov;
                }

                this._isProjDirty = true;
              }

              get fov() {
                return this._fov;
              }

              set nearClip(nearClip) {
                this._nearClip = nearClip;

                {
                  this._nativeObj.nearClip = this._nearClip;
                }

                this._isProjDirty = true;
              }

              get nearClip() {
                return this._nearClip;
              }

              set farClip(farClip) {
                this._farClip = farClip;

                {
                  this._nativeObj.farClip = this._farClip;
                }

                this._isProjDirty = true;
              }

              get farClip() {
                return this._farClip;
              }

              set clearColor(val) {
                this._clearColor.x = val.x;
                this._clearColor.y = val.y;
                this._clearColor.z = val.z;
                this._clearColor.w = val.w;

                {
                  this._nativeObj.clearColor = this._clearColor;
                }
              }

              get clearColor() {
                return this._clearColor;
              }

              get viewport() {
                return this._viewport;
              }

              set viewport(val) {
                warnID(8302);
                this.setViewportInOrientedSpace(val);
              }

              setViewportInOrientedSpace(val) {
                var _this$window2;

                const {
                  x,
                  width,
                  height
                } = val;
                const y = this._device.capabilities.screenSpaceSignY < 0 ? 1 - val.y - height : val.y;
                const swapchain = (_this$window2 = this.window) === null || _this$window2 === void 0 ? void 0 : _this$window2.swapchain;
                const orientation = swapchain && swapchain.surfaceTransform || SurfaceTransform.IDENTITY;

                switch (orientation) {
                  case SurfaceTransform.ROTATE_90:
                    this._viewport.x = 1 - y - height;
                    this._viewport.y = x;
                    this._viewport.width = height;
                    this._viewport.height = width;
                    break;

                  case SurfaceTransform.ROTATE_180:
                    this._viewport.x = 1 - x - width;
                    this._viewport.y = 1 - y - height;
                    this._viewport.width = width;
                    this._viewport.height = height;
                    break;

                  case SurfaceTransform.ROTATE_270:
                    this._viewport.x = y;
                    this._viewport.y = 1 - x - width;
                    this._viewport.width = height;
                    this._viewport.height = width;
                    break;

                  case SurfaceTransform.IDENTITY:
                    this._viewport.x = x;
                    this._viewport.y = y;
                    this._viewport.width = width;
                    this._viewport.height = height;
                    break;
                }

                this._orientedViewport.x = x;
                this._orientedViewport.y = y;
                this._orientedViewport.width = width;
                this._orientedViewport.height = height;

                {
                  this._nativeObj.viewPort = this._viewport;
                }

                this.resize(this.width, this.height);
              }

              get scene() {
                return this._scene;
              }

              get name() {
                return this._name;
              }

              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              get aspect() {
                return this._aspect;
              }

              get matView() {
                return this._matView;
              }

              get matProj() {
                return this._matProj;
              }

              get matProjInv() {
                return this._matProjInv;
              }

              get matViewProj() {
                return this._matViewProj;
              }

              get matViewProjInv() {
                return this._matViewProjInv;
              }

              set frustum(val) {
                this._frustum = val;

                {
                  this._nativeObj.frustum = this._frustum;
                }
              }

              get frustum() {
                return this._frustum;
              }

              set window(val) {
                this._window = val;

                if ( val) {
                  this._nativeObj.window = this._window.native;
                }
              }

              get window() {
                return this._window;
              }

              set forward(val) {
                this._forward = val;

                {
                  this._nativeObj.forward = this._forward;
                }
              }

              get forward() {
                return this._forward;
              }

              set position(val) {
                this._position = val;

                {
                  this._nativeObj.position = this._position;
                }
              }

              get position() {
                return this._position;
              }

              set visibility(vis) {
                this._visibility = vis;

                {
                  this._nativeObj.visibility = this._visibility;
                }
              }

              get visibility() {
                return this._visibility;
              }

              get priority() {
                return this._priority;
              }

              set priority(val) {
                this._priority = val;
              }

              set aperture(val) {
                this._aperture = val;
                this._apertureValue = FSTOPS[this._aperture];
                this.updateExposure();
              }

              get aperture() {
                return this._aperture;
              }

              get apertureValue() {
                return this._apertureValue;
              }

              set shutter(val) {
                this._shutter = val;
                this._shutterValue = SHUTTERS[this._shutter];
                this.updateExposure();
              }

              get shutter() {
                return this._shutter;
              }

              get shutterValue() {
                return this._shutterValue;
              }

              set iso(val) {
                this._iso = val;
                this._isoValue = ISOS[this._iso];
                this.updateExposure();
              }

              get iso() {
                return this._iso;
              }

              get isoValue() {
                return this._isoValue;
              }

              set ec(val) {
                this._ec = val;
              }

              get ec() {
                return this._ec;
              }

              get exposure() {
                return this._exposure;
              }

              get clearFlag() {
                return this._clearFlag;
              }

              set clearFlag(flag) {
                this._clearFlag = flag;

                {
                  this._nativeObj.clearFlag = flag;
                }
              }

              get clearDepth() {
                return this._clearDepth;
              }

              set clearDepth(depth) {
                this._clearDepth = depth;

                {
                  this._nativeObj.clearDepth = depth;
                }
              }

              get clearStencil() {
                return this._clearStencil;
              }

              set clearStencil(stencil) {
                this._clearStencil = stencil;

                {
                  this._nativeObj.clearStencil = stencil;
                }
              }

              get native() {
                return this._nativeObj;
              }

              changeTargetWindow(window = null) {
                if (this._window) {
                  this._window.detachCamera(this);
                }

                const win = window || legacyCC.director.root.mainWindow;

                if (win) {
                  win.attachCamera(this);
                  this.window = win;
                  const swapchain = win.swapchain;
                  const orientation = swapchain && swapchain.surfaceTransform || SurfaceTransform.IDENTITY;
                  if (orientation % 2) this.resize(win.height, win.width);else this.resize(win.width, win.height);
                }
              }

              detachCamera() {
                if (this._window) {
                  this._window.detachCamera(this);
                }
              }

              screenPointToRay(out, x, y) {
                if (!this._node) return null;
                const width = this.width;
                const height = this.height;
                const cx = this._orientedViewport.x * width;
                const cy = this._orientedViewport.y * height;
                const cw = this._orientedViewport.width * width;
                const ch = this._orientedViewport.height * height;
                const isProj = this._proj === CameraProjection.PERSPECTIVE;
                const ySign = this._device.capabilities.clipSpaceSignY;
                const preTransform = preTransforms[this._curTransform];
                Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, isProj ? 1 : -1);
                const {
                  x: ox,
                  y: oy
                } = v_a;
                v_a.x = ox * preTransform[0] + oy * preTransform[2] * ySign;
                v_a.y = ox * preTransform[1] + oy * preTransform[3] * ySign;
                Vec3.transformMat4(isProj ? v_a : out.o, v_a, this._matViewProjInv);

                if (isProj) {
                  this._node.getWorldPosition(v_b);

                  Ray.fromPoints(out, v_b, v_a);
                } else {
                  Vec3.transformQuat(out.d, Vec3.FORWARD, this._node.worldRotation);
                }

                return out;
              }

              screenToWorld(out, screenPos) {
                const width = this.width;
                const height = this.height;
                const cx = this._orientedViewport.x * width;
                const cy = this._orientedViewport.y * height;
                const cw = this._orientedViewport.width * width;
                const ch = this._orientedViewport.height * height;
                const ySign = this._device.capabilities.clipSpaceSignY;
                const preTransform = preTransforms[this._curTransform];

                if (this._proj === CameraProjection.PERSPECTIVE) {
                  Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1.0);
                  const {
                    x,
                    y
                  } = out;
                  out.x = x * preTransform[0] + y * preTransform[2] * ySign;
                  out.y = x * preTransform[1] + y * preTransform[3] * ySign;
                  Vec3.transformMat4(out, out, this._matViewProjInv);

                  if (this._node) {
                    this._node.getWorldPosition(v_a);
                  }

                  Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z));
                } else {
                  Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, screenPos.z * 2 - 1);
                  const {
                    x,
                    y
                  } = out;
                  out.x = x * preTransform[0] + y * preTransform[2] * ySign;
                  out.y = x * preTransform[1] + y * preTransform[3] * ySign;
                  Vec3.transformMat4(out, out, this._matViewProjInv);
                }

                return out;
              }

              worldToScreen(out, worldPos) {
                const ySign = this._device.capabilities.clipSpaceSignY;
                const preTransform = preTransforms[this._curTransform];
                Vec3.transformMat4(out, worldPos, this._matViewProj);
                const {
                  x,
                  y
                } = out;
                out.x = x * preTransform[0] + y * preTransform[2] * ySign;
                out.y = x * preTransform[1] + y * preTransform[3] * ySign;
                const width = this.width;
                const height = this.height;
                const cx = this._orientedViewport.x * width;
                const cy = this._orientedViewport.y * height;
                const cw = this._orientedViewport.width * width;
                const ch = this._orientedViewport.height * height;
                out.x = cx + (out.x + 1) * 0.5 * cw;
                out.y = cy + (out.y + 1) * 0.5 * ch;
                out.z = out.z * 0.5 + 0.5;
                return out;
              }

              worldMatrixToScreen(out, worldMatrix, width, height) {
                Mat4.multiply(out, this._matViewProj, worldMatrix);
                Mat4.multiply(out, correctionMatrices[this._curTransform], out);
                const halfWidth = width / 2;
                const halfHeight = height / 2;
                Mat4.identity(_tempMat1);
                Mat4.transform(_tempMat1, _tempMat1, Vec3.set(v_a, halfWidth, halfHeight, 0));
                Mat4.scale(_tempMat1, _tempMat1, Vec3.set(v_a, halfWidth, halfHeight, 1));
                Mat4.multiply(out, _tempMat1, out);
                return out;
              }

              setExposure(ev100) {
                this._exposure = 0.833333 / 2.0 ** ev100;

                {
                  this._nativeObj.exposure = this._exposure;
                }
              }

              updateExposure() {
                const ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100.0 / this._isoValue);
                this.setExposure(ev100);
              }

            } exports('cy', Camera);

            let CUSTOM_PIXEL_FORMAT = 1024;
            let PixelFormat;

            (function (PixelFormat) {
              PixelFormat[PixelFormat["RGB565"] = Format.R5G6B5] = "RGB565";
              PixelFormat[PixelFormat["RGB5A1"] = Format.RGB5A1] = "RGB5A1";
              PixelFormat[PixelFormat["RGBA4444"] = Format.RGBA4] = "RGBA4444";
              PixelFormat[PixelFormat["RGB888"] = Format.RGB8] = "RGB888";
              PixelFormat[PixelFormat["RGB32F"] = Format.RGB32F] = "RGB32F";
              PixelFormat[PixelFormat["RGBA8888"] = Format.RGBA8] = "RGBA8888";
              PixelFormat[PixelFormat["RGBA32F"] = Format.RGBA32F] = "RGBA32F";
              PixelFormat[PixelFormat["A8"] = Format.A8] = "A8";
              PixelFormat[PixelFormat["I8"] = Format.L8] = "I8";
              PixelFormat[PixelFormat["AI8"] = Format.LA8] = "AI8";
              PixelFormat[PixelFormat["RGB_PVRTC_2BPPV1"] = Format.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGBA_PVRTC_2BPPV1"] = Format.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGB_A_PVRTC_2BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGB_PVRTC_4BPPV1"] = Format.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGBA_PVRTC_4BPPV1"] = Format.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGB_A_PVRTC_4BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGB_ETC1"] = Format.ETC_RGB8] = "RGB_ETC1";
              PixelFormat[PixelFormat["RGBA_ETC1"] = CUSTOM_PIXEL_FORMAT++] = "RGBA_ETC1";
              PixelFormat[PixelFormat["RGB_ETC2"] = Format.ETC2_RGB8] = "RGB_ETC2";
              PixelFormat[PixelFormat["RGBA_ETC2"] = Format.ETC2_RGBA8] = "RGBA_ETC2";
              PixelFormat[PixelFormat["RGBA_ASTC_4x4"] = Format.ASTC_RGBA_4X4] = "RGBA_ASTC_4x4";
              PixelFormat[PixelFormat["RGBA_ASTC_5x4"] = Format.ASTC_RGBA_5X4] = "RGBA_ASTC_5x4";
              PixelFormat[PixelFormat["RGBA_ASTC_5x5"] = Format.ASTC_RGBA_5X5] = "RGBA_ASTC_5x5";
              PixelFormat[PixelFormat["RGBA_ASTC_6x5"] = Format.ASTC_RGBA_6X5] = "RGBA_ASTC_6x5";
              PixelFormat[PixelFormat["RGBA_ASTC_6x6"] = Format.ASTC_RGBA_6X6] = "RGBA_ASTC_6x6";
              PixelFormat[PixelFormat["RGBA_ASTC_8x5"] = Format.ASTC_RGBA_8X5] = "RGBA_ASTC_8x5";
              PixelFormat[PixelFormat["RGBA_ASTC_8x6"] = Format.ASTC_RGBA_8X6] = "RGBA_ASTC_8x6";
              PixelFormat[PixelFormat["RGBA_ASTC_8x8"] = Format.ASTC_RGBA_8X8] = "RGBA_ASTC_8x8";
              PixelFormat[PixelFormat["RGBA_ASTC_10x5"] = Format.ASTC_RGBA_10X5] = "RGBA_ASTC_10x5";
              PixelFormat[PixelFormat["RGBA_ASTC_10x6"] = Format.ASTC_RGBA_10X6] = "RGBA_ASTC_10x6";
              PixelFormat[PixelFormat["RGBA_ASTC_10x8"] = Format.ASTC_RGBA_10X8] = "RGBA_ASTC_10x8";
              PixelFormat[PixelFormat["RGBA_ASTC_10x10"] = Format.ASTC_RGBA_10X10] = "RGBA_ASTC_10x10";
              PixelFormat[PixelFormat["RGBA_ASTC_12x10"] = Format.ASTC_RGBA_12X10] = "RGBA_ASTC_12x10";
              PixelFormat[PixelFormat["RGBA_ASTC_12x12"] = Format.ASTC_RGBA_12X12] = "RGBA_ASTC_12x12";
            })(PixelFormat || (PixelFormat = exports('cZ', {})));

            let WrapMode$1;

            (function (WrapMode) {
              WrapMode[WrapMode["REPEAT"] = Address.WRAP] = "REPEAT";
              WrapMode[WrapMode["CLAMP_TO_EDGE"] = Address.CLAMP] = "CLAMP_TO_EDGE";
              WrapMode[WrapMode["MIRRORED_REPEAT"] = Address.MIRROR] = "MIRRORED_REPEAT";
              WrapMode[WrapMode["CLAMP_TO_BORDER"] = Address.BORDER] = "CLAMP_TO_BORDER";
            })(WrapMode$1 || (WrapMode$1 = exports('d7', {})));

            let Filter$1;

            (function (Filter$1) {
              Filter$1[Filter$1["NONE"] = Filter.NONE] = "NONE";
              Filter$1[Filter$1["LINEAR"] = Filter.LINEAR] = "LINEAR";
              Filter$1[Filter$1["NEAREST"] = Filter.POINT] = "NEAREST";
            })(Filter$1 || (Filter$1 = exports('cY', {})));

            var _dec$b, _class$b, _class2$9, _class3$4, _temp$8;

            function isImageBitmap(imageSource) {
              return !!(legacyCC.sys.hasFeature(legacyCC.sys.Feature.IMAGE_BITMAP) && imageSource instanceof ImageBitmap);
            }

            function isNativeImage(imageSource) {

              if ( imageSource._compressed === true) {
                return false;
              }

              return imageSource instanceof HTMLImageElement || imageSource instanceof HTMLCanvasElement || isImageBitmap(imageSource);
            }

            let ImageAsset = exports('d6', (_dec$b = ccclass('cc.ImageAsset'), _dec$b(_class$b = (_class2$9 = (_temp$8 = _class3$4 = class ImageAsset extends Asset {
              get _nativeAsset() {
                return this._nativeData;
              }

              set _nativeAsset(value) {
                if (!(value instanceof HTMLElement) && !isImageBitmap(value)) {
                  value.format = value.format || this._format;
                }

                this.reset(value);
              }

              get data() {
                if (this._nativeData && isNativeImage(this._nativeData)) {
                  return this._nativeData;
                }

                return this._nativeData && this._nativeData._data;
              }

              get width() {
                return this._nativeData.width || this._width;
              }

              get height() {
                return this._nativeData.height || this._height;
              }

              get format() {
                return this._format;
              }

              get isCompressed() {
                return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_ASTC_12x12 || this._format >= PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= PixelFormat.RGBA_ETC1;
              }

              get url() {
                return this.nativeUrl;
              }

              constructor(nativeAsset) {
                super();
                this._nativeData = void 0;
                this._exportedExts = undefined;
                this._format = PixelFormat.RGBA8888;
                this._width = 0;
                this._height = 0;
                this._nativeData = {
                  _data: null,
                  width: 0,
                  height: 0,
                  format: 0,
                  _compressed: false
                };

                if (nativeAsset !== undefined) {
                  this.reset(nativeAsset);
                }
              }

              reset(data) {
                if (isImageBitmap(data)) {
                  this._nativeData = data;
                } else if (!(data instanceof HTMLElement)) {
                  this._nativeData = data;
                  this._format = data.format;
                } else {
                  this._nativeData = data;
                }
              }

              destroy() {
                if (this.data && this.data instanceof HTMLImageElement) {
                  this.data.src = '';

                  this._setRawAsset('');

                  this.data.destroy();
                } else if (isImageBitmap(this.data)) {
                  this.data.close && this.data.close();
                }

                return super.destroy();
              }

              _serialize() {
              }

              _deserialize(data) {
                let fmtStr = '';

                if (typeof data === 'string') {
                  fmtStr = data;
                } else {
                  this._width = data.w;
                  this._height = data.h;
                  fmtStr = data.fmt;
                }

                const device = _getGlobalDevice();

                const extensionIDs = fmtStr.split('_');
                let preferedExtensionIndex = Number.MAX_VALUE;
                let format = this._format;
                let ext = '';
                const SupportTextureFormats = legacyCC.macro.SUPPORT_TEXTURE_FORMATS;

                for (const extensionID of extensionIDs) {
                  const extFormat = extensionID.split('@');
                  const i = parseInt(extFormat[0], undefined);
                  const tmpExt = ImageAsset.extnames[i] || extFormat[0];
                  const index = SupportTextureFormats.indexOf(tmpExt);

                  if (index !== -1 && index < preferedExtensionIndex) {
                    const fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;

                    if (tmpExt === '.astc' && (!device || !device.hasFeature(Feature$1.FORMAT_ASTC))) {
                      continue;
                    } else if (tmpExt === '.pvr' && (!device || !device.hasFeature(Feature$1.FORMAT_PVRTC))) {
                      continue;
                    } else if ((fmt === PixelFormat.RGB_ETC1 || fmt === PixelFormat.RGBA_ETC1) && (!device || !device.hasFeature(Feature$1.FORMAT_ETC1))) {
                      continue;
                    } else if ((fmt === PixelFormat.RGB_ETC2 || fmt === PixelFormat.RGBA_ETC2) && (!device || !device.hasFeature(Feature$1.FORMAT_ETC2))) {
                      continue;
                    } else if (tmpExt === '.webp' && !legacyCC.sys.hasFeature(legacyCC.sys.Feature.WEBP)) {
                      continue;
                    }

                    preferedExtensionIndex = index;
                    ext = tmpExt;
                    format = fmt;
                  }
                }

                if (ext) {
                  this._setRawAsset(ext);

                  this._format = format;
                } else {
                  warnID(3121);
                }
              }

              initDefault(uuid) {
                super.initDefault(uuid);

                if (!ImageAsset._sharedPlaceHolderCanvas) {
                  const canvas = document.createElement('canvas');
                  const context = canvas.getContext('2d');
                  const l = canvas.width = canvas.height = 2;
                  context.fillStyle = '#ff00ff';
                  context.fillRect(0, 0, l, l);
                  this.reset(canvas);
                  ImageAsset._sharedPlaceHolderCanvas = canvas;
                } else {
                  this.reset(ImageAsset._sharedPlaceHolderCanvas);
                }
              }

              validate() {
                return !!this.data;
              }

            }, _class3$4.extnames = ['.png', '.jpg', '.jpeg', '.bmp', '.webp', '.pvr', '.pkm', '.astc'], _class3$4._sharedPlaceHolderCanvas = null, _temp$8), (_applyDecoratedDescriptor(_class2$9.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$9.prototype, "_nativeAsset"), _class2$9.prototype)), _class2$9)) || _class$b));

            function _getGlobalDevice() {
              if (legacyCC.director.root) {
                return legacyCC.director.root.device;
              }

              return null;
            }

            legacyCC.ImageAsset = ImageAsset;

            var _dec$c, _class$c, _class2$a, _descriptor$8, _descriptor2$5, _descriptor3$3, _descriptor4$2, _descriptor5$1, _descriptor6, _descriptor7, _descriptor8, _class3$5, _temp$9;
            ccenum(Format);
            const idGenerator$1 = new IDGenerator('Tex');
            let TextureBase = exports('e9', (_dec$c = ccclass('cc.TextureBase'), _dec$c(_class$c = (_class2$a = (_temp$9 = _class3$5 = class TextureBase extends Asset {
              get isCompressed() {
                return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_ASTC_12x12 || this._format >= PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= PixelFormat.RGBA_ETC1;
              }

              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_format", _descriptor$8, this);

                _initializerDefineProperty(this, "_minFilter", _descriptor2$5, this);

                _initializerDefineProperty(this, "_magFilter", _descriptor3$3, this);

                _initializerDefineProperty(this, "_mipFilter", _descriptor4$2, this);

                _initializerDefineProperty(this, "_wrapS", _descriptor5$1, this);

                _initializerDefineProperty(this, "_wrapT", _descriptor6, this);

                _initializerDefineProperty(this, "_wrapR", _descriptor7, this);

                _initializerDefineProperty(this, "_anisotropy", _descriptor8, this);

                this._width = 1;
                this._height = 1;
                this._id = void 0;
                this._samplerInfo = new SamplerInfo();
                this._gfxSampler = null;
                this._gfxDevice = null;
                this._textureHash = 0;
                this._id = idGenerator$1.getNewId();
                this._gfxDevice = this._getGFXDevice();
                this._textureHash = murmurhash2_32_gc(this._id, 666);
              }

              getId() {
                return this._id;
              }

              getPixelFormat() {
                return this._format;
              }

              getAnisotropy() {
                return this._anisotropy;
              }

              setWrapMode(wrapS, wrapT, wrapR) {
                if (wrapR === undefined) wrapR = wrapS;
                this._wrapS = wrapS;
                this._samplerInfo.addressU = wrapS;
                this._wrapT = wrapT;
                this._samplerInfo.addressV = wrapT;
                this._wrapR = wrapR;
                this._samplerInfo.addressW = wrapR;

                if (this._gfxDevice) {
                  this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                }
              }

              setFilters(minFilter, magFilter) {
                this._minFilter = minFilter;
                this._samplerInfo.minFilter = minFilter;
                this._magFilter = magFilter;
                this._samplerInfo.magFilter = magFilter;

                if (this._gfxDevice) {
                  this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                }
              }

              setMipFilter(mipFilter) {
                this._mipFilter = mipFilter;
                this._samplerInfo.mipFilter = mipFilter;

                if (this._gfxDevice) {
                  this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                }
              }

              setAnisotropy(anisotropy) {
                this._anisotropy = anisotropy;
                this._samplerInfo.maxAnisotropy = anisotropy;

                if (this._gfxDevice) {
                  this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                }
              }

              destroy() {
                var _legacyCC$director$ro;

                const destroyed = super.destroy();

                if (destroyed && ((_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.batcher2D)) {
                  legacyCC.director.root.batcher2D._releaseDescriptorSetCache(this._textureHash);
                }

                return destroyed;
              }

              getHash() {
                return this._textureHash;
              }

              getGFXTexture() {
                return null;
              }

              getSamplerInfo() {
                return this._samplerInfo;
              }

              getGFXSampler() {
                if (!this._gfxSampler) {
                  if (this._gfxDevice) {
                    this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                  } else {
                    errorID(9302);
                  }
                }

                return this._gfxSampler;
              }

              _serialize(ctxForExporting) {

                return '';
              }

              _deserialize(serializedData, handle) {
                const data = serializedData;
                const fields = data.split(',');
                fields.unshift('');

                if (fields.length >= 5) {
                  this.setFilters(parseInt(fields[1]), parseInt(fields[2]));
                  this.setWrapMode(parseInt(fields[3]), parseInt(fields[4]));
                }

                if (fields.length >= 7) {
                  this.setMipFilter(parseInt(fields[5]));
                  this.setAnisotropy(parseInt(fields[6]));
                }
              }

              _getGFXDevice() {
                if (legacyCC.director.root) {
                  return legacyCC.director.root.device;
                }

                return null;
              }

              _getGFXFormat() {
                return this._getGFXPixelFormat(this._format);
              }

              _setGFXFormat(format) {
                this._format = format === undefined ? PixelFormat.RGBA8888 : format;
              }

              _getGFXPixelFormat(format) {
                if (format === PixelFormat.RGBA_ETC1) {
                  format = PixelFormat.RGB_ETC1;
                } else if (format === PixelFormat.RGB_A_PVRTC_4BPPV1) {
                  format = PixelFormat.RGB_PVRTC_4BPPV1;
                } else if (format === PixelFormat.RGB_A_PVRTC_2BPPV1) {
                  format = PixelFormat.RGB_PVRTC_2BPPV1;
                }

                return format;
              }

            }, _class3$5.PixelFormat = PixelFormat, _class3$5.WrapMode = WrapMode$1, _class3$5.Filter = Filter$1, _temp$9), (_descriptor$8 = _applyDecoratedDescriptor(_class2$a.prototype, "_format", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PixelFormat.RGBA8888;
              }
            }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$a.prototype, "_minFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Filter$1.LINEAR;
              }
            }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$a.prototype, "_magFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Filter$1.LINEAR;
              }
            }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$a.prototype, "_mipFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Filter$1.NONE;
              }
            }), _descriptor5$1 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapS", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return WrapMode$1.REPEAT;
              }
            }), _descriptor6 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapT", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return WrapMode$1.REPEAT;
              }
            }), _descriptor7 = _applyDecoratedDescriptor(_class2$a.prototype, "_wrapR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return WrapMode$1.REPEAT;
              }
            }), _descriptor8 = _applyDecoratedDescriptor(_class2$a.prototype, "_anisotropy", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$a)) || _class$c));
            legacyCC.TextureBase = TextureBase;

            const dependMap = new WeakMap();
            const nativeDependMap = new WeakSet();
            const onLoadedInvokedMap = new WeakSet();

            function deserializeAsset(json, options) {
              let classFinder;

              {
                classFinder = MissingScript.safeFindClass;
              }

              const tdInfo = Details.pool.get();
              let asset;

              try {
                asset = deserialize(json, tdInfo, {
                  classFinder,
                  customEnv: options
                });
              } catch (e) {
                error(e);
                Details.pool.put(tdInfo);
                throw e;
              }

              asset._uuid = options.__uuid__ || '';

              const uuidList = tdInfo.uuidList;
              const objList = tdInfo.uuidObjList;
              const propList = tdInfo.uuidPropList;
              const typeList = tdInfo.uuidTypeList || [];
              const depends = [];

              for (let i = 0; i < uuidList.length; i++) {
                const dependUuid = uuidList[i];
                depends[i] = {
                  uuid: decodeUuid(dependUuid),
                  owner: objList[i],
                  prop: propList[i],
                  type: js._getClassById(typeList[i])
                };
              }

              dependMap.set(asset, depends);

              if (asset._native) {
                nativeDependMap.add(asset);
              }

              Details.pool.put(tdInfo);
              return asset;
            }

            class DependUtil {
              constructor() {
                this._depends = new Cache();
              }

              init() {
                this._depends.clear();
              }

              getNativeDep(uuid) {
                const depend = this._depends.get(uuid);

                if (depend && depend.nativeDep) {
                  return { ...depend.nativeDep
                  };
                }

                return null;
              }

              getDeps(uuid) {
                if (this._depends.has(uuid)) {
                  return this._depends.get(uuid).deps;
                }

                return [];
              }

              getDepsRecursively(uuid) {
                const exclude = Object.create(null);
                const depends = [];

                this._descend(uuid, exclude, depends);

                return depends;
              }

              remove(uuid) {
                this._depends.remove(uuid);
              }

              parse(uuid, json) {
                let out = null;

                if (Array.isArray(json) || json.__type__ || json instanceof CCON) {
                  if (this._depends.has(uuid)) {
                    return this._depends.get(uuid);
                  }

                  if (Array.isArray(json) && ( !hasNativeDep(json))) {
                    out = {
                      deps: this._parseDepsFromJson(json)
                    };
                  } else {
                    try {
                      const asset = deserializeAsset(json, {
                        __uuid__: uuid
                      });
                      out = this._parseDepsFromAsset(asset);

                      if (out.nativeDep) {
                        out.nativeDep.uuid = uuid;
                      }

                      parsed.add(`${uuid}@import`, asset);
                    } catch (e) {
                      files.remove(`${uuid}@import`);
                      out = {
                        deps: []
                      };
                    }
                  }
                } else {
                  if ( this._depends.has(uuid)) {
                    out = this._depends.get(uuid);

                    if (out.parsedFromExistAsset) {
                      return out;
                    }
                  }

                  out = this._parseDepsFromAsset(json);
                }

                this._depends.add(uuid, out);

                return out;
              }

              _parseDepsFromAsset(asset) {
                const out = {
                  deps: [],
                  parsedFromExistAsset: true
                };
                const deps = dependMap.get(asset);
                assertIsNonNullable(deps);

                for (let i = 0, l = deps.length; i < l; i++) {
                  out.deps.push(deps[i].uuid);
                }

                if (nativeDependMap.has(asset)) {
                  out.nativeDep = asset._nativeDep;
                }

                return out;
              }

              _parseDepsFromJson(json) {
                const depends = parseUuidDependencies(json);
                depends.forEach((uuid, index) => depends[index] = decodeUuid(uuid));
                return depends;
              }

              _descend(uuid, exclude, depends) {
                const deps = this.getDeps(uuid);

                for (let i = 0; i < deps.length; i++) {
                  const depend = deps[i];

                  if (!exclude[depend]) {
                    exclude[depend] = true;
                    depends.push(depend);

                    this._descend(depend, exclude, depends);
                  }
                }
              }

            }
            var dependUtil = new DependUtil();

            var _dec$d, _class$d, _temp$a;
            const _regions = [new BufferTextureCopy()];

            function getMipLevel(width, height) {
              let size = Math.max(width, height);
              let level = 0;

              while (size) {
                size >>= 1;
                level++;
              }

              return level;
            }

            function isPOT(n) {
              return n && (n & n - 1) === 0;
            }

            function canGenerateMipmap(device, w, h) {
              const needCheckPOT = device.gfxAPI === API.WEBGL;

              if (needCheckPOT) {
                return isPOT(w) && isPOT(h);
              }

              return true;
            }

            let SimpleTexture = (_dec$d = ccclass('cc.SimpleTexture'), _dec$d(_class$d = (_temp$a = class SimpleTexture extends TextureBase {
              constructor(...args) {
                super(...args);
                this._gfxTexture = null;
                this._mipmapLevel = 1;
                this._textureWidth = 0;
                this._textureHeight = 0;
              }

              get mipmapLevel() {
                return this._mipmapLevel;
              }

              getGFXTexture() {
                return this._gfxTexture;
              }

              destroy() {
                this._tryDestroyTexture();

                return super.destroy();
              }

              updateImage() {
                this.updateMipmaps(0);
              }

              updateMipmaps(firstLevel = 0, count) {}

              uploadData(source, level = 0, arrayIndex = 0) {
                if (!this._gfxTexture || this._mipmapLevel <= level) {
                  return;
                }

                const gfxDevice = this._getGFXDevice();

                if (!gfxDevice) {
                  return;
                }

                const region = _regions[0];
                region.texExtent.width = this._textureWidth >> level;
                region.texExtent.height = this._textureHeight >> level;
                region.texSubres.mipLevel = level;
                region.texSubres.baseArrayLayer = arrayIndex;

                if (ArrayBuffer.isView(source)) {
                  gfxDevice.copyBuffersToTexture([source], this._gfxTexture, _regions);
                } else {
                  gfxDevice.copyTexImagesToTexture([source], this._gfxTexture, _regions);
                }
              }

              _assignImage(image, level, arrayIndex) {
                const data = image.data;

                if (!data) {
                  return;
                }

                this.uploadData(data, level, arrayIndex);

                this._checkTextureLoaded();

                if (macro.CLEANUP_IMAGE_CACHE) {
                  const deps = dependUtil.getDeps(this._uuid);
                  const index = deps.indexOf(image._uuid);

                  if (index !== -1) {
                    fastRemoveAt(deps, index);
                    image.decRef();
                  }
                }
              }

              _checkTextureLoaded() {
                this._textureReady();
              }

              _textureReady() {
                this.loaded = true;
                this.emit('load');
              }

              _setMipmapLevel(value) {
                this._mipmapLevel = value < 1 ? 1 : value;
              }

              _getGfxTextureCreateInfo(presumed) {
                return null;
              }

              _tryReset() {
                this._tryDestroyTexture();

                if (this._mipmapLevel === 0) {
                  return;
                }

                const device = this._getGFXDevice();

                if (!device) {
                  return;
                }

                this._createTexture(device);
              }

              _createTexture(device) {
                if (this._width === 0 || this._height === 0) {
                  return;
                }

                let flags = TextureFlagBit.NONE;

                if (this._mipFilter !== Filter$1.NONE && canGenerateMipmap(device, this._width, this._height)) {
                  this._mipmapLevel = getMipLevel(this._width, this._height);
                  flags = TextureFlagBit.GEN_MIPMAP;
                }

                const textureCreateInfo = this._getGfxTextureCreateInfo({
                  usage: TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST,
                  format: this._getGFXFormat(),
                  levelCount: this._mipmapLevel,
                  flags
                });

                if (!textureCreateInfo) {
                  return;
                }

                const texture = device.createTexture(textureCreateInfo);
                this._textureWidth = textureCreateInfo.width;
                this._textureHeight = textureCreateInfo.height;
                this._gfxTexture = texture;
              }

              _tryDestroyTexture() {
                if (this._gfxTexture) {
                  this._gfxTexture.destroy();

                  this._gfxTexture = null;
                }
              }

            }, _temp$a)) || _class$d);
            legacyCC.SimpleTexture = SimpleTexture;

            var _dec$e, _dec2$4, _class$e, _class2$b, _descriptor$9, _temp$b;
            let Texture2D = exports('cX', (_dec$e = ccclass('cc.Texture2D'), _dec2$4 = type([ImageAsset]), _dec$e(_class$e = (_class2$b = (_temp$b = class Texture2D extends SimpleTexture {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_mipmaps", _descriptor$9, this);
              }

              get mipmaps() {
                return this._mipmaps;
              }

              set mipmaps(value) {
                this._mipmaps = value;

                this._setMipmapLevel(this._mipmaps.length);

                if (this._mipmaps.length > 0) {
                  const imageAsset = this._mipmaps[0];
                  this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._mipmaps.length
                  });

                  this._mipmaps.forEach((mipmap, level) => {
                    this._assignImage(mipmap, level);
                  });
                } else {
                  this.reset({
                    width: 0,
                    height: 0,
                    mipmapLevel: this._mipmaps.length
                  });
                }
              }

              get image() {
                return this._mipmaps.length === 0 ? null : this._mipmaps[0];
              }

              set image(value) {
                this.mipmaps = value ? [value] : [];
              }

              initialize() {
                this.mipmaps = this._mipmaps;
              }

              onLoaded() {
                this.initialize();
              }

              reset(info) {
                this._width = info.width;
                this._height = info.height;

                this._setGFXFormat(info.format);

                this._setMipmapLevel(info.mipmapLevel || 1);

                this._tryReset();
              }

              create(width, height, format = PixelFormat.RGBA8888, mipmapLevel = 1) {
                this.reset({
                  width,
                  height,
                  format,
                  mipmapLevel
                });
              }

              toString() {
                return this._mipmaps.length !== 0 ? this._mipmaps[0].url : '';
              }

              updateMipmaps(firstLevel = 0, count) {
                if (firstLevel >= this._mipmaps.length) {
                  return;
                }

                const nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

                for (let i = 0; i < nUpdate; ++i) {
                  const level = firstLevel + i;

                  this._assignImage(this._mipmaps[level], level);
                }
              }

              getHtmlElementObj() {
                return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
              }

              destroy() {
                this._mipmaps = [];
                return super.destroy();
              }

              description() {
                const url = this._mipmaps[0] ? this._mipmaps[0].url : '';
                return `<cc.Texture2D | Name = ${url} | Dimension = ${this.width} x ${this.height}>`;
              }

              releaseTexture() {
                this.destroy();
              }

              _serialize(ctxForExporting) {

                return null;
              }

              _deserialize(serializedData, handle) {
                const data = serializedData;

                super._deserialize(data.base, handle);

                this._mipmaps = new Array(data.mipmaps.length);

                for (let i = 0; i < data.mipmaps.length; ++i) {
                  this._mipmaps[i] = new ImageAsset();

                  if (!data.mipmaps[i]) {
                    continue;
                  }

                  const mipmapUUID = data.mipmaps[i];
                  handle.result.push(this._mipmaps, `${i}`, mipmapUUID, js._getClassId(ImageAsset));
                }
              }

              _getGfxTextureCreateInfo(presumed) {
                const texInfo = new TextureInfo(TextureType.TEX2D);
                texInfo.width = this._width;
                texInfo.height = this._height;
                return Object.assign(texInfo, presumed);
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                const imageAsset = new ImageAsset();
                imageAsset.initDefault();
                this.image = imageAsset;
              }

              validate() {
                return this.mipmaps && this.mipmaps.length !== 0;
              }

            }, _temp$b), (_descriptor$9 = _applyDecoratedDescriptor(_class2$b.prototype, "_mipmaps", [_dec2$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$b)) || _class$e));
            legacyCC.Texture2D = Texture2D;

            var _dec$f, _class$f, _class2$c, _descriptor$a, _descriptor2$6, _class3$6, _temp$c;
            var FaceIndex;

            (function (FaceIndex) {
              FaceIndex[FaceIndex["right"] = 0] = "right";
              FaceIndex[FaceIndex["left"] = 1] = "left";
              FaceIndex[FaceIndex["top"] = 2] = "top";
              FaceIndex[FaceIndex["bottom"] = 3] = "bottom";
              FaceIndex[FaceIndex["front"] = 4] = "front";
              FaceIndex[FaceIndex["back"] = 5] = "back";
            })(FaceIndex || (FaceIndex = {}));

            let TextureCube = exports('fF', (_dec$f = ccclass('cc.TextureCube'), _dec$f(_class$f = (_class2$c = (_temp$c = _class3$6 = class TextureCube extends SimpleTexture {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "isRGBE", _descriptor$a, this);

                _initializerDefineProperty(this, "_mipmaps", _descriptor2$6, this);
              }

              get mipmaps() {
                return this._mipmaps;
              }

              set mipmaps(value) {
                this._mipmaps = value;

                this._setMipmapLevel(this._mipmaps.length);

                if (this._mipmaps.length > 0) {
                  const imageAsset = this._mipmaps[0].front;
                  this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._mipmaps.length
                  });

                  this._mipmaps.forEach((mipmap, level) => {
                    _forEachFace(mipmap, (face, faceIndex) => {
                      this._assignImage(face, level, faceIndex);
                    });
                  });
                } else {
                  this.reset({
                    width: 0,
                    height: 0,
                    mipmapLevel: this._mipmaps.length
                  });
                }
              }

              get image() {
                return this._mipmaps.length === 0 ? null : this._mipmaps[0];
              }

              set image(value) {
                this.mipmaps = value ? [value] : [];
              }

              static fromTexture2DArray(textures, out) {
                const mipmaps = [];
                const nMipmaps = textures.length / 6;

                for (let i = 0; i < nMipmaps; i++) {
                  const x = i * 6;
                  mipmaps.push({
                    front: textures[x + FaceIndex.front].image,
                    back: textures[x + FaceIndex.back].image,
                    left: textures[x + FaceIndex.left].image,
                    right: textures[x + FaceIndex.right].image,
                    top: textures[x + FaceIndex.top].image,
                    bottom: textures[x + FaceIndex.bottom].image
                  });
                }

                out = out || new TextureCube();
                out.mipmaps = mipmaps;
                return out;
              }

              onLoaded() {
                this.mipmaps = this._mipmaps;
              }

              reset(info) {
                this._width = info.width;
                this._height = info.height;

                this._setGFXFormat(info.format);

                this._setMipmapLevel(info.mipmapLevel || 1);

                this._tryReset();
              }

              updateMipmaps(firstLevel = 0, count) {
                if (firstLevel >= this._mipmaps.length) {
                  return;
                }

                const nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

                for (let i = 0; i < nUpdate; ++i) {
                  const level = firstLevel + i;

                  _forEachFace(this._mipmaps[level], (face, faceIndex) => {
                    this._assignImage(face, level, faceIndex);
                  });
                }
              }

              destroy() {
                this._mipmaps = [];
                return super.destroy();
              }

              releaseTexture() {
                this.mipmaps = [];
              }

              _serialize(ctxForExporting) {

                return null;
              }

              _deserialize(serializedData, handle) {
                const data = serializedData;

                super._deserialize(data.base, handle);

                this.isRGBE = data.rgbe;
                this._mipmaps = new Array(data.mipmaps.length);

                for (let i = 0; i < data.mipmaps.length; ++i) {
                  this._mipmaps[i] = {
                    front: new ImageAsset(),
                    back: new ImageAsset(),
                    left: new ImageAsset(),
                    right: new ImageAsset(),
                    top: new ImageAsset(),
                    bottom: new ImageAsset()
                  };
                  const mipmap = data.mipmaps[i];

                  const imageAssetClassId = js._getClassId(ImageAsset);

                  handle.result.push(this._mipmaps[i], `front`, mipmap.front, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `back`, mipmap.back, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `left`, mipmap.left, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `right`, mipmap.right, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `top`, mipmap.top, imageAssetClassId);
                  handle.result.push(this._mipmaps[i], `bottom`, mipmap.bottom, imageAssetClassId);
                }
              }

              _getGfxTextureCreateInfo(presumed) {
                const texInfo = new TextureInfo(TextureType.CUBE);
                texInfo.width = this._width;
                texInfo.height = this._height;
                texInfo.layerCount = 6;
                Object.assign(texInfo, presumed);
                return texInfo;
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                const imageAsset = new ImageAsset();
                imageAsset.initDefault();
                this.mipmaps = [{
                  front: imageAsset,
                  back: imageAsset,
                  top: imageAsset,
                  bottom: imageAsset,
                  left: imageAsset,
                  right: imageAsset
                }];
              }

              validate() {
                return this._mipmaps.length !== 0 && !this._mipmaps.find(x => !(x.top && x.bottom && x.front && x.back && x.left && x.right));
              }

            }, _class3$6.FaceIndex = FaceIndex, _temp$c), (_descriptor$a = _applyDecoratedDescriptor(_class2$c.prototype, "isRGBE", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$c.prototype, "_mipmaps", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$c)) || _class$f));
            legacyCC.TextureCube = TextureCube;

            function _forEachFace(mipmap, callback) {
              callback(mipmap.front, FaceIndex.front);
              callback(mipmap.back, FaceIndex.back);
              callback(mipmap.left, FaceIndex.left);
              callback(mipmap.right, FaceIndex.right);
              callback(mipmap.top, FaceIndex.top);
              callback(mipmap.bottom, FaceIndex.bottom);
            }

            const effects = exports('gi', [{
              "name": "billboard",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "billboard|vert:vs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "billboard|vert:vs_main|tinted-fs:add",
                "hash": 2909832090,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 53,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 2
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "nodeRotation",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "builtin",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "cc_size_rotation",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 2,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 3
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "clear-stencil",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "clear-stencil|sprite-vs:vert|sprite-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "clear-stencil|sprite-vs:vert|sprite-fs:frag",
                "hash": 3507038093,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 0,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "geometry-renderer",
              "techniques": [{
                "passes": [{
                  "primitive": 1,
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|line-vs:vert|line-fs:front",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }, {
                "passes": [{
                  "primitive": 1,
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|line-vs:vert|line-fs:front",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  }
                }, {
                  "primitive": 1,
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|line-vs:vert|line-fs:back",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false,
                    "depthFunc": 4
                  }
                }]
              }, {
                "passes": [{
                  "primitive": 1,
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }, {
                "passes": [{
                  "primitive": 1,
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  }
                }, {
                  "primitive": 1,
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:back",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false,
                    "depthFunc": 4
                  }
                }]
              }, {
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 2
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|triangle-vs:vert|triangle-fs:front",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }, {
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 2
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|triangle-vs:vert|triangle-fs:front",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  }
                }, {
                  "rasterizerState": {
                    "cullMode": 2
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "geometry-renderer|triangle-vs:vert|triangle-fs:back",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false,
                    "depthFunc": 4
                  }
                }]
              }],
              "shaders": [{
                "name": "geometry-renderer|line-vs:vert|line-fs:front",
                "hash": 3617431000,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "USE_FORWARD_PIPELINE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "geometry-renderer|line-vs:vert|line-fs:back",
                "hash": 4168905198,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "USE_FORWARD_PIPELINE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",
                "hash": 4034582016,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "USE_FORWARD_PIPELINE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "geometry-renderer|dashed-line-vs:vert|dashed-line-fs:back",
                "hash": 1762165009,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "USE_FORWARD_PIPELINE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "geometry-renderer|triangle-vs:vert|triangle-fs:front",
                "hash": 4143142643,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "USE_FORWARD_PIPELINE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 2
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "geometry-renderer|triangle-vs:vert|triangle-fs:back",
                "hash": 826026446,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "USE_FORWARD_PIPELINE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 2
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "graphics",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 1,
                      "blendDst": 4,
                      "blendSrcAlpha": 1,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "graphics|vs:vert|fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "graphics|vs:vert|fs:frag",
                "hash": 2610213142,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 48,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_dist",
                  "defines": [],
                  "format": 11,
                  "location": 2
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "occlusion-query",
              "techniques": [{
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 2
                  },
                  "blendState": {
                    "targets": [{
                      "blendColorMask": 0
                    }]
                  },
                  "program": "occlusion-query|occlusion-query-vs:vert|occlusion-query-fs:frag",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "occlusion-query|occlusion-query-vs:vert|occlusion-query-fs:frag",
                "hash": 1571978323,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 41,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCWorldBound",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "particle-gpu",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
                "hash": 1250077034,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 63,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "USE_VK_SHADER",
                  "type": "boolean"
                }, {
                  "name": "COLOR_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "SIZE_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "FORCE_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "VELOCITY_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "TEXTURE_ANIMATION_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position_starttime",
                  "defines": [],
                  "format": 44,
                  "location": 0
                }, {
                  "name": "a_size_uv",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_rotation_uv",
                  "defines": [],
                  "format": 44,
                  "location": 2
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_dir_life",
                  "defines": [],
                  "format": 44,
                  "location": 4
                }, {
                  "name": "a_rndSeed",
                  "defines": [],
                  "format": 11,
                  "location": 5
                }, {
                  "name": "a_texCoord",
                  "defines": ["CC_RENDER_MODE"],
                  "format": 32,
                  "location": 6
                }, {
                  "name": "a_texCoord3",
                  "defines": ["CC_RENDER_MODE"],
                  "format": 32,
                  "location": 7
                }, {
                  "name": "a_normal",
                  "defines": ["CC_RENDER_MODE"],
                  "format": 32,
                  "location": 8
                }, {
                  "name": "a_color1",
                  "defines": ["CC_RENDER_MODE"],
                  "format": 44,
                  "location": 9
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "nodeRotation",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "SampleConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_sampleInfo",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "TickConstants",
                  "defines": [],
                  "binding": 2,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_worldRot",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "u_timeDelta",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "ColorConstant",
                  "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
                  "binding": 3,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_color_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "RotationConstant",
                  "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
                  "binding": 4,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_rotation_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "SizeConstant",
                  "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
                  "binding": 5,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_size_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "ForceConstant",
                  "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
                  "binding": 6,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_force_mode",
                    "type": 5,
                    "count": 1
                  }, {
                    "name": "u_force_space",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "VelocityConstant",
                  "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
                  "binding": 7,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_velocity_mode",
                    "type": 5,
                    "count": 1
                  }, {
                    "name": "u_velocity_space",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "AnimationConstant",
                  "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
                  "binding": 8,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_anim_info",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 9,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "color_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 10
                }, {
                  "name": "rotation_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 11
                }, {
                  "name": "size_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 12
                }, {
                  "name": "force_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 13
                }, {
                  "name": "velocity_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 14
                }, {
                  "name": "texture_animation_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 15
                }, {
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 16
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "particle-trail",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "particle-trail|particle-trail:vs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "frameTile_velLenScale": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "particle-trail|particle-trail:vs_main|tinted-fs:add",
                "hash": 1437790364,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 52,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_DRAW_WIRE_FRAME",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_texCoord1",
                  "defines": [],
                  "format": 32,
                  "location": 2
                }, {
                  "name": "a_texCoord2",
                  "defines": [],
                  "format": 32,
                  "location": 3
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 4
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "nodeRotation",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "particle",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                "hash": 2766437914,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 52,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }, {
                  "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord1",
                  "defines": [],
                  "format": 32,
                  "location": 2
                }, {
                  "name": "a_texCoord2",
                  "defines": [],
                  "format": 32,
                  "location": 3
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 4
                }, {
                  "name": "a_color1",
                  "defines": ["CC_RENDER_MODE"],
                  "format": 32,
                  "location": 8
                }, {
                  "name": "a_texCoord3",
                  "defines": ["CC_RENDER_MODE"],
                  "format": 32,
                  "location": 6
                }, {
                  "name": "a_normal",
                  "defines": ["CC_RENDER_MODE"],
                  "format": 32,
                  "location": 7
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "nodeRotation",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "spine",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "spine|sprite-vs:vert|sprite-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  },
                  "properties": {
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "spine|sprite-vs:vert|sprite-fs:frag",
                "hash": 3192452405,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 48,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": ["USE_LOCAL"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_spriteTexture",
                      "defines": []
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "USE_LOCAL",
                  "type": "boolean"
                }, {
                  "name": "TWO_COLORED",
                  "type": "boolean"
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 2
                }, {
                  "name": "a_color2",
                  "defines": ["TWO_COLORED"],
                  "format": 44,
                  "location": 3
                }],
                "blocks": [{
                  "name": "ALPHA_TEST_DATA",
                  "defines": ["USE_ALPHA_TEST"],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "alphaThreshold",
                    "type": 13,
                    "count": 1
                  }]
                }],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "sprite-gpu",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "sprite-gpu|sprite-vs-gpu:vert|sprite-fs-gpu:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "sprite-gpu|sprite-vs-gpu:vert|sprite-fs-gpu:frag",
                "hash": 2450198964,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCUILocal",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_spriteTexture",
                      "defines": ["USE_TEXTURE"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "SAMPLE_FROM_RT",
                  "type": "boolean"
                }, {
                  "name": "USE_PIXEL_ALIGNMENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_EMBEDDED_ALPHA",
                  "type": "boolean"
                }, {
                  "name": "USE_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "IS_GRAY",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_batch_id",
                  "defines": [],
                  "format": 11,
                  "location": 2
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "sprite",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "sprite|sprite-vs:vert|sprite-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  },
                  "properties": {
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "sprite|sprite-vs:vert|sprite-fs:frag",
                "hash": 1770338543,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 48,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": ["USE_LOCAL"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_spriteTexture",
                      "defines": ["USE_TEXTURE"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "USE_LOCAL",
                  "type": "boolean"
                }, {
                  "name": "SAMPLE_FROM_RT",
                  "type": "boolean"
                }, {
                  "name": "USE_PIXEL_ALIGNMENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_EMBEDDED_ALPHA",
                  "type": "boolean"
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "USE_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "IS_GRAY",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 2
                }],
                "blocks": [{
                  "name": "ALPHA_TEST_DATA",
                  "defines": ["USE_ALPHA_TEST"],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "alphaThreshold",
                    "type": 13,
                    "count": 1
                  }]
                }],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "standard",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "standard|standard-vs|standard-fs",
                  "properties": {
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "linear": true,
                      "type": 16,
                      "handleInfo": ["albedo", 0, 16]
                    },
                    "albedoScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["albedoScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["albedoScaleAndCutoff", 3, 13]
                    },
                    "occlusion": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 0, 13]
                    },
                    "roughness": {
                      "value": [0.8],
                      "type": 13,
                      "handleInfo": ["pbrParams", 1, 13]
                    },
                    "metallic": {
                      "value": [0.6],
                      "type": 13,
                      "handleInfo": ["pbrParams", 2, 13]
                    },
                    "SpecularIntensity": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["pbrParams", 3, 13]
                    },
                    "emissive": {
                      "value": [0, 0, 0, 1],
                      "linear": true,
                      "type": 16
                    },
                    "emissiveScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["emissiveScaleParam", 0, 15]
                    },
                    "normalStrenth": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["emissiveScaleParam", 3, 13]
                    },
                    "mainTexture": {
                      "value": "grey",
                      "type": 28,
                      "handleInfo": ["albedoMap", 0, 28]
                    },
                    "normalMap": {
                      "value": "normal",
                      "type": 28
                    },
                    "pbrMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "metallicRoughnessMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "occlusionMap": {
                      "value": "white",
                      "type": 28
                    },
                    "emissiveMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "albedo": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    },
                    "pbrParams": {
                      "type": 16,
                      "value": [1, 0.8, 0.6, 0.5]
                    },
                    "emissiveScaleParam": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoMap": {
                      "type": 28,
                      "value": "grey"
                    }
                  }
                }, {
                  "phase": "forward-add",
                  "propertyIndex": 0,
                  "embeddedMacros": {
                    "CC_FORWARD_ADD": true
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 1,
                      "blendDst": 1,
                      "blendSrcAlpha": 0,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "standard|standard-vs|standard-fs",
                  "depthStencilState": {
                    "depthFunc": 2,
                    "depthTest": true,
                    "depthWrite": false
                  }
                }, {
                  "phase": "shadow-caster",
                  "propertyIndex": 0,
                  "rasterizerState": {
                    "cullMode": 1
                  },
                  "program": "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
                  "properties": {
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16,
                      "handleInfo": ["albedo", 0, 16]
                    },
                    "albedoScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["albedoScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["albedoScaleAndCutoff", 3, 13]
                    },
                    "mainTexture": {
                      "value": "grey",
                      "type": 28,
                      "handleInfo": ["albedoMap", 0, 28]
                    },
                    "albedo": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    },
                    "albedoMap": {
                      "type": 28,
                      "value": "grey"
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "standard|standard-vs|standard-fs",
                "hash": 89487378,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 222,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 65
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_shadowMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_spotLightingMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_environment",
                      "defines": ["CC_USE_IBL"]
                    }, {
                      "name": "cc_diffuseMap",
                      "defines": ["CC_USE_IBL", "CC_USE_DIFFUSEMAP"]
                    }],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }, {
                      "name": "CCForwardLight",
                      "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "cc_lightingMap",
                      "defines": ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_USE_ACCURATE_FOG",
                  "type": "boolean"
                }, {
                  "name": "CC_RECEIVE_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "USE_VERTEX_COLOR",
                  "type": "boolean"
                }, {
                  "name": "USE_NORMAL_MAP",
                  "type": "boolean"
                }, {
                  "name": "HAS_SECOND_UV",
                  "type": "boolean"
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "USE_TWOSIDE",
                  "type": "boolean"
                }, {
                  "name": "SAMPLE_FROM_RT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "CC_USE_DIFFUSEMAP",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "USE_REFLECTION_DENOISE",
                  "type": "boolean"
                }, {
                  "name": "CC_ENABLE_DIR_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_ALBEDO_MAP",
                  "type": "boolean"
                }, {
                  "name": "ALBEDO_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "NORMAL_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "PBR_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_PBR_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_METALLIC_ROUGHNESS_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_OCCLUSION_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_EMISSIVE_MAP",
                  "type": "boolean"
                }, {
                  "name": "EMISSIVE_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r"]
                }, {
                  "name": "CC_PIPELINE_TYPE",
                  "type": "number",
                  "range": [0, 1]
                }, {
                  "name": "CC_FORCE_FORWARD_SHADING",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_color",
                  "defines": ["USE_VERTEX_COLOR"],
                  "format": 44,
                  "location": 13
                }, {
                  "name": "a_texCoord1",
                  "defines": [],
                  "format": 21,
                  "location": 14
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 17,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedo",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedoScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "pbrParams",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissive",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissiveScaleParam",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "albedoMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_ALBEDO_MAP"],
                  "stageFlags": 16,
                  "binding": 1
                }, {
                  "name": "normalMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_NORMAL_MAP"],
                  "stageFlags": 16,
                  "binding": 2
                }, {
                  "name": "pbrMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_PBR_MAP"],
                  "stageFlags": 16,
                  "binding": 3
                }, {
                  "name": "metallicRoughnessMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_METALLIC_ROUGHNESS_MAP"],
                  "stageFlags": 16,
                  "binding": 4
                }, {
                  "name": "occlusionMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_OCCLUSION_MAP"],
                  "stageFlags": 16,
                  "binding": 5
                }, {
                  "name": "emissiveMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_EMISSIVE_MAP"],
                  "stageFlags": 16,
                  "binding": 6
                }],
                "buffers": [{
                  "name": "b_ccLightsBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 7
                }, {
                  "name": "b_clusterLightIndicesBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 8
                }, {
                  "name": "b_clusterLightGridBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 9
                }],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
                "hash": 3041904316,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 183,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 65
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCShadow",
                      "defines": []
                    }, {
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_shadowMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_spotLightingMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "HAS_SECOND_UV",
                  "type": "boolean"
                }, {
                  "name": "CC_RECEIVE_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "USE_ALBEDO_MAP",
                  "type": "boolean"
                }, {
                  "name": "ALBEDO_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r"]
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_texCoord1",
                  "defines": [],
                  "format": 21,
                  "location": 13
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 17,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedo",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedoScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "pbrParams",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissive",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissiveScaleParam",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "albedoMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_ALBEDO_MAP"],
                  "stageFlags": 16,
                  "binding": 1
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "terrain",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "terrain|terrain-vs|terrain-fs",
                  "properties": {
                    "UVScale": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "lightMapUVParam": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "metallic": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "roughness": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "weightMap": {
                      "value": "black",
                      "type": 28
                    },
                    "detailMap0": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap1": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap2": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap3": {
                      "value": "grey",
                      "type": 28
                    },
                    "normalMap0": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap1": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap2": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap3": {
                      "value": "normal",
                      "type": 28
                    },
                    "lightMap": {
                      "value": "grey",
                      "type": 28
                    }
                  }
                }, {
                  "phase": "forward-add",
                  "propertyIndex": 0,
                  "embeddedMacros": {
                    "CC_FORWARD_ADD": true
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 1,
                      "blendDst": 1,
                      "blendSrcAlpha": 0,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "terrain|terrain-vs|terrain-fs",
                  "depthStencilState": {
                    "depthFunc": 2,
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "UVScale": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "lightMapUVParam": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "metallic": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "roughness": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "weightMap": {
                      "value": "black",
                      "type": 28
                    },
                    "detailMap0": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap1": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap2": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap3": {
                      "value": "grey",
                      "type": 28
                    },
                    "normalMap0": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap1": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap2": {
                      "value": "normal",
                      "type": 28
                    },
                    "normalMap3": {
                      "value": "normal",
                      "type": 28
                    },
                    "lightMap": {
                      "value": "grey",
                      "type": 28
                    }
                  }
                }, {
                  "phase": "shadow-add",
                  "propertyIndex": 0,
                  "rasterizerState": {
                    "cullMode": 2
                  },
                  "program": "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag"
                }]
              }],
              "shaders": [{
                "name": "terrain|terrain-vs|terrain-fs",
                "hash": 2957432815,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 70,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 61
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_shadowMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_spotLightingMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_environment",
                      "defines": ["CC_USE_IBL"]
                    }, {
                      "name": "cc_diffuseMap",
                      "defines": ["CC_USE_IBL", "CC_USE_DIFFUSEMAP"]
                    }],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }, {
                      "name": "CCForwardLight",
                      "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_lightingMap",
                      "defines": ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_USE_ACCURATE_FOG",
                  "type": "boolean"
                }, {
                  "name": "CC_RECEIVE_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "USE_NORMALMAP",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "CC_USE_DIFFUSEMAP",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "USE_REFLECTION_DENOISE",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "CC_ENABLE_DIR_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "LAYERS",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "USE_PBR",
                  "type": "boolean"
                }, {
                  "name": "CC_PIPELINE_TYPE",
                  "type": "number",
                  "range": [0, 1]
                }, {
                  "name": "CC_FORCE_FORWARD_SHADING",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }],
                "blocks": [{
                  "name": "TexCoords",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "UVScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "lightMapUVParam",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "PbrParams",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "metallic",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "roughness",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "weightMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }, {
                  "name": "detailMap0",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 3
                }, {
                  "name": "detailMap1",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 4
                }, {
                  "name": "detailMap2",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 5
                }, {
                  "name": "detailMap3",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 6
                }, {
                  "name": "normalMap0",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 7
                }, {
                  "name": "normalMap1",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 8
                }, {
                  "name": "normalMap2",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 9
                }, {
                  "name": "normalMap3",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 10
                }, {
                  "name": "lightMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 11
                }],
                "buffers": [{
                  "name": "b_ccLightsBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 12
                }, {
                  "name": "b_clusterLightIndicesBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 13
                }, {
                  "name": "b_clusterLightGridBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_FORWARD_ADD", "CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 14
                }],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag",
                "hash": 4270039829,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 68,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 0
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "unlit",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "unlit|unlit-vs:vert|unlit-fs:frag",
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "linear": true,
                      "type": 16
                    },
                    "colorScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["colorScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["colorScaleAndCutoff", 3, 13]
                    },
                    "color": {
                      "linear": true,
                      "type": 16,
                      "handleInfo": ["mainColor", 0, 16]
                    },
                    "colorScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "unlit|unlit-vs:vert|unlit-fs:frag",
                "hash": 3062078908,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 197,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 41
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_USE_ACCURATE_FOG",
                  "type": "boolean"
                }, {
                  "name": "USE_VERTEX_COLOR",
                  "type": "boolean"
                }, {
                  "name": "USE_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "SAMPLE_FROM_RT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r", "g", "b"]
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_color",
                  "defines": ["USE_VERTEX_COLOR"],
                  "format": 44,
                  "location": 13
                }],
                "blocks": [{
                  "name": "TexCoords",
                  "defines": ["USE_TEXTURE"],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "Constant",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "mainColor",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "colorScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_TEXTURE"],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "bloom",
              "techniques": [{
                "passes": [{
                  "phase": "bloom-prefilter",
                  "program": "bloom|bloom-vs|prefilter-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-downsample",
                  "program": "bloom|bloom-vs|downsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-downsample",
                  "program": "bloom|bloom-vs|downsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-downsample",
                  "program": "bloom|bloom-vs|downsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-downsample",
                  "program": "bloom|bloom-vs|downsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-downsample",
                  "program": "bloom|bloom-vs|downsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-downsample",
                  "program": "bloom|bloom-vs|downsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-upsample",
                  "program": "bloom|bloom-vs|upsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-upsample",
                  "program": "bloom|bloom-vs|upsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-upsample",
                  "program": "bloom|bloom-vs|upsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-upsample",
                  "program": "bloom|bloom-vs|upsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-upsample",
                  "program": "bloom|bloom-vs|upsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-upsample",
                  "program": "bloom|bloom-vs|upsample-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }, {
                  "phase": "bloom-combine",
                  "program": "bloom|bloom-vs|combine-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "bloom|bloom-vs|prefilter-fs",
                "hash": 3493244111,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }],
                "blocks": [{
                  "name": "BloomUBO",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "texSize",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "outputResultMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 1
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "bloom|bloom-vs|downsample-fs",
                "hash": 3733277754,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }],
                "blocks": [{
                  "name": "BloomUBO",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "texSize",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "bloomTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 1
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "bloom|bloom-vs|upsample-fs",
                "hash": 4151134822,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }],
                "blocks": [{
                  "name": "BloomUBO",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "texSize",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "bloomTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 1
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }, {
                "name": "bloom|bloom-vs|combine-fs",
                "hash": 1122355486,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 40
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }],
                "blocks": [{
                  "name": "BloomUBO",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "texSize",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "outputResultMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 1
                }, {
                  "name": "bloomTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "deferred-lighting",
              "techniques": [{
                "passes": [{
                  "phase": "deferred-lighting",
                  "program": "deferred-lighting|lighting-vs|lighting-fs",
                  "depthStencilState": {
                    "depthFunc": 4,
                    "depthTest": true,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "deferred-lighting|lighting-vs|lighting-fs",
                "hash": 856786959,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 59
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_shadowMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_spotLightingMap",
                      "defines": ["CC_RECEIVE_SHADOW"]
                    }, {
                      "name": "cc_environment",
                      "defines": ["CC_USE_IBL"]
                    }, {
                      "name": "cc_diffuseMap",
                      "defines": ["CC_USE_IBL", "CC_USE_DIFFUSEMAP"]
                    }],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCForwardLight",
                      "defines": ["CC_ENABLE_CLUSTERED_LIGHT_CULLING"]
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_RECEIVE_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "CC_USE_DIFFUSEMAP",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "USE_REFLECTION_DENOISE",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "CC_ENABLE_DIR_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "CC_PIPELINE_TYPE",
                  "type": "number",
                  "range": [0, 1]
                }, {
                  "name": "CC_FORCE_FORWARD_SHADING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [{
                  "name": "b_ccLightsBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 4
                }, {
                  "name": "b_clusterLightIndicesBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 5
                }, {
                  "name": "b_clusterLightGridBuffer",
                  "memoryAccess": 1,
                  "defines": ["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],
                  "stageFlags": 16,
                  "binding": 6
                }],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": [{
                  "name": "gbuffer_albedoMap",
                  "count": 1,
                  "defines": ["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],
                  "stageFlags": 16,
                  "binding": 0
                }, {
                  "name": "gbuffer_positionMap",
                  "count": 1,
                  "defines": ["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],
                  "stageFlags": 16,
                  "binding": 1
                }, {
                  "name": "gbuffer_normalMap",
                  "count": 1,
                  "defines": ["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],
                  "stageFlags": 16,
                  "binding": 2
                }, {
                  "name": "gbuffer_emissiveMap",
                  "count": 1,
                  "defines": ["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],
                  "stageFlags": 16,
                  "binding": 3
                }]
              }]
            }, {
              "name": "planar-shadow",
              "techniques": [{
                "passes": [{
                  "phase": "planarShadow",
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false,
                    "stencilTestFront": true,
                    "stencilFuncFront": 5,
                    "stencilPassOpFront": 2,
                    "stencilRefBack": 128,
                    "stencilRefFront": 128,
                    "stencilReadMaskBack": 128,
                    "stencilReadMaskFront": 128,
                    "stencilWriteMaskBack": 128,
                    "stencilWriteMaskFront": 128
                  }
                }]
              }],
              "shaders": [{
                "name": "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                "hash": 868654446,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 216,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 59
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "defines": ["USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "format": 11,
                  "location": 12
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "post-process",
              "techniques": [{
                "passes": [{
                  "phase": "post-process",
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "post-process|post-process-vs|post-process-fs",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "post-process|post-process-vs|post-process-fs",
                "hash": 3535122263,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 147,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }],
                    "samplerTextures": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "ANTIALIAS_TYPE",
                  "type": "number",
                  "range": [0, 3]
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "defines": ["CC_USE_MORPH"],
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "defines": ["CC_USE_SKINNING"],
                  "location": 4
                }, {
                  "name": "a_weights",
                  "defines": ["CC_USE_SKINNING"],
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }],
                "blocks": [],
                "samplerTextures": [{
                  "name": "outputResultMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 0
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "skybox",
              "techniques": [{
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "skybox|sky-vs:vert|sky-fs:frag",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "skybox|sky-vs:vert|sky-fs:frag",
                "hash": 3653711100,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 39,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [{
                      "name": "cc_environment",
                      "defines": []
                    }],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_RGBE_CUBEMAP",
                  "type": "boolean"
                }],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "defines": [],
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "defines": [],
                  "format": 44,
                  "location": 3
                }],
                "blocks": [],
                "samplerTextures": [],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "profiler",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "profiler|profiler-vs:vert|profiler-fs:frag",
                  "priority": 255,
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "profiler|profiler-vs:vert|profiler-fs:frag",
                "hash": 179162168,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 60,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 39
                  },
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCCamera",
                      "defines": []
                    }],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "defines": [],
                  "format": 44,
                  "location": 1
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "offset",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "PerFrameInfo",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "digits",
                    "type": 16,
                    "count": 20
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }, {
              "name": "splash-screen",
              "techniques": [{
                "name": "default",
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "resolution": {
                      "value": [640, 960],
                      "type": 14,
                      "handleInfo": ["u_buffer0", 0, 14]
                    },
                    "percent": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["u_percent", 0, 13]
                    },
                    "scale": {
                      "value": [200, 500],
                      "type": 14,
                      "handleInfo": ["u_buffer1", 0, 14]
                    },
                    "translate": {
                      "value": [320, 480],
                      "type": 14,
                      "handleInfo": ["u_buffer1", 2, 14]
                    },
                    "u_buffer0": {
                      "type": 16,
                      "value": [640, 960, 0, 0]
                    },
                    "u_percent": {
                      "type": 13,
                      "value": [0.5]
                    },
                    "u_buffer1": {
                      "type": 16,
                      "value": [200, 500, 320, 480]
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
                "hash": 3189094080,
                "builtins": {
                  "statistics": {
                    "CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS": 6,
                    "CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS": 1
                  },
                  "globals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplerTextures": [],
                    "buffers": [],
                    "images": []
                  }
                },
                "defines": [],
                "attributes": [{
                  "name": "a_position",
                  "defines": [],
                  "format": 21,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "defines": [],
                  "format": 21,
                  "location": 1
                }],
                "blocks": [{
                  "name": "Constant",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_buffer0",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "u_buffer1",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "u_projection",
                    "type": 25,
                    "count": 1
                  }]
                }, {
                  "name": "Factor",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "u_percent",
                    "type": 13,
                    "count": 1
                  }]
                }],
                "samplerTextures": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "buffers": [],
                "images": [],
                "textures": [],
                "samplers": [],
                "subpassInputs": []
              }]
            }]);

            const typeMask = 0xfc000000;
            const bindingMask = 0x03f00000;
            const countMask = 0x000ff000;
            const offsetMask = 0x00000fff;
            const genHandle = (binding, type, count, offset = 0) => type << 26 & typeMask | binding << 20 & bindingMask | count << 12 & countMask | offset & offsetMask;
            const getTypeFromHandle = handle => (handle & typeMask) >>> 26;
            const getBindingFromHandle = handle => (handle & bindingMask) >>> 20;
            const getCountFromHandle = handle => (handle & countMask) >>> 12;
            const getOffsetFromHandle = handle => handle & offsetMask;
            const customizeType = (handle, type) => handle & ~typeMask | type << 26 & typeMask;
            const type2reader = {
              [Type.UNKNOWN]: (a, v, idx = 0) => console.warn('illegal uniform handle'),
              [Type.INT]: (a, v, idx = 0) => a[idx],
              [Type.INT2]: (a, v, idx = 0) => Vec2.fromArray(v, a, idx),
              [Type.INT3]: (a, v, idx = 0) => Vec3.fromArray(v, a, idx),
              [Type.INT4]: (a, v, idx = 0) => Vec4.fromArray(v, a, idx),
              [Type.FLOAT]: (a, v, idx = 0) => a[idx],
              [Type.FLOAT2]: (a, v, idx = 0) => Vec2.fromArray(v, a, idx),
              [Type.FLOAT3]: (a, v, idx = 0) => Vec3.fromArray(v, a, idx),
              [Type.FLOAT4]: (a, v, idx = 0) => Vec4.fromArray(v, a, idx),
              [Type.MAT3]: (a, v, idx = 0) => Mat3.fromArray(v, a, idx),
              [Type.MAT4]: (a, v, idx = 0) => Mat4.fromArray(v, a, idx)
            };
            const type2writer = {
              [Type.UNKNOWN]: (a, v, idx = 0) => console.warn('illegal uniform handle'),
              [Type.INT]: (a, v, idx = 0) => a[idx] = v,
              [Type.INT2]: (a, v, idx = 0) => Vec2.toArray(a, v, idx),
              [Type.INT3]: (a, v, idx = 0) => Vec3.toArray(a, v, idx),
              [Type.INT4]: (a, v, idx = 0) => Vec4.toArray(a, v, idx),
              [Type.FLOAT]: (a, v, idx = 0) => a[idx] = v,
              [Type.FLOAT2]: (a, v, idx = 0) => Vec2.toArray(a, v, idx),
              [Type.FLOAT3]: (a, v, idx = 0) => Vec3.toArray(a, v, idx),
              [Type.FLOAT4]: (a, v, idx = 0) => Vec4.toArray(a, v, idx),
              [Type.MAT3]: (a, v, idx = 0) => Mat3.toArray(a, v, idx),
              [Type.MAT4]: (a, v, idx = 0) => Mat4.toArray(a, v, idx)
            };
            const defaultValues = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];
            function getDefaultFromType(type) {
              switch (type) {
                case Type.BOOL:
                case Type.INT:
                case Type.UINT:
                case Type.FLOAT:
                  return defaultValues[0];

                case Type.BOOL2:
                case Type.INT2:
                case Type.UINT2:
                case Type.FLOAT2:
                  return defaultValues[1];

                case Type.BOOL4:
                case Type.INT4:
                case Type.UINT4:
                case Type.FLOAT4:
                  return defaultValues[2];

                case Type.MAT4:
                  return defaultValues[3];

                case Type.SAMPLER2D:
                  return 'default-texture';

                case Type.SAMPLER_CUBE:
                  return 'default-cube-texture';
              }

              return defaultValues[0];
            }
            function overrideMacros(target, source) {
              const entries = Object.entries(source);
              let isDifferent = false;

              for (let i = 0; i < entries.length; i++) {
                if (target[entries[i][0]] !== entries[i][1]) {
                  target[entries[i][0]] = entries[i][1];
                  isDifferent = true;
                }
              }

              return isDifferent;
            }

            const _dsLayoutInfo = new DescriptorSetLayoutInfo();

            function getBitCount(cnt) {
              return Math.ceil(Math.log2(Math.max(cnt, 2)));
            }

            function mapDefine(info, def) {
              switch (info.type) {
                case 'boolean':
                  return typeof def === 'number' ? def.toString() : def ? '1' : '0';

                case 'string':
                  return def !== undefined ? def : info.options[0];

                case 'number':
                  return def !== undefined ? def.toString() : info.range[0].toString();

                default:
                  console.warn(`unknown define type '${info.type}'`);
                  return '-1';
              }
            }

            function prepareDefines(defs, tDefs) {
              const macros = [];

              for (let i = 0; i < tDefs.length; i++) {
                const tmpl = tDefs[i];
                const name = tmpl.name;
                const v = defs[name];
                const value = mapDefine(tmpl, v);
                const isDefault = !v || v === '0';
                macros.push({
                  name,
                  value,
                  isDefault
                });
              }

              return macros;
            }

            function getShaderInstanceName(name, macros) {
              return name + macros.reduce((acc, cur) => cur.isDefault ? acc : `${acc}|${cur.name}${cur.value}`, '');
            }

            function insertBuiltinBindings(tmpl, tmplInfo, source, type, outBindings) {
              const target = tmpl.builtins[type];
              const tempBlocks = [];

              for (let i = 0; i < target.blocks.length; i++) {
                const b = target.blocks[i];
                const info = source.layouts[b.name];
                const binding = info && source.bindings.find(bd => bd.binding === info.binding);

                if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_BUFFER_TYPE)) {
                  console.warn(`builtin UBO '${b.name}' not available!`);
                  continue;
                }

                tempBlocks.push(info);
                if (outBindings && !outBindings.includes(binding)) outBindings.push(binding);
              }

              Array.prototype.unshift.apply(tmplInfo.shaderInfo.blocks, tempBlocks);
              const tempSamplerTextures = [];

              for (let i = 0; i < target.samplerTextures.length; i++) {
                const s = target.samplerTextures[i];
                const info = source.layouts[s.name];
                const binding = info && source.bindings.find(bd => bd.binding === info.binding);

                if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_SAMPLER_TYPE)) {
                  console.warn(`builtin samplerTexture '${s.name}' not available!`);
                  continue;
                }

                tempSamplerTextures.push(info);
                if (outBindings && !outBindings.includes(binding)) outBindings.push(binding);
              }

              Array.prototype.unshift.apply(tmplInfo.shaderInfo.samplerTextures, tempSamplerTextures);
              if (outBindings) outBindings.sort((a, b) => a.binding - b.binding);
            }

            function getSize(block) {
              return block.members.reduce((s, m) => s + GetTypeSize(m.type) * m.count, 0);
            }

            function genHandles(tmpl) {
              const handleMap = {};

              for (let i = 0; i < tmpl.blocks.length; i++) {
                const block = tmpl.blocks[i];
                const members = block.members;
                let offset = 0;

                for (let j = 0; j < members.length; j++) {
                  const uniform = members[j];
                  handleMap[uniform.name] = genHandle(block.binding, uniform.type, uniform.count, offset);
                  offset += (GetTypeSize(uniform.type) >> 2) * uniform.count;
                }
              }

              for (let i = 0; i < tmpl.samplerTextures.length; i++) {
                const samplerTexture = tmpl.samplerTextures[i];
                handleMap[samplerTexture.name] = genHandle(samplerTexture.binding, samplerTexture.type, samplerTexture.count);
              }

              return handleMap;
            }

            function dependencyCheck(dependencies, defines) {
              for (let i = 0; i < dependencies.length; i++) {
                const d = dependencies[i];

                if (d[0] === '!') {
                  if (defines[d.slice(1)]) {
                    return false;
                  }
                } else if (!defines[d]) {
                  return false;
                }
              }

              return true;
            }

            function getActiveAttributes(tmpl, tmplInfo, defines) {
              const out = [];
              const attributes = tmpl.attributes;
              const gfxAttributes = tmplInfo.gfxAttributes;

              for (let i = 0; i < attributes.length; i++) {
                if (!dependencyCheck(attributes[i].defines, defines)) {
                  continue;
                }

                out.push(gfxAttributes[i]);
              }

              return out;
            }

            class ProgramLib {
              constructor() {
                this._templates = {};
                this._cache = {};
                this._templateInfos = {};
              }

              register(effect) {
                for (let i = 0; i < effect.shaders.length; i++) {
                  const tmpl = this.define(effect.shaders[i]);
                  tmpl.effectName = effect.name;
                }

                for (let i = 0; i < effect.techniques.length; i++) {
                  const tech = effect.techniques[i];

                  for (let j = 0; j < tech.passes.length; j++) {
                    const pass = tech.passes[j];

                    if (pass.propertyIndex !== undefined && pass.properties === undefined) {
                      pass.properties = tech.passes[pass.propertyIndex].properties;
                    }
                  }
                }
              }

              define(shader) {
                const curTmpl = this._templates[shader.name];

                if (curTmpl && curTmpl.hash === shader.hash) {
                  return curTmpl;
                }

                const tmpl = { ...shader
                };
                let offset = 0;

                for (let i = 0; i < tmpl.defines.length; i++) {
                  const def = tmpl.defines[i];
                  let cnt = 1;

                  if (def.type === 'number') {
                    const range = def.range;
                    cnt = getBitCount(range[1] - range[0] + 1);

                    def._map = value => value - range[0];
                  } else if (def.type === 'string') {
                    cnt = getBitCount(def.options.length);

                    def._map = value => Math.max(0, def.options.findIndex(s => s === value));
                  } else if (def.type === 'boolean') {
                    def._map = value => value ? 1 : 0;
                  }

                  def._offset = offset;
                  offset += cnt;
                }

                if (offset > 31) {
                  tmpl.uber = true;
                }

                tmpl.constantMacros = '';

                for (const key in tmpl.builtins.statistics) {
                  tmpl.constantMacros += `#define ${key} ${tmpl.builtins.statistics[key]}\n`;
                }

                this._templates[shader.name] = tmpl;

                if (!this._templateInfos[tmpl.hash]) {
                  const tmplInfo = {};
                  tmplInfo.samplerStartBinding = tmpl.blocks.length;
                  tmplInfo.shaderInfo = new ShaderInfo();
                  tmplInfo.blockSizes = [];
                  tmplInfo.bindings = [];

                  for (let i = 0; i < tmpl.blocks.length; i++) {
                    const block = tmpl.blocks[i];
                    tmplInfo.blockSizes.push(getSize(block));
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(block.binding, DescriptorType.UNIFORM_BUFFER, 1, block.stageFlags));
                    tmplInfo.shaderInfo.blocks.push(new UniformBlock(SetIndex.MATERIAL, block.binding, block.name, block.members.map(m => new Uniform(m.name, m.type, m.count)), 1));
                  }

                  for (let i = 0; i < tmpl.samplerTextures.length; i++) {
                    const samplerTexture = tmpl.samplerTextures[i];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(samplerTexture.binding, DescriptorType.SAMPLER_TEXTURE, samplerTexture.count, samplerTexture.stageFlags));
                    tmplInfo.shaderInfo.samplerTextures.push(new UniformSamplerTexture(SetIndex.MATERIAL, samplerTexture.binding, samplerTexture.name, samplerTexture.type, samplerTexture.count));
                  }

                  for (let i = 0; i < tmpl.samplers.length; i++) {
                    const sampler = tmpl.samplers[i];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(sampler.binding, DescriptorType.SAMPLER, sampler.count, sampler.stageFlags));
                    tmplInfo.shaderInfo.samplers.push(new UniformSampler(SetIndex.MATERIAL, sampler.binding, sampler.name, sampler.count));
                  }

                  for (let i = 0; i < tmpl.textures.length; i++) {
                    const texture = tmpl.textures[i];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(texture.binding, DescriptorType.TEXTURE, texture.count, texture.stageFlags));
                    tmplInfo.shaderInfo.textures.push(new UniformTexture(SetIndex.MATERIAL, texture.binding, texture.name, texture.type, texture.count));
                  }

                  for (let i = 0; i < tmpl.buffers.length; i++) {
                    const buffer = tmpl.buffers[i];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(buffer.binding, DescriptorType.STORAGE_BUFFER, 1, buffer.stageFlags));
                    tmplInfo.shaderInfo.buffers.push(new UniformStorageBuffer(SetIndex.MATERIAL, buffer.binding, buffer.name, 1, buffer.memoryAccess));
                  }

                  for (let i = 0; i < tmpl.images.length; i++) {
                    const image = tmpl.images[i];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(image.binding, DescriptorType.STORAGE_IMAGE, image.count, image.stageFlags));
                    tmplInfo.shaderInfo.images.push(new UniformStorageImage(SetIndex.MATERIAL, image.binding, image.name, image.type, image.count, image.memoryAccess));
                  }

                  for (let i = 0; i < tmpl.subpassInputs.length; i++) {
                    const subpassInput = tmpl.subpassInputs[i];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(subpassInput.binding, DescriptorType.INPUT_ATTACHMENT, subpassInput.count, subpassInput.stageFlags));
                    tmplInfo.shaderInfo.subpassInputs.push(new UniformInputAttachment(SetIndex.MATERIAL, subpassInput.binding, subpassInput.name, subpassInput.count));
                  }

                  tmplInfo.gfxAttributes = [];

                  for (let i = 0; i < tmpl.attributes.length; i++) {
                    const attr = tmpl.attributes[i];
                    tmplInfo.gfxAttributes.push(new Attribute(attr.name, attr.format, attr.isNormalized, 0, attr.isInstanced, attr.location));
                  }

                  insertBuiltinBindings(tmpl, tmplInfo, localDescriptorSetLayout, 'locals');
                  tmplInfo.shaderInfo.stages.push(new ShaderStage(ShaderStageFlagBit.VERTEX, ''));
                  tmplInfo.shaderInfo.stages.push(new ShaderStage(ShaderStageFlagBit.FRAGMENT, ''));
                  tmplInfo.handleMap = genHandles(tmpl);
                  tmplInfo.setLayouts = [];
                  this._templateInfos[tmpl.hash] = tmplInfo;
                }

                return tmpl;
              }

              getTemplate(name) {
                return this._templates[name];
              }

              getTemplateInfo(name) {
                const hash = this._templates[name].hash;
                return this._templateInfos[hash];
              }

              getDescriptorSetLayout(device, name, isLocal = false) {
                const tmpl = this._templates[name];
                const tmplInfo = this._templateInfos[tmpl.hash];

                if (!tmplInfo.setLayouts.length) {
                  _dsLayoutInfo.bindings = tmplInfo.bindings;
                  tmplInfo.setLayouts[SetIndex.MATERIAL] = device.createDescriptorSetLayout(_dsLayoutInfo);
                  _dsLayoutInfo.bindings = localDescriptorSetLayout.bindings;
                  tmplInfo.setLayouts[SetIndex.LOCAL] = device.createDescriptorSetLayout(_dsLayoutInfo);
                }

                return tmplInfo.setLayouts[isLocal ? SetIndex.LOCAL : SetIndex.MATERIAL];
              }

              hasProgram(name) {
                return this._templates[name] !== undefined;
              }

              getKey(name, defines) {
                const tmpl = this._templates[name];
                const tmplDefs = tmpl.defines;

                if (tmpl.uber) {
                  let key = '';

                  for (let i = 0; i < tmplDefs.length; i++) {
                    const tmplDef = tmplDefs[i];
                    const value = defines[tmplDef.name];

                    if (!value || !tmplDef._map) {
                      continue;
                    }

                    const mapped = tmplDef._map(value);

                    const offset = tmplDef._offset;
                    key += `${offset}${mapped}|`;
                  }

                  return `${key}${tmpl.hash}`;
                }

                let key = 0;

                for (let i = 0; i < tmplDefs.length; i++) {
                  const tmplDef = tmplDefs[i];
                  const value = defines[tmplDef.name];

                  if (!value || !tmplDef._map) {
                    continue;
                  }

                  const mapped = tmplDef._map(value);

                  const offset = tmplDef._offset;
                  key |= mapped << offset;
                }

                return `${key.toString(16)}|${tmpl.hash}`;
              }

              destroyShaderByDefines(defines) {
                const names = Object.keys(defines);

                if (!names.length) {
                  return;
                }

                const regexes = names.map(cur => {
                  let val = defines[cur];

                  if (typeof val === 'boolean') {
                    val = val ? '1' : '0';
                  }

                  return new RegExp(`${cur}${val}`);
                });
                const keys = Object.keys(this._cache).filter(k => regexes.every(re => re.test(this._cache[k].name)));

                for (let i = 0; i < keys.length; i++) {
                  const k = keys[i];
                  const prog = this._cache[k];
                  debug(`destroyed shader ${prog.name}`);
                  prog.destroy();
                  delete this._cache[k];
                }
              }

              getGFXShader(device, name, defines, pipeline, key) {
                Object.assign(defines, pipeline.macros);
                if (!key) key = this.getKey(name, defines);
                const res = this._cache[key];

                if (res) {
                  return res;
                }

                const tmpl = this._templates[name];
                const tmplInfo = this._templateInfos[tmpl.hash];

                if (!tmplInfo.pipelineLayout) {
                  this.getDescriptorSetLayout(device, name);
                  insertBuiltinBindings(tmpl, tmplInfo, globalDescriptorSetLayout, 'globals');
                  tmplInfo.setLayouts[SetIndex.GLOBAL] = pipeline.descriptorSetLayout;
                  tmplInfo.pipelineLayout = device.createPipelineLayout(new PipelineLayoutInfo(tmplInfo.setLayouts));
                }

                const macroArray = prepareDefines(defines, tmpl.defines);
                const prefix = pipeline.constantMacros + tmpl.constantMacros + macroArray.reduce((acc, cur) => `${acc}#define ${cur.name} ${cur.value}\n`, '');
                let src = tmpl.glsl3;
                const deviceShaderVersion = getDeviceShaderVersion(device);

                if (deviceShaderVersion) {
                  src = tmpl[deviceShaderVersion];
                } else {
                  console.error('Invalid GFX API!');
                }

                tmplInfo.shaderInfo.stages[0].source = prefix + src.vert;
                tmplInfo.shaderInfo.stages[1].source = prefix + src.frag;
                tmplInfo.shaderInfo.attributes = getActiveAttributes(tmpl, tmplInfo, defines);
                tmplInfo.shaderInfo.name = getShaderInstanceName(name, macroArray);
                return this._cache[key] = device.createShader(tmplInfo.shaderInfo);
              }

            }

            function getDeviceShaderVersion(device) {
              switch (device.gfxAPI) {
                case API.GLES2:
                case API.WEBGL:
                  return 'glsl1';

                case API.GLES3:
                case API.WEBGL2:
                  return 'glsl3';

                default:
                  return 'glsl4';
              }
            }
            const programLib = new ProgramLib();
            legacyCC.programLib = programLib;

            const glsl1 = [[{
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"
            }, {
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 front() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 back() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"
            }, {
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_normal;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_normal;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute float a_dist;\nvarying float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying float v_dist;\nvec4 frag () {\nvec4 o = v_color;\n#ifdef GL_OES_standard_derivatives\nfloat aa = fwidth(v_dist);\n#else\nfloat aa = 0.05;\n#endif\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_worldBoundCenter;\nuniform highp vec4 cc_worldBoundHalfExtents;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition *= cc_worldBoundHalfExtents;\nposition += cc_worldBoundCenter;\nposition = cc_matViewProj * position;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 frag () {\nreturn vec4(1, 0, 0, 1);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 eulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom(float x) {\n#if USE_VK_SHADER\nfloat o = x;\nx = mod(x - 1.0, 2.0) - 1.0;\nfloat freqVar = 10.16640753482;\nfloat y = sin(freqVar * floor(o * 0.5 - 0.5));\nfloat v = max(0.0, 1.0-abs(x));\nv *= 0.7071067812;\nv = y < 0.0 ? -v : v;\nreturn v;\n#else\nfloat seed = mod(x, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n#endif\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nuniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nuniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nuniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nuniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nuniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nuniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = startRotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., startRotation.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(startRotation);\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture2D(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            }], [{
              "vert": "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\nattribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n#else\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(a_texCoord2);\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 v_light;\nvarying vec2 uv0;\n#if TWO_COLORED\nattribute vec4 a_color2;\nvarying vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 v_light;\n#if TWO_COLORED\nvarying vec4 v_dark;\n#endif\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture2D(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture2D(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nstruct SpriteVertexData {\nvec4 position;\nvec4 color;\n};\nstruct SpriteFragmentData {\nvec2 uv;\n};\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute float a_batch_id;\nvarying vec2 v_uv0;\nvarying float v_uvMode;\nvarying vec4 v_uvSizeOffset;\nvarying vec4 v_uvParams0;\nvarying vec4 v_uvParams1;\nstruct SpriteVertexInternalData {\nvec4 rotation;\nvec3 translation;\nvec3 scale;\nvec4 uvSizeOffset;\nfloat uvMode;\nvec4 uvParams;\nfloat filltype;\n};\nuniform vec4 cc_local_data[(CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS - CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS) / 5 * 5];\nvec3 VectorTransformQuat (vec3 v, vec4 q) {\nreturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvoid CCSpriteInput(out SpriteVertexData i0) {\nvec4 data0 = cc_local_data[int(a_batch_id) * 5];\nvec4 data1 = cc_local_data[int(a_batch_id) * 5 + 1];\nvec4 data2 = cc_local_data[int(a_batch_id) * 5 + 2];\nvec4 data3 = cc_local_data[int(a_batch_id) * 5 + 3];\nvec4 data4 = cc_local_data[int(a_batch_id) * 5 + 4];\nfloat rg = data0.w;\nfloat r = floor(rg);\nfloat ba = data2.z;\nfloat b = floor(ba);\nSpriteVertexInternalData i1;\ni1.rotation = data1;\ni1.translation = data0.xyz;\ni1.scale = vec3(data2.xy, 1.0);\ni1.uvSizeOffset = data3;\ni1.filltype = fract(data2.w) * 10.0;\ni1.uvMode = data2.w;\ni1.uvParams = data4;\ni0.position = vec4(VectorTransformQuat(a_position * i1.scale, i1.rotation) + i1.translation, 1.0);\ni0.color = vec4(r * (1.0 / 255.0), rg - r, b * (1.0 / 255.0), ba - b);\nvec2 uvWithRotation;\nif (i1.uvSizeOffset.x < 0.0) {\ni1.uvSizeOffset.x = abs(i1.uvSizeOffset.x);\nuvWithRotation = vec2(1.0 - a_texCoord.y, a_texCoord.x);\n} else {\nuvWithRotation = a_texCoord;\n}\nif (i1.uvMode >= 3.0) {\nv_uv0 = uvWithRotation;\nv_uvSizeOffset = i1.uvSizeOffset;\nv_uvParams0 = vec4(i1.uvParams.xy, i1.filltype, 0);\nif (i1.filltype >= 2.0) {\nv_uvParams1 = i1.uvParams;\n} else if (i1.filltype >= 1.0) {\nv_uvParams0 = vec4(1.0 - v_uvParams0.y, 1.0 - v_uvParams0.x, v_uvParams0.zw);\n}\n} else if (i1.uvMode >= 2.0) {\nv_uv0 = uvWithRotation * i1.uvParams.xy;\nv_uv0.y -= fract(i1.uvParams.y);\nv_uvSizeOffset = i1.uvSizeOffset;\n} else if (i1.uvMode >= 1.0) {\nv_uv0 = uvWithRotation;\nv_uvSizeOffset = i1.uvSizeOffset;\nvec4 params0 = fract(i1.uvParams);\nvec4 params1 = floor(i1.uvParams) / 2048.0;\nv_uvParams0 = vec4(params0.xy, params1.xy);\nv_uvParams1 = vec4(params0.zw, params1.zw);\n} else {\nv_uv0 = uvWithRotation * i1.uvSizeOffset.xy + i1.uvSizeOffset.zw;\n}\nv_uvMode = i1.uvMode;\n#if SAMPLE_FROM_RT\nv_uv0 = cc_cameraPos.w > 1.0 ? vec2(v_uv0.x, 1.0 - v_uv0.y) : v_uv0;\n#endif\n}\nvarying vec4 v_color;\nvec4 vert () {\nSpriteVertexData i;\nCCSpriteInput(i);\nv_color = i.color;\nvec4 pos = i.position;\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nstruct SpriteVertexData {\nvec4 position;\nvec4 color;\n};\nstruct SpriteFragmentData {\nvec2 uv;\n};\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture2D(tex, uv);\n#endif\n}\nvarying vec2 v_uv0;\nvarying float v_uvMode;\nvarying vec4 v_uvSizeOffset;\nvarying vec4 v_uvParams0;\nvarying vec4 v_uvParams1;\nvec2 evalSlicedUV(vec2 uv) {\nvec4 p0 = mix(vec4(0.0), v_uvParams0, step(v_uvParams0.xyxy, uv.xyxy));\np0 = mix(       p0, v_uvParams1, step(v_uvParams1.xyxy, uv.xyxy));\nvec4 p1 = mix(vec4(1.0), v_uvParams1, step(uv.xyxy, v_uvParams1.xyxy));\np1 = mix(       p1, v_uvParams0, step(uv.xyxy, v_uvParams0.xyxy));\nvec2 k = (p1.zw - p0.zw) / (p1.xy - p0.xy);\nvec2 b = (p1.xy * p0.zw - p0.xy * p1.zw) / (p1.xy - p0.xy);\nreturn k * uv + b;\n}\nfloat evalFilledUV(vec2 uv, float mode) {\nfloat alpha = 1.0;\nif (mode >= 2.0) {\nfloat start = v_uvParams1.x;\nfloat range = v_uvParams1.y;\nvec2 dir = uv - v_uvParams1.zw;\nfloat angle = -atan(dir.y, dir.x) * 0.3183098861838;\nif (range < 0.0) {\nangle += mix(0.0, -2.0, step(start, angle));\nalpha = step(start + range, angle);\n} else {\nangle += mix(0.0, 2.0, step(angle, start));\nalpha = step(angle, start + range);\n}\n} else if (mode >= 1.0) {\nif (uv.y >= v_uvParams0.x && uv.y <= v_uvParams0.y) {\nalpha = 1.0;\n} else {\nalpha = 0.0;\n}\n} else {\nif (uv.x >= v_uvParams0.x && uv.x <= v_uvParams0.y) {\nalpha = 1.0;\n} else {\nalpha = 0.0;\n}\n}\nreturn alpha;\n}\nvoid CCSpriteInput(out SpriteFragmentData i) {\n#if USE_TEXTURE\nif(v_uvMode >= 3.0) {\ni.uv = v_uv0 * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else if (v_uvMode >= 2.0) {\ni.uv = fract(v_uv0) * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else if (v_uvMode >= 1.0) {\ni.uv = evalSlicedUV(v_uv0) * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else {\ni.uv = v_uv0;\n}\n#endif\n}\nvec4 CCSpriteSample(sampler2D tex, vec2 uv) {\nvec4 o = CCSampleWithAlphaSeparated(tex, uv);\nif (v_uvMode >= 3.0) {\no.a *= evalFilledUV(v_uv0, v_uvParams0.z);\n}\nreturn o;\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nSpriteFragmentData i;\nCCSpriteInput(i);\n#if USE_TEXTURE\nvec4 color = v_color * CCSpriteSample(cc_spriteTexture, i.uv);\n#else\nvec4 color = v_color;\n#endif\n#if IS_GRAY\ncolor.rgb = SRGBToLinear(color.rgb);\ncolor.rgb = vec3(dot(color.rgb, vec3(0.2126, 0.7152, 0.0722)));\ncolor.rgb = sqrt(color.rgb);\n#endif\nreturn color;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nuniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nattribute vec4 a_color;\nvarying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_TWOSIDE\nvec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\nv_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n#endif\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(pos);\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
              "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nuniform highp mat4 cc_matView;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\nvarying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture2D(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n(nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture2D(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.a;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture2D(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = pbr.x;\ns.roughness = pbr.y;\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nCC_APPLY_FOG(color, s.position.xyz);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\ngl_FragData[1] = vec4(position, s.roughness);\ngl_FragData[2] = vec4(s.normal, s.metallic);\ngl_FragData[3] = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nuniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nuniform highp mat4 cc_matLightView;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture2D(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nreturn vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if USE_NORMALMAP\nvarying mediump vec3 v_tangent;\nvarying mediump vec3 v_binormal;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 luv;\nvarying mediump vec3 diffuse;\nuniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\nCC_TRANSFER_FOG(vec4(worldPos, 1.0));\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
              "frag": "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nuniform highp mat4 cc_matView;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if USE_NORMALMAP\nvarying mediump vec3 v_tangent;\nvarying mediump vec3 v_binormal;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 diffuse;\nvarying mediump vec3 luv;\nuniform vec4 metallic;\nuniform vec4 roughness;\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture2D(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture2D(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\nbaseColor += texture2D(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture2D(detailMap0, uv0);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture2D(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\nbaseNormal += texture2D(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture2D(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nCC_APPLY_FOG(color, s.position.xyz);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\ngl_FragData[1] = vec4(position, s.roughness);\ngl_FragData[2] = vec4(s.normal, s.metallic);\ngl_FragData[3] = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matLightViewProj;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nvarying vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\nattribute lowp vec4 a_color;\nvarying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform vec4 tilingOffset;\n#endif\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(matWorld * position);\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\nvarying lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no.rgb *= SRGBToLinear(v_color.rgb);\no.a *= v_color.a;\n#endif\n#if USE_TEXTURE\nvec4 texColor = texture2D(mainTexture, v_uv);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\no *= texColor;\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\nCC_APPLY_FOG(o);\nreturn CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D outputResultMap;\nfloat luminance(vec3 color) {\nreturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\nvoid main() {\nvec3 color = texture2D(outputResultMap, v_uv).xyz;\nif (luminance(SRGBToLinear(color)) > texSize.z) {\ngl_FragColor = vec4(color, 1.0);\n} else {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D bloomTexture;\nvec3 downsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture2D(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main()\n{\nvec3 result = downsample4taps(v_uv, 1.0 / texSize.xy).rgb;\ngl_FragColor = vec4(result, 1.0);\n}"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D bloomTexture;\nvec3 upsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture2D(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main() {\nvec3 result = upsample4taps(v_uv, 0.5 / texSize.xy).rgb;\ngl_FragColor = vec4(result, 1.0);\n}"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D outputResultMap;\nuniform sampler2D bloomTexture;\nvoid main() {\nvec4 hdrColor = texture2D(outputResultMap, v_uv);\nvec3 bloomColor = texture2D(bloomTexture, v_uv).rgb;\nvec3 result = hdrColor.rgb + bloomColor * texSize.w * hdrColor.a;\ngl_FragColor = vec4(result, hdrColor.a);\n}"
            }], [{
              "vert": "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
              "frag": "\n#ifdef GL_EXT_shader_framebuffer_fetch\n#extension GL_EXT_shader_framebuffer_fetch: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nuniform highp mat4 cc_matView;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp mat4 cc_matLightViewProj;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\nvarying vec2 v_uv;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\n#else\nuniform sampler2D gbuffer_albedoMap;\nuniform sampler2D gbuffer_positionMap;\nuniform sampler2D gbuffer_normalMap;\nuniform sampler2D gbuffer_emissiveMap;\n#endif\n#if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\n#endif\nvoid main () {\nStandardSurface s;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nvec4 albedoMap = gl_LastFragData[0];\nvec4 positionMap = gl_LastFragData[1];\nvec4 normalMap = gl_LastFragData[2];\nvec4 emissiveMap = gl_LastFragData[3];\n#else\nvec4 albedoMap = texture2D(gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture2D(gbuffer_positionMap,v_uv);\nvec4 normalMap = texture2D(gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture2D(gbuffer_emissiveMap,v_uv);\n#endif\ns.albedo = albedoMap;\nvec3 position = positionMap.xyz;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, position);\n#else\ns.position = position;\n#endif\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\nCC_TRANSFER_FOG_BASE(vec4(position, 1), fogFactor);\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nCCClusterShadingAdditive(s, shadowPos);\n#else\nCCStandardShadingAdditive(s, shadowPos);\n#endif\nCC_APPLY_FOG_BASE(color, fogFactor);\ncolor = CCFragOutput(color);\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\ngl_FragData[3] = color;\n#else\ngl_FragColor = color;\n#endif\n}"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform mediump vec4 cc_mainLitDir;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nuniform mediump vec4 cc_planarNDInfo;\nvarying float v_discard;\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\nvec3 P = (matWorld * position).xyz;\nvec3 L = cc_mainLitDir.xyz;\nvec3 N = cc_planarNDInfo.xyz;\nfloat d = cc_planarNDInfo.w - 0.001;\nfloat dist = (-d - dot(P, N)) / (dot(L, N) + 0.0001);\nvec3 shadowPos = P + L * dist;\nposition = cc_matProj * cc_matView * vec4(shadowPos, 1.0);\nposition.z -= 0.0001;\nv_discard = dist < 0.00001 ? 0.0 : 10.0;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying float v_discard;\nvec4 frag () {\nif(v_discard < 9.9)\ndiscard;\nreturn CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\n#if ANTIALIAS_TYPE == 1\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\nvec4 texColor = texture2D(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\n#endif\nvarying vec2 v_uv;\nuniform sampler2D outputResultMap;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\n#if ANTIALIAS_TYPE == 1\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\ngl_FragColor = fxaa(outputResultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n#else\ngl_FragColor = texture2D(outputResultMap, v_uv);\n#endif\n}"
            }], [{
              "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nvarying mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nvec4 pos = matViewRotOnly * viewDir;\nif (cc_matProj[3].w > 0.0) {\nmat4 matProj = cc_matProj;\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\npos = matProj * pos;\n} else {\npos = cc_matProj * pos;\n}\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nvarying mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nmat2 proj = mat2(cc_matProj[0].xy, cc_matProj[1].xy);\nproj /= abs(proj[1].x + proj[1].y);\nvec2 position = proj * a_position.xy + offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn vec4(position, 0.0, 1.0);\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nuniform vec4 u_buffer0;\nuniform vec4 u_buffer1;\nuniform mat4 u_projection;\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvarying vec2 v_uv;\nuniform float u_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture2D(mainTexture, v_uv);\nfloat percent = clamp(u_percent, 0.0, 1.0);\ncolor.xyz *= percent;\nreturn color;\n}\nvoid main() { gl_FragColor = frag(); }"
            }]];

            const glsl3 = [[{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nlayout(std140) uniform builtin {\nvec4 cc_size_rotation;\n};\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nin vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nout float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nin float v_distance;\nvec4 front() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nout float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nin float v_distance;\nvec4 back() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_normal;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_normal;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin float a_dist;\nout float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nin vec4 v_color;\nin float v_dist;\nvec4 frag () {\nvec4 o = v_color;\nfloat aa = fwidth(v_dist);\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCWorldBound {\nhighp vec4 cc_worldBoundCenter;\nhighp vec4 cc_worldBoundHalfExtents;\n};\nin vec3 a_position;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition *= cc_worldBoundHalfExtents;\nposition += cc_worldBoundCenter;\nposition = cc_matViewProj * position;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 frag () {\nreturn vec4(1, 0, 0, 1);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 eulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(std140) uniform SampleConstants {\nvec4 u_sampleInfo;\n};\nlayout(std140) uniform TickConstants {\nvec4 u_worldRot;\nvec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord;\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom(float x) {\n#if USE_VK_SHADER\nfloat o = x;\nx = mod(x - 1.0, 2.0) - 1.0;\nfloat freqVar = 10.16640753482;\nfloat y = sin(freqVar * floor(o * 0.5 - 0.5));\nfloat v = max(0.0, 1.0-abs(x));\nv *= 0.7071067812;\nv = y < 0.0 ? -v : v;\nreturn v;\n#else\nfloat seed = mod(x, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n#endif\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nlayout(std140) uniform ColorConstant {\nint u_color_mode;\n};\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nlayout(std140) uniform RotationConstant {\nint u_rotation_mode;\n};\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nlayout(std140) uniform SizeConstant {\nint u_size_mode;\n};\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nlayout(std140) uniform ForceConstant {\nint u_force_mode;\nint u_force_space;\n};\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nlayout(std140) uniform VelocityConstant {\nint u_velocity_mode;\nint u_velocity_space;\n};\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nlayout(std140) uniform AnimationConstant {\nvec4 u_anim_info;\n};\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = startRotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., startRotation.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(startRotation);\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nout vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\n#if CC_DRAW_WIRE_FRAME\nin vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\nin vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n#else\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(a_texCoord2);\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 v_light;\nout vec2 uv0;\n#if TWO_COLORED\nin vec4 a_color2;\nout vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 v_light;\n#if TWO_COLORED\nin vec4 v_dark;\n#endif\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nstruct SpriteVertexData {\nvec4 position;\nvec4 color;\n};\nstruct SpriteFragmentData {\nvec2 uv;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec3 a_position;\nin vec2 a_texCoord;\nin float a_batch_id;\nout vec2 v_uv0;\nout float v_uvMode;\nout vec4 v_uvSizeOffset;\nout vec4 v_uvParams0;\nout vec4 v_uvParams1;\nstruct SpriteVertexInternalData {\nvec4 rotation;\nvec3 translation;\nvec3 scale;\nvec4 uvSizeOffset;\nfloat uvMode;\nvec4 uvParams;\nfloat filltype;\n};\nlayout(std140) uniform CCUILocal {\nvec4 cc_local_data[(CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS - CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS) / 5 * 5];\n};\nvec3 VectorTransformQuat (vec3 v, vec4 q) {\nreturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvoid CCSpriteInput(out SpriteVertexData i0) {\nvec4 data0 = cc_local_data[int(a_batch_id) * 5];\nvec4 data1 = cc_local_data[int(a_batch_id) * 5 + 1];\nvec4 data2 = cc_local_data[int(a_batch_id) * 5 + 2];\nvec4 data3 = cc_local_data[int(a_batch_id) * 5 + 3];\nvec4 data4 = cc_local_data[int(a_batch_id) * 5 + 4];\nfloat rg = data0.w;\nfloat r = floor(rg);\nfloat ba = data2.z;\nfloat b = floor(ba);\nSpriteVertexInternalData i1;\ni1.rotation = data1;\ni1.translation = data0.xyz;\ni1.scale = vec3(data2.xy, 1.0);\ni1.uvSizeOffset = data3;\ni1.filltype = fract(data2.w) * 10.0;\ni1.uvMode = data2.w;\ni1.uvParams = data4;\ni0.position = vec4(VectorTransformQuat(a_position * i1.scale, i1.rotation) + i1.translation, 1.0);\ni0.color = vec4(r * (1.0 / 255.0), rg - r, b * (1.0 / 255.0), ba - b);\nvec2 uvWithRotation;\nif (i1.uvSizeOffset.x < 0.0) {\ni1.uvSizeOffset.x = abs(i1.uvSizeOffset.x);\nuvWithRotation = vec2(1.0 - a_texCoord.y, a_texCoord.x);\n} else {\nuvWithRotation = a_texCoord;\n}\nif (i1.uvMode >= 3.0) {\nv_uv0 = uvWithRotation;\nv_uvSizeOffset = i1.uvSizeOffset;\nv_uvParams0 = vec4(i1.uvParams.xy, i1.filltype, 0);\nif (i1.filltype >= 2.0) {\nv_uvParams1 = i1.uvParams;\n} else if (i1.filltype >= 1.0) {\nv_uvParams0 = vec4(1.0 - v_uvParams0.y, 1.0 - v_uvParams0.x, v_uvParams0.zw);\n}\n} else if (i1.uvMode >= 2.0) {\nv_uv0 = uvWithRotation * i1.uvParams.xy;\nv_uv0.y -= fract(i1.uvParams.y);\nv_uvSizeOffset = i1.uvSizeOffset;\n} else if (i1.uvMode >= 1.0) {\nv_uv0 = uvWithRotation;\nv_uvSizeOffset = i1.uvSizeOffset;\nvec4 params0 = fract(i1.uvParams);\nvec4 params1 = floor(i1.uvParams) / 2048.0;\nv_uvParams0 = vec4(params0.xy, params1.xy);\nv_uvParams1 = vec4(params0.zw, params1.zw);\n} else {\nv_uv0 = uvWithRotation * i1.uvSizeOffset.xy + i1.uvSizeOffset.zw;\n}\nv_uvMode = i1.uvMode;\n#if SAMPLE_FROM_RT\nv_uv0 = cc_cameraPos.w > 1.0 ? vec2(v_uv0.x, 1.0 - v_uv0.y) : v_uv0;\n#endif\n}\nout vec4 v_color;\nvec4 vert () {\nSpriteVertexData i;\nCCSpriteInput(i);\nv_color = i.color;\nvec4 pos = i.position;\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nstruct SpriteVertexData {\nvec4 position;\nvec4 color;\n};\nstruct SpriteFragmentData {\nvec2 uv;\n};\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\nin vec2 v_uv0;\nin float v_uvMode;\nin vec4 v_uvSizeOffset;\nin vec4 v_uvParams0;\nin vec4 v_uvParams1;\nvec2 evalSlicedUV(vec2 uv) {\nvec4 p0 = mix(vec4(0.0), v_uvParams0, step(v_uvParams0.xyxy, uv.xyxy));\np0 = mix(       p0, v_uvParams1, step(v_uvParams1.xyxy, uv.xyxy));\nvec4 p1 = mix(vec4(1.0), v_uvParams1, step(uv.xyxy, v_uvParams1.xyxy));\np1 = mix(       p1, v_uvParams0, step(uv.xyxy, v_uvParams0.xyxy));\nvec2 k = (p1.zw - p0.zw) / (p1.xy - p0.xy);\nvec2 b = (p1.xy * p0.zw - p0.xy * p1.zw) / (p1.xy - p0.xy);\nreturn k * uv + b;\n}\nfloat evalFilledUV(vec2 uv, float mode) {\nfloat alpha = 1.0;\nif (mode >= 2.0) {\nfloat start = v_uvParams1.x;\nfloat range = v_uvParams1.y;\nvec2 dir = uv - v_uvParams1.zw;\nfloat angle = -atan(dir.y, dir.x) * 0.3183098861838;\nif (range < 0.0) {\nangle += mix(0.0, -2.0, step(start, angle));\nalpha = step(start + range, angle);\n} else {\nangle += mix(0.0, 2.0, step(angle, start));\nalpha = step(angle, start + range);\n}\n} else if (mode >= 1.0) {\nif (uv.y >= v_uvParams0.x && uv.y <= v_uvParams0.y) {\nalpha = 1.0;\n} else {\nalpha = 0.0;\n}\n} else {\nif (uv.x >= v_uvParams0.x && uv.x <= v_uvParams0.y) {\nalpha = 1.0;\n} else {\nalpha = 0.0;\n}\n}\nreturn alpha;\n}\nvoid CCSpriteInput(out SpriteFragmentData i) {\n#if USE_TEXTURE\nif(v_uvMode >= 3.0) {\ni.uv = v_uv0 * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else if (v_uvMode >= 2.0) {\ni.uv = fract(v_uv0) * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else if (v_uvMode >= 1.0) {\ni.uv = evalSlicedUV(v_uv0) * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else {\ni.uv = v_uv0;\n}\n#endif\n}\nvec4 CCSpriteSample(sampler2D tex, vec2 uv) {\nvec4 o = CCSampleWithAlphaSeparated(tex, uv);\nif (v_uvMode >= 3.0) {\no.a *= evalFilledUV(v_uv0, v_uvParams0.z);\n}\nreturn o;\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nin vec4 v_color;\n#if USE_TEXTURE\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nSpriteFragmentData i;\nCCSpriteInput(i);\n#if USE_TEXTURE\nvec4 color = v_color * CCSpriteSample(cc_spriteTexture, i.uv);\n#else\nvec4 color = v_color;\n#endif\n#if IS_GRAY\ncolor.rgb = SRGBToLinear(color.rgb);\ncolor.rgb = vec3(dot(color.rgb, vec3(0.2126, 0.7152, 0.0722)));\ncolor.rgb = sqrt(color.rgb);\n#endif\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if SAMPLE_FROM_RT\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 color;\n#if USE_TEXTURE\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nin vec4 a_color;\nout vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\nout vec3 v_tangent;\nout vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nout vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_TWOSIDE\nvec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\nv_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n#endif\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(pos);\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\nin vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nin vec3 v_tangent;\nin vec3 v_bitangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n(nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.a;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = pbr.x;\ns.roughness = pbr.y;\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nfragColor1 = vec4(position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nreturn vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout highp vec3 v_position;\nout mediump vec3 v_normal;\n#if USE_NORMALMAP\nout mediump vec3 v_tangent;\nout mediump vec3 v_binormal;\n#endif\nout mediump vec2 uvw;\nout mediump vec2 uv0;\nout mediump vec2 uv1;\nout mediump vec2 uv2;\nout mediump vec2 uv3;\nout mediump vec3 luv;\nout mediump vec3 diffuse;\nlayout(std140) uniform TexCoords {\nvec4 UVScale;\nvec4 lightMapUVParam;\n};\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\nCC_TRANSFER_FOG(vec4(worldPos, 1.0));\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nin highp vec3 v_position;\nin mediump vec3 v_normal;\n#if USE_NORMALMAP\nin mediump vec3 v_tangent;\nin mediump vec3 v_binormal;\n#endif\nin mediump vec2 uvw;\nin mediump vec2 uv0;\nin mediump vec2 uv1;\nin mediump vec2 uv2;\nin mediump vec2 uv3;\nin mediump vec3 diffuse;\nin mediump vec3 luv;\nlayout(std140) uniform PbrParams {\nvec4 metallic;\nvec4 roughness;\n};\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\nbaseColor += texture(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture(detailMap0, uv0);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\nbaseNormal += texture(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nfragColor1 = vec4(position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nin vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\nin lowp vec4 a_color;\nout lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nout vec2 v_uv;\nlayout(std140) uniform TexCoords {\nvec4 tilingOffset;\n};\n#endif\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(matWorld * position);\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nin vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\nvec4 mainColor;\nvec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\nin lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no.rgb *= SRGBToLinear(v_color.rgb);\no.a *= v_color.a;\n#endif\n#if USE_TEXTURE\nvec4 texColor = texture(mainTexture, v_uv);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\no *= texColor;\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\nCC_APPLY_FOG(o);\nreturn CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D outputResultMap;\nlayout(location = 0) out vec4 fragColor;\nfloat luminance(vec3 color) {\nreturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\nvoid main() {\nvec3 color = texture(outputResultMap, v_uv).xyz;\nif (luminance(SRGBToLinear(color)) > texSize.z) {\nfragColor = vec4(color, 1.0);\n} else {\nfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvec3 downsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main()\n{\nvec3 result = downsample4taps(v_uv, 1.0 / texSize.xy).rgb;\nfragColor = vec4(result, 1.0);\n}"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvec3 upsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main() {\nvec3 result = upsample4taps(v_uv, 0.5 / texSize.xy).rgb;\nfragColor = vec4(result, 1.0);\n}"
            }, {
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D outputResultMap;\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvoid main() {\nvec4 hdrColor = texture(outputResultMap, v_uv);\nvec3 bloomColor = texture(bloomTexture, v_uv).rgb;\nvec3 result = hdrColor.rgb + bloomColor * texSize.w * hdrColor.a;\nfragColor = vec4(result, hdrColor.a);\n}"
            }], [{
              "vert": "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
              "frag": "\n#ifdef GL_EXT_shader_framebuffer_fetch\n#extension GL_EXT_shader_framebuffer_fetch: enable\n#endif\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\nin vec2 v_uv;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nlayout(location = 0) inout vec4 gbuffer_albedoMap;\nlayout(location = 1) inout vec4 gbuffer_positionMap;\nlayout(location = 2) inout vec4 gbuffer_normalMap;\nlayout(location = 3) inout vec4 gbuffer_emissiveMap;\n#else\nuniform sampler2D gbuffer_albedoMap;\nuniform sampler2D gbuffer_positionMap;\nuniform sampler2D gbuffer_normalMap;\nuniform sampler2D gbuffer_emissiveMap;\n#endif\n#if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\nlayout(location = 0) out vec4 fragColor;\n#endif\nvoid main () {\nStandardSurface s;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nvec4 albedoMap = gbuffer_albedoMap;\nvec4 positionMap = gbuffer_positionMap;\nvec4 normalMap = gbuffer_normalMap;\nvec4 emissiveMap = gbuffer_emissiveMap;\n#else\nvec4 albedoMap = texture(gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture(gbuffer_positionMap,v_uv);\nvec4 normalMap = texture(gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture(gbuffer_emissiveMap,v_uv);\n#endif\ns.albedo = albedoMap;\nvec3 position = positionMap.xyz;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, position);\n#else\ns.position = position;\n#endif\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\nCC_TRANSFER_FOG_BASE(vec4(position, 1), fogFactor);\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nCCClusterShadingAdditive(s, shadowPos);\n#else\nCCStandardShadingAdditive(s, shadowPos);\n#endif\nCC_APPLY_FOG_BASE(color, fogFactor);\ncolor = CCFragOutput(color);\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\ngbuffer_emissiveMap = color;\n#else\nfragColor = color;\n#endif\n}"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nout float v_discard;\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\nvec3 P = (matWorld * position).xyz;\nvec3 L = cc_mainLitDir.xyz;\nvec3 N = cc_planarNDInfo.xyz;\nfloat d = cc_planarNDInfo.w - 0.001;\nfloat dist = (-d - dot(P, N)) / (dot(L, N) + 0.0001);\nvec3 shadowPos = P + L * dist;\nposition = cc_matProj * cc_matView * vec4(shadowPos, 1.0);\nposition.z -= 0.0001;\nv_discard = dist < 0.00001 ? 0.0 : 10.0;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin float v_discard;\nvec4 frag () {\nif(v_discard < 9.9)\ndiscard;\nreturn CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if ANTIALIAS_TYPE == 1\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture(tex, v_rgbSE).xyz;\nvec4 texColor = texture(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\n#endif\nin vec2 v_uv;\nuniform sampler2D outputResultMap;\nlayout(location = 0) out vec4 fragColor;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\n#if ANTIALIAS_TYPE == 1\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\nfragColor = fxaa(outputResultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n#else\nfragColor = texture(outputResultMap, v_uv);\n#endif\n}"
            }], [{
              "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nout mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nvec4 pos = matViewRotOnly * viewDir;\nif (cc_matProj[3].w > 0.0) {\nmat4 matProj = cc_matProj;\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\npos = matProj * pos;\n} else {\npos = cc_matProj * pos;\n}\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nin mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nlayout(std140) uniform Constants {\nvec4 offset;\n};\nlayout(std140) uniform PerFrameInfo {\nvec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nmat2 proj = mat2(cc_matProj[0].xy, cc_matProj[1].xy);\nproj /= abs(proj[1].x + proj[1].y);\nvec2 position = proj * a_position.xy + offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn vec4(position, 0.0, 1.0);\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nlayout(std140) uniform Constant {\nvec4 u_buffer0;\nvec4 u_buffer1;\nmat4 u_projection;\n};\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nin vec2 v_uv;\nlayout(std140) uniform Factor {\nfloat u_percent;\n};\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture(mainTexture, v_uv);\nfloat percent = clamp(u_percent, 0.0, 1.0);\ncolor.xyz *= percent;\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }]];

            const glsl4 = [[{
              "vert": "\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(set = 1, binding = 1) uniform builtin {\nvec4 cc_size_rotation;\n};\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 3) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 2) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(location = 0) in vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in highp vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in highp vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in highp vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nlayout(location = 1) out float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec4 v_color;\nlayout(location = 1) in float v_distance;\nvec4 front() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in highp vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nlayout(location = 1) out float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec4 v_color;\nlayout(location = 1) in float v_distance;\nvec4 back() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in highp vec3 a_position;\nlayout(location = 1) in vec4 a_normal;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"
            }, {
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in highp vec3 a_position;\nlayout(location = 1) in vec4 a_normal;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nlayout(location = 2) in float a_dist;\nlayout(location = 1) out float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nlayout(location = 0) in vec4 v_color;\nlayout(location = 1) in float v_dist;\nvec4 frag () {\nvec4 o = v_color;\nfloat aa = fwidth(v_dist);\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCWorldBound {\nhighp vec4 cc_worldBoundCenter;\nhighp vec4 cc_worldBoundHalfExtents;\n};\nlayout(location = 0) in vec3 a_position;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition *= cc_worldBoundHalfExtents;\nposition += cc_worldBoundCenter;\nposition = cc_matViewProj * position;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nvec4 frag () {\nreturn vec4(1, 0, 0, 1);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 eulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(set = 1, binding = 1) uniform SampleConstants {\nvec4 u_sampleInfo;\n};\nlayout(set = 1, binding = 2) uniform TickConstants {\nvec4 u_worldRot;\nvec4 u_timeDelta;\n};\nlayout(location = 0) in vec4 a_position_starttime;\nlayout(location = 1) in vec4 a_size_uv;\nlayout(location = 2) in vec4 a_rotation_uv;\nlayout(location = 3) in vec4 a_color;\nlayout(location = 4) in vec4 a_dir_life;\nlayout(location = 5) in float a_rndSeed;\n#if CC_RENDER_MODE == 4\nlayout(location = 6) in vec3 a_texCoord;\nlayout(location = 7) in vec3 a_texCoord3;\nlayout(location = 8) in vec3 a_normal;\nlayout(location = 9) in vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom(float x) {\n#if USE_VK_SHADER\nfloat o = x;\nx = mod(x - 1.0, 2.0) - 1.0;\nfloat freqVar = 10.16640753482;\nfloat y = sin(freqVar * floor(o * 0.5 - 0.5));\nfloat v = max(0.0, 1.0-abs(x));\nv *= 0.7071067812;\nv = y < 0.0 ? -v : v;\nreturn v;\n#else\nfloat seed = mod(x, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n#endif\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 10) uniform sampler2D color_over_time_tex0;\nlayout(set = 1, binding = 3) uniform ColorConstant {\nint u_color_mode;\n};\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 11) uniform sampler2D rotation_over_time_tex0;\nlayout(set = 1, binding = 4) uniform RotationConstant {\nint u_rotation_mode;\n};\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 12) uniform sampler2D size_over_time_tex0;\nlayout(set = 1, binding = 5) uniform SizeConstant {\nint u_size_mode;\n};\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 13) uniform sampler2D force_over_time_tex0;\nlayout(set = 1, binding = 6) uniform ForceConstant {\nint u_force_mode;\nint u_force_space;\n};\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nlayout(set = 1, binding = 14) uniform sampler2D velocity_over_time_tex0;\nlayout(set = 1, binding = 7) uniform VelocityConstant {\nint u_velocity_mode;\nint u_velocity_space;\n};\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nlayout(set = 1, binding = 15) uniform sampler2D texture_animation_tex0;\nlayout(set = 1, binding = 8) uniform AnimationConstant {\nvec4 u_anim_info;\n};\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = startRotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., startRotation.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(startRotation);\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 16) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 9) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nlayout(location = 2) out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\n#if CC_DRAW_WIRE_FRAME\nlayout(location = 2) in vec3 vBarycentric;\n#endif\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\nlayout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nlayout(location = 6) in vec3 a_texCoord3;\nlayout(location = 7) in vec3 a_normal;\nlayout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n#else\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(a_texCoord2);\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 v_light;\nlayout(location = 1) out vec2 uv0;\n#if TWO_COLORED\nlayout(location = 3) in vec4 a_color2;\nlayout(location = 2) out vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\nlayout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nlayout(location = 0) in vec4 v_light;\n#if TWO_COLORED\nlayout(location = 2) in vec4 v_dark;\n#endif\nlayout(location = 1) in vec2 uv0;\nlayout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nstruct SpriteVertexData {\nvec4 position;\nvec4 color;\n};\nstruct SpriteFragmentData {\nvec2 uv;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in float a_batch_id;\nlayout(location = 0) out vec2 v_uv0;\nlayout(location = 1) out float v_uvMode;\nlayout(location = 2) out vec4 v_uvSizeOffset;\nlayout(location = 3) out vec4 v_uvParams0;\nlayout(location = 4) out vec4 v_uvParams1;\nstruct SpriteVertexInternalData {\nvec4 rotation;\nvec3 translation;\nvec3 scale;\nvec4 uvSizeOffset;\nfloat uvMode;\nvec4 uvParams;\nfloat filltype;\n};\nlayout(set = 2, binding = 5) uniform CCUILocal {\nvec4 cc_local_data[(CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS - CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS) / 5 * 5];\n};\nvec3 VectorTransformQuat (vec3 v, vec4 q) {\nreturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvoid CCSpriteInput(out SpriteVertexData i0) {\nvec4 data0 = cc_local_data[int(a_batch_id) * 5];\nvec4 data1 = cc_local_data[int(a_batch_id) * 5 + 1];\nvec4 data2 = cc_local_data[int(a_batch_id) * 5 + 2];\nvec4 data3 = cc_local_data[int(a_batch_id) * 5 + 3];\nvec4 data4 = cc_local_data[int(a_batch_id) * 5 + 4];\nfloat rg = data0.w;\nfloat r = floor(rg);\nfloat ba = data2.z;\nfloat b = floor(ba);\nSpriteVertexInternalData i1;\ni1.rotation = data1;\ni1.translation = data0.xyz;\ni1.scale = vec3(data2.xy, 1.0);\ni1.uvSizeOffset = data3;\ni1.filltype = fract(data2.w) * 10.0;\ni1.uvMode = data2.w;\ni1.uvParams = data4;\ni0.position = vec4(VectorTransformQuat(a_position * i1.scale, i1.rotation) + i1.translation, 1.0);\ni0.color = vec4(r * (1.0 / 255.0), rg - r, b * (1.0 / 255.0), ba - b);\nvec2 uvWithRotation;\nif (i1.uvSizeOffset.x < 0.0) {\ni1.uvSizeOffset.x = abs(i1.uvSizeOffset.x);\nuvWithRotation = vec2(1.0 - a_texCoord.y, a_texCoord.x);\n} else {\nuvWithRotation = a_texCoord;\n}\nif (i1.uvMode >= 3.0) {\nv_uv0 = uvWithRotation;\nv_uvSizeOffset = i1.uvSizeOffset;\nv_uvParams0 = vec4(i1.uvParams.xy, i1.filltype, 0);\nif (i1.filltype >= 2.0) {\nv_uvParams1 = i1.uvParams;\n} else if (i1.filltype >= 1.0) {\nv_uvParams0 = vec4(1.0 - v_uvParams0.y, 1.0 - v_uvParams0.x, v_uvParams0.zw);\n}\n} else if (i1.uvMode >= 2.0) {\nv_uv0 = uvWithRotation * i1.uvParams.xy;\nv_uv0.y -= fract(i1.uvParams.y);\nv_uvSizeOffset = i1.uvSizeOffset;\n} else if (i1.uvMode >= 1.0) {\nv_uv0 = uvWithRotation;\nv_uvSizeOffset = i1.uvSizeOffset;\nvec4 params0 = fract(i1.uvParams);\nvec4 params1 = floor(i1.uvParams) / 2048.0;\nv_uvParams0 = vec4(params0.xy, params1.xy);\nv_uvParams1 = vec4(params0.zw, params1.zw);\n} else {\nv_uv0 = uvWithRotation * i1.uvSizeOffset.xy + i1.uvSizeOffset.zw;\n}\nv_uvMode = i1.uvMode;\n#if SAMPLE_FROM_RT\nv_uv0 = cc_cameraPos.w > 1.0 ? vec2(v_uv0.x, 1.0 - v_uv0.y) : v_uv0;\n#endif\n}\nlayout(location = 5) out vec4 v_color;\nvec4 vert () {\nSpriteVertexData i;\nCCSpriteInput(i);\nv_color = i.color;\nvec4 pos = i.position;\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nstruct SpriteVertexData {\nvec4 position;\nvec4 color;\n};\nstruct SpriteFragmentData {\nvec2 uv;\n};\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\nlayout(location = 0) in vec2 v_uv0;\nlayout(location = 1) in float v_uvMode;\nlayout(location = 2) in vec4 v_uvSizeOffset;\nlayout(location = 3) in vec4 v_uvParams0;\nlayout(location = 4) in vec4 v_uvParams1;\nvec2 evalSlicedUV(vec2 uv) {\nvec4 p0 = mix(vec4(0.0), v_uvParams0, step(v_uvParams0.xyxy, uv.xyxy));\np0 = mix(       p0, v_uvParams1, step(v_uvParams1.xyxy, uv.xyxy));\nvec4 p1 = mix(vec4(1.0), v_uvParams1, step(uv.xyxy, v_uvParams1.xyxy));\np1 = mix(       p1, v_uvParams0, step(uv.xyxy, v_uvParams0.xyxy));\nvec2 k = (p1.zw - p0.zw) / (p1.xy - p0.xy);\nvec2 b = (p1.xy * p0.zw - p0.xy * p1.zw) / (p1.xy - p0.xy);\nreturn k * uv + b;\n}\nfloat evalFilledUV(vec2 uv, float mode) {\nfloat alpha = 1.0;\nif (mode >= 2.0) {\nfloat start = v_uvParams1.x;\nfloat range = v_uvParams1.y;\nvec2 dir = uv - v_uvParams1.zw;\nfloat angle = -atan(dir.y, dir.x) * 0.3183098861838;\nif (range < 0.0) {\nangle += mix(0.0, -2.0, step(start, angle));\nalpha = step(start + range, angle);\n} else {\nangle += mix(0.0, 2.0, step(angle, start));\nalpha = step(angle, start + range);\n}\n} else if (mode >= 1.0) {\nif (uv.y >= v_uvParams0.x && uv.y <= v_uvParams0.y) {\nalpha = 1.0;\n} else {\nalpha = 0.0;\n}\n} else {\nif (uv.x >= v_uvParams0.x && uv.x <= v_uvParams0.y) {\nalpha = 1.0;\n} else {\nalpha = 0.0;\n}\n}\nreturn alpha;\n}\nvoid CCSpriteInput(out SpriteFragmentData i) {\n#if USE_TEXTURE\nif(v_uvMode >= 3.0) {\ni.uv = v_uv0 * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else if (v_uvMode >= 2.0) {\ni.uv = fract(v_uv0) * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else if (v_uvMode >= 1.0) {\ni.uv = evalSlicedUV(v_uv0) * v_uvSizeOffset.xy + v_uvSizeOffset.zw;\n} else {\ni.uv = v_uv0;\n}\n#endif\n}\nvec4 CCSpriteSample(sampler2D tex, vec2 uv) {\nvec4 o = CCSampleWithAlphaSeparated(tex, uv);\nif (v_uvMode >= 3.0) {\no.a *= evalFilledUV(v_uv0, v_uvParams0.z);\n}\nreturn o;\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(location = 5) in vec4 v_color;\n#if USE_TEXTURE\nlayout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nSpriteFragmentData i;\nCCSpriteInput(i);\n#if USE_TEXTURE\nvec4 color = v_color * CCSpriteSample(cc_spriteTexture, i.uv);\n#else\nvec4 color = v_color;\n#endif\n#if IS_GRAY\ncolor.rgb = SRGBToLinear(color.rgb);\ncolor.rgb = vec3(dot(color.rgb, vec3(0.2126, 0.7152, 0.0722)));\ncolor.rgb = sqrt(color.rgb);\n#endif\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if SAMPLE_FROM_RT\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nlayout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nlayout(location = 0) in vec4 color;\n#if USE_TEXTURE\nlayout(location = 1) in vec2 uv0;\nlayout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\nlayout(location = 8) in vec4 a_matWorld0;\nlayout(location = 9) in vec4 a_matWorld1;\nlayout(location = 10) in vec4 a_matWorld2;\n#if USE_LIGHTMAP\nlayout(location = 11) in vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nlayout(location = 12) in float a_dyn_batch_id;\nlayout(set = 2, binding = 0) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nlayout(location = 13) in vec4 a_color;\nlayout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\nlayout(location = 7) out vec3 v_tangent;\nlayout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nlayout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nlayout(location = 9) out vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_TWOSIDE\nvec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\nv_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n#endif\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(pos);\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nlayout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nlayout(location = 9) in vec3 v_luv;\nlayout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\nlayout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nlayout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nlayout(location = 7) in vec3 v_tangent;\nlayout(location = 8) in vec3 v_bitangent;\nlayout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nlayout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nlayout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nlayout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nlayout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n(nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.a;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = pbr.x;\ns.roughness = pbr.y;\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(set = 2, binding = 1) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nfragColor1 = vec4(position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\n#if USE_INSTANCING\nlayout(location = 8) in vec4 a_matWorld0;\nlayout(location = 9) in vec4 a_matWorld1;\nlayout(location = 10) in vec4 a_matWorld2;\n#if USE_LIGHTMAP\nlayout(location = 11) in vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nlayout(location = 12) in float a_dyn_batch_id;\nlayout(set = 2, binding = 0) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\nlayout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\nlayout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nreturn vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 2) out highp vec3 v_position;\nlayout(location = 3) out mediump vec3 v_normal;\n#if USE_NORMALMAP\nlayout(location = 4) out mediump vec3 v_tangent;\nlayout(location = 5) out mediump vec3 v_binormal;\n#endif\nlayout(location = 6) out mediump vec2 uvw;\nlayout(location = 7) out mediump vec2 uv0;\nlayout(location = 8) out mediump vec2 uv1;\nlayout(location = 9) out mediump vec2 uv2;\nlayout(location = 10) out mediump vec2 uv3;\nlayout(location = 11) out mediump vec3 luv;\nlayout(location = 12) out mediump vec3 diffuse;\nlayout(set = 1, binding = 0) uniform TexCoords {\nvec4 UVScale;\nvec4 lightMapUVParam;\n};\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\nCC_TRANSFER_FOG(vec4(worldPos, 1.0));\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nlayout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nlayout(location = 13) in vec3 v_luv;\nlayout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nlayout(location = 2) in highp vec3 v_position;\nlayout(location = 3) in mediump vec3 v_normal;\n#if USE_NORMALMAP\nlayout(location = 4) in mediump vec3 v_tangent;\nlayout(location = 5) in mediump vec3 v_binormal;\n#endif\nlayout(location = 6) in mediump vec2 uvw;\nlayout(location = 7) in mediump vec2 uv0;\nlayout(location = 8) in mediump vec2 uv1;\nlayout(location = 9) in mediump vec2 uv2;\nlayout(location = 10) in mediump vec2 uv3;\nlayout(location = 12) in mediump vec3 diffuse;\nlayout(location = 11) in mediump vec3 luv;\nlayout(set = 1, binding = 1) uniform PbrParams {\nvec4 metallic;\nvec4 roughness;\n};\nlayout(set = 1, binding = 2) uniform sampler2D weightMap;\nlayout(set = 1, binding = 3) uniform sampler2D detailMap0;\nlayout(set = 1, binding = 4) uniform sampler2D detailMap1;\nlayout(set = 1, binding = 5) uniform sampler2D detailMap2;\nlayout(set = 1, binding = 6) uniform sampler2D detailMap3;\nlayout(set = 1, binding = 7) uniform sampler2D normalMap0;\nlayout(set = 1, binding = 8) uniform sampler2D normalMap1;\nlayout(set = 1, binding = 9) uniform sampler2D normalMap2;\nlayout(set = 1, binding = 10) uniform sampler2D normalMap3;\nlayout(set = 1, binding = 11) uniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\nbaseColor += texture(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture(detailMap0, uv0);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\nbaseNormal += texture(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(set = 2, binding = 1) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(set = 1, binding = 12) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(set = 1, binding = 13) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(set = 1, binding = 14) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nfragColor1 = vec4(position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
            }, {
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 0) out vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nlayout(location = 0) in vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\nlayout(location = 8) in vec4 a_matWorld0;\nlayout(location = 9) in vec4 a_matWorld1;\nlayout(location = 10) in vec4 a_matWorld2;\n#if USE_LIGHTMAP\nlayout(location = 11) in vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nlayout(location = 12) in float a_dyn_batch_id;\nlayout(set = 2, binding = 0) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\nlayout(location = 13) in lowp vec4 a_color;\nlayout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nlayout(location = 2) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform TexCoords {\nvec4 tilingOffset;\n};\n#endif\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(matWorld * position);\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nlayout(location = 2) in vec2 v_uv;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\nvec4 mainColor;\nvec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\nlayout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no.rgb *= SRGBToLinear(v_color.rgb);\no.a *= v_color.a;\n#endif\n#if USE_TEXTURE\nvec4 texColor = texture(mainTexture, v_uv);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\no *= texColor;\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\nCC_APPLY_FOG(o);\nreturn CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 0) uniform BloomUBO {\nmediump vec4 texSize;\n};\nlayout(set = 1, binding = 1) uniform sampler2D outputResultMap;\nlayout(location = 0) out vec4 fragColor;\nfloat luminance(vec3 color) {\nreturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\nvoid main() {\nvec3 color = texture(outputResultMap, v_uv).xyz;\nif (luminance(SRGBToLinear(color)) > texSize.z) {\nfragColor = vec4(color, 1.0);\n} else {\nfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}"
            }, {
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 0) uniform BloomUBO {\nmediump vec4 texSize;\n};\nlayout(set = 1, binding = 1) uniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvec3 downsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main()\n{\nvec3 result = downsample4taps(v_uv, 1.0 / texSize.xy).rgb;\nfragColor = vec4(result, 1.0);\n}"
            }, {
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 0) uniform BloomUBO {\nmediump vec4 texSize;\n};\nlayout(set = 1, binding = 1) uniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvec3 upsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main() {\nvec3 result = upsample4taps(v_uv, 0.5 / texSize.xy).rgb;\nfragColor = vec4(result, 1.0);\n}"
            }, {
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 0) uniform BloomUBO {\nmediump vec4 texSize;\n};\nlayout(set = 1, binding = 1) uniform sampler2D outputResultMap;\nlayout(set = 1, binding = 2) uniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvoid main() {\nvec4 hdrColor = texture(outputResultMap, v_uv);\nvec3 bloomColor = texture(bloomTexture, v_uv).rgb;\nvec3 result = hdrColor.rgb + bloomColor * texSize.w * hdrColor.a;\nfragColor = vec4(result, hdrColor.a);\n}"
            }], [{
              "vert": "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nlayout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\nlayout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n{\nvec4 newShadowPos = shadowPos;\nif(cc_shadowLPNNInfo.z > 0.0001)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > 0.000001) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nfloat bias = cc_shadowWHPBInfo.w;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nlayout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\nif (NL > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(set = 2, binding = 1) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(set = 1, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(set = 1, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(set = 1, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_screenSize.x / float(16));\nfloat clusterSizeY = ceil(cc_screenSize.y / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\nlayout(location = 0) in vec2 v_uv;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nlayout(set = 1, binding = 0, input_attachment_index = 0) uniform subpassInput gbuffer_albedoMap;\nlayout(set = 1, binding = 1, input_attachment_index = 1) uniform subpassInput gbuffer_positionMap;\nlayout(set = 1, binding = 2, input_attachment_index = 2) uniform subpassInput gbuffer_normalMap;\nlayout(set = 1, binding = 3, input_attachment_index = 3) uniform subpassInput gbuffer_emissiveMap;\n#else\nlayout(set = 1, binding = 0) uniform sampler2D gbuffer_albedoMap;\nlayout(set = 1, binding = 1) uniform sampler2D gbuffer_positionMap;\nlayout(set = 1, binding = 2) uniform sampler2D gbuffer_normalMap;\nlayout(set = 1, binding = 3) uniform sampler2D gbuffer_emissiveMap;\n#endif\n#if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\nlayout(location = 0) out vec4 fragColor;\n#endif\nvoid main () {\nStandardSurface s;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nvec4 albedoMap = subpassLoad(gbuffer_albedoMap);\nvec4 positionMap = subpassLoad(gbuffer_positionMap);\nvec4 normalMap = subpassLoad(gbuffer_normalMap);\nvec4 emissiveMap = subpassLoad(gbuffer_emissiveMap);\n#else\nvec4 albedoMap = texture(gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture(gbuffer_positionMap,v_uv);\nvec4 normalMap = texture(gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture(gbuffer_emissiveMap,v_uv);\n#endif\ns.albedo = albedoMap;\nvec3 position = positionMap.xyz;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, position);\n#else\ns.position = position;\n#endif\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\nCC_TRANSFER_FOG_BASE(vec4(position, 1), fogFactor);\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nCCClusterShadingAdditive(s, shadowPos);\n#else\nCCStandardShadingAdditive(s, shadowPos);\n#endif\nCC_APPLY_FOG_BASE(color, fogFactor);\ncolor = CCFragOutput(color);\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nfragColor = color;\n#else\nfragColor = color;\n#endif\n}"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\nlayout(location = 8) in vec4 a_matWorld0;\nlayout(location = 9) in vec4 a_matWorld1;\nlayout(location = 10) in vec4 a_matWorld2;\n#if USE_LIGHTMAP\nlayout(location = 11) in vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nlayout(location = 12) in float a_dyn_batch_id;\nlayout(set = 2, binding = 0) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nlayout(location = 0) out float v_discard;\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\nvec3 P = (matWorld * position).xyz;\nvec3 L = cc_mainLitDir.xyz;\nvec3 N = cc_planarNDInfo.xyz;\nfloat d = cc_planarNDInfo.w - 0.001;\nfloat dist = (-d - dot(P, N)) / (dot(L, N) + 0.0001);\nvec3 shadowPos = P + L * dist;\nposition = cc_matProj * cc_matView * vec4(shadowPos, 1.0);\nposition.z -= 0.0001;\nv_discard = dist < 0.00001 ? 0.0 : 10.0;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 2) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in float v_discard;\nvec4 frag () {\nif(v_discard < 9.9)\ndiscard;\nreturn CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\nint getVertexId() {\nreturn gl_VertexIndex;\n}\nlayout(set = 2, binding = 4) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nlayout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nlayout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nlayout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u32vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nlayout(location = 7) in highp vec4 a_jointAnimInfo;\n#endif\nlayout(set = 2, binding = 3) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(set = 2, binding = 2) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nlayout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(set = 2, binding = 3) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) out vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
              "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if ANTIALIAS_TYPE == 1\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture(tex, v_rgbSE).xyz;\nvec4 texColor = texture(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 0) uniform sampler2D outputResultMap;\nlayout(location = 0) out vec4 fragColor;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\n#if ANTIALIAS_TYPE == 1\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\nfragColor = fxaa(outputResultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n#else\nfragColor = texture(outputResultMap, v_uv);\n#endif\n}"
            }], [{
              "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\nlayout(location = 0) out mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nvec4 pos = matViewRotOnly * viewDir;\nif (cc_matProj[3].w > 0.0) {\nmat4 matProj = cc_matProj;\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\npos = matProj * pos;\n} else {\npos = cc_matProj * pos;\n}\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 4) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nlayout(location = 0) in mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform Constants {\nvec4 offset;\n};\nlayout(set = 1, binding = 1) uniform PerFrameInfo {\nvec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nmat2 proj = mat2(cc_matProj[0].xy, cc_matProj[1].xy);\nproj /= abs(proj[1].x + proj[1].y);\nvec2 position = proj * a_position.xy + offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn vec4(position, 0.0, 1.0);\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }], [{
              "vert": "\nprecision mediump float;\nlayout(location = 0) in vec2 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform Constant {\nvec4 u_buffer0;\nvec4 u_buffer1;\nmat4 u_projection;\n};\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
              "frag": "\nprecision mediump float;\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 1) uniform Factor {\nfloat u_percent;\n};\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture(mainTexture, v_uv);\nfloat percent = clamp(u_percent, 0.0, 1.0);\ncolor.xyz *= percent;\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
            }]];

            const assembly = (() => {
              {
                return {
                  glsl1,
                  glsl3,
                  glsl4
                };
              }
            })();

            class BuiltinResMgr {
              constructor() {
                this._device = null;
                this._resources = {};
              }

              initBuiltinRes(device) {
                this._device = device;
                const resources = this._resources;
                const len = 2;
                const numChannels = 4;
                const blackValueView = new Uint8Array(len * len * numChannels);
                const emptyValueView = new Uint8Array(len * len * numChannels);
                const greyValueView = new Uint8Array(len * len * numChannels);
                const whiteValueView = new Uint8Array(len * len * numChannels);
                const normalValueView = new Uint8Array(len * len * numChannels);
                let offset = 0;

                for (let i = 0; i < len * len; i++) {
                  blackValueView[offset] = 0;
                  blackValueView[offset + 1] = 0;
                  blackValueView[offset + 2] = 0;
                  blackValueView[offset + 3] = 255;
                  emptyValueView[offset] = 0;
                  emptyValueView[offset + 1] = 0;
                  emptyValueView[offset + 2] = 0;
                  emptyValueView[offset + 3] = 0;
                  greyValueView[offset] = 119;
                  greyValueView[offset + 1] = 119;
                  greyValueView[offset + 2] = 119;
                  greyValueView[offset + 3] = 255;
                  whiteValueView[offset] = 255;
                  whiteValueView[offset + 1] = 255;
                  whiteValueView[offset + 2] = 255;
                  whiteValueView[offset + 3] = 255;
                  normalValueView[offset] = 127;
                  normalValueView[offset + 1] = 127;
                  normalValueView[offset + 2] = 255;
                  normalValueView[offset + 3] = 255;
                  offset += numChannels;
                }

                const defaultSize = 16;
                const halfDefaultSize = defaultSize / 2;
                const defaultValueView = new Uint8Array(defaultSize * defaultSize * numChannels);
                offset = 0;

                for (let i = 0; i < defaultSize * defaultSize; i++) {
                  defaultValueView[offset] = 221;
                  defaultValueView[offset + 1] = 221;
                  defaultValueView[offset + 2] = 221;
                  defaultValueView[offset + 3] = 255;
                  offset += numChannels;
                }

                offset = 0;

                for (let i = 0; i < halfDefaultSize; i++) {
                  for (let j = 0; j < halfDefaultSize; j++) {
                    defaultValueView[offset] = 85;
                    defaultValueView[offset + 1] = 85;
                    defaultValueView[offset + 2] = 85;
                    defaultValueView[offset + 3] = 255;
                    offset += numChannels;
                  }

                  offset += halfDefaultSize * numChannels;
                }

                offset += halfDefaultSize * numChannels;

                for (let i = 0; i < halfDefaultSize; i++) {
                  for (let j = 0; j < halfDefaultSize; j++) {
                    defaultValueView[offset] = 85;
                    defaultValueView[offset + 1] = 85;
                    defaultValueView[offset + 2] = 85;
                    defaultValueView[offset + 3] = 255;
                    offset += numChannels;
                  }

                  offset += halfDefaultSize * numChannels;
                }

                const blackMemImageSource = {
                  width: len,
                  height: len,
                  _data: blackValueView,
                  _compressed: false,
                  format: Texture2D.PixelFormat.RGBA8888
                };
                const emptyMemImageSource = {
                  width: len,
                  height: len,
                  _data: emptyValueView,
                  _compressed: false,
                  format: Texture2D.PixelFormat.RGBA8888
                };
                const greyMemImageSource = {
                  width: len,
                  height: len,
                  _data: greyValueView,
                  _compressed: false,
                  format: Texture2D.PixelFormat.RGBA8888
                };
                const whiteMemImageSource = {
                  width: len,
                  height: len,
                  _data: whiteValueView,
                  _compressed: false,
                  format: Texture2D.PixelFormat.RGBA8888
                };
                const normalMemImageSource = {
                  width: len,
                  height: len,
                  _data: normalValueView,
                  _compressed: false,
                  format: Texture2D.PixelFormat.RGBA8888
                };
                const defaultMemImageSource = {
                  width: defaultSize,
                  height: defaultSize,
                  _data: defaultValueView,
                  _compressed: false,
                  format: Texture2D.PixelFormat.RGBA8888
                };
                const imgAsset = new ImageAsset(blackMemImageSource);
                const blackTexture = new Texture2D();
                blackTexture._uuid = 'black-texture';
                blackTexture.image = imgAsset;
                resources[blackTexture._uuid] = blackTexture;
                const emptyImgAsset = new ImageAsset(emptyMemImageSource);
                const emptyTexture = new Texture2D();
                emptyTexture._uuid = 'empty-texture';
                emptyTexture.image = emptyImgAsset;
                resources[emptyTexture._uuid] = emptyTexture;
                const blackCubeTexture = new TextureCube();
                blackCubeTexture._uuid = 'black-cube-texture';
                blackCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
                blackCubeTexture.image = {
                  front: new ImageAsset(blackMemImageSource),
                  back: new ImageAsset(blackMemImageSource),
                  left: new ImageAsset(blackMemImageSource),
                  right: new ImageAsset(blackMemImageSource),
                  top: new ImageAsset(blackMemImageSource),
                  bottom: new ImageAsset(blackMemImageSource)
                };
                resources[blackCubeTexture._uuid] = blackCubeTexture;
                const greyImgAsset = new ImageAsset(greyMemImageSource);
                const greyTexture = new Texture2D();
                greyTexture._uuid = 'grey-texture';
                greyTexture.image = greyImgAsset;
                resources[greyTexture._uuid] = greyTexture;
                const whiteImgAsset = new ImageAsset(whiteMemImageSource);
                const whiteTexture = new Texture2D();
                whiteTexture._uuid = 'white-texture';
                whiteTexture.image = whiteImgAsset;
                resources[whiteTexture._uuid] = whiteTexture;
                const whiteCubeTexture = new TextureCube();
                whiteCubeTexture._uuid = 'white-cube-texture';
                whiteCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
                whiteCubeTexture.image = {
                  front: new ImageAsset(whiteMemImageSource),
                  back: new ImageAsset(whiteMemImageSource),
                  left: new ImageAsset(whiteMemImageSource),
                  right: new ImageAsset(whiteMemImageSource),
                  top: new ImageAsset(whiteMemImageSource),
                  bottom: new ImageAsset(whiteMemImageSource)
                };
                resources[whiteCubeTexture._uuid] = whiteCubeTexture;
                const normalImgAsset = new ImageAsset(normalMemImageSource);
                const normalTexture = new Texture2D();
                normalTexture._uuid = 'normal-texture';
                normalTexture.image = normalImgAsset;
                resources[normalTexture._uuid] = normalTexture;
                const defaultImgAsset = new ImageAsset(defaultMemImageSource);
                const defaultTexture = new Texture2D();
                defaultTexture._uuid = 'default-texture';
                defaultTexture.image = defaultImgAsset;
                resources[defaultTexture._uuid] = defaultTexture;
                const defaultCubeTexture = new TextureCube();
                defaultCubeTexture.setMipFilter(TextureCube.Filter.NEAREST);
                defaultCubeTexture._uuid = 'default-cube-texture';
                defaultCubeTexture.image = {
                  front: new ImageAsset(defaultMemImageSource),
                  back: new ImageAsset(defaultMemImageSource),
                  left: new ImageAsset(defaultMemImageSource),
                  right: new ImageAsset(defaultMemImageSource),
                  top: new ImageAsset(defaultMemImageSource),
                  bottom: new ImageAsset(defaultMemImageSource)
                };
                resources[defaultCubeTexture._uuid] = defaultCubeTexture;

                if (legacyCC.SpriteFrame) {
                  const spriteFrame = new legacyCC.SpriteFrame();
                  const image = imgAsset;
                  const texture = new Texture2D();
                  texture.image = image;
                  spriteFrame.texture = texture;
                  spriteFrame._uuid = 'default-spriteframe';
                  resources[spriteFrame._uuid] = spriteFrame;
                }

                const shaderVersionKey = getDeviceShaderVersion(device);

                if (!shaderVersionKey) {
                  return Promise.reject(Error('Failed to initialize builtin shaders: unknown device.'));
                }

                const shaderSources = assembly[shaderVersionKey];

                if (!shaderSources) {
                  return Promise.reject(Error(`Current device is requiring builtin shaders of version ${shaderVersionKey} ` + `but shaders of that version are not assembled in this build.`));
                }

                return Promise.resolve().then(() => {
                  effects.forEach((e, effectIndex) => {
                    const effect = Object.assign(new legacyCC.EffectAsset(), e);
                    effect.shaders.forEach((shaderInfo, shaderIndex) => {
                      const shaderSource = shaderSources[effectIndex][shaderIndex];

                      if (shaderSource) {
                        shaderInfo[shaderVersionKey] = shaderSource;
                      }
                    });
                    effect.hideInEditor = true;
                    effect.onLoaded();
                  });

                  this._initMaterials();
                });
              }

              get(uuid) {
                return this._resources[uuid];
              }

              _initMaterials() {
                const resources = this._resources;
                const materialsToBeCompiled = [];
                const standardMtl = new legacyCC.Material();
                standardMtl._uuid = 'standard-material';
                standardMtl.initialize({
                  effectName: 'standard'
                });
                resources[standardMtl._uuid] = standardMtl;
                materialsToBeCompiled.push(standardMtl);
                const missingEfxMtl = new legacyCC.Material();
                missingEfxMtl._uuid = 'missing-effect-material';
                missingEfxMtl.initialize({
                  effectName: 'unlit',
                  defines: {
                    USE_COLOR: true
                  }
                });
                missingEfxMtl.setProperty('mainColor', legacyCC.color('#ffff00'));
                resources[missingEfxMtl._uuid] = missingEfxMtl;
                materialsToBeCompiled.push(missingEfxMtl);
                const missingMtl = new legacyCC.Material();
                missingMtl._uuid = 'missing-material';
                missingMtl.initialize({
                  effectName: 'unlit',
                  defines: {
                    USE_COLOR: true
                  }
                });
                missingMtl.setProperty('mainColor', legacyCC.color('#ff00ff'));
                resources[missingMtl._uuid] = missingMtl;
                materialsToBeCompiled.push(missingMtl);
                const clearStencilMtl = new legacyCC.Material();
                clearStencilMtl._uuid = 'default-clear-stencil';
                clearStencilMtl.initialize({
                  defines: {
                    USE_TEXTURE: false
                  },
                  effectName: 'clear-stencil'
                });
                resources[clearStencilMtl._uuid] = clearStencilMtl;
                materialsToBeCompiled.push(clearStencilMtl);
                const spriteMtl = new legacyCC.Material();
                spriteMtl._uuid = 'ui-base-material';
                spriteMtl.initialize({
                  defines: {
                    USE_TEXTURE: false
                  },
                  effectName: 'sprite'
                });
                resources[spriteMtl._uuid] = spriteMtl;
                materialsToBeCompiled.push(spriteMtl);
                const spriteColorMtl = new legacyCC.Material();
                spriteColorMtl._uuid = 'ui-sprite-material';
                spriteColorMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: false,
                    IS_GRAY: false
                  },
                  effectName: 'sprite'
                });
                resources[spriteColorMtl._uuid] = spriteColorMtl;
                materialsToBeCompiled.push(spriteColorMtl);
                const alphaTestMaskMtl = new legacyCC.Material();
                alphaTestMaskMtl._uuid = 'ui-alpha-test-material';
                alphaTestMaskMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    USE_ALPHA_TEST: true,
                    CC_USE_EMBEDDED_ALPHA: false,
                    IS_GRAY: false
                  },
                  effectName: 'sprite'
                });
                resources[alphaTestMaskMtl._uuid] = alphaTestMaskMtl;
                materialsToBeCompiled.push(alphaTestMaskMtl);
                const spriteGrayMtl = new legacyCC.Material();
                spriteGrayMtl._uuid = 'ui-sprite-gray-material';
                spriteGrayMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: false,
                    IS_GRAY: true
                  },
                  effectName: 'sprite'
                });
                resources[spriteGrayMtl._uuid] = spriteGrayMtl;
                materialsToBeCompiled.push(spriteGrayMtl);
                const spriteAlphaMtl = new legacyCC.Material();
                spriteAlphaMtl._uuid = 'ui-sprite-alpha-sep-material';
                spriteAlphaMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: true,
                    IS_GRAY: false
                  },
                  effectName: 'sprite'
                });
                resources[spriteAlphaMtl._uuid] = spriteAlphaMtl;
                materialsToBeCompiled.push(spriteAlphaMtl);
                const spriteAlphaGrayMtl = new legacyCC.Material();
                spriteAlphaGrayMtl._uuid = 'ui-sprite-gray-alpha-sep-material';
                spriteAlphaGrayMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: true,
                    IS_GRAY: true
                  },
                  effectName: 'sprite'
                });
                resources[spriteAlphaGrayMtl._uuid] = spriteAlphaGrayMtl;
                materialsToBeCompiled.push(spriteAlphaGrayMtl);
                const defaultGraphicsMtl = new legacyCC.Material();
                defaultGraphicsMtl._uuid = 'ui-graphics-material';
                defaultGraphicsMtl.initialize({
                  effectName: 'graphics'
                });
                resources[defaultGraphicsMtl._uuid] = defaultGraphicsMtl;
                materialsToBeCompiled.push(defaultGraphicsMtl);

                const defaultParticleMtl = new legacyCC.Material();
                defaultParticleMtl._uuid = 'default-particle-material';
                defaultParticleMtl.initialize({
                  effectName: 'particle'
                });
                resources[defaultParticleMtl._uuid] = defaultParticleMtl;
                materialsToBeCompiled.push(defaultParticleMtl);

                {
                  const defaultParticleGPUMtl = new legacyCC.Material();
                  defaultParticleGPUMtl._uuid = 'default-particle-gpu-material';
                  defaultParticleGPUMtl.initialize({
                    effectName: 'particle-gpu'
                  });
                  resources[defaultParticleGPUMtl._uuid] = defaultParticleGPUMtl;
                  materialsToBeCompiled.push(defaultParticleGPUMtl);
                }

                const defaultTrailMtl = new legacyCC.Material();
                defaultTrailMtl._uuid = 'default-trail-material';
                defaultTrailMtl.initialize({
                  effectName: 'particle-trail'
                });
                resources[defaultTrailMtl._uuid] = defaultTrailMtl;
                materialsToBeCompiled.push(defaultTrailMtl);
                const defaultBillboardMtl = new legacyCC.Material();
                defaultBillboardMtl._uuid = 'default-billboard-material';
                defaultBillboardMtl.initialize({
                  effectName: 'billboard'
                });
                resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
                materialsToBeCompiled.push(defaultBillboardMtl);
                const spineTwoColorMtl = new legacyCC.Material();
                spineTwoColorMtl._uuid = 'default-spine-material';
                spineTwoColorMtl.initialize({
                  defines: {
                    USE_TEXTURE: true,
                    CC_USE_EMBEDDED_ALPHA: false,
                    IS_GRAY: false
                  },
                  effectName: 'spine'
                });
                resources[spineTwoColorMtl._uuid] = spineTwoColorMtl;
                materialsToBeCompiled.push(spineTwoColorMtl);
                legacyCC.game.on(legacyCC.Game.EVENT_GAME_INITED, () => {
                  for (let i = 0; i < materialsToBeCompiled.length; ++i) {
                    const mat = materialsToBeCompiled[i];

                    for (let j = 0; j < mat.passes.length; ++j) {
                      mat.passes[j].tryCompile();
                    }
                  }
                });
              }

            }

            const builtinResMgr = exports('bV', legacyCC.builtinResMgr = new BuiltinResMgr());

            const getPhaseID = (() => {
              const phases = new Map();
              let phaseNum = 0;
              return phaseName => {
                if (typeof phaseName === 'number') {
                  return phaseName;
                }

                if (!phases.has(phaseName)) {
                  phases.set(phaseName, 1 << phaseNum);
                  phaseNum++;
                }

                return phases.get(phaseName);
              };
            })();

            const INITIAL_CAPACITY = 32;
            const MAX_CAPACITY = 1024;
            class InstancedBuffer {
              constructor(pass) {
                this.instances = [];
                this.pass = void 0;
                this.hasPendingModels = false;
                this.dynamicOffsets = [];
                this._device = void 0;
                this._device = pass.device;
                this.pass = pass;
              }

              destroy() {
                for (let i = 0; i < this.instances.length; ++i) {
                  const instance = this.instances[i];
                  instance.vb.destroy();
                  instance.ia.destroy();
                }

                this.instances.length = 0;
              }

              merge(subModel, attrs, passIdx, shaderImplant = null) {
                const stride = attrs.buffer.length;

                if (!stride) {
                  return;
                }

                const sourceIA = subModel.inputAssembler;
                const lightingMap = subModel.descriptorSet.getTexture(UNIFORM_LIGHTMAP_TEXTURE_BINDING);
                let shader = shaderImplant;

                if (!shader) {
                  shader = subModel.shaders[passIdx];
                }

                const descriptorSet = subModel.descriptorSet;

                for (let i = 0; i < this.instances.length; ++i) {
                  const instance = this.instances[i];

                  if (instance.ia.indexBuffer !== sourceIA.indexBuffer || instance.count >= MAX_CAPACITY) {
                    continue;
                  }

                  if (instance.lightingMap !== lightingMap) {
                    continue;
                  }

                  if (instance.stride !== stride) {
                    continue;
                  }

                  if (instance.count >= instance.capacity) {
                    instance.capacity <<= 1;
                    const newSize = instance.stride * instance.capacity;
                    const oldData = instance.data;
                    instance.data = new Uint8Array(newSize);
                    instance.data.set(oldData);
                    instance.vb.resize(newSize);
                  }

                  if (instance.shader !== shader) {
                    instance.shader = shader;
                  }

                  if (instance.descriptorSet !== descriptorSet) {
                    instance.descriptorSet = descriptorSet;
                  }

                  instance.data.set(attrs.buffer, instance.stride * instance.count++);
                  this.hasPendingModels = true;
                  return;
                }

                const vb = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, stride * INITIAL_CAPACITY, stride));

                const data = new Uint8Array(stride * INITIAL_CAPACITY);
                const vertexBuffers = sourceIA.vertexBuffers.slice();
                const attributes = sourceIA.attributes.slice();
                const indexBuffer = sourceIA.indexBuffer;

                for (let i = 0; i < attrs.attributes.length; i++) {
                  const attr = attrs.attributes[i];
                  const newAttr = new Attribute(attr.name, attr.format, attr.isNormalized, vertexBuffers.length, true);
                  attributes.push(newAttr);
                }

                data.set(attrs.buffer);
                vertexBuffers.push(vb);
                const iaInfo = new InputAssemblerInfo(attributes, vertexBuffers, indexBuffer);

                const ia = this._device.createInputAssembler(iaInfo);

                this.instances.push({
                  count: 1,
                  capacity: INITIAL_CAPACITY,
                  vb,
                  data,
                  ia,
                  stride,
                  shader,
                  descriptorSet,
                  lightingMap
                });
                this.hasPendingModels = true;
              }

              uploadBuffers(cmdBuff) {
                for (let i = 0; i < this.instances.length; ++i) {
                  const instance = this.instances[i];

                  if (!instance.count) {
                    continue;
                  }

                  instance.ia.instanceCount = instance.count;
                  cmdBuff.updateBuffer(instance.vb, instance.data);
                }
              }

              clear() {
                for (let i = 0; i < this.instances.length; ++i) {
                  const instance = this.instances[i];
                  instance.count = 0;
                }

                this.hasPendingModels = false;
              }

            }

            class BatchedBuffer {
              constructor(pass) {
                this.batches = [];
                this.dynamicOffsets = [];
                this._device = void 0;
                this._device = pass.device;
              }

              destroy() {
                for (let i = 0; i < this.batches.length; ++i) {
                  const batch = this.batches[i];

                  for (let j = 0; j < batch.vbs.length; ++j) {
                    batch.vbs[j].destroy();
                  }

                  batch.vbIdx.destroy();
                  batch.ia.destroy();
                  batch.ubo.destroy();
                }

                this.batches.length = 0;
              }

              merge(subModel, passIdx, model) {
                const flatBuffers = subModel.subMesh.flatBuffers;

                if (flatBuffers.length === 0) {
                  return;
                }

                let vbSize = 0;
                let vbIdxSize = 0;
                const vbCount = flatBuffers[0].count;
                const pass = subModel.passes[passIdx];
                const shader = subModel.shaders[passIdx];
                const descriptorSet = subModel.descriptorSet;
                let isBatchExist = false;

                for (let i = 0; i < this.batches.length; ++i) {
                  const batch = this.batches[i];

                  if (batch.vbs.length === flatBuffers.length && batch.mergeCount < UBOLocalBatched.BATCHING_COUNT) {
                    isBatchExist = true;

                    for (let j = 0; j < batch.vbs.length; ++j) {
                      const vb = batch.vbs[j];

                      if (vb.stride !== flatBuffers[j].stride) {
                        isBatchExist = false;
                        break;
                      }
                    }

                    if (isBatchExist) {
                      for (let j = 0; j < batch.vbs.length; ++j) {
                        const flatBuff = flatBuffers[j];
                        const batchVB = batch.vbs[j];
                        const vbBuf = batch.vbDatas[j];
                        vbSize = (vbCount + batch.vbCount) * flatBuff.stride;

                        if (vbSize > batchVB.size) {
                          batchVB.resize(vbSize);
                          batch.vbDatas[j] = new Uint8Array(vbSize);
                          batch.vbDatas[j].set(vbBuf);
                        }

                        batch.vbDatas[j].set(flatBuff.buffer, batch.vbCount * flatBuff.stride);
                      }

                      let vbIdxBuf = batch.vbIdxData;
                      vbIdxSize = (vbCount + batch.vbCount) * 4;

                      if (vbIdxSize > batch.vbIdx.size) {
                        batch.vbIdx.resize(vbIdxSize);
                        batch.vbIdxData = new Float32Array(vbIdxSize / Float32Array.BYTES_PER_ELEMENT);
                        batch.vbIdxData.set(vbIdxBuf);
                        vbIdxBuf = batch.vbIdxData;
                      }

                      const start = batch.vbCount;
                      const end = start + vbCount;
                      const mergeCount = batch.mergeCount;

                      if (vbIdxBuf[start] !== mergeCount || vbIdxBuf[end - 1] !== mergeCount) {
                        for (let j = start; j < end; j++) {
                          vbIdxBuf[j] = mergeCount + 0.1;
                        }
                      }

                      Mat4.toArray(batch.uboData, model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET + batch.mergeCount * 16);

                      if (!batch.mergeCount) {
                        descriptorSet.bindBuffer(UBOLocalBatched.BINDING, batch.ubo);
                        descriptorSet.update();
                        batch.pass = pass;
                        batch.shader = shader;
                        batch.descriptorSet = descriptorSet;
                      }

                      ++batch.mergeCount;
                      batch.vbCount += vbCount;
                      batch.ia.vertexCount += vbCount;
                      return;
                    }
                  }
                }

                const vbs = [];
                const vbDatas = [];
                const totalVBs = [];

                for (let i = 0; i < flatBuffers.length; ++i) {
                  const flatBuff = flatBuffers[i];

                  const newVB = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, flatBuff.count * flatBuff.stride, flatBuff.stride));

                  newVB.update(flatBuff.buffer.buffer);
                  vbs.push(newVB);
                  vbDatas.push(new Uint8Array(newVB.size));
                  totalVBs.push(newVB);
                }

                const vbIdx = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbCount * 4, 4));

                const vbIdxData = new Float32Array(vbCount);
                vbIdxData.fill(0);
                vbIdx.update(vbIdxData);
                totalVBs.push(vbIdx);
                const attributes = subModel.inputAssembler.attributes;
                const attrs = new Array(attributes.length + 1);

                for (let a = 0; a < attributes.length; ++a) {
                  attrs[a] = attributes[a];
                }

                attrs[attributes.length] = new Attribute('a_dyn_batch_id', Format.R32F, false, flatBuffers.length);
                const iaInfo = new InputAssemblerInfo(attrs, totalVBs);

                const ia = this._device.createInputAssembler(iaInfo);

                const ubo = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocalBatched.SIZE, UBOLocalBatched.SIZE));

                descriptorSet.bindBuffer(UBOLocalBatched.BINDING, ubo);
                descriptorSet.update();
                const uboData = new Float32Array(UBOLocalBatched.COUNT);
                Mat4.toArray(uboData, model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET);
                this.batches.push({
                  mergeCount: 1,
                  vbs,
                  vbDatas,
                  vbIdx,
                  vbIdxData,
                  vbCount,
                  ia,
                  ubo,
                  uboData,
                  pass,
                  shader,
                  descriptorSet
                });
              }

              clear() {
                for (let i = 0; i < this.batches.length; ++i) {
                  const batch = this.batches[i];
                  batch.vbCount = 0;
                  batch.mergeCount = 0;
                  batch.ia.vertexCount = 0;
                }
              }

            }

            const _bufferInfo = new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE);

            const _bufferViewInfo = new BufferViewInfo(null);

            const _dsInfo = new DescriptorSetInfo(null);

            let BatchingSchemes;

            (function (BatchingSchemes) {
              BatchingSchemes[BatchingSchemes["NONE"] = 0] = "NONE";
              BatchingSchemes[BatchingSchemes["INSTANCING"] = 1] = "INSTANCING";
              BatchingSchemes[BatchingSchemes["VB_MERGING"] = 2] = "VB_MERGING";
            })(BatchingSchemes || (BatchingSchemes = exports('cO', {})));

            class Pass {
              static fillPipelineInfo(pass, info) {
                if (info.priority !== undefined) {
                  pass._setPriority(info.priority);
                }

                if (info.primitive !== undefined) {
                  pass._setPrimitive(info.primitive);
                }

                if (info.stage !== undefined) {
                  pass._setStage(info.stage);
                }

                if (info.dynamicStates !== undefined) {
                  pass._setDynamicState(info.dynamicStates);
                }

                if (info.phase !== undefined) {
                  pass._setPhase(getPhaseID(info.phase));
                }

                const bs = pass._bs;

                if (info.blendState) {
                  const bsInfo = info.blendState;
                  const {
                    targets
                  } = bsInfo;

                  if (targets) {
                    targets.forEach((t, i) => {
                      bs.setTarget(i, t);
                    });
                  }

                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }

                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }

                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }

                pass._rs.assign(info.rasterizerState);

                pass._dss.assign(info.depthStencilState);
              }

              static getPassHash(pass) {
                const shaderKey = programLib.getKey(pass.program, pass.defines);
                let res = `${shaderKey},${pass._primitive},${pass._dynamicStates}`;
                res += serializeBlendState(pass._bs);
                res += serializeDepthStencilState(pass._dss);
                res += serializeRasterizerState(pass._rs);
                return murmurhash2_32_gc(res, 666);
              }

              get native() {
                return this._nativeObj;
              }

              constructor(root) {
                this._rootBuffer = null;
                this._buffers = [];
                this._descriptorSet = null;
                this._pipelineLayout = null;
                this._passIndex = 0;
                this._propertyIndex = 0;
                this._programName = '';
                this._dynamics = {};
                this._propertyHandleMap = {};
                this._rootBlock = null;
                this._blocksInt = [];
                this._blocks = [];
                this._shaderInfo = null;
                this._defines = {};
                this._properties = {};
                this._shader = null;
                this._bs = new BlendState$1();
                this._dss = new DepthStencilState$1();
                this._rs = new RasterizerState$1();
                this._priority = RenderPriority.DEFAULT;
                this._stage = RenderPassStage.DEFAULT;
                this._phase = getPhaseID('default');
                this._primitive = PrimitiveMode.TRIANGLE_LIST;
                this._batchingScheme = BatchingSchemes.NONE;
                this._dynamicStates = DynamicStateFlagBit.NONE;
                this._instancedBuffers = {};
                this._batchedBuffers = {};
                this._hash = 0;
                this._root = void 0;
                this._device = void 0;
                this._passHandle = NULL_HANDLE;
                this._rootBufferDirty = false;
                this._root = root;
                this._device = root.device;
              }

              initialize(info) {
                this._doInit(info);

                this.resetUBOs();
                this.resetTextures();
                this.tryCompile();
              }

              getHandle(name, offset = 0, targetType = Type.UNKNOWN) {
                let handle = this._propertyHandleMap[name];

                if (!handle) {
                  return 0;
                }

                if (targetType) {
                  handle = customizeType(handle, targetType);
                } else if (offset) {
                  handle = customizeType(handle, getTypeFromHandle(handle) - offset);
                }

                return handle + offset;
              }

              getBinding(name) {
                const handle = this.getHandle(name);

                if (!handle) {
                  return -1;
                }

                return Pass.getBindingFromHandle(handle);
              }

              setUniform(handle, value) {
                const binding = Pass.getBindingFromHandle(handle);
                const type = Pass.getTypeFromHandle(handle);
                const ofs = Pass.getOffsetFromHandle(handle);

                const block = this._getBlockView(type, binding);

                type2writer[type](block, value, ofs);

                this._setRootBufferDirty(true);
              }

              getUniform(handle, out) {
                const binding = Pass.getBindingFromHandle(handle);
                const type = Pass.getTypeFromHandle(handle);
                const ofs = Pass.getOffsetFromHandle(handle);

                const block = this._getBlockView(type, binding);

                return type2reader[type](block, out, ofs);
              }

              setUniformArray(handle, value) {
                const binding = Pass.getBindingFromHandle(handle);
                const type = Pass.getTypeFromHandle(handle);
                const stride = GetTypeSize(type) >> 2;

                const block = this._getBlockView(type, binding);

                let ofs = Pass.getOffsetFromHandle(handle);

                for (let i = 0; i < value.length; i++, ofs += stride) {
                  if (value[i] === null) {
                    continue;
                  }

                  type2writer[type](block, value[i], ofs);
                }

                this._setRootBufferDirty(true);
              }

              bindTexture(binding, value, index) {
                this._descriptorSet.bindTexture(binding, value, index || 0);
              }

              bindSampler(binding, value, index) {
                this._descriptorSet.bindSampler(binding, value, index || 0);
              }

              setDynamicState(state, value) {
                const ds = this._dynamics[state];

                if (ds && ds.value === value) {
                  return;
                }

                ds.value = value;
                ds.dirty = true;
              }

              overridePipelineStates(original, overrides) {
                console.warn('base pass cannot override states, please use pass instance instead.');
              }

              _setRootBufferDirty(val) {
                this._rootBufferDirty = val;

                {
                  this._nativeObj.setRootBufferDirty(val);
                }
              }

              update() {
                if (!this._descriptorSet) {
                  errorID(12006);
                  return;
                }

                if (this._rootBuffer && this._rootBufferDirty) {
                  this._rootBuffer.update(this._rootBlock);

                  this._setRootBufferDirty(false);
                }

                this._descriptorSet.update();

                {
                  this._nativeObj.update();
                }
              }

              getInstancedBuffer(extraKey = 0) {
                return this._instancedBuffers[extraKey] || (this._instancedBuffers[extraKey] = new InstancedBuffer(this));
              }

              getBatchedBuffer(extraKey = 0) {
                return this._batchedBuffers[extraKey] || (this._batchedBuffers[extraKey] = new BatchedBuffer(this));
              }

              _initNative() {
                if ( !this._nativeObj) {
                  this._nativeObj = new NativePass();
                  this._passHandle = PassPool.alloc();
                  this._nativePriority = PassPool.getTypedArray(this._passHandle, PassView.PRIORITY);
                  this._nativeStage = PassPool.getTypedArray(this._passHandle, PassView.STAGE);
                  this._nativePhase = PassPool.getTypedArray(this._passHandle, PassView.PHASE);
                  this._nativePrimitive = PassPool.getTypedArray(this._passHandle, PassView.PRIMITIVE);
                  this._nativeBatchingScheme = PassPool.getTypedArray(this._passHandle, PassView.BATCHING_SCHEME);
                  this._nativeDynamicStates = PassPool.getTypedArray(this._passHandle, PassView.DYNAMIC_STATE);
                  this._nativeHash = PassPool.getTypedArray(this._passHandle, PassView.HASH);

                  this._nativeObj.initWithData(PassPool.getBuffer(this._passHandle));
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;

                  if (this._passHandle) {
                    PassPool.free(this._passHandle);
                  }
                }
              }

              destroy() {
                for (let i = 0; i < this._shaderInfo.blocks.length; i++) {
                  const u = this._shaderInfo.blocks[i];

                  this._buffers[u.binding].destroy();
                }

                this._buffers = [];

                if (this._rootBuffer) {
                  this._rootBuffer.destroy();

                  this._rootBuffer = null;
                }

                for (const ib in this._instancedBuffers) {
                  this._instancedBuffers[ib].destroy();
                }

                for (const bb in this._batchedBuffers) {
                  this._batchedBuffers[bb].destroy();
                }

                this._descriptorSet.destroy();

                this._rs.destroy();

                this._dss.destroy();

                this._bs.destroy();

                this._destroy();
              }

              resetUniform(name) {
                const handle = this.getHandle(name);

                if (!handle) {
                  return;
                }

                const type = Pass.getTypeFromHandle(handle);
                const binding = Pass.getBindingFromHandle(handle);
                const ofs = Pass.getOffsetFromHandle(handle);
                const count = Pass.getCountFromHandle(handle);

                const block = this._getBlockView(type, binding);

                const info = this._properties[name];
                const givenDefault = info && info.value;
                const value = givenDefault || getDefaultFromType(type);
                const size = (GetTypeSize(type) >> 2) * count;

                for (let k = 0; k + value.length <= size; k += value.length) {
                  block.set(value, ofs + k);
                }

                this._setRootBufferDirty(true);
              }

              resetTexture(name, index) {
                const handle = this.getHandle(name);

                if (!handle) {
                  return;
                }

                const type = Pass.getTypeFromHandle(handle);
                const binding = Pass.getBindingFromHandle(handle);
                const info = this._properties[name];
                const value = info && info.value;
                const texName = value ? `${value}-texture` : getDefaultFromType(type);
                const textureBase = builtinResMgr.get(texName);
                const texture = textureBase && textureBase.getGFXTexture();
                const samplerInfo = info && info.samplerHash !== undefined ? Sampler.unpackFromHash(info.samplerHash) : textureBase && textureBase.getSamplerInfo();

                const sampler = this._device.getSampler(samplerInfo);

                this._descriptorSet.bindSampler(binding, sampler, index);

                this._descriptorSet.bindTexture(binding, texture, index);
              }

              resetUBOs() {
                for (let i = 0; i < this._shaderInfo.blocks.length; i++) {
                  const u = this._shaderInfo.blocks[i];
                  let ofs = 0;

                  for (let j = 0; j < u.members.length; j++) {
                    const cur = u.members[j];

                    const block = this._getBlockView(cur.type, u.binding);

                    const info = this._properties[cur.name];
                    const givenDefault = info && info.value;
                    const value = givenDefault || getDefaultFromType(cur.type);
                    const size = (GetTypeSize(cur.type) >> 2) * cur.count;

                    for (let k = 0; k + value.length <= size; k += value.length) {
                      block.set(value, ofs + k);
                    }

                    ofs += size;
                  }
                }

                this._setRootBufferDirty(true);
              }

              resetTextures() {
                for (let i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
                  const u = this._shaderInfo.samplerTextures[i];

                  for (let j = 0; j < u.count; j++) {
                    this.resetTexture(u.name, j);
                  }
                }
              }

              tryCompile() {
                const {
                  pipeline
                } = this._root;

                if (!pipeline) {
                  return false;
                }

                this._syncBatchingScheme();

                const shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

                if (!shader) {
                  console.warn(`create shader ${this._programName} failed`);
                  return false;
                }

                this._shader = shader;

                this._setPipelineLayout(programLib.getTemplateInfo(this._programName).pipelineLayout);

                this._setHash(Pass.getPassHash(this));

                return true;
              }

              getShaderVariant(patches = null) {
                if (!this._shader && !this.tryCompile()) {
                  console.warn('pass resources incomplete');
                  return null;
                }

                if (!patches) {
                  return this._shader;
                }

                const {
                  pipeline
                } = this._root;

                for (let i = 0; i < patches.length; i++) {
                  const patch = patches[i];
                  this._defines[patch.name] = patch.value;
                }

                const shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

                for (let i = 0; i < patches.length; i++) {
                  const patch = patches[i];
                  delete this._defines[patch.name];
                }

                return shader;
              }

              beginChangeStatesSilently() {}

              endChangeStatesSilently() {}

              _setPriority(val) {
                this._priority = val;

                {
                  this._nativePriority[0] = val;
                }
              }

              _setStage(val) {
                this._stage = val;

                {
                  this._nativeStage[0] = val;
                }
              }

              _setPhase(val) {
                this._phase = val;

                {
                  this._nativePhase[0] = val;
                }
              }

              _setPrimitive(val) {
                this._primitive = val;

                {
                  this._nativePrimitive[0] = val;
                }
              }

              _setState(bs, dss, rs, ds) {
                this._bs = bs;
                this._dss = dss;
                this._rs = rs;
                this._descriptorSet = ds;

                {
                  this._nativeObj.blendState = bs.native;
                  this._nativeObj.depthStencilState = dss.native;
                  this._nativeObj.rasterizerState = rs.native;
                  this._nativeObj.descriptorSet = ds;
                }
              }

              _doInit(info, copyDefines = false) {
                this._initNative();

                this._setPriority(RenderPriority.DEFAULT);

                this._setStage(RenderPassStage.DEFAULT);

                this._setPhase(getPhaseID('default'));

                this._setPrimitive(PrimitiveMode.TRIANGLE_LIST);

                this._passIndex = info.passIndex;
                this._propertyIndex = info.propertyIndex !== undefined ? info.propertyIndex : info.passIndex;
                this._programName = info.program;
                this._defines = copyDefines ? { ...info.defines
                } : info.defines;
                this._shaderInfo = programLib.getTemplate(info.program);
                this._properties = info.properties || this._properties;
                const device = this._device;
                Pass.fillPipelineInfo(this, info);

                if (info.stateOverrides) {
                  Pass.fillPipelineInfo(this, info.stateOverrides);
                }

                _dsInfo.layout = programLib.getDescriptorSetLayout(this._device, info.program);
                this._descriptorSet = this._device.createDescriptorSet(_dsInfo);

                this._setState(this._bs, this._dss, this._rs, this._descriptorSet);

                const blocks = this._shaderInfo.blocks;
                const tmplInfo = programLib.getTemplateInfo(info.program);
                const {
                  blockSizes,
                  handleMap
                } = tmplInfo;
                const alignment = device.capabilities.uboOffsetAlignment;
                const startOffsets = [];
                let lastSize = 0;
                let lastOffset = 0;

                for (let i = 0; i < blocks.length; i++) {
                  const size = blockSizes[i];
                  startOffsets.push(lastOffset);
                  lastOffset += Math.ceil(size / alignment) * alignment;
                  lastSize = size;
                }

                const totalSize = startOffsets[startOffsets.length - 1] + lastSize;

                if (totalSize) {
                  _bufferInfo.size = Math.ceil(totalSize / 16) * 16;
                  this._rootBuffer = device.createBuffer(_bufferInfo);
                  this._rootBlock = new ArrayBuffer(totalSize);

                  {
                    this._nativeObj.setRootBufferAndBlock(this._rootBuffer, this._rootBlock);
                  }
                }

                for (let i = 0, count = 0; i < blocks.length; i++) {
                  const {
                    binding
                  } = blocks[i];
                  const size = blockSizes[i];
                  _bufferViewInfo.buffer = this._rootBuffer;
                  _bufferViewInfo.offset = startOffsets[count++];
                  _bufferViewInfo.range = Math.ceil(size / 16) * 16;
                  const bufferView = this._buffers[binding] = device.createBuffer(_bufferViewInfo);
                  this._blocks[binding] = new Float32Array(this._rootBlock, _bufferViewInfo.offset, size / Float32Array.BYTES_PER_ELEMENT);
                  this._blocksInt[binding] = new Int32Array(this._blocks[binding].buffer, this._blocks[binding].byteOffset, this._blocks[binding].length);

                  this._descriptorSet.bindBuffer(binding, bufferView);
                }

                const directHandleMap = this._propertyHandleMap = handleMap;
                const indirectHandleMap = {};

                for (const name in this._properties) {
                  const prop = this._properties[name];

                  if (!prop.handleInfo) {
                    continue;
                  }

                  indirectHandleMap[name] = this.getHandle.apply(this, prop.handleInfo);
                }

                Object.assign(directHandleMap, indirectHandleMap);
              }

              _syncBatchingScheme() {
                if (this._defines.USE_INSTANCING) {
                  if (this._device.hasFeature(Feature$1.INSTANCED_ARRAYS)) {
                    this._setBatchingScheme(BatchingSchemes.INSTANCING);
                  } else {
                    this._defines.USE_INSTANCING = false;

                    this._setBatchingScheme(BatchingSchemes.NONE);
                  }
                } else if (this._defines.USE_BATCHING) {
                  this._setBatchingScheme(BatchingSchemes.VB_MERGING);
                } else {
                  this._setBatchingScheme(BatchingSchemes.NONE);
                }
              }

              _setBatchingScheme(val) {
                this._batchingScheme = val;

                {
                  this._nativeBatchingScheme[0] = val;
                }
              }

              _setDynamicState(val) {
                this._dynamicStates = val;

                {
                  this._nativeDynamicStates[0] = val;
                }
              }

              _setHash(val) {
                this._hash = val;

                {
                  this._nativeHash[0] = val;
                }
              }

              _getBlockView(type, binding) {
                return type < Type.FLOAT ? this._blocksInt[binding] : this._blocks[binding];
              }

              _setPipelineLayout(pipelineLayout) {
                this._pipelineLayout = pipelineLayout;

                {
                  this._nativeObj.setPipelineLayout(pipelineLayout);
                }
              }

              _initPassFromTarget(target, dss, bs, hashFactor) {
                this._initNative();

                this._setPriority(target.priority);

                this._setStage(target.stage);

                this._setPhase(target.phase);

                this._setBatchingScheme(target.batchingScheme);

                this._setPrimitive(target.primitive);

                this._setDynamicState(target.dynamicStates);

                this._setState(bs, dss, target.rasterizerState, target.descriptorSet);

                this._passIndex = target.passIndex;
                this._propertyIndex = target.propertyIndex;
                this._programName = target.program;
                this._defines = target.defines;
                this._shaderInfo = target._shaderInfo;
                this._properties = target._properties;
                this._blocks = target._blocks;
                this._blocksInt = target._blocksInt;
                this._dynamics = target._dynamics;
                this._shader = target._shader;

                this._setPipelineLayout(programLib.getTemplateInfo(this._programName).pipelineLayout);

                this._setHash(target._hash ^ hashFactor);
              }

              get root() {
                return this._root;
              }

              get device() {
                return this._device;
              }

              get shaderInfo() {
                return this._shaderInfo;
              }

              get localSetLayout() {
                return programLib.getDescriptorSetLayout(this._device, this._programName, true);
              }

              get program() {
                return this._programName;
              }

              get properties() {
                return this._properties;
              }

              get defines() {
                return this._defines;
              }

              get passIndex() {
                return this._passIndex;
              }

              get propertyIndex() {
                return this._propertyIndex;
              }

              get dynamics() {
                return this._dynamics;
              }

              get blocks() {
                return this._blocks;
              }

              get blocksInt() {
                return this._blocksInt;
              }

              get rootBufferDirty() {
                return this._rootBufferDirty;
              }

              get priority() {
                return this._priority;
              }

              get primitive() {
                return this._primitive;
              }

              get stage() {
                return this._stage;
              }

              get phase() {
                return this._phase;
              }

              get rasterizerState() {
                return this._rs;
              }

              get depthStencilState() {
                return this._dss;
              }

              get blendState() {
                return this._bs;
              }

              get dynamicStates() {
                return this._dynamicStates;
              }

              get batchingScheme() {
                return this._batchingScheme;
              }

              get descriptorSet() {
                return this._descriptorSet;
              }

              get hash() {
                return this._hash;
              }

              get pipelineLayout() {
                return this._pipelineLayout;
              }

            } exports('di', Pass);
            Pass.getTypeFromHandle = getTypeFromHandle;
            Pass.getBindingFromHandle = getBindingFromHandle;
            Pass.getCountFromHandle = getCountFromHandle;
            Pass.getOffsetFromHandle = getOffsetFromHandle;

            function serializeBlendState(bs) {
              let res = `,bs,${bs.isA2C}`;

              for (const t of bs.targets) {
                res += `,bt,${t.blend},${t.blendEq},${t.blendAlphaEq},${t.blendColorMask}`;
                res += `,${t.blendSrc},${t.blendDst},${t.blendSrcAlpha},${t.blendDstAlpha}`;
              }

              return res;
            }

            function serializeRasterizerState(rs) {
              return `,rs,${rs.cullMode},${rs.depthBias},${rs.isFrontFaceCCW}`;
            }

            function serializeDepthStencilState(dss) {
              let res = `,dss,${dss.depthTest},${dss.depthWrite},${dss.depthFunc}`;
              res += `,${dss.stencilTestFront},${dss.stencilFuncFront},${dss.stencilRefFront},${dss.stencilReadMaskFront}`;
              res += `,${dss.stencilFailOpFront},${dss.stencilZFailOpFront},${dss.stencilPassOpFront},${dss.stencilWriteMaskFront}`;
              res += `,${dss.stencilTestBack},${dss.stencilFuncBack},${dss.stencilRefBack},${dss.stencilReadMaskBack}`;
              res += `,${dss.stencilFailOpBack},${dss.stencilZFailOpBack},${dss.stencilPassOpBack},${dss.stencilWriteMaskBack}`;
              return res;
            }

            const _dsInfo$1 = new DescriptorSetInfo(null);

            const MAX_PASS_COUNT = 8;
            class SubModel {
              constructor() {
                this._device = null;
                this._passes = null;
                this._shaders = null;
                this._subMesh = null;
                this._patches = null;
                this._priority = RenderPriority.DEFAULT;
                this._inputAssembler = null;
                this._descriptorSet = null;
                this._worldBoundDescriptorSet = null;
                this._planarInstanceShader = null;
                this._planarShader = null;
                this._reflectionTex = null;
                this._reflectionSampler = null;
              }

              _destroyDescriptorSet() {
                this._descriptorSet.destroy();

                {
                  this._nativeObj.setDescriptorSet(null);
                }

                this._descriptorSet = null;
              }

              _destroyWorldBoundDescriptorSet() {
                this._worldBoundDescriptorSet.destroy();

                {
                  this._nativeObj.setWorldBoundDescriptorSet(null);
                }

                this._worldBoundDescriptorSet = null;
              }

              _destroyInputAssembler() {
                this._inputAssembler.destroy();

                {
                  this._nativeObj.setInputAssembler(null);
                }

                this._inputAssembler = null;
              }

              _createDescriptorSet(descInfo) {
                this._descriptorSet = this._device.createDescriptorSet(descInfo);

                {
                  this._nativeObj.setDescriptorSet(this._descriptorSet);
                }
              }

              _createWorldBoundDescriptorSet(descInfo) {
                this._worldBoundDescriptorSet = this._device.createDescriptorSet(descInfo);

                {
                  this._nativeObj.setWorldBoundDescriptorSet(this._worldBoundDescriptorSet);
                }
              }

              set passes(passes) {
                const passLengh = passes.length;

                if (passLengh > MAX_PASS_COUNT) {
                  errorID(12004, MAX_PASS_COUNT);
                  return;
                }

                this._passes = passes;

                this._flushPassInfo();

                if (this._passes[0].batchingScheme === BatchingSchemes.VB_MERGING) {
                  this.subMesh.genFlatBuffers();

                  this._setSubMesh(this.subMesh);
                }

                if (this._descriptorSet) {
                  this._destroyDescriptorSet();

                  _dsInfo$1.layout = passes[0].localSetLayout;

                  this._createDescriptorSet(_dsInfo$1);
                }
              }

              get passes() {
                return this._passes;
              }

              get shaders() {
                return this._shaders;
              }

              set subMesh(subMesh) {
                this._inputAssembler.destroy();

                this._inputAssembler.initialize(subMesh.iaInfo);

                if (this._passes[0].batchingScheme === BatchingSchemes.VB_MERGING) {
                  this.subMesh.genFlatBuffers();
                }

                this._setSubMesh(subMesh);
              }

              get subMesh() {
                return this._subMesh;
              }

              set priority(val) {
                this._priority = val;

                {
                  this._nativeObj.setPriority(val);
                }
              }

              get priority() {
                return this._priority;
              }

              get inputAssembler() {
                return this._inputAssembler;
              }

              get descriptorSet() {
                return this._descriptorSet;
              }

              get worldBoundDescriptorSet() {
                return this._worldBoundDescriptorSet;
              }

              get patches() {
                return this._patches;
              }

              get planarInstanceShader() {
                return this._planarInstanceShader;
              }

              get planarShader() {
                return this._planarShader;
              }

              _setInputAssembler(iaInfo) {
                this._inputAssembler = this._device.createInputAssembler(iaInfo);

                {
                  this._nativeObj.setInputAssembler(this._inputAssembler);
                }
              }

              _setSubMesh(subMesh) {
                this._subMesh = subMesh;

                {
                  this._nativeObj.setSubMeshBuffers(subMesh.flatBuffers);
                }
              }

              get native() {
                return this._nativeObj;
              }

              _init() {
                {
                  this._nativeObj = new NativeSubModel();
                }
              }

              initialize(subMesh, passes, patches = null) {
                const root = legacyCC.director.root;
                this._device = root.device;
                _dsInfo$1.layout = passes[0].localSetLayout;

                this._init();

                this._setInputAssembler(subMesh.iaInfo);

                this._createDescriptorSet(_dsInfo$1);

                const pipeline = legacyCC.director.root.pipeline;
                const occlusionPass = pipeline.pipelineSceneData.getOcclusionQueryPass();
                const occlusionDSInfo = new DescriptorSetInfo(null);
                occlusionDSInfo.layout = occlusionPass.localSetLayout;

                this._createWorldBoundDescriptorSet(occlusionDSInfo);

                this._setSubMesh(subMesh);

                this._patches = patches;
                this._passes = passes;

                this._flushPassInfo();

                if (passes[0].batchingScheme === BatchingSchemes.VB_MERGING) {
                  this.subMesh.genFlatBuffers();

                  this._setSubMesh(this.subMesh);
                }

                this.priority = RenderPriority.DEFAULT;

                if (passes[0].phase === getPhaseID('reflection')) {
                  let texWidth = root.mainWindow.width;
                  let texHeight = root.mainWindow.height;
                  const minSize = 512;

                  if (texHeight < texWidth) {
                    texWidth = minSize * texWidth / texHeight;
                    texHeight = minSize;
                  } else {
                    texWidth = minSize;
                    texHeight = minSize * texHeight / texWidth;
                  }

                  this._reflectionTex = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.STORAGE | TextureUsageBit.TRANSFER_SRC | TextureUsageBit.SAMPLED, Format.RGBA8, texWidth, texHeight));
                  this.descriptorSet.bindTexture(UNIFORM_REFLECTION_TEXTURE_BINDING, this._reflectionTex);
                  this._reflectionSampler = this._device.getSampler(new SamplerInfo(Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP));
                  this.descriptorSet.bindSampler(UNIFORM_REFLECTION_TEXTURE_BINDING, this._reflectionSampler);
                  this.descriptorSet.bindTexture(UNIFORM_REFLECTION_STORAGE_BINDING, this._reflectionTex);
                }
              }

              _initNativePlanarShadowShader(shadowInfo) {
                this._planarShader = shadowInfo.getPlanarShader(this._patches);

                {
                  this._nativeObj.setPlanarShader(this._planarShader);
                }
              }

              initPlanarShadowShader() {
                const pipeline = legacyCC.director.root.pipeline;
                const shadowInfo = pipeline.pipelineSceneData.shadows;

                this._initNativePlanarShadowShader(shadowInfo);
              }

              _initNativePlanarShadowInstanceShader(shadowInfo) {
                this._planarInstanceShader = shadowInfo.getPlanarInstanceShader(this._patches);

                {
                  this._nativeObj.setPlanarInstanceShader(this._planarInstanceShader);
                }
              }

              initPlanarShadowInstanceShader() {
                const pipeline = legacyCC.director.root.pipeline;
                const shadowInfo = pipeline.pipelineSceneData.shadows;

                this._initNativePlanarShadowInstanceShader(shadowInfo);
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroyDescriptorSet();

                this._destroyWorldBoundDescriptorSet();

                this._destroyInputAssembler();

                this.priority = RenderPriority.DEFAULT;
                this._patches = null;
                this._subMesh = null;
                this._passes = null;
                this._shaders = null;
                if (this._reflectionTex) this._reflectionTex.destroy();
                this._reflectionTex = null;
                this._reflectionSampler = null;

                this._destroy();
              }

              update() {
                for (let i = 0; i < this._passes.length; ++i) {
                  const pass = this._passes[i];
                  pass.update();
                }

                this._descriptorSet.update();

                this._worldBoundDescriptorSet.update();
              }

              onPipelineStateChanged() {
                const passes = this._passes;

                if (!passes) {
                  return;
                }

                for (let i = 0; i < passes.length; i++) {
                  const pass = passes[i];
                  pass.beginChangeStatesSilently();
                  pass.tryCompile();
                  pass.endChangeStatesSilently();
                }

                this._flushPassInfo();
              }

              onMacroPatchesStateChanged(patches) {
                this._patches = patches;
                const passes = this._passes;

                if (!passes) {
                  return;
                }

                for (let i = 0; i < passes.length; i++) {
                  const pass = passes[i];
                  pass.beginChangeStatesSilently();
                  pass.tryCompile();
                  pass.endChangeStatesSilently();
                }

                this._flushPassInfo();
              }

              _flushPassInfo() {
                const passes = this._passes;

                if (!passes) {
                  return;
                }

                if (!this._shaders) {
                  this._shaders = [];
                }

                this._shaders.length = passes.length;

                for (let i = 0, len = passes.length; i < len; i++) {
                  this._shaders[i] = passes[i].getShaderVariant(this.patches);
                }

                {
                  const passesNative = passes.map(_pass => _pass.native);

                  this._nativeObj.setPasses(passesNative);

                  this._nativeObj.setShaders(this._shaders);
                }
              }

            }

            const m4_1 = new Mat4();
            const shadowMapPatches = [{
              name: 'CC_ENABLE_DIR_SHADOW',
              value: true
            }, {
              name: 'CC_RECEIVE_SHADOW',
              value: true
            }];
            let ModelType;

            (function (ModelType) {
              ModelType[ModelType["DEFAULT"] = 0] = "DEFAULT";
              ModelType[ModelType["SKINNING"] = 1] = "SKINNING";
              ModelType[ModelType["BAKED_SKINNING"] = 2] = "BAKED_SKINNING";
              ModelType[ModelType["BATCH_2D"] = 3] = "BATCH_2D";
              ModelType[ModelType["PARTICLE_BATCH"] = 4] = "PARTICLE_BATCH";
              ModelType[ModelType["LINE"] = 5] = "LINE";
            })(ModelType || (ModelType = exports('cJ', {})));

            function uploadMat4AsVec4x3(mat, v1, v2, v3) {
              v1[0] = mat.m00;
              v1[1] = mat.m01;
              v1[2] = mat.m02;
              v1[3] = mat.m12;
              v2[0] = mat.m04;
              v2[1] = mat.m05;
              v2[2] = mat.m06;
              v2[3] = mat.m13;
              v3[0] = mat.m08;
              v3[1] = mat.m09;
              v3[2] = mat.m10;
              v3[3] = mat.m14;
            }

            const lightmapSamplerHash = new SamplerInfo(Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);
            const lightmapSamplerWithMipHash = new SamplerInfo(Filter.LINEAR, Filter.LINEAR, Filter.LINEAR, Address.CLAMP, Address.CLAMP, Address.CLAMP);
            class Model {
              get subModels() {
                return this._subModels;
              }

              get inited() {
                return this._inited;
              }

              get worldBounds() {
                return this._worldBounds;
              }

              get modelBounds() {
                return this._modelBounds;
              }

              get localBuffer() {
                return this._localBuffer;
              }

              get worldBoundBuffer() {
                return this._worldBoundBuffer;
              }

              get updateStamp() {
                return this._updateStamp;
              }

              get isInstancingEnabled() {
                return this._instMatWorldIdx >= 0;
              }

              get receiveShadow() {
                return this._receiveShadow;
              }

              set receiveShadow(val) {
                this._setReceiveShadow(val);

                this.onMacroPatchesStateChanged();
              }

              get castShadow() {
                return this._castShadow;
              }

              set castShadow(val) {
                this._castShadow = val;

                {
                  this._nativeObj.setCastShadow(val);
                }
              }

              get node() {
                return this._node;
              }

              set node(n) {
                this._node = n;

                {
                  this._nativeObj.setNode(n.native);
                }
              }

              get transform() {
                return this._transform;
              }

              set transform(n) {
                this._transform = n;

                {
                  this._nativeObj.setTransform(n.native);
                }
              }

              get visFlags() {
                return this._visFlags;
              }

              set visFlags(val) {
                this._visFlags = val;

                {
                  this._nativeObj.seVisFlag(val);
                }
              }

              get enabled() {
                return this._enabled;
              }

              set enabled(val) {
                this._enabled = val;

                {
                  this._nativeObj.setEnabled(val);
                }
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this.type = ModelType.DEFAULT;
                this.scene = null;
                this.isDynamicBatching = false;
                this.instancedAttributes = {
                  buffer: null,
                  views: [],
                  attributes: []
                };
                this._worldBounds = null;
                this._modelBounds = null;
                this._subModels = [];
                this._node = null;
                this._transform = null;
                this._device = void 0;
                this._inited = false;
                this._descriptorSetCount = 1;
                this._updateStamp = -1;
                this._localDataUpdated = true;
                this._localData = new Float32Array(UBOLocal.COUNT);
                this._localBuffer = null;
                this._instMatWorldIdx = -1;
                this._lightmap = null;
                this._lightmapUVParam = new Vec4();
                this._worldBoundBuffer = null;
                this._receiveShadow = false;
                this._castShadow = false;
                this._enabled = true;
                this._visFlags = Layers.Enum.NONE;
                this._device = legacyCC.director.root.device;
              }

              _setReceiveShadow(val) {
                this._receiveShadow = val;

                {
                  this._nativeObj.setReceiveShadow(val);
                }
              }

              _init() {
                {
                  this._nativeObj = new NativeModel();
                }
              }

              initialize() {
                if (this._inited) {
                  return;
                }

                this._init();

                this._setReceiveShadow(true);

                this.castShadow = false;
                this.enabled = true;
                this.visFlags = Layers.Enum.NONE;
                this._inited = true;
              }

              _destroySubmodel(subModel) {
                subModel.destroy();
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                const subModels = this._subModels;

                for (let i = 0; i < subModels.length; i++) {
                  const subModel = this._subModels[i];

                  this._destroySubmodel(subModel);
                }

                if (this._localBuffer) {
                  this._localBuffer.destroy();

                  this._localBuffer = null;
                }

                if (this._worldBoundBuffer) {
                  this._worldBoundBuffer.destroy();

                  this._worldBoundBuffer = null;
                }

                this._worldBounds = null;
                this._modelBounds = null;
                this._subModels.length = 0;
                this._inited = false;
                this._localDataUpdated = true;
                this._transform = null;
                this._node = null;
                this.isDynamicBatching = false;

                this._destroy();
              }

              attachToScene(scene) {
                this.scene = scene;
                this._localDataUpdated = true;
              }

              detachFromScene() {
                this.scene = null;
              }

              updateTransform(stamp) {
                const node = this.transform;

                if (node.hasChangedFlags || node._dirtyFlags) {
                  node.updateWorldTransform();
                  this._localDataUpdated = true;
                  const worldBounds = this._worldBounds;

                  if (this._modelBounds && worldBounds) {
                    this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                  }
                }
              }

              updateWorldBound() {
                const node = this.transform;

                if (node !== null) {
                  node.updateWorldTransform();
                  this._localDataUpdated = true;
                  const worldBounds = this._worldBounds;

                  if (this._modelBounds && worldBounds) {
                    this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                  }
                }
              }

              _applyLocalData() {
              }

              _applyLocalBuffer() {
                {
                  this._nativeObj.setLocalBuffer(this._localBuffer);
                }
              }

              _applyWorldBoundBuffer() {
                {
                  this._nativeObj.setWorldBoundBuffer(this._worldBoundBuffer);
                }
              }

              updateUBOs(stamp) {
                const subModels = this._subModels;

                for (let i = 0; i < subModels.length; i++) {
                  subModels[i].update();
                }

                this._updateStamp = stamp;

                if (!this._localDataUpdated) {
                  return;
                }

                this._localDataUpdated = false;
                const worldMatrix = this.transform._mat;
                const idx = this._instMatWorldIdx;

                if (idx >= 0) {
                  const attrs = this.instancedAttributes.views;
                  uploadMat4AsVec4x3(worldMatrix, attrs[idx], attrs[idx + 1], attrs[idx + 2]);
                } else if (this._localBuffer) {
                  Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
                  Mat4.inverseTranspose(m4_1, worldMatrix);

                  Mat4.toArray(this._localData, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET);

                  this._localBuffer.update(this._localData);

                  this._applyLocalData();

                  this._applyLocalBuffer();
                }
              }

              _updateNativeBounds() {
                {
                  this._nativeObj.setBounds(this._worldBounds.native);
                }
              }

              createBoundingShape(minPos, maxPos) {
                if (!minPos || !maxPos) {
                  return;
                }

                this._modelBounds = AABB.fromPoints(AABB.create(), minPos, maxPos);
                this._worldBounds = AABB.clone(this._modelBounds);

                this._updateNativeBounds();
              }

              _createSubModel() {
                return new SubModel();
              }

              initSubModel(idx, subMeshData, mat) {
                this.initialize();

                if (this._subModels[idx] == null) {
                  this._subModels[idx] = this._createSubModel();
                } else {
                  this._subModels[idx].destroy();
                }

                this._subModels[idx].initialize(subMeshData, mat.passes, this.getMacroPatches(idx));

                this._subModels[idx].initPlanarShadowShader();

                this._subModels[idx].initPlanarShadowInstanceShader();

                this._updateAttributesAndBinding(idx);

                {
                  this._nativeObj.setSubModel(idx, this._subModels[idx].native);
                }
              }

              setSubModelMesh(idx, subMesh) {
                if (!this._subModels[idx]) {
                  return;
                }

                this._subModels[idx].subMesh = subMesh;
              }

              setSubModelMaterial(idx, mat) {
                if (!this._subModels[idx]) {
                  return;
                }

                this._subModels[idx].passes = mat.passes;

                this._updateAttributesAndBinding(idx);
              }

              onGlobalPipelineStateChanged() {
                const subModels = this._subModels;

                for (let i = 0; i < subModels.length; i++) {
                  subModels[i].onPipelineStateChanged();
                }
              }

              onMacroPatchesStateChanged() {
                const subModels = this._subModels;

                for (let i = 0; i < subModels.length; i++) {
                  subModels[i].onMacroPatchesStateChanged(this.getMacroPatches(i));
                }
              }

              updateLightingmap(texture, uvParam) {
                Vec4.toArray(this._localData, uvParam, UBOLocal.LIGHTINGMAP_UVPARAM);
                this._localDataUpdated = true;
                this._lightmap = texture;
                this._lightmapUVParam = uvParam;

                if (texture === null) {
                  texture = builtinResMgr.get('empty-texture');
                }

                const gfxTexture = texture.getGFXTexture();

                if (gfxTexture) {
                  const sampler = this._device.getSampler(texture.mipmaps.length > 1 ? lightmapSamplerWithMipHash : lightmapSamplerHash);

                  const subModels = this._subModels;

                  for (let i = 0; i < subModels.length; i++) {
                    const {
                      descriptorSet
                    } = subModels[i];
                    descriptorSet.bindTexture(UNIFORM_LIGHTMAP_TEXTURE_BINDING, gfxTexture);
                    descriptorSet.bindSampler(UNIFORM_LIGHTMAP_TEXTURE_BINDING, sampler);
                    descriptorSet.update();
                  }

                  {
                    this._nativeObj.updateLightingmap(uvParam, sampler, gfxTexture);
                  }
                }
              }

              getMacroPatches(subModelIndex) {
                return this.receiveShadow ? shadowMapPatches : null;
              }

              _updateAttributesAndBinding(subModelIndex) {
                const subModel = this._subModels[subModelIndex];

                if (!subModel) {
                  return;
                }

                this._initLocalDescriptors(subModelIndex);

                this._updateLocalDescriptors(subModelIndex, subModel.descriptorSet);

                this._initWorldBoundDescriptors(subModelIndex);

                this._updateWorldBoundDescriptors(subModelIndex, subModel.worldBoundDescriptorSet);

                const shader = subModel.passes[0].getShaderVariant(subModel.patches);

                this._updateInstancedAttributes(shader.attributes, subModel.passes[0]);
              }

              _getInstancedAttributeIndex(name) {
                const {
                  attributes
                } = this.instancedAttributes;

                for (let i = 0; i < attributes.length; i++) {
                  if (attributes[i].name === name) {
                    return i;
                  }
                }

                return -1;
              }

              _setInstMatWorldIdx(idx) {
                this._instMatWorldIdx = idx;

                {
                  this._nativeObj.setInstMatWorldIdx(idx);
                }
              }

              _updateInstancedAttributes(attributes, pass) {
                if (!pass.device.hasFeature(Feature$1.INSTANCED_ARRAYS)) {
                  return;
                }

                let size = 0;

                for (let j = 0; j < attributes.length; j++) {
                  const attribute = attributes[j];

                  if (!attribute.isInstanced) {
                    continue;
                  }

                  size += FormatInfos[attribute.format].size;
                }

                const attrs = this.instancedAttributes;
                attrs.buffer = new Uint8Array(size);
                attrs.views.length = attrs.attributes.length = 0;
                let offset = 0;

                for (let j = 0; j < attributes.length; j++) {
                  const attribute = attributes[j];

                  if (!attribute.isInstanced) {
                    continue;
                  }

                  const attr = new Attribute();
                  attr.format = attribute.format;
                  attr.name = attribute.name;
                  attr.isNormalized = attribute.isNormalized;
                  attr.location = attribute.location;
                  attrs.attributes.push(attr);
                  const info = FormatInfos[attribute.format];
                  const typeViewArray = new (getTypedArrayConstructor(info))(attrs.buffer.buffer, offset, info.count);
                  attrs.views.push(typeViewArray);
                  offset += info.size;
                }

                if (pass.batchingScheme === BatchingSchemes.INSTANCING) {
                  pass.getInstancedBuffer().destroy();
                }

                this._setInstMatWorldIdx(this._getInstancedAttributeIndex(INST_MAT_WORLD));

                this._localDataUpdated = true;

                {
                  this._nativeObj.setInstancedAttrBlock(attrs.buffer.buffer, attrs.views, attrs.attributes);
                }
              }

              _initLocalDescriptors(subModelIndex) {
                if (!this._localBuffer) {
                  this._localBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));

                  this._applyLocalBuffer();
                }
              }

              _initWorldBoundDescriptors(subModelIndex) {
                if (!this._worldBoundBuffer) {
                  this._worldBoundBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOWorldBound.SIZE, UBOWorldBound.SIZE));

                  this._applyWorldBoundBuffer();
                }
              }

              _updateLocalDescriptors(subModelIndex, descriptorSet) {
                if (this._localBuffer) descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);
              }

              _updateWorldBoundDescriptors(subModelIndex, descriptorSet) {
                if (this._worldBoundBuffer) descriptorSet.bindBuffer(UBOWorldBound.BINDING, this._worldBoundBuffer);
              }

            } exports('bB', Model);

            let NodeSpace;

            (function (NodeSpace) {
              NodeSpace[NodeSpace["LOCAL"] = 0] = "LOCAL";
              NodeSpace[NodeSpace["WORLD"] = 1] = "WORLD";
            })(NodeSpace || (NodeSpace = {}));

            let TransformBit;

            (function (TransformBit) {
              TransformBit[TransformBit["NONE"] = 0] = "NONE";
              TransformBit[TransformBit["POSITION"] = 1] = "POSITION";
              TransformBit[TransformBit["ROTATION"] = 2] = "ROTATION";
              TransformBit[TransformBit["SCALE"] = 4] = "SCALE";
              TransformBit[TransformBit["RS"] = TransformBit.ROTATION | TransformBit.SCALE] = "RS";
              TransformBit[TransformBit["TRS"] = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS";
              TransformBit[TransformBit["TRS_MASK"] = ~TransformBit.TRS] = "TRS_MASK";
            })(TransformBit || (TransformBit = exports('bU', {})));

            legacyCC.internal.TransformBit = TransformBit;

            class RenderScene {
              get root() {
                return this._root;
              }

              get name() {
                return this._name;
              }

              get cameras() {
                return this._cameras;
              }

              get mainLight() {
                return this._mainLight;
              }

              get sphereLights() {
                return this._sphereLights;
              }

              get spotLights() {
                return this._spotLights;
              }

              get models() {
                return this._models;
              }

              get native() {
                return this._nativeObj;
              }

              get batches() {
                return this._batches;
              }

              static registerCreateFunc(root) {
                root._createSceneFun = _root => new RenderScene(_root);
              }

              constructor(root) {
                this._root = void 0;
                this._name = '';
                this._cameras = [];
                this._models = [];
                this._batches = [];
                this._directionalLights = [];
                this._sphereLights = [];
                this._spotLights = [];
                this._mainLight = null;
                this._modelId = 0;
                this._root = root;

                this._createNativeObject();
              }

              initialize(info) {
                this._name = info.name;
                return true;
              }

              activate() {
                {
                  this._nativeObj.activate();
                }
              }

              update(stamp) {
                {
                  const nativeBatches = [];

                  for (let i = 0, len = this._batches.length; i < len; ++i) {
                    nativeBatches.push(this._batches[i].native);
                  }

                  this._nativeObj.updateBatches(nativeBatches);

                  this._nativeObj.update(stamp);

                  return;
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this.removeCameras();
                this.removeSphereLights();
                this.removeSpotLights();
                this.removeModels();

                this._destroy();
              }

              addCamera(cam) {
                cam.attachToScene(this);

                this._cameras.push(cam);
              }

              removeCamera(camera) {
                for (let i = 0; i < this._cameras.length; ++i) {
                  if (this._cameras[i] === camera) {
                    this._cameras.splice(i, 1);

                    camera.detachFromScene();
                    return;
                  }
                }
              }

              removeCameras() {
                for (const camera of this._cameras) {
                  camera.detachFromScene();
                }

                this._cameras.splice(0);
              }

              setMainLight(dl) {
                this._mainLight = dl;

                {
                  this._nativeObj.setMainLight(dl ? dl.native : null);
                }
              }

              unsetMainLight(dl) {
                if (this._mainLight === dl) {
                  const dlList = this._directionalLights;

                  if (dlList.length) {
                    this.setMainLight(dlList[dlList.length - 1]);

                    if (this._mainLight.node) {
                      this._mainLight.node.hasChangedFlags |= TransformBit.ROTATION;
                    }

                    return;
                  }

                  this.setMainLight(null);
                }
              }

              addDirectionalLight(dl) {
                dl.attachToScene(this);

                this._directionalLights.push(dl);
              }

              removeDirectionalLight(dl) {
                for (let i = 0; i < this._directionalLights.length; ++i) {
                  if (this._directionalLights[i] === dl) {
                    dl.detachFromScene();

                    this._directionalLights.splice(i, 1);

                    return;
                  }
                }
              }

              addSphereLight(pl) {
                pl.attachToScene(this);

                this._sphereLights.push(pl);

                {
                  this._nativeObj.addSphereLight(pl.native);
                }
              }

              removeSphereLight(pl) {
                for (let i = 0; i < this._sphereLights.length; ++i) {
                  if (this._sphereLights[i] === pl) {
                    pl.detachFromScene();

                    this._sphereLights.splice(i, 1);

                    {
                      this._nativeObj.removeSphereLight(pl.native);
                    }

                    return;
                  }
                }
              }

              addSpotLight(sl) {
                sl.attachToScene(this);

                this._spotLights.push(sl);

                {
                  this._nativeObj.addSpotLight(sl.native);
                }
              }

              removeSpotLight(sl) {
                for (let i = 0; i < this._spotLights.length; ++i) {
                  if (this._spotLights[i] === sl) {
                    sl.detachFromScene();

                    this._spotLights.splice(i, 1);

                    {
                      this._nativeObj.removeSpotLight(sl.native);
                    }

                    return;
                  }
                }
              }

              removeSphereLights() {
                for (let i = 0; i < this._sphereLights.length; ++i) {
                  this._sphereLights[i].detachFromScene();
                }

                this._sphereLights.length = 0;

                {
                  this._nativeObj.removeSphereLights();
                }
              }

              removeSpotLights() {
                for (let i = 0; i < this._spotLights.length; ++i) {
                  this._spotLights[i].detachFromScene();
                }

                this._spotLights = [];

                {
                  this._nativeObj.removeSpotLights();
                }
              }

              addModel(m) {
                m.attachToScene(this);

                this._models.push(m);

                {
                  switch (m.type) {
                    case ModelType.SKINNING:
                      this._nativeObj.addSkinningModel(m.native);

                      break;

                    case ModelType.BAKED_SKINNING:
                      this._nativeObj.addBakedSkinningModel(m.native);

                      break;

                    case ModelType.DEFAULT:
                    default:
                      this._nativeObj.addModel(m.native);

                  }
                }
              }

              removeModel(model) {
                for (let i = 0; i < this._models.length; ++i) {
                  if (this._models[i] === model) {
                    model.detachFromScene();

                    this._models.splice(i, 1);

                    {
                      this._nativeObj.removeModel(i);
                    }

                    return;
                  }
                }
              }

              removeModels() {
                for (const m of this._models) {
                  m.detachFromScene();
                  m.destroy();
                }

                this._models.length = 0;

                {
                  this._nativeObj.removeModels();
                }
              }

              addBatch(batch) {
                this._batches.push(batch);
              }

              removeBatch(batch) {
                for (let i = 0; i < this._batches.length; ++i) {
                  if (this._batches[i] === batch) {
                    this._batches.splice(i, 1);

                    {
                      this._nativeObj.removeBatch(i);
                    }

                    return;
                  }
                }
              }

              removeBatches() {
                this._batches.length = 0;

                {
                  this._nativeObj.removeBatches();
                }
              }

              onGlobalPipelineStateChanged() {
                for (const m of this._models) {
                  m.onGlobalPipelineStateChanged();
                }
              }

              generateModelId() {
                return this._modelId++;
              }

              _createNativeObject() {
                if ( !this._nativeObj) {
                  this._nativeObj = new NativeRenderScene();
                }
              }

            }

            var _dec$g, _class$g, _class2$d, _descriptor$b, _descriptor2$7, _descriptor3$4, _descriptor4$3, _class3$7, _temp$d;
            let EffectAsset = exports('dL', (_dec$g = ccclass('cc.EffectAsset'), _dec$g(_class$g = (_class2$d = (_temp$d = _class3$7 = class EffectAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "techniques", _descriptor$b, this);

                _initializerDefineProperty(this, "shaders", _descriptor2$7, this);

                _initializerDefineProperty(this, "combinations", _descriptor3$4, this);

                _initializerDefineProperty(this, "hideInEditor", _descriptor4$3, this);
              }

              static register(asset) {
                EffectAsset._effects[asset.name] = asset;
              }

              static remove(asset) {
                if (typeof asset !== 'string') {
                  if (EffectAsset._effects[asset.name] && EffectAsset._effects[asset.name].equals(asset)) {
                    delete EffectAsset._effects[asset.name];
                  }
                } else {
                  if (EffectAsset._effects[asset]) {
                    delete EffectAsset._effects[asset];
                    return;
                  }

                  for (const n in EffectAsset._effects) {
                    if (EffectAsset._effects[n]._uuid === asset) {
                      delete EffectAsset._effects[n];
                      return;
                    }
                  }
                }
              }

              static get(name) {
                if (EffectAsset._effects[name]) {
                  return EffectAsset._effects[name];
                }

                for (const n in EffectAsset._effects) {
                  if (EffectAsset._effects[n]._uuid === name) {
                    return EffectAsset._effects[n];
                  }
                }

                return null;
              }

              static getAll() {
                return EffectAsset._effects;
              }

              onLoaded() {
                programLib.register(this);
                EffectAsset.register(this);

                {
                  legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this._precompile, this);
                }
              }

              _precompile() {
                const root = legacyCC.director.root;

                for (let i = 0; i < this.shaders.length; i++) {
                  const shader = this.shaders[i];
                  const combination = this.combinations[i];

                  if (!combination) {
                    continue;
                  }

                  const defines = Object.keys(combination).reduce((out, name) => out.reduce((acc, cur) => {
                    const choices = combination[name];

                    for (let i = 0; i < choices.length; ++i) {
                      const defines = { ...cur
                      };
                      defines[name] = choices[i];
                      acc.push(defines);
                    }

                    return acc;
                  }, []), [{}]);
                  defines.forEach(defines => programLib.getGFXShader(root.device, shader.name, defines, root.pipeline));
                }
              }

              destroy() {
                EffectAsset.remove(this);
                return super.destroy();
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                const effect = EffectAsset.get('unlit');
                this.name = 'unlit';
                this.shaders = effect.shaders;
                this.combinations = effect.combinations;
                this.techniques = effect.techniques;
              }

              validate() {
                return this.techniques.length > 0 && this.shaders.length > 0;
              }

            }, _class3$7._effects = {}, _temp$d), (_descriptor$b = _applyDecoratedDescriptor(_class2$d.prototype, "techniques", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$d.prototype, "shaders", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$d.prototype, "combinations", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$d.prototype, "hideInEditor", [serializable, editorOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class2$d)) || _class$g));
            legacyCC.EffectAsset = EffectAsset;

            class PipelineStateManager {
              static getOrCreatePipelineState(device, pass, shader, renderPass, ia) {
                const hash1 = pass.hash;
                const hash2 = renderPass.hash;
                const hash3 = ia.attributesHash;
                const hash4 = shader.typedID;
                const newHash = hash1 ^ hash2 ^ hash3 ^ hash4;

                let pso = this._PSOHashMap.get(newHash);

                if (!pso) {
                  const pipelineLayout = pass.pipelineLayout;
                  const inputState = new InputState(ia.attributes);
                  const psoInfo = new PipelineStateInfo$1(shader, pipelineLayout, renderPass, inputState, pass.rasterizerState, pass.depthStencilState, pass.blendState, pass.primitive, pass.dynamicStates);
                  pso = device.createPipelineState(psoInfo);

                  this._PSOHashMap.set(newHash, pso);
                }

                return pso;
              }

            }
            PipelineStateManager._PSOHashMap = new Map();

            function SRGBToLinear(out, gamma) {
              out.x = gamma.x * gamma.x;
              out.y = gamma.y * gamma.y;
              out.z = gamma.z * gamma.z;
            }
            function decideProfilerCamera(cameras) {
              for (let i = cameras.length - 1; i >= 0; --i) {
                const camera = cameras[i];

                if (camera.window.swapchain) {
                  return;
                }
              }
            }

            var _dec$h, _dec2$5, _class$h, _class2$e, _descriptor$c, _descriptor2$8, _descriptor3$5, _descriptor4$4, _descriptor5$2, _temp$e;
            const v4_1 = new Vec4();
            let Material = exports('c2', (_dec$h = ccclass('cc.Material'), _dec2$5 = type(EffectAsset), _dec$h(_class$h = (_class2$e = (_temp$e = class Material extends Asset {
              static getHash(material) {
                let hash = 0;

                for (const pass of material.passes) {
                  hash ^= pass.hash;
                }

                return hash;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_effectAsset", _descriptor$c, this);

                _initializerDefineProperty(this, "_techIdx", _descriptor2$8, this);

                _initializerDefineProperty(this, "_defines", _descriptor3$5, this);

                _initializerDefineProperty(this, "_states", _descriptor4$4, this);

                _initializerDefineProperty(this, "_props", _descriptor5$2, this);

                this._passes = [];
                this._hash = 0;
              }

              get effectAsset() {
                return this._effectAsset;
              }

              get effectName() {
                return this._effectAsset ? this._effectAsset.name : '';
              }

              get technique() {
                return this._techIdx;
              }

              get passes() {
                return this._passes;
              }

              get hash() {
                return this._hash;
              }

              get parent() {
                return null;
              }

              get owner() {
                return null;
              }

              initialize(info) {
                if (this._passes.length) {
                  warnID(12005);
                  return;
                }

                if (!this._defines) {
                  this._defines = [];
                }

                if (!this._states) {
                  this._states = [];
                }

                if (!this._props) {
                  this._props = [];
                }

                this._fillInfo(info);

                this._update();
              }

              reset(info) {
                this.initialize(info);
              }

              destroy() {
                this._doDestroy();

                return super.destroy();
              }

              recompileShaders(overrides, passIdx) {
                console.warn(`Shaders in material asset '${this.name}' cannot be modified at runtime, please instantiate the material first.`);
              }

              overridePipelineStates(overrides, passIdx) {
                console.warn(`Pipeline states in material asset '${this.name}' cannot be modified at runtime, please instantiate the material first.`);
              }

              onLoaded() {
                this._update();
              }

              resetUniforms(clearPasses = true) {
                this._props.length = this._passes.length;

                for (let i = 0; i < this._props.length; i++) {
                  this._props[i] = {};
                }

                if (!clearPasses) {
                  return;
                }

                for (const pass of this._passes) {
                  pass.resetUBOs();
                  pass.resetTextures();
                }
              }

              setProperty(name, val, passIdx) {
                let success = false;

                if (passIdx === undefined) {
                  const passes = this._passes;
                  const len = passes.length;

                  for (let i = 0; i < len; i++) {
                    const pass = passes[i];

                    if (this._uploadProperty(pass, name, val)) {
                      this._props[pass.propertyIndex][name] = val;
                      success = true;
                    }
                  }
                } else {
                  if (passIdx >= this._passes.length) {
                    console.warn(`illegal pass index: ${passIdx}.`);
                    return;
                  }

                  const pass = this._passes[passIdx];

                  if (this._uploadProperty(pass, name, val)) {
                    this._props[pass.propertyIndex][name] = val;
                    success = true;
                  }
                }

                if (!success) {
                  console.warn(`illegal property name: ${name}.`);
                }
              }

              getProperty(name, passIdx) {
                if (passIdx === undefined) {
                  const propsArray = this._props;
                  const len = propsArray.length;

                  for (let i = 0; i < len; i++) {
                    const props = propsArray[i];

                    if (name in props) {
                      return props[name];
                    }
                  }
                } else {
                  if (passIdx >= this._props.length) {
                    console.warn(`illegal pass index: ${passIdx}.`);
                    return null;
                  }

                  const props = this._props[this._passes[passIdx].propertyIndex];

                  if (name in props) {
                    return props[name];
                  }
                }

                return null;
              }

              copy(mat, overrides) {
                this._techIdx = mat._techIdx;
                this._props.length = mat._props.length;

                for (let i = 0; i < mat._props.length; i++) {
                  this._props[i] = { ...mat._props[i]
                  };
                }

                this._defines.length = mat._defines.length;

                for (let i = 0; i < mat._defines.length; i++) {
                  this._defines[i] = { ...mat._defines[i]
                  };
                }

                this._states.length = mat._states.length;

                for (let i = 0; i < mat._states.length; i++) {
                  this._states[i] = { ...mat._states[i]
                  };
                }

                this._effectAsset = mat._effectAsset;
                if (overrides) this._fillInfo(overrides);

                this._update();
              }

              _fillInfo(info) {
                if (info.technique !== undefined) {
                  this._techIdx = info.technique;
                }

                if (info.effectAsset) {
                  this._effectAsset = info.effectAsset;
                } else if (info.effectName) {
                  this._effectAsset = EffectAsset.get(info.effectName);
                }

                if (info.defines) {
                  this._prepareInfo(info.defines, this._defines);
                }

                if (info.states) {
                  this._prepareInfo(info.states, this._states);
                }
              }

              _prepareInfo(patch, cur) {
                let patchArray = patch;

                if (!Array.isArray(patchArray)) {
                  const len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                  patchArray = Array(len).fill(patchArray);
                }

                for (let i = 0; i < patchArray.length; ++i) {
                  Object.assign(cur[i] || (cur[i] = {}), patchArray[i]);
                }
              }

              _createPasses() {
                const tech = this._effectAsset.techniques[this._techIdx || 0];

                if (!tech) {
                  return [];
                }

                const passNum = tech.passes.length;
                const passes = [];

                for (let k = 0; k < passNum; ++k) {
                  const passInfo = tech.passes[k];
                  const propIdx = passInfo.passIndex = k;
                  const defines = passInfo.defines = this._defines[propIdx] || (this._defines[propIdx] = {});
                  passInfo.stateOverrides = this._states[propIdx] || (this._states[propIdx] = {});

                  if (passInfo.propertyIndex !== undefined) {
                    Object.assign(defines, this._defines[passInfo.propertyIndex]);
                  }

                  if (passInfo.embeddedMacros !== undefined) {
                    Object.assign(defines, passInfo.embeddedMacros);
                  }

                  if (passInfo.switch && !defines[passInfo.switch]) {
                    continue;
                  }

                  const pass = new Pass(legacyCC.director.root);
                  pass.initialize(passInfo);
                  passes.push(pass);
                }

                return passes;
              }

              _update(keepProps = true) {
                if (this._effectAsset) {
                  this._passes = this._createPasses();
                  const totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
                  this._props.length = totalPasses;

                  if (keepProps) {
                    this._passes.forEach((pass, i) => {
                      let props = this._props[i];

                      if (!props) {
                        props = this._props[i] = {};
                      }

                      if (pass.propertyIndex !== undefined) {
                        Object.assign(props, this._props[pass.propertyIndex]);
                      }

                      for (const p in props) {
                        this._uploadProperty(pass, p, props[p]);
                      }
                    });
                  } else {
                    for (let i = 0; i < this._props.length; i++) {
                      this._props[i] = {};
                    }
                  }
                }

                this._hash = Material.getHash(this);
              }

              _uploadProperty(pass, name, val) {
                const handle = pass.getHandle(name);

                if (!handle) {
                  return false;
                }

                const type = Pass.getTypeFromHandle(handle);

                if (type < Type.SAMPLER1D) {
                  if (Array.isArray(val)) {
                    pass.setUniformArray(handle, val);
                  } else if (val !== null) {
                    var _pass$properties$name;

                    if ((_pass$properties$name = pass.properties[name]) === null || _pass$properties$name === void 0 ? void 0 : _pass$properties$name.linear) {
                      const v4 = val;
                      SRGBToLinear(v4_1, v4);
                      v4_1.w = v4.w;
                      val = v4_1;
                    }

                    pass.setUniform(handle, val);
                  } else {
                    pass.resetUniform(name);
                  }
                } else if (Array.isArray(val)) {
                  for (let i = 0; i < val.length; i++) {
                    this._bindTexture(pass, handle, val[i], i);
                  }
                } else if (val) {
                  this._bindTexture(pass, handle, val);
                } else {
                  pass.resetTexture(name);
                }

                return true;
              }

              _bindTexture(pass, handle, val, index) {
                const binding = Pass.getBindingFromHandle(handle);

                if (val instanceof Texture) {
                  pass.bindTexture(binding, val, index);
                } else if (val instanceof TextureBase) {
                  const texture = val.getGFXTexture();

                  if (!texture || !texture.width || !texture.height) {
                    return;
                  }

                  pass.bindTexture(binding, texture, index);
                  pass.bindSampler(binding, val.getGFXSampler(), index);
                }
              }

              _doDestroy() {
                if (this._passes && this._passes.length) {
                  for (const pass of this._passes) {
                    pass.destroy();
                  }
                }

                this._passes.length = 0;
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this.initialize({
                  effectName: 'unlit',
                  defines: {
                    USE_COLOR: true
                  }
                });
                this.setProperty('mainColor', new Color('#ff00ff'));
              }

              validate() {
                return !!this._effectAsset && !this._effectAsset.isDefault && this.passes.length > 0;
              }

            }, _temp$e), (_descriptor$c = _applyDecoratedDescriptor(_class2$e.prototype, "_effectAsset", [_dec2$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$e.prototype, "_techIdx", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$e.prototype, "_defines", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$e.prototype, "_states", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$e.prototype, "_props", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$e)) || _class$h));
            legacyCC.Material = Material;

            const ShadowSize = Enum({
              Low_256x256: 256,
              Medium_512x512: 512,
              High_1024x1024: 1024,
              Ultra_2048x2048: 2048
            });
            const ShadowType = Enum({
              Planar: 0,
              ShadowMap: 1
            });
            const PCFType = Enum({
              HARD: 0,
              SOFT: 1,
              SOFT_2X: 2
            });
            const SHADOW_TYPE_NONE = ShadowType.ShadowMap + 1;
            class Shadows {
              get enabled() {
                return this._enabled;
              }

              set enabled(val) {
                this._setEnable(val);

                this.activate();
              }

              get normal() {
                return this._normal;
              }

              set normal(val) {
                Vec3.copy(this._normal, val);

                {
                  this._nativeObj.normal = this._normal;
                }
              }

              get distance() {
                return this._distance;
              }

              set distance(val) {
                this._distance = val;

                {
                  this._nativeObj.distance = val;
                }
              }

              get shadowColor() {
                return this._shadowColor;
              }

              set shadowColor(color) {
                this._shadowColor = color;

                {
                  this._nativeObj.color = color;
                }
              }

              get invisibleOcclusionRange() {
                return this._invisibleOcclusionRange;
              }

              set invisibleOcclusionRange(val) {
                this._invisibleOcclusionRange = val;

                {
                  this._nativeObj.invisibleOcclusionRange = val;
                }
              }

              get shadowDistance() {
                return this._shadowDistance;
              }

              set shadowDistance(val) {
                this._shadowDistance = val;

                {
                  this._nativeObj.shadowDistance = val;
                }
              }

              get type() {
                return this._type;
              }

              set type(val) {
                this._setType(val);

                this.activate();
              }

              get near() {
                return this._near;
              }

              set near(val) {
                this._near = val;

                {
                  this._nativeObj.nearValue = val;
                }
              }

              get far() {
                return this._far;
              }

              set far(val) {
                this._far = val;

                {
                  this._nativeObj.farValue = val;
                }
              }

              get orthoSize() {
                return this._orthoSize;
              }

              set orthoSize(val) {
                this._orthoSize = val;

                {
                  this._nativeObj.orthoSize = val;
                }
              }

              get size() {
                return this._size;
              }

              set size(val) {
                this._size.set(val);

                {
                  this._nativeObj.size = val;
                }
              }

              get pcf() {
                return this._pcf;
              }

              set pcf(val) {
                this._pcf = val;

                {
                  this._nativeObj.pcfType = val;
                }
              }

              get shadowMapDirty() {
                return this._shadowMapDirty;
              }

              set shadowMapDirty(val) {
                this._shadowMapDirty = val;

                {
                  this._nativeObj.shadowMapDirty = val;
                }
              }

              get bias() {
                return this._bias;
              }

              set bias(val) {
                this._bias = val;

                {
                  this._nativeObj.bias = val;
                }
              }

              get normalBias() {
                return this._normalBias;
              }

              set normalBias(val) {
                this._normalBias = val;

                {
                  this._nativeObj.normalBias = val;
                }
              }

              get saturation() {
                return this._saturation;
              }

              set saturation(val) {
                this._saturation = val;

                {
                  this._nativeObj.saturation = val;
                }
              }

              get fixedArea() {
                return this._fixedArea;
              }

              set fixedArea(val) {
                this._fixedArea = val;

                {
                  this._nativeObj.fixedArea = val;
                }
              }

              get matLight() {
                return this._matLight;
              }

              get material() {
                return this._material;
              }

              get instancingMaterial() {
                return this._instancingMaterial;
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this.fixedSphere = new Sphere(0.0, 0.0, 0.0, 0.01);
                this.maxReceived = 4;
                this.firstSetCSM = false;
                this.shadowCameraFar = 0;
                this.matShadowView = new Mat4();
                this.matShadowProj = new Mat4();
                this.matShadowViewProj = new Mat4();
                this._normal = new Vec3(0, 1, 0);
                this._shadowColor = new Color(0, 0, 0, 76);
                this._matLight = new Mat4();
                this._material = null;
                this._instancingMaterial = null;
                this._size = new Vec2(512, 512);
                this._enabled = false;
                this._distance = 0;
                this._type = SHADOW_TYPE_NONE;
                this._near = 0.1;
                this._far = 10;
                this._invisibleOcclusionRange = 200;
                this._shadowDistance = 100;
                this._orthoSize = 1;
                this._pcf = 0;
                this._shadowMapDirty = false;
                this._bias = 0;
                this._normalBias = 0;
                this._fixedArea = false;
                this._saturation = 0.75;

                {
                  this._nativeObj = new NativeShadow();
                }
              }

              getPlanarShader(patches) {
                if (!this._material) {
                  this._material = new Material();

                  this._material.initialize({
                    effectName: 'planar-shadow'
                  });

                  {
                    this._nativeObj.planarPass = this._material.passes[0].native;
                  }
                }

                return this._material.passes[0].getShaderVariant(patches);
              }

              getPlanarInstanceShader(patches) {
                if (!this._instancingMaterial) {
                  this._instancingMaterial = new Material();

                  this._instancingMaterial.initialize({
                    effectName: 'planar-shadow',
                    defines: {
                      USE_INSTANCING: true
                    }
                  });

                  {
                    this._nativeObj.instancePass = this._instancingMaterial.passes[0].native;
                  }
                }

                return this._instancingMaterial.passes[0].getShaderVariant(patches);
              }

              _setEnable(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                  if (!val) this._setType(SHADOW_TYPE_NONE);
                }
              }

              _setType(val) {
                this._type = this.enabled ? val : SHADOW_TYPE_NONE;

                {
                  this._nativeObj.shadowType = this._type;
                }
              }

              initialize(shadowsInfo) {
                this.near = shadowsInfo.near;
                this.far = shadowsInfo.far;
                this.invisibleOcclusionRange = shadowsInfo.invisibleOcclusionRange;
                this.shadowDistance = shadowsInfo.shadowDistance;
                this.orthoSize = shadowsInfo.orthoSize;
                this.size = shadowsInfo.size;
                this.pcf = shadowsInfo.pcf;
                this.normal = shadowsInfo.normal;
                this.distance = shadowsInfo.distance;
                this.shadowColor = shadowsInfo.shadowColor;
                this.bias = shadowsInfo.bias;
                this.normalBias = shadowsInfo.normalBias;
                this.maxReceived = shadowsInfo.maxReceived;
                this.fixedArea = shadowsInfo.fixedArea;

                this._setEnable(shadowsInfo.enabled);

                this._setType(shadowsInfo.type);

                this.saturation = shadowsInfo.saturation;
              }

              activate() {
                if (this.enabled) {
                  if (this.type === ShadowType.ShadowMap) {
                    this._updatePipeline();
                  } else {
                    this._updatePlanarInfo();
                  }
                } else {
                  const root = legacyCC.director.root;
                  const pipeline = root.pipeline;
                  pipeline.macros.CC_ENABLE_DIR_SHADOW = 0;
                  root.onGlobalPipelineStateChanged();
                }
              }

              _updatePlanarInfo() {
                if (!this._material) {
                  this._material = new Material();

                  this._material.initialize({
                    effectName: 'planar-shadow'
                  });

                  {
                    this._nativeObj.planarPass = this._material.passes[0].native;
                  }
                }

                if (!this._instancingMaterial) {
                  this._instancingMaterial = new Material();

                  this._instancingMaterial.initialize({
                    effectName: 'planar-shadow',
                    defines: {
                      USE_INSTANCING: true
                    }
                  });

                  {
                    this._nativeObj.instancePass = this._instancingMaterial.passes[0].native;
                  }
                }

                const root = legacyCC.director.root;
                const pipeline = root.pipeline;
                pipeline.macros.CC_ENABLE_DIR_SHADOW = 0;
                root.onGlobalPipelineStateChanged();
              }

              _updatePipeline() {
                const root = legacyCC.director.root;
                const pipeline = root.pipeline;
                pipeline.macros.CC_ENABLE_DIR_SHADOW = 1;
                root.onGlobalPipelineStateChanged();
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();

                if (this._material) {
                  this._material.destroy();
                }

                if (this._instancingMaterial) {
                  this._instancingMaterial.destroy();
                }

                this.fixedSphere.destroy();
              }

            }
            Shadows.MAX_FAR = 2000.0;
            Shadows.COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
            legacyCC.Shadows = Shadows;

            removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
              name: 'raycastUI2DNode'
            }, {
              name: 'raycastUINode'
            }]);
            removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
              name: 'raycastAll',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastAllModels',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastSingleModel',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastAllCanvas',
              suggest: 'using intersect.rayAABB in geometry'
            }, {
              name: 'rayResultCanvas'
            }, {
              name: 'rayResultModels'
            }, {
              name: 'rayResultAll'
            }, {
              name: 'rayResultSingleModel'
            }]);
            const CameraVisFlags = {};
            removeProperty(CameraVisFlags, 'CameraVisFlags', [{
              name: 'GENERAL'
            }]);
            replaceProperty(CameraVisFlags, 'CameraVisFlags', [{
              name: 'PROFILER',
              newName: 'PROFILER',
              target: Layers.BitMask,
              targetName: 'PROFILER'
            }, {
              name: 'GIZMOS',
              newName: 'GIZMOS',
              target: Layers.BitMask,
              targetName: 'GIZMOS'
            }, {
              name: 'EDITOR',
              newName: 'EDITOR',
              target: Layers.BitMask,
              targetName: 'EDITOR'
            }, {
              name: 'UI',
              newName: 'UI',
              target: Layers.BitMask,
              targetName: 'UI_3D'
            }, {
              name: 'UI2D',
              newName: 'UI2D',
              target: Layers.BitMask,
              targetName: 'UI_2D'
            }]);
            legacyCC.CameraVisFlags = CameraVisFlags;
            const VisibilityFlags = {};
            removeProperty(VisibilityFlags, 'VisibilityFlags', [{
              name: 'GENERAL'
            }]);
            replaceProperty(VisibilityFlags, 'VisibilityFlags', [{
              name: 'ALWALS',
              newName: 'ALWALS',
              target: Layers.Enum,
              targetName: 'ALWALS'
            }, {
              name: 'PROFILER',
              newName: 'PROFILER',
              target: Layers.Enum,
              targetName: 'PROFILER'
            }, {
              name: 'GIZMOS',
              newName: 'GIZMOS',
              target: Layers.Enum,
              targetName: 'GIZMOS'
            }, {
              name: 'EDITOR',
              newName: 'EDITOR',
              target: Layers.Enum,
              targetName: 'EDITOR'
            }, {
              name: 'UI',
              newName: 'UI',
              target: Layers.Enum,
              targetName: 'UI_3D'
            }, {
              name: 'UI2D',
              newName: 'UI2D',
              target: Layers.Enum,
              targetName: 'UI_2D'
            }]);
            legacyCC.VisibilityFlags = VisibilityFlags;
            replaceProperty(Pass.prototype, 'Pass.prototype', [{
              name: 'getBindingTypeFromHandle',
              newName: 'getDescriptorTypeFromHandle'
            }]);
            removeProperty(Camera.prototype, 'Camera.prototype', [{
              name: 'getSplitFrustum'
            }, {
              name: 'setMatView'
            }, {
              name: 'setMatViewInv'
            }, {
              name: 'setMatProjInv'
            }, {
              name: 'setMatViewProjInv'
            }, {
              name: 'setMatProj'
            }, {
              name: 'setMatViewProj'
            }, {
              name: 'getMatViewInv'
            }]);
            removeProperty(Shadows.prototype, 'Shadows.prototype', [{
              name: 'aspect'
            }, {
              name: 'selfShadow'
            }, {
              name: 'linear'
            }, {
              name: 'packing'
            }, {
              name: 'autoAdapt'
            }]);

            function ColorTemperatureToRGB(rgb, kelvin) {
              if (kelvin < 1000.0) {
                kelvin = 1000.0;
              } else if (kelvin > 15000.0) {
                kelvin = 15000.0;
              }

              const kSqr = kelvin * kelvin;
              const u = (0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kSqr) / (1.0 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kSqr);
              const v = (0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kSqr) / (1.0 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kSqr);
              const d = 2.0 * u - 8.0 * v + 4.0;
              const x = 3.0 * u / d;
              const y = 2.0 * v / d;
              const z = 1.0 - x - y;
              const X = 1.0 / y * x;
              const Z = 1.0 / y * z;
              rgb.x = 3.2404542 * X + -1.5371385 + -0.4985314 * Z;
              rgb.y = -0.9692660 * X + 1.8760108 + 0.0415560 * Z;
              rgb.z = 0.0556434 * X + -0.2040259 + 1.0572252 * Z;
            }
            let LightType;

            (function (LightType) {
              LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
              LightType[LightType["SPHERE"] = 1] = "SPHERE";
              LightType[LightType["SPOT"] = 2] = "SPOT";
              LightType[LightType["UNKNOWN"] = 3] = "UNKNOWN";
            })(LightType || (LightType = exports('cs', {})));

            const nt2lm = exports('cz', size => 4 * Math.PI * Math.PI * size * size);
            class Light {
              constructor() {
                this._baked = false;
                this._color = new Vec3(1, 1, 1);
                this._colorTemp = 6550.0;
                this._colorTempRGB = new Vec3(1, 1, 1);
                this._scene = null;
                this._node = null;
                this._name = null;
                this._useColorTemperature = false;
                this._type = LightType.UNKNOWN;
              }

              _init() {
                {
                  switch (this._type) {
                    case LightType.DIRECTIONAL:
                      this._nativeObj = new NativeDirectionalLight();
                      break;

                    case LightType.SPHERE:
                      this._nativeObj = new NativeSphereLight();
                      break;

                    case LightType.SPOT:
                      this._nativeObj = new NativeSpotLight();
                      break;
                  }

                  this._nativeObj.setType(this._type);
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              get baked() {
                return this._baked;
              }

              set baked(val) {
                this._baked = val;

                {
                  this._nativeObj.setBaked(val);
                }
              }

              set color(color) {
                this._color.set(color);

                {
                  this._nativeObj.setColor(color);
                }
              }

              get color() {
                return this._color;
              }

              set useColorTemperature(enable) {
                this._useColorTemperature = enable;

                {
                  this._nativeObj.setUseColorTemperature(enable);
                }
              }

              get useColorTemperature() {
                return this._useColorTemperature;
              }

              set colorTemperature(val) {
                this._colorTemp = val;
                ColorTemperatureToRGB(this._colorTempRGB, this._colorTemp);

                {
                  this._nativeObj.setColorTemperatureRGB(this._colorTempRGB);
                }
              }

              get colorTemperature() {
                return this._colorTemp;
              }

              get colorTemperatureRGB() {
                return this._colorTempRGB;
              }

              set node(n) {
                this._node = n;

                if (this._node) {
                  this._node.hasChangedFlags |= TransformBit.ROTATION;

                  {
                    this._nativeObj.setNode(n ? n.native : null);
                  }
                }
              }

              get node() {
                return this._node;
              }

              get type() {
                return this._type;
              }

              get name() {
                return this._name;
              }

              set name(n) {
                this._name = n;
              }

              get scene() {
                return this._scene;
              }

              get native() {
                return this._nativeObj;
              }

              initialize() {
                this._init();

                this.color = new Vec3(1, 1, 1);
                this.colorTemperature = 6550.0;
              }

              attachToScene(scene) {
                this._scene = scene;
              }

              detachFromScene() {
                this._scene = null;
              }

              destroy() {
                this._name = null;
                this._node = null;

                this._destroy();
              }

              update() {}

            } exports('cu', Light);

            const _forward = new Vec3(0, 0, -1);

            const _v3 = new Vec3();

            class DirectionalLight extends Light {
              set direction(dir) {
                Vec3.normalize(this._dir, dir);

                {
                  this._nativeObj.setDirection(dir);
                }
              }

              get direction() {
                return this._dir;
              }

              get illuminance() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._illuminanceHDR;
                } else {
                  return this._illuminanceLDR;
                }
              }

              set illuminance(value) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this.illuminanceHDR = value;
                } else {
                  this.illuminanceLDR = value;
                }
              }

              get illuminanceHDR() {
                return this._illuminanceHDR;
              }

              set illuminanceHDR(value) {
                this._illuminanceHDR = value;

                {
                  this._nativeObj.setIlluminanceHDR(value);
                }
              }

              get illuminanceLDR() {
                return this._illuminanceLDR;
              }

              set illuminanceLDR(value) {
                this._illuminanceLDR = value;

                {
                  this._nativeObj.setIlluminanceLDR(value);
                }
              }

              constructor() {
                super();
                this._dir = new Vec3(1.0, -1.0, -1.0);
                this._illuminanceHDR = Ambient.SUN_ILLUM;
                this._illuminanceLDR = 1.0;
                this._type = LightType.DIRECTIONAL;
              }

              initialize() {
                super.initialize();
                this.illuminance = Ambient.SUN_ILLUM;
                this.direction = new Vec3(1.0, -1.0, -1.0);
              }

              update() {
                if (this._node && this._node.hasChangedFlags) {
                  this.direction = Vec3.transformQuat(_v3, _forward, this._node.worldRotation);
                }
              }

            } exports('cx', DirectionalLight);

            class PassInstance extends Pass {
              get parent() {
                return this._parent;
              }

              constructor(parent, owner) {
                super(parent.root);
                this._parent = void 0;
                this._owner = void 0;
                this._dontNotify = false;
                this._parent = parent;
                this._owner = owner;

                this._doInit(this._parent, true);

                for (let i = 0; i < this._shaderInfo.blocks.length; i++) {
                  const u = this._shaderInfo.blocks[i];
                  const block = this._blocks[u.binding];
                  const parentBlock = this._parent.blocks[u.binding];
                  block.set(parentBlock);
                }

                this._setRootBufferDirty(true);

                const paren = this._parent;

                for (let i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
                  const u = this._shaderInfo.samplerTextures[i];

                  for (let j = 0; j < u.count; j++) {
                    const sampler = paren._descriptorSet.getSampler(u.binding, j);

                    const texture = paren._descriptorSet.getTexture(u.binding, j);

                    this._descriptorSet.bindSampler(u.binding, sampler, j);

                    this._descriptorSet.bindTexture(u.binding, texture, j);
                  }
                }

                super.tryCompile();
              }

              overridePipelineStates(original, overrides) {
                this._bs.reset();

                this._rs.reset();

                this._dss.reset();

                Pass.fillPipelineInfo(this, original);
                Pass.fillPipelineInfo(this, overrides);

                this._onStateChange();
              }

              tryCompile(defineOverrides) {
                if (defineOverrides) {
                  if (!overrideMacros(this._defines, defineOverrides)) {
                    return false;
                  }
                }

                const res = super.tryCompile();

                this._onStateChange();

                return res;
              }

              beginChangeStatesSilently() {
                this._dontNotify = true;
              }

              endChangeStatesSilently() {
                this._dontNotify = false;
              }

              _syncBatchingScheme() {
                this._defines.USE_BATCHING = this._defines.USE_INSTANCING = false;

                this._setBatchingScheme(BatchingSchemes.NONE);
              }

              _onStateChange() {
                this._setHash(Pass.getPassHash(this));

                this._owner.onPassStateChange(this._dontNotify);
              }

            }

            class MaterialInstance extends Material {
              get parent() {
                return this._parent;
              }

              get owner() {
                return this._owner;
              }

              constructor(info) {
                super();
                this._passes = [];
                this._parent = void 0;
                this._owner = void 0;
                this._subModelIdx = 0;
                this._parent = info.parent;
                this._owner = info.owner || null;
                this._subModelIdx = info.subModelIdx || 0;
                this.copy(this._parent);
              }

              recompileShaders(overrides, passIdx) {
                if (!this._passes || !this.effectAsset) {
                  return;
                }

                if (passIdx === undefined) {
                  for (const pass of this._passes) {
                    pass.tryCompile(overrides);
                  }
                } else {
                  this._passes[passIdx].tryCompile(overrides);
                }
              }

              overridePipelineStates(overrides, passIdx) {
                if (!this._passes || !this.effectAsset) {
                  return;
                }

                const passInfos = this.effectAsset.techniques[this.technique].passes;

                if (passIdx === undefined) {
                  for (let i = 0; i < this._passes.length; i++) {
                    const pass = this._passes[i];
                    const state = this._states[i] || (this._states[i] = {});

                    for (const key in overrides) {
                      state[key] = overrides[key];
                    }

                    pass.overridePipelineStates(passInfos[pass.passIndex], state);
                  }
                } else {
                  const state = this._states[passIdx] || (this._states[passIdx] = {});

                  for (const key in overrides) {
                    state[key] = overrides[key];
                  }

                  this._passes[passIdx].overridePipelineStates(passInfos[passIdx], state);
                }
              }

              destroy() {
                this._doDestroy();

                return true;
              }

              onPassStateChange(dontNotify) {
                this._hash = Material.getHash(this);

                if (!dontNotify && this._owner) {
                  this._owner._onRebuildPSO(this._subModelIdx, this);
                }
              }

              _createPasses() {
                const passes = [];
                const parentPasses = this._parent.passes;

                if (!parentPasses) {
                  return passes;
                }

                for (let k = 0; k < parentPasses.length; ++k) {
                  passes.push(new PassInstance(parentPasses[k], this));
                }

                return passes;
              }

            } exports('da', MaterialInstance);

            let skybox_mesh = null;
            let skybox_material = null;
            class Skybox {
              get model() {
                return this._model;
              }

              get enabled() {
                return this._enabled;
              }

              set enabled(val) {
                this._setEnabled(val);

                if (val) this.activate();else this._updatePipeline();
              }

              get useHDR() {
                return this._useHDR;
              }

              set useHDR(val) {
                this._setUseHDR(val);

                this.setEnvMaps(this._envmapHDR, this._envmapLDR);
              }

              get useIBL() {
                return this._useIBL;
              }

              set useIBL(val) {
                this._setUseIBL(val);

                this._updatePipeline();
              }

              get useDiffuseMap() {
                return this._useDiffuseMap;
              }

              set useDiffuseMap(val) {
                this._useDiffuseMap = val;
                this.setDiffuseMaps(null, null);
              }

              get isRGBE() {
                if (this.envmap) {
                  return this.envmap.isRGBE;
                } else {
                  return false;
                }
              }

              get envmap() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._envmapHDR;
                } else {
                  return this._envmapLDR;
                }
              }

              set envmap(val) {
                const root = legacyCC.director.root;
                const isHDR = root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this.setEnvMaps(val, this._envmapLDR);
                } else {
                  this.setEnvMaps(this._envmapHDR, val);
                }
              }

              get diffuseMap() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._diffuseMapHDR;
                } else {
                  return this._diffuseMapLDR;
                }
              }

              set diffuseMap(val) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this.setDiffuseMaps(val, this._diffuseMapLDR);
                } else {
                  this.setDiffuseMaps(this._diffuseMapHDR, val);
                }
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this._envmapLDR = null;
                this._envmapHDR = null;
                this._diffuseMapLDR = null;
                this._diffuseMapHDR = null;
                this._globalDSManager = null;
                this._model = null;
                this._default = null;
                this._enabled = false;
                this._useIBL = false;
                this._useHDR = true;
                this._useDiffuseMap = false;

                {
                  this._nativeObj = new NaitveSkybox();
                }
              }

              _setEnabled(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                }
              }

              _setUseIBL(val) {
                this._useIBL = val;

                {
                  this._nativeObj.useIBL = val;
                }
              }

              _setUseHDR(val) {
                this._useHDR = val;

                {
                  this._nativeObj.useHDR = val;
                }
              }

              _setUseDiffuseMap(val) {
                this._useDiffuseMap = val;

                {
                  this._nativeObj.useDiffuseMap = val;
                }
              }

              initialize(skyboxInfo) {
                this._setEnabled(skyboxInfo.enabled);

                this._setUseIBL(skyboxInfo.useIBL);

                this._setUseDiffuseMap(skyboxInfo.applyDiffuseMap);

                this._setUseHDR(skyboxInfo.useHDR);
              }

              setEnvMaps(envmapHDR, envmapLDR) {
                this._envmapHDR = envmapHDR;
                this._envmapLDR = envmapLDR;
                const root = legacyCC.director.root;
                const isHDR = root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  if (envmapHDR) {
                    root.pipeline.pipelineSceneData.ambient.mipmapCount = envmapHDR.mipmapLevel;
                  }
                } else if (envmapLDR) {
                  root.pipeline.pipelineSceneData.ambient.mipmapCount = envmapLDR.mipmapLevel;
                }

                this._updateGlobalBinding();

                this._updatePipeline();
              }

              setDiffuseMaps(diffuseMapHDR, diffuseMapLDR) {
                this._diffuseMapHDR = diffuseMapHDR;
                this._diffuseMapLDR = diffuseMapLDR;

                this._updateGlobalBinding();

                this._updatePipeline();
              }

              activate() {
                const pipeline = legacyCC.director.root.pipeline;
                this._globalDSManager = pipeline.globalDSManager;
                this._default = builtinResMgr.get('default-cube-texture');

                if (!this._model) {
                  this._model = legacyCC.director.root.createModel(legacyCC.renderer.scene.Model);

                  this._model._initLocalDescriptors = () => {};

                  this._model._initWorldBoundDescriptors = () => {};

                  {
                    this._nativeObj.model = this._model.native;
                  }
                }

                let isRGBE = this._default.isRGBE;

                if (this.envmap) {
                  isRGBE = this.envmap.isRGBE;
                }

                if (!skybox_material) {
                  const mat = new Material();
                  mat.initialize({
                    effectName: 'skybox',
                    defines: {
                      USE_RGBE_CUBEMAP: isRGBE
                    }
                  });
                  skybox_material = new MaterialInstance({
                    parent: mat
                  });
                }

                if (this.enabled) {
                  if (!skybox_mesh) {
                    skybox_mesh = legacyCC.utils.createMesh(legacyCC.primitives.box({
                      width: 2,
                      height: 2,
                      length: 2
                    }));
                  }

                  this._model.initSubModel(0, skybox_mesh.renderingSubMeshes[0], skybox_material);
                }

                if (!this.envmap) {
                  this.envmap = this._default;
                }

                if (!this.diffuseMap) {
                  this.diffuseMap = this._default;
                }

                this._updateGlobalBinding();

                this._updatePipeline();
              }

              _updatePipeline() {
                {
                  this._nativeObj.isRGBE = this.isRGBE;
                }

                const root = legacyCC.director.root;
                const pipeline = root.pipeline;
                const useIBLValue = this.useIBL ? this.isRGBE ? 2 : 1 : 0;
                const useDiffuseMapValue = this.useIBL && this.useDiffuseMap && this.diffuseMap ? this.isRGBE ? 2 : 1 : 0;
                const useHDRValue = this.useHDR;

                if (pipeline.macros.CC_USE_IBL !== useIBLValue || pipeline.macros.CC_USE_DIFFUSEMAP !== useDiffuseMapValue || pipeline.macros.CC_USE_HDR !== useHDRValue) {
                  pipeline.macros.CC_USE_IBL = useIBLValue;
                  pipeline.macros.CC_USE_DIFFUSEMAP = useDiffuseMapValue;
                  pipeline.macros.CC_USE_HDR = useHDRValue;
                  root.onGlobalPipelineStateChanged();
                }

                if (this.enabled && skybox_material) {
                  skybox_material.recompileShaders({
                    USE_RGBE_CUBEMAP: this.isRGBE
                  });
                }

                if (this._model) {
                  this._model.setSubModelMaterial(0, skybox_material);
                }
              }

              _updateGlobalBinding() {
                if (this._globalDSManager) {
                  const device = legacyCC.director.root.device;
                  const envmap = this.envmap ? this.envmap : this._default;

                  if (envmap) {
                    const texture = envmap.getGFXTexture();
                    const sampler = device.getSampler(envmap.getSamplerInfo());

                    this._globalDSManager.bindSampler(UNIFORM_ENVIRONMENT_BINDING, sampler);

                    this._globalDSManager.bindTexture(UNIFORM_ENVIRONMENT_BINDING, texture);
                  }

                  const diffuseMap = this.diffuseMap ? this.diffuseMap : this._default;

                  if (diffuseMap) {
                    const texture = diffuseMap.getGFXTexture();
                    const sampler = device.getSampler(diffuseMap.getSamplerInfo());

                    this._globalDSManager.bindSampler(UNIFORM_DIFFUSEMAP_BINDING, sampler);

                    this._globalDSManager.bindTexture(UNIFORM_DIFFUSEMAP_BINDING, texture);
                  }

                  this._globalDSManager.update();
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();
              }

            }
            legacyCC.Skybox = Skybox;

            class SphereLight extends Light {
              _init() {
                super._init();

                {
                  this._nativeObj.setPosition(this._pos);

                  this._nativeObj.setAABB(this._aabb.native);
                }
              }

              _destroy() {
                super._destroy();
              }

              get position() {
                return this._pos;
              }

              set size(size) {
                this._size = size;

                {
                  this._nativeObj.setSize(size);
                }
              }

              get size() {
                return this._size;
              }

              set range(range) {
                this._range = range;

                {
                  this._nativeObj.setRange(range);
                }

                this._needUpdate = true;
              }

              get range() {
                return this._range;
              }

              get luminance() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._luminanceHDR;
                } else {
                  return this._luminanceLDR;
                }
              }

              set luminance(value) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this.luminanceHDR = value;
                } else {
                  this.luminanceLDR = value;
                }
              }

              get luminanceHDR() {
                return this._luminanceHDR;
              }

              set luminanceHDR(value) {
                this._luminanceHDR = value;

                {
                  this._nativeObj.setLuminanceHDR(value);
                }
              }

              set luminanceLDR(value) {
                this._luminanceLDR = value;

                {
                  this._nativeObj.setLuminanceLDR(value);
                }
              }

              get aabb() {
                return this._aabb;
              }

              constructor() {
                super();
                this._needUpdate = false;
                this._size = 0.15;
                this._range = 1.0;
                this._luminanceHDR = 0;
                this._luminanceLDR = 0;
                this._pos = void 0;
                this._aabb = void 0;
                this._aabb = AABB.create();
                this._pos = new Vec3();
                this._type = LightType.SPHERE;
              }

              initialize() {
                super.initialize();
                const size = 0.15;
                this.size = size;
                this.range = 1.0;
                this.luminance = 1700 / nt2lm(size);
                this.luminanceLDR = 1.0;
              }

              update() {
                if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                  this._node.getWorldPosition(this._pos);

                  const range = this._range;
                  AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, range, range, range);
                  this._needUpdate = false;
                }
              }

            } exports('cA', SphereLight);

            const _forward$1 = new Vec3(0, 0, -1);

            const _qt = new Quat();

            const _matView = new Mat4();

            const _matProj = new Mat4();

            const _matViewProj = new Mat4();

            const _matViewProjInv = new Mat4();

            class SpotLight extends Light {
              _init() {
                super._init();

                {
                  const nativeSpotLight = this._nativeObj;
                  nativeSpotLight.setAABB(this._aabb.native);
                  nativeSpotLight.setFrustum(this._frustum);
                  nativeSpotLight.setDirection(this._dir);
                  nativeSpotLight.setPosition(this._pos);
                }
              }

              _destroy() {
                super._destroy();
              }

              _setDirection(dir) {
                this._dir.set(dir);

                {
                  this._nativeObj.setDirection(dir);
                }
              }

              get position() {
                return this._pos;
              }

              set size(size) {
                this._size = size;

                {
                  this._nativeObj.setSize(size);
                }
              }

              get size() {
                return this._size;
              }

              set range(range) {
                this._range = range;

                {
                  this._nativeObj.setRange(range);
                }

                this._needUpdate = true;
              }

              get range() {
                return this._range;
              }

              get luminance() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._luminanceHDR;
                } else {
                  return this._luminanceLDR;
                }
              }

              set luminance(value) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this.luminanceHDR = value;
                } else {
                  this.luminanceLDR = value;
                }
              }

              get luminanceHDR() {
                return this._luminanceHDR;
              }

              set luminanceHDR(value) {
                this._luminanceHDR = value;

                {
                  this._nativeObj.setLuminanceHDR(value);
                }
              }

              get luminanceLDR() {
                return this._luminanceLDR;
              }

              set luminanceLDR(value) {
                this._luminanceLDR = value;

                {
                  this._nativeObj.setLuminanceLDR(value);
                }
              }

              get direction() {
                return this._dir;
              }

              get spotAngle() {
                return this._spotAngle;
              }

              set spotAngle(val) {
                this._angle = val;
                this._spotAngle = Math.cos(val * 0.5);

                {
                  this._nativeObj.setAngle(this._spotAngle);
                }

                this._needUpdate = true;
              }

              get angle() {
                return this._angle;
              }

              set aspect(val) {
                this._aspect = val;

                {
                  this._nativeObj.setAspect(val);
                }

                this._needUpdate = true;
              }

              get aspect() {
                return this._aspect;
              }

              get aabb() {
                return this._aabb;
              }

              get frustum() {
                return this._frustum;
              }

              constructor() {
                super();
                this._dir = new Vec3(1.0, -1.0, -1.0);
                this._range = 5.0;
                this._spotAngle = Math.cos(Math.PI / 6);
                this._pos = void 0;
                this._aabb = void 0;
                this._frustum = void 0;
                this._angle = 0;
                this._needUpdate = false;
                this._size = 0.15;
                this._luminanceHDR = 0;
                this._luminanceLDR = 0;
                this._aspect = 0;
                this._aabb = AABB.create();
                this._frustum = Frustum.create();
                this._pos = new Vec3();
                this._type = LightType.SPOT;
              }

              initialize() {
                super.initialize();
                const size = 0.15;
                this.size = size;
                this.aspect = 1.0;
                this.luminance = 1700 / nt2lm(size);
                this.luminanceLDR = 1.0;
                this.range = Math.cos(Math.PI / 6);

                this._setDirection(new Vec3(1.0, -1.0, -1.0));
              }

              update() {
                if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                  this._node.getWorldPosition(this._pos);

                  Vec3.transformQuat(this._dir, _forward$1, this._node.getWorldRotation(_qt));
                  Vec3.normalize(this._dir, this._dir);
                  AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range);

                  this._node.getWorldRT(_matView);

                  Mat4.invert(_matView, _matView);
                  Mat4.perspective(_matProj, this._angle, 1.0, 0.001, this._range);
                  Mat4.multiply(_matViewProj, _matProj, _matView);

                  this._frustum.update(_matViewProj, _matViewProjInv);

                  this._needUpdate = false;
                }
              }

            } exports('cC', SpotLight);

            var index = /*#__PURE__*/Object.freeze({
                __proto__: null,
                Ambient: Ambient,
                Octree: Octree,
                get CameraFOVAxis () { return CameraFOVAxis; },
                get CameraProjection () { return CameraProjection; },
                get CameraAperture () { return CameraAperture; },
                get CameraISO () { return CameraISO; },
                get CameraShutter () { return CameraShutter; },
                SKYBOX_FLAG: SKYBOX_FLAG,
                Camera: Camera,
                CameraVisFlags: CameraVisFlags,
                VisibilityFlags: VisibilityFlags,
                DirectionalLight: DirectionalLight,
                ColorTemperatureToRGB: ColorTemperatureToRGB,
                get LightType () { return LightType; },
                nt2lm: nt2lm,
                Light: Light,
                get ModelType () { return ModelType; },
                Model: Model,
                ShadowSize: ShadowSize,
                ShadowType: ShadowType,
                PCFType: PCFType,
                Shadows: Shadows,
                RenderScene: RenderScene,
                Skybox: Skybox,
                SphereLight: SphereLight,
                SpotLight: SpotLight,
                SubModel: SubModel,
                NativeNode: NativeNode,
                NativeScene: NativeScene,
                NativeModel: NativeModel,
                NativeSkinningModel: NativeSkinningModel,
                NativeBakedSkinningModel: NativeBakedSkinningModel,
                NativeLight: NativeLight,
                NativeDirectionalLight: NativeDirectionalLight,
                NativeSpotLight: NativeSpotLight,
                NativeSphereLight: NativeSphereLight,
                NaitveSkybox: NaitveSkybox,
                NativeFog: NativeFog,
                NativeAmbient: NativeAmbient,
                NativeShadow: NativeShadow,
                NativeOctree: NativeOctree,
                NativeCamera: NativeCamera,
                NativeRenderWindow: NativeRenderWindow,
                NativeRenderScene: NativeRenderScene,
                NativeDrawBatch2D: NativeDrawBatch2D,
                NativePass: NativePass,
                NativeSubModel: NativeSubModel,
                NativeRoot: NativeRoot,
                NativePipelineSharedSceneData: NativePipelineSharedSceneData,
                NativeAABB: NativeAABB,
                NativeGeometryRenderer: NativeGeometryRenderer
            });

            function createIA(device, data) {
              if (!data.positions) {
                console.error('The data must have positions field');
                return null;
              }

              const verts = [];
              const vcount = data.positions.length / 3;

              for (let i = 0; i < vcount; ++i) {
                verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);

                if (data.normals) {
                  verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
                }

                if (data.uvs) {
                  verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
                }

                if (data.colors) {
                  verts.push(data.colors[3 * i], data.colors[3 * i + 1], data.colors[3 * i + 2]);
                }
              }

              const vfmt = [];
              vfmt.push(new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F));

              if (data.normals) {
                vfmt.push(new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F));
              }

              if (data.uvs) {
                vfmt.push(new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F));
              }

              if (data.colors) {
                vfmt.push(new Attribute(AttributeName.ATTR_COLOR, Format.RGB32F));
              }

              const vb = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, verts.length * 4, verts.length * 4 / vcount));
              vb.update(new Float32Array(verts));
              let ib = null;

              if (data.indices) {
                ib = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, data.indices.length * 2, 2));
                ib.update(new Uint16Array(data.indices));
              }

              return device.createInputAssembler(new InputAssemblerInfo(vfmt, [vb], ib));
            }

            let RenderQueue;

            (function (RenderQueue) {
              RenderQueue[RenderQueue["OPAQUE"] = 0] = "OPAQUE";
              RenderQueue[RenderQueue["TRANSPARENT"] = 1] = "TRANSPARENT";
              RenderQueue[RenderQueue["OVERLAY"] = 2] = "OVERLAY";
            })(RenderQueue || (RenderQueue = {}));

            let PassStage;

            (function (PassStage) {
              PassStage[PassStage["DEFAULT"] = 1] = "DEFAULT";
              PassStage[PassStage["FORWARD"] = 2] = "FORWARD";
              PassStage[PassStage["SHADOWCAST"] = 4] = "SHADOWCAST";
            })(PassStage || (PassStage = {}));

            function nearestPOT(num) {
              --num;
              num |= num >> 16;
              num |= num >> 8;
              num |= num >> 4;
              num |= num >> 2;
              num |= num >> 1;
              ++num;
              return num;
            }

            function roundUp(n, alignment) {
              return Math.ceil(n / alignment) * alignment;
            }

            class TextureBufferPool {
              constructor(device) {
                this._device = void 0;
                this._format = Format.UNKNOWN;
                this._formatSize = 0;
                this._chunks = [];
                this._chunkCount = 0;
                this._handles = [];
                this._region0 = new BufferTextureCopy();
                this._region1 = new BufferTextureCopy();
                this._region2 = new BufferTextureCopy();
                this._roundUpFn = null;
                this._bufferViewCtor = Uint8Array;
                this._channels = 4;
                this._alignment = 1;
                this._device = device;
              }

              initialize(info) {
                const formatInfo = FormatInfos[info.format];
                this._format = info.format;
                this._formatSize = formatInfo.size;
                this._channels = formatInfo.count;
                this._bufferViewCtor = getTypedArrayConstructor(formatInfo);
                this._roundUpFn = info.roundUpFn || null;
                this._alignment = info.alignment || 1;

                if (info.inOrderFree) {
                  this.alloc = this._McDonaldAlloc;
                }
              }

              destroy() {
                for (let i = 0; i < this._chunkCount; ++i) {
                  const chunk = this._chunks[i];
                  chunk.texture.destroy();
                }

                this._chunks.length = 0;
                this._handles.length = 0;
              }

              alloc(size, chunkIdx) {
                size = roundUp(size, this._alignment);
                let index = -1;
                let start = -1;

                if (chunkIdx !== undefined) {
                  index = chunkIdx;
                  start = this._findAvailableSpace(size, index);
                }

                if (start < 0) {
                  for (let i = 0; i < this._chunkCount; ++i) {
                    index = i;
                    start = this._findAvailableSpace(size, index);

                    if (start >= 0) {
                      break;
                    }
                  }
                }

                if (start >= 0) {
                  const chunk = this._chunks[index];
                  chunk.start += size;
                  const handle = {
                    chunkIdx: index,
                    start,
                    end: start + size,
                    texture: chunk.texture
                  };

                  this._handles.push(handle);

                  return handle;
                }

                const targetSize = Math.sqrt(size / this._formatSize);
                const texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

                const newChunk = this._chunks[this.createChunk(texLength)];

                newChunk.start += size;
                const texHandle = {
                  chunkIdx: this._chunkCount - 1,
                  start: 0,
                  end: size,
                  texture: newChunk.texture
                };

                this._handles.push(texHandle);

                return texHandle;
              }

              free(handle) {
                for (let i = 0; i < this._handles.length; ++i) {
                  if (this._handles[i] === handle) {
                    this._chunks[handle.chunkIdx].end = handle.end;

                    this._handles.splice(i, 1);

                    return;
                  }
                }
              }

              createChunk(length) {
                const texSize = length * length * this._formatSize;
                debug(`TextureBufferPool: Allocate chunk ${this._chunkCount}, size: ${texSize}, format: ${this._format}`);

                const texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, this._format, length, length));

                const chunk = {
                  texture,
                  size: texSize,
                  start: 0,
                  end: texSize
                };
                this._chunks[this._chunkCount] = chunk;
                return this._chunkCount++;
              }

              update(handle, buffer) {
                const buffers = [];
                const regions = [];
                const start = handle.start / this._formatSize;
                let remainSize = buffer.byteLength / this._formatSize;
                let offsetX = start % handle.texture.width;
                let offsetY = Math.floor(start / handle.texture.width);
                let copySize = Math.min(handle.texture.width - offsetX, remainSize);
                let begin = 0;

                if (offsetX > 0) {
                  this._region0.texOffset.x = offsetX;
                  this._region0.texOffset.y = offsetY;
                  this._region0.texExtent.width = copySize;
                  this._region0.texExtent.height = 1;
                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
                  regions.push(this._region0);
                  offsetX = 0;
                  offsetY += 1;
                  remainSize -= copySize;
                  begin += copySize;
                }

                if (remainSize > 0) {
                  this._region1.texOffset.x = offsetX;
                  this._region1.texOffset.y = offsetY;

                  if (remainSize > handle.texture.width) {
                    this._region1.texExtent.width = handle.texture.width;
                    this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width);
                    copySize = this._region1.texExtent.width * this._region1.texExtent.height;
                  } else {
                    copySize = remainSize;
                    this._region1.texExtent.width = copySize;
                    this._region1.texExtent.height = 1;
                  }

                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
                  regions.push(this._region1);
                  offsetX = 0;
                  offsetY += this._region1.texExtent.height;
                  remainSize -= copySize;
                  begin += copySize;
                }

                if (remainSize > 0) {
                  this._region2.texOffset.x = offsetX;
                  this._region2.texOffset.y = offsetY;
                  this._region2.texExtent.width = remainSize;
                  this._region2.texExtent.height = 1;
                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels));
                  regions.push(this._region2);
                }

                this._device.copyBuffersToTexture(buffers, handle.texture, regions);
              }

              _findAvailableSpace(size, chunkIdx) {
                const chunk = this._chunks[chunkIdx];
                let isFound = false;
                let start = chunk.start;

                if (start + size <= chunk.size) {
                  isFound = true;
                } else {
                  start = 0;

                  const handles = this._handles.filter(h => h.chunkIdx === chunkIdx).sort((a, b) => a.start - b.start);

                  for (let i = 0; i < handles.length; i++) {
                    const handle = handles[i];

                    if (start + size <= handle.start) {
                      isFound = true;
                      break;
                    }

                    start = handle.end;
                  }

                  if (!isFound && start + size <= chunk.size) {
                    isFound = true;
                  }
                }

                return isFound ? start : -1;
              }

              _McDonaldAlloc(size) {
                size = roundUp(size, this._alignment);

                for (let i = 0; i < this._chunkCount; ++i) {
                  const chunk = this._chunks[i];
                  let isFound = false;
                  let start = chunk.start;

                  if (start + size <= chunk.end) {
                    isFound = true;
                  } else if (start > chunk.end) {
                    if (start + size <= chunk.size) {
                      isFound = true;
                    } else if (size <= chunk.end) {
                      chunk.start = start = 0;
                      isFound = true;
                    }
                  } else if (start === chunk.end) {
                    chunk.start = start = 0;
                    chunk.end = chunk.size;

                    if (size <= chunk.end) {
                      isFound = true;
                    }
                  }

                  if (isFound) {
                    chunk.start += size;
                    const handle = {
                      chunkIdx: i,
                      start,
                      end: start + size,
                      texture: chunk.texture
                    };

                    this._handles.push(handle);

                    return handle;
                  }
                }

                const targetSize = Math.sqrt(size / this._formatSize);
                const texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

                const newChunk = this._chunks[this.createChunk(texLength)];

                newChunk.start += size;
                const texHandle = {
                  chunkIdx: this._chunkCount,
                  start: 0,
                  end: size,
                  texture: newChunk.texture
                };

                this._handles.push(texHandle);

                return texHandle;
              }

            } exports('cF', TextureBufferPool);

            const addStage = config.addStage;

            var renderer = /*#__PURE__*/Object.freeze({
                __proto__: null,
                addStage: addStage,
                scene: index,
                createIA: createIA,
                get RenderQueue () { return RenderQueue; },
                get PassStage () { return PassStage; },
                genHandle: genHandle,
                getTypeFromHandle: getTypeFromHandle,
                getBindingFromHandle: getBindingFromHandle,
                getCountFromHandle: getCountFromHandle,
                getOffsetFromHandle: getOffsetFromHandle,
                customizeType: customizeType,
                type2reader: type2reader,
                type2writer: type2writer,
                getDefaultFromType: getDefaultFromType,
                overrideMacros: overrideMacros,
                get BatchingSchemes () { return BatchingSchemes; },
                Pass: Pass,
                getDeviceShaderVersion: getDeviceShaderVersion,
                programLib: programLib,
                nearestPOT: nearestPOT,
                TextureBufferPool: TextureBufferPool,
                MaterialInstance: MaterialInstance,
                PassInstance: PassInstance,
                get PoolType () { return PoolType; },
                NULL_HANDLE: NULL_HANDLE,
                get NodeView () { return NodeView; },
                NodePool: NodePool,
                get PassView () { return PassView; },
                PassPool: PassPool,
                get AABBView () { return AABBView; },
                AABBPool: AABBPool
            });
            exports('eX', renderer);

            const _tempVec3 = new Vec3();

            const _dir_negate = new Vec3();

            const _vec3_p = new Vec3();

            const _shadowPos = new Vec3();

            const _mat4_trans = new Mat4();

            const _castLightViewBounds = new AABB();

            const _castWorldBounds = new AABB();

            let _castBoundsInited = false;

            const _sphere = Sphere.create(0, 0, 0, 1);

            const _cameraBoundingSphere = new Sphere();

            const _validFrustum = new Frustum();

            _validFrustum.accurate = true;

            let _lightViewFrustum = new Frustum();

            _lightViewFrustum.accurate = true;

            const _dirLightFrustum = new Frustum();

            const _matShadowTrans = new Mat4();

            const _matShadowView = new Mat4();

            const _matShadowViewInv = new Mat4();

            const _matShadowProj = new Mat4();

            const _matShadowViewProj = new Mat4();

            const _matShadowViewProjArbitaryPos = new Mat4();

            const _matShadowViewProjArbitaryPosInv = new Mat4();

            const _projPos = new Vec3();

            const _texelSize = new Vec2();

            const _projSnap = new Vec3();

            const _snap = new Vec3();

            const _focus = new Vec3(0, 0, 0);

            const _ab = new AABB();

            const roPool = new Pool(() => ({
              model: null,
              depth: 0
            }), 128);
            const dirShadowPool = new Pool(() => ({
              model: null,
              depth: 0
            }), 128);
            const castShadowPool = new Pool(() => ({
              model: null,
              depth: 0
            }), 128);

            function getRenderObject(model, camera) {
              let depth = 0;

              if (model.node) {
                Vec3.subtract(_tempVec3, model.node.worldPosition, camera.position);
                depth = Vec3.dot(_tempVec3, camera.forward);
              }

              const ro = roPool.alloc();
              ro.model = model;
              ro.depth = depth;
              return ro;
            }

            function getDirShadowRenderObject(model, camera) {
              let depth = 0;

              if (model.node) {
                Vec3.subtract(_tempVec3, model.node.worldPosition, camera.position);
                depth = Vec3.dot(_tempVec3, camera.forward);
              }

              const ro = dirShadowPool.alloc();
              ro.model = model;
              ro.depth = depth;
              return ro;
            }

            function getCastShadowRenderObject(model, camera) {
              let depth = 0;

              if (model.node) {
                Vec3.subtract(_tempVec3, model.node.worldPosition, camera.position);
                depth = Vec3.dot(_tempVec3, camera.forward);
              }

              const ro = castShadowPool.alloc();
              ro.model = model;
              ro.depth = depth;
              return ro;
            }

            function updateDirLight(pipeline, light) {
              const shadows = pipeline.pipelineSceneData.shadows;
              const dir = light.direction;
              const n = shadows.normal;
              const d = shadows.distance + 0.001;
              const NdL = Vec3.dot(n, dir);
              const scale = 1 / NdL;
              const lx = dir.x * scale;
              const ly = dir.y * scale;
              const lz = dir.z * scale;
              const nx = n.x;
              const ny = n.y;
              const nz = n.z;
              const m = shadows.matLight;
              m.m00 = 1 - nx * lx;
              m.m01 = -nx * ly;
              m.m02 = -nx * lz;
              m.m03 = 0;
              m.m04 = -ny * lx;
              m.m05 = 1 - ny * ly;
              m.m06 = -ny * lz;
              m.m07 = 0;
              m.m08 = -nz * lx;
              m.m09 = -nz * ly;
              m.m10 = 1 - nz * lz;
              m.m11 = 0;
              m.m12 = lx * d;
              m.m13 = ly * d;
              m.m14 = lz * d;
              m.m15 = 1;
              pipeline.pipelineUBO.updateShadowUBORange(UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET, shadows.matLight);
            }

            function updatePlanarPROJ(shadowInfo, light, shadowUBO) {
              const dir = light.direction;
              const n = shadowInfo.normal;
              const d = shadowInfo.distance + 0.001;
              const NdL = Vec3.dot(n, dir);
              const scale = 1 / NdL;
              const lx = dir.x * scale;
              const ly = dir.y * scale;
              const lz = dir.z * scale;
              const nx = n.x;
              const ny = n.y;
              const nz = n.z;
              const m = shadowInfo.matLight;
              m.m00 = 1 - nx * lx;
              m.m01 = -nx * ly;
              m.m02 = -nx * lz;
              m.m03 = 0;
              m.m04 = -ny * lx;
              m.m05 = 1 - ny * ly;
              m.m06 = -ny * lz;
              m.m07 = 0;
              m.m08 = -nz * lx;
              m.m09 = -nz * ly;
              m.m10 = 1 - nz * lz;
              m.m11 = 0;
              m.m12 = lx * d;
              m.m13 = ly * d;
              m.m14 = lz * d;
              m.m15 = 1;
              Mat4.toArray(shadowUBO, m, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET);
            }
            function updatePlanarNormalAndDistance(shadowInfo, shadowUBO) {
              Vec3.normalize(_tempVec3, shadowInfo.normal);
              shadowUBO[UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 0] = _tempVec3.x;
              shadowUBO[UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 1] = _tempVec3.y;
              shadowUBO[UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 2] = _tempVec3.z;
              shadowUBO[UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 3] = shadowInfo.distance;
            }
            function validPunctualLightsCulling(pipeline, camera) {
              const sceneData = pipeline.pipelineSceneData;
              const validPunctualLights = sceneData.validPunctualLights;
              validPunctualLights.length = 0;
              const {
                spotLights
              } = camera.scene;

              for (let i = 0; i < spotLights.length; i++) {
                const light = spotLights[i];

                if (light.baked) {
                  continue;
                }

                Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);

                if (intersect.sphereFrustum(_sphere, camera.frustum)) {
                  validPunctualLights.push(light);
                }
              }

              const {
                sphereLights
              } = camera.scene;

              for (let i = 0; i < sphereLights.length; i++) {
                const light = sphereLights[i];

                if (light.baked) {
                  continue;
                }

                Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);

                if (intersect.sphereFrustum(_sphere, camera.frustum)) {
                  validPunctualLights.push(light);
                }
              }
            }
            function getCameraWorldMatrix(out, camera) {
              if (!camera.node) {
                return;
              }

              const cameraNode = camera.node;
              const position = cameraNode.getWorldPosition();
              const rotation = cameraNode.getWorldRotation();
              Mat4.fromRT(out, rotation, position);
              out.m08 *= -1.0;
              out.m09 *= -1.0;
              out.m10 *= -1.0;
            }
            function QuantizeDirLightShadowCamera(out, pipeline, dirLight, camera, shadowInfo) {
              const device = pipeline.device;

              if (shadowInfo.fixedArea) {
                const x = shadowInfo.orthoSize;
                const y = shadowInfo.orthoSize;
                const near = shadowInfo.near;
                const far = shadowInfo.far;
                Mat4.fromRT(_matShadowTrans, dirLight.node.getWorldRotation(), dirLight.node.getWorldPosition());
                Mat4.invert(_matShadowView, _matShadowTrans);
                Mat4.ortho(_matShadowProj, -x, x, -y, y, near, far, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY);
                Mat4.multiply(_matShadowViewProj, _matShadowProj, _matShadowView);
                Mat4.invert(_matShadowViewInv, _matShadowView);
                shadowInfo.matShadowView = _matShadowView;
                shadowInfo.matShadowProj = _matShadowProj;
                shadowInfo.matShadowViewProj = _matShadowViewProj;
                Frustum.createOrtho(out, x * 2.0, y * 2.0, near, far, _matShadowViewInv);
              } else {
                const invisibleOcclusionRange = shadowInfo.invisibleOcclusionRange;
                const shadowMapWidth = shadowInfo.size.x;
                getCameraWorldMatrix(_mat4_trans, camera);
                Frustum.split(_validFrustum, camera, _mat4_trans, 0.1, shadowInfo.shadowDistance);
                _lightViewFrustum = Frustum.clone(_validFrustum);
                Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _focus);
                Mat4.invert(_matShadowView, _matShadowTrans);
                Mat4.invert(_matShadowViewInv, _matShadowView);

                const shadowViewArbitaryPos = _matShadowView.clone();

                _lightViewFrustum.transform(_matShadowView);

                AABB.fromPoints(_castLightViewBounds, new Vec3(10000000, 10000000, 10000000), new Vec3(-10000000, -10000000, -10000000));

                _castLightViewBounds.mergeFrustum(_lightViewFrustum);

                const r = _castLightViewBounds.halfExtents.z * 2.0;

                _shadowPos.set(_castLightViewBounds.center.x, _castLightViewBounds.center.y, _castLightViewBounds.center.z + _castLightViewBounds.halfExtents.z + invisibleOcclusionRange);

                Vec3.transformMat4(_shadowPos, _shadowPos, _matShadowViewInv);
                Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _shadowPos);
                Mat4.invert(_matShadowView, _matShadowTrans);
                Mat4.invert(_matShadowViewInv, _matShadowView);
                const orthoSizeMin = Vec3.distance(_validFrustum.vertices[0], _validFrustum.vertices[6]);

                _cameraBoundingSphere.center.set(0, 0, 0);

                _cameraBoundingSphere.radius = -1.0;

                _cameraBoundingSphere.mergePoints(_validFrustum.vertices);

                const orthoSizeMax = _cameraBoundingSphere.radius * 2.0;
                const orthoSize = orthoSizeMin * 0.8 + orthoSizeMax * 0.2;
                shadowInfo.shadowCameraFar = r + invisibleOcclusionRange;
                const halfOrthoSize = orthoSize * 0.5;
                Mat4.ortho(_matShadowProj, -halfOrthoSize, halfOrthoSize, -halfOrthoSize, halfOrthoSize, 0.1, shadowInfo.shadowCameraFar, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY);

                if (shadowMapWidth > 0.0) {
                  Mat4.multiply(_matShadowViewProjArbitaryPos, _matShadowProj, shadowViewArbitaryPos);
                  Vec3.transformMat4(_projPos, _shadowPos, _matShadowViewProjArbitaryPos);
                  const invActualSize = 2.0 / shadowMapWidth;

                  _texelSize.set(invActualSize, invActualSize);

                  const modX = _projPos.x % _texelSize.x;
                  const modY = _projPos.y % _texelSize.y;

                  _projSnap.set(_projPos.x - modX, _projPos.y - modY, _projPos.z);

                  Mat4.invert(_matShadowViewProjArbitaryPosInv, _matShadowViewProjArbitaryPos);
                  Vec3.transformMat4(_snap, _projSnap, _matShadowViewProjArbitaryPosInv);
                  Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _snap);
                  Mat4.invert(_matShadowView, _matShadowTrans);
                  Mat4.invert(_matShadowViewInv, _matShadowView);
                  Frustum.createOrtho(out, orthoSize, orthoSize, 0.1, shadowInfo.shadowCameraFar, _matShadowViewInv);
                } else {
                  for (let i = 0; i < 8; i++) {
                    out.vertices[i].set(0.0, 0.0, 0.0);
                  }

                  out.updatePlanes();
                }

                Mat4.multiply(_matShadowViewProj, _matShadowProj, _matShadowView);
                shadowInfo.matShadowView = _matShadowView;
                shadowInfo.matShadowProj = _matShadowProj;
                shadowInfo.matShadowViewProj = _matShadowViewProj;
              }
            }
            function sceneCulling(pipeline, camera) {
              const scene = camera.scene;
              const mainLight = scene.mainLight;
              const sceneData = pipeline.pipelineSceneData;
              const shadows = sceneData.shadows;
              const skybox = sceneData.skybox;
              const renderObjects = sceneData.renderObjects;
              roPool.freeArray(renderObjects);
              renderObjects.length = 0;
              const castShadowObjects = sceneData.castShadowObjects;
              castShadowPool.freeArray(castShadowObjects);
              castShadowObjects.length = 0;
              _castBoundsInited = false;
              let dirShadowObjects = null;

              if (shadows.enabled) {
                pipeline.pipelineUBO.updateShadowUBORange(UBOShadow.SHADOW_COLOR_OFFSET, shadows.shadowColor);

                if (shadows.type === ShadowType.ShadowMap) {
                  dirShadowObjects = pipeline.pipelineSceneData.dirShadowObjects;
                  dirShadowPool.freeArray(dirShadowObjects);
                  dirShadowObjects.length = 0;

                  if (mainLight && mainLight.node) {
                    QuantizeDirLightShadowCamera(_dirLightFrustum, pipeline, mainLight, camera, shadows);
                  } else {
                    for (let i = 0; i < 8; i++) {
                      _dirLightFrustum.vertices[i].set(0.0, 0.0, 0.0);
                    }

                    _dirLightFrustum.updatePlanes();
                  }
                }
              }

              if (mainLight) {
                if (shadows.type === ShadowType.Planar) {
                  updateDirLight(pipeline, mainLight);
                }
              }

              if (skybox.enabled && skybox.model && camera.clearFlag & SKYBOX_FLAG) {
                renderObjects.push(getRenderObject(skybox.model, camera));
              }

              const models = scene.models;
              const visibility = camera.visibility;

              for (let i = 0; i < models.length; i++) {
                const model = models[i];

                if (model.enabled) {
                  if (model.castShadow) {
                    castShadowObjects.push(getCastShadowRenderObject(model, camera));
                  }

                  if (shadows.firstSetCSM && model.worldBounds) {
                    if (!_castBoundsInited) {
                      _castWorldBounds.copy(model.worldBounds);

                      _castBoundsInited = true;
                    }

                    AABB.merge(_castWorldBounds, _castWorldBounds, model.worldBounds);
                  }

                  if (model.node && (visibility & model.node.layer) === model.node.layer || visibility & model.visFlags) {
                    if (dirShadowObjects != null && model.castShadow && model.worldBounds) {
                      if (intersect.aabbFrustum(model.worldBounds, _dirLightFrustum)) {
                        dirShadowObjects.push(getDirShadowRenderObject(model, camera));
                      }
                    }

                    if (model.worldBounds && !intersect.aabbFrustum(model.worldBounds, camera.frustum)) {
                      continue;
                    }

                    renderObjects.push(getRenderObject(model, camera));
                  }
                }
              }

              if (shadows.firstSetCSM) {
                shadows.shadowDistance = _castWorldBounds.halfExtents.length() * 2.0;
                shadows.firstSetCSM = false;
              }
            }

            const _samplerLinearInfo = new SamplerInfo(Filter.LINEAR, Filter.LINEAR, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);

            const _samplerPointInfo = new SamplerInfo(Filter.POINT, Filter.POINT, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);

            class GlobalDSManager {
              get descriptorSetMap() {
                return this._descriptorSetMap;
              }

              get linearSampler() {
                return this._linearSampler;
              }

              get pointSampler() {
                return this._pointSampler;
              }

              get descriptorSetLayout() {
                return this._descriptorSetLayout;
              }

              get globalDescriptorSet() {
                return this._globalDescriptorSet;
              }

              constructor(pipeline) {
                this._device = void 0;
                this._descriptorSetMap = new Map();
                this._globalDescriptorSet = void 0;
                this._descriptorSetLayout = void 0;
                this._linearSampler = void 0;
                this._pointSampler = void 0;
                this._device = pipeline.device;
                this._linearSampler = this._device.getSampler(_samplerLinearInfo);
                this._pointSampler = this._device.getSampler(_samplerPointInfo);
                const layoutInfo = new DescriptorSetLayoutInfo(globalDescriptorSetLayout.bindings);
                this._descriptorSetLayout = this._device.createDescriptorSetLayout(layoutInfo);
                this._globalDescriptorSet = this._device.createDescriptorSet(new DescriptorSetInfo(this._descriptorSetLayout));
              }

              bindBuffer(binding, buffer) {
                this._globalDescriptorSet.bindBuffer(binding, buffer);

                const it = this._descriptorSetMap.values();

                let res = it.next();

                while (!res.done) {
                  const descriptorSet = res.value;
                  descriptorSet.bindBuffer(binding, buffer);
                  res = it.next();
                }
              }

              bindSampler(binding, sampler) {
                this._globalDescriptorSet.bindSampler(binding, sampler);

                const it = this._descriptorSetMap.values();

                let res = it.next();

                while (!res.done) {
                  const descriptorSet = res.value;
                  descriptorSet.bindSampler(binding, sampler);
                  res = it.next();
                }
              }

              bindTexture(binding, texture) {
                this._globalDescriptorSet.bindTexture(binding, texture);

                const it = this._descriptorSetMap.values();

                let res = it.next();

                while (!res.done) {
                  const descriptorSet = res.value;
                  descriptorSet.bindTexture(binding, texture);
                  res = it.next();
                }
              }

              update() {
                this._globalDescriptorSet.update();

                const it = this._descriptorSetMap.values();

                let res = it.next();

                while (!res.done) {
                  const descriptorSet = res.value;
                  descriptorSet.update();
                  res = it.next();
                }
              }

              getOrCreateDescriptorSet(idx) {
                const device = this._device;

                if (!this._descriptorSetMap.has(idx)) {
                  const globalDescriptorSet = this._globalDescriptorSet;
                  const descriptorSet = device.createDescriptorSet(new DescriptorSetInfo(this._descriptorSetLayout));

                  this._descriptorSetMap.set(idx, descriptorSet);

                  for (let i = PipelineGlobalBindings.UBO_GLOBAL; i < PipelineGlobalBindings.COUNT; i++) {
                    descriptorSet.bindBuffer(i, globalDescriptorSet.getBuffer(i));
                    descriptorSet.bindSampler(i, globalDescriptorSet.getSampler(i));
                    descriptorSet.bindTexture(i, globalDescriptorSet.getTexture(i));
                  }

                  const shadowUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOShadow.SIZE, UBOShadow.SIZE));
                  descriptorSet.bindBuffer(UBOShadow.BINDING, shadowUBO);
                  descriptorSet.update();
                }

                return this._descriptorSetMap.get(idx);
              }

              destroy() {
                this._descriptorSetLayout.destroy();
              }

            }

            const _min$1 = new Vec3();

            const _max$1 = new Vec3();

            const _v0 = new Vec3();

            const _v1 = new Vec3();

            const _v2 = new Vec3();

            const _v3$1 = new Vec3();

            const _v4 = new Vec3();

            const _v5 = new Vec3();

            const _v6 = new Vec3();

            const _v7 = new Vec3();

            const GEOMETRY_DEPTH_TYPE_COUNT = 2;
            const GEOMETRY_NO_DEPTH_TEST_PASS_NUM = 1;
            const GEOMETRY_DEPTH_TEST_PASS_NUM = 2;
            const GEOMETRY_VERTICES_PER_LINE = 2;
            const GEOMETRY_VERTICES_PER_TRIANGLE = 3;
            const GEOMETRY_MAX_LINES = 100000;
            const GEOMETRY_MAX_DASHED_LINES = 10000;
            const GEOMETRY_MAX_TRIANGLES = 10000;
            var GeometryType;

            (function (GeometryType) {
              GeometryType[GeometryType["LINE"] = 0] = "LINE";
              GeometryType[GeometryType["DASHED_LINE"] = 1] = "DASHED_LINE";
              GeometryType[GeometryType["TRIANGLE"] = 2] = "TRIANGLE";
            })(GeometryType || (GeometryType = {}));

            class GeometryVertexBuffer {
              constructor() {
                this._maxVertices = 0;
                this._vertexCount = 0;
                this._stride = 0;
              }

              init(device, maxVertices, stride, attributes) {
                this._maxVertices = maxVertices;
                this._vertexCount = 0;
                this._stride = stride;
                this._vertices = new Float32Array(maxVertices * stride / Float32Array.BYTES_PER_ELEMENT);
              }

              empty() {
                return this._vertexCount === 0;
              }

              reset() {
                this._vertexCount = 0;
              }

              update() {
                if (!this.empty()) {
                  const count = Math.min(this._vertexCount, this._maxVertices);
                  const size = count * this._stride;

                  this._buffer.update(this._vertices, size);
                }
              }

              destroy() {
                if (this._inputAssembler) {
                  this._inputAssembler.destroy();
                }

                if (this._buffer) {
                  this._buffer.destroy();
                }
              }

            }

            class GeometryVertexBuffers {
              constructor() {
                this.lines = [];
                this.dashedLines = [];
                this.triangles = [];

                for (let i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
                  this.lines[i] = new GeometryVertexBuffer();
                  this.dashedLines[i] = new GeometryVertexBuffer();
                  this.triangles[i] = new GeometryVertexBuffer();
                }
              }

            }

            class GeometryRenderer {
              constructor() {
                this._device = null;
                this._pipeline = null;
                this._buffers = void 0;
                this._nativeObj = null;
                this._buffers = new GeometryVertexBuffers();

                {
                  this._nativeObj = new NativeGeometryRenderer();
                }
              }

              get native() {
                return this._nativeObj;
              }

              activate(device, pipeline, config) {
                this._device = device;
                this._pipeline = pipeline;
                const posColorAttributes = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
                const posNormColorAttributes = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
                const maxLines = config ? config.maxLines : GEOMETRY_MAX_LINES;
                const maxDashedLines = config ? config.maxDashedLines : GEOMETRY_MAX_DASHED_LINES;
                const maxTriangles = config ? config.maxTriangles : GEOMETRY_MAX_TRIANGLES;
                const lineStride = Float32Array.BYTES_PER_ELEMENT * (Vec3.length + Color.length);
                const triangleStride = Float32Array.BYTES_PER_ELEMENT * (Vec3.length + Vec4.length + Color.length);

                for (let i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
                  this._buffers.lines[i].init(this._device, maxLines * GEOMETRY_VERTICES_PER_LINE, lineStride, posColorAttributes);

                  this._buffers.dashedLines[i].init(this._device, maxDashedLines * GEOMETRY_VERTICES_PER_LINE, lineStride, posColorAttributes);

                  this._buffers.triangles[i].init(this._device, maxTriangles * GEOMETRY_VERTICES_PER_TRIANGLE, triangleStride, posNormColorAttributes);
                }
              }

              flush() {
                {
                  for (let i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
                    const lines = this._buffers.lines[i];

                    if (!lines.empty()) {
                      this._nativeObj.flushFromJSB(GeometryType.LINE, i, lines._vertices, lines._vertexCount);

                      lines.reset();
                    }

                    const dashedLines = this._buffers.dashedLines[i];

                    if (!dashedLines.empty()) {
                      this._nativeObj.flushFromJSB(GeometryType.DASHED_LINE, i, dashedLines._vertices, dashedLines._vertexCount);

                      dashedLines.reset();
                    }

                    const triangles = this._buffers.triangles[i];

                    if (!triangles.empty()) {
                      this._nativeObj.flushFromJSB(GeometryType.TRIANGLE, i, triangles._vertices, triangles._vertexCount);

                      triangles.reset();
                    }
                  }
                }
              }

              render(renderPass, cmdBuff) {
                this.update();
                const passes = this._pipeline.pipelineSceneData.geometryRendererPasses;
                const shaders = this._pipeline.pipelineSceneData.geometryRendererShaders;
                let offset = 0;
                const passCount = [GEOMETRY_NO_DEPTH_TEST_PASS_NUM, GEOMETRY_DEPTH_TEST_PASS_NUM];

                for (let i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
                  const lines = this._buffers.lines[i];

                  if (!lines.empty()) {
                    const drawInfo = new DrawInfo();
                    drawInfo.vertexCount = lines._vertexCount;

                    for (let p = 0; p < passCount[i]; p++) {
                      const pass = passes[offset + p];
                      const shader = shaders[offset + p];
                      const pso = PipelineStateManager.getOrCreatePipelineState(this._device, pass, shader, renderPass, lines._inputAssembler);
                      cmdBuff.bindPipelineState(pso);
                      cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
                      cmdBuff.bindInputAssembler(lines._inputAssembler);
                      cmdBuff.draw(drawInfo);
                    }
                  }

                  offset += passCount[i];
                }

                for (let i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
                  const dashedLines = this._buffers.dashedLines[i];

                  if (!dashedLines.empty()) {
                    const drawInfo = new DrawInfo();
                    drawInfo.vertexCount = dashedLines._vertexCount;

                    for (let p = 0; p < passCount[i]; p++) {
                      const pass = passes[offset + p];
                      const shader = shaders[offset + p];
                      const pso = PipelineStateManager.getOrCreatePipelineState(this._device, pass, shader, renderPass, dashedLines._inputAssembler);
                      cmdBuff.bindPipelineState(pso);
                      cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
                      cmdBuff.bindInputAssembler(dashedLines._inputAssembler);
                      cmdBuff.draw(drawInfo);
                    }
                  }

                  offset += passCount[i];
                }

                for (let i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
                  const triangles = this._buffers.triangles[i];

                  if (!triangles.empty()) {
                    const drawInfo = new DrawInfo();
                    drawInfo.vertexCount = triangles._vertexCount;

                    for (let p = 0; p < passCount[i]; p++) {
                      const pass = passes[offset + p];
                      const shader = shaders[offset + p];
                      const pso = PipelineStateManager.getOrCreatePipelineState(this._device, pass, shader, renderPass, triangles._inputAssembler);
                      cmdBuff.bindPipelineState(pso);
                      cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, pass.descriptorSet);
                      cmdBuff.bindInputAssembler(triangles._inputAssembler);
                      cmdBuff.draw(drawInfo);
                    }
                  }

                  offset += passCount[i];
                }

                this.reset();
              }

              destroy() {
                {
                  this._nativeObj = null;
                  return;
                }
              }

              update() {
                for (let i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
                  this._buffers.lines[i].update();

                  this._buffers.dashedLines[i].update();

                  this._buffers.triangles[i].update();
                }
              }

              reset() {
                for (let i = 0; i < GEOMETRY_DEPTH_TYPE_COUNT; i++) {
                  this._buffers.lines[i].reset();

                  this._buffers.dashedLines[i].reset();

                  this._buffers.triangles[i].reset();
                }
              }

              addDashedLine(v0, v1, color, depthTest = true) {
                const dashedLines = this._buffers.dashedLines[depthTest ? 1 : 0];

                if (dashedLines._vertexCount + GEOMETRY_VERTICES_PER_LINE > dashedLines._maxVertices) {
                  warnID(12008);
                  return;
                }

                let offset = dashedLines._vertexCount * (Vec3.length + Color.length);
                Vec3.toArray(dashedLines._vertices, v0, offset);
                offset += Vec3.length;
                Color.toArray(dashedLines._vertices, color, offset);
                offset += Color.length;
                Vec3.toArray(dashedLines._vertices, v1, offset);
                offset += Vec3.length;
                Color.toArray(dashedLines._vertices, color, offset);
                dashedLines._vertexCount += GEOMETRY_VERTICES_PER_LINE;
              }

              addLine(v0, v1, color, depthTest = true) {
                const lines = this._buffers.lines[depthTest ? 1 : 0];

                if (lines._vertexCount + GEOMETRY_VERTICES_PER_LINE > lines._maxVertices) {
                  warnID(12008);
                  return;
                }

                let offset = lines._vertexCount * (Vec3.length + Color.length);
                Vec3.toArray(lines._vertices, v0, offset);
                offset += Vec3.length;
                Color.toArray(lines._vertices, color, offset);
                offset += Color.length;
                Vec3.toArray(lines._vertices, v1, offset);
                offset += Vec3.length;
                Color.toArray(lines._vertices, color, offset);
                lines._vertexCount += GEOMETRY_VERTICES_PER_LINE;
              }

              addTriangle(v0, v1, v2, color, wireframe = true, depthTest = true, unlit = false) {
                if (wireframe) {
                  this.addLine(v0, v1, color, depthTest);
                  this.addLine(v1, v2, color, depthTest);
                  this.addLine(v2, v0, color, depthTest);
                  return;
                }

                const triangles = this._buffers.triangles[depthTest ? 1 : 0];

                if (triangles._vertexCount + GEOMETRY_VERTICES_PER_TRIANGLE > triangles._maxVertices) {
                  warnID(12009);
                  return;
                }

                const normal = new Vec4(Vec4.ZERO);

                if (!unlit) {
                  const dist1 = new Vec3(v1.x - v0.x, v1.y - v0.y, v1.z - v0.z);
                  const dist2 = new Vec3(v2.x - v0.x, v2.y - v0.y, v2.z - v0.z);
                  const norm = new Vec3();
                  Vec3.normalize(norm, Vec3.cross(norm, dist1, dist2));
                  normal.set(norm.x, norm.y, norm.z, 1.0);
                }

                let offset = triangles._vertexCount * (Vec3.length + Vec4.length + Color.length);
                Vec3.toArray(triangles._vertices, v0, offset);
                offset += Vec3.length;
                Vec4.toArray(triangles._vertices, normal, offset);
                offset += Vec4.length;
                Color.toArray(triangles._vertices, color, offset);
                offset += Color.length;
                Vec3.toArray(triangles._vertices, v1, offset);
                offset += Vec3.length;
                Vec4.toArray(triangles._vertices, normal, offset);
                offset += Vec4.length;
                Color.toArray(triangles._vertices, color, offset);
                offset += Color.length;
                Vec3.toArray(triangles._vertices, v2, offset);
                offset += Vec3.length;
                Vec4.toArray(triangles._vertices, normal, offset);
                offset += Vec4.length;
                Color.toArray(triangles._vertices, color, offset);
                triangles._vertexCount += GEOMETRY_VERTICES_PER_TRIANGLE;
              }

              addQuad(v0, v1, v2, v3, color, wireframe = true, depthTest = true, unlit = false) {
                if (wireframe) {
                  this.addLine(v0, v1, color, depthTest);
                  this.addLine(v1, v2, color, depthTest);
                  this.addLine(v2, v3, color, depthTest);
                  this.addLine(v3, v0, color, depthTest);
                } else {
                  this.addTriangle(v0, v1, v2, color, wireframe, depthTest, unlit);
                  this.addTriangle(v0, v2, v3, color, wireframe, depthTest, unlit);
                }
              }

              addBoundingBox(aabb, color, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                _min$1.set(aabb.center.x - aabb.halfExtents.x, aabb.center.y - aabb.halfExtents.y, aabb.center.z - aabb.halfExtents.z);

                _max$1.set(aabb.center.x + aabb.halfExtents.x, aabb.center.y + aabb.halfExtents.y, aabb.center.z + aabb.halfExtents.z);

                _v0.set(_min$1.x, _min$1.y, _min$1.z);

                _v1.set(_max$1.x, _min$1.y, _min$1.z);

                _v2.set(_min$1.x, _max$1.y, _min$1.z);

                _v3$1.set(_max$1.x, _max$1.y, _min$1.z);

                _v4.set(_min$1.x, _min$1.y, _max$1.z);

                _v5.set(_max$1.x, _min$1.y, _max$1.z);

                _v6.set(_min$1.x, _max$1.y, _max$1.z);

                _v7.set(_max$1.x, _max$1.y, _max$1.z);

                if (useTransform) {
                  Vec3.transformMat4(_v0, _v0, transform);
                  Vec3.transformMat4(_v1, _v1, transform);
                  Vec3.transformMat4(_v2, _v2, transform);
                  Vec3.transformMat4(_v3$1, _v3$1, transform);
                  Vec3.transformMat4(_v4, _v4, transform);
                  Vec3.transformMat4(_v5, _v5, transform);
                  Vec3.transformMat4(_v6, _v6, transform);
                  Vec3.transformMat4(_v7, _v7, transform);
                }

                if (wireframe) {
                  this.addLine(_v6, _v7, color, depthTest);
                  this.addLine(_v7, _v3$1, color, depthTest);
                  this.addLine(_v3$1, _v2, color, depthTest);
                  this.addLine(_v2, _v6, color, depthTest);
                  this.addLine(_v4, _v5, color, depthTest);
                  this.addLine(_v5, _v1, color, depthTest);
                  this.addLine(_v1, _v0, color, depthTest);
                  this.addLine(_v0, _v4, color, depthTest);
                  this.addLine(_v6, _v4, color, depthTest);
                  this.addLine(_v7, _v5, color, depthTest);
                  this.addLine(_v3$1, _v1, color, depthTest);
                  this.addLine(_v2, _v0, color, depthTest);
                } else {
                  this.addQuad(_v4, _v5, _v7, _v6, color, wireframe, depthTest, unlit);
                  this.addQuad(_v5, _v1, _v3$1, _v7, color, wireframe, depthTest, unlit);
                  this.addQuad(_v1, _v0, _v2, _v3$1, color, wireframe, depthTest, unlit);
                  this.addQuad(_v0, _v4, _v6, _v2, color, wireframe, depthTest, unlit);
                  this.addQuad(_v6, _v7, _v3$1, _v2, color, wireframe, depthTest, unlit);
                  this.addQuad(_v0, _v1, _v5, _v4, color, wireframe, depthTest, unlit);
                }
              }

              addCross(position, size, color, depthTest = true) {
                const halfSize = size * 0.5;
                const v0 = new Vec3(position.x - halfSize, position.y, position.z);
                const v1 = new Vec3(position.x + halfSize, position.y, position.z);
                this.addLine(v0, v1, color, depthTest);
                v0.set(position.x, position.y - halfSize, position.z);
                v1.set(position.x, position.y + halfSize, position.z);
                this.addLine(v0, v1, color, depthTest);
                v0.set(position.x, position.y, position.z - halfSize);
                v1.set(position.x, position.y, position.z + halfSize);
                this.addLine(v0, v1, color, depthTest);
              }

              addFrustum(frustum, color, depthTest = true) {
                const vertices = frustum.vertices;
                this.addLine(vertices[0], vertices[1], color, depthTest);
                this.addLine(vertices[1], vertices[2], color, depthTest);
                this.addLine(vertices[2], vertices[3], color, depthTest);
                this.addLine(vertices[3], vertices[0], color, depthTest);
                this.addLine(vertices[4], vertices[5], color, depthTest);
                this.addLine(vertices[5], vertices[6], color, depthTest);
                this.addLine(vertices[6], vertices[7], color, depthTest);
                this.addLine(vertices[7], vertices[4], color, depthTest);
                this.addLine(vertices[0], vertices[4], color, depthTest);
                this.addLine(vertices[1], vertices[5], color, depthTest);
                this.addLine(vertices[2], vertices[6], color, depthTest);
                this.addLine(vertices[3], vertices[7], color, depthTest);
              }

              addCapsule(center, radius, height, color, segmentsU = 32, hemiSegmentsV = 8, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                const deltaPhi = Math.PI * 2.0 / segmentsU;
                const deltaTheta = Math.PI / 2.0 / hemiSegmentsV;
                const bottomCenter = new Vec3(center.x, center.y - height / 2.0, center.z);
                const topCenter = new Vec3(center.x, center.y + height / 2.0, center.z);
                const bottomPoints = new Array();
                const topPoints = new Array();

                for (let i = 0; i < hemiSegmentsV + 1; i++) {
                  const bottomList = new Array();
                  const topList = new Array();
                  const theta = i * deltaTheta;
                  const sinTheta = Math.sin(theta);
                  const cosTheta = Math.cos(theta);

                  for (let j = 0; j < segmentsU + 1; j++) {
                    const phi = j * deltaPhi;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    const p = new Vec3(radius * sinTheta * cosPhi, radius * cosTheta, radius * sinTheta * sinPhi);
                    const p0 = new Vec3(bottomCenter.x + p.x, bottomCenter.y - p.y, bottomCenter.z + p.z);
                    const p1 = new Vec3(topCenter.x + p.x, topCenter.y + p.y, topCenter.z + p.z);
                    bottomList.push(p0);
                    topList.push(p1);
                  }

                  bottomPoints.push(bottomList);
                  topPoints.push(topList);
                }

                if (useTransform) {
                  for (let i = 0; i < hemiSegmentsV + 1; i++) {
                    for (let j = 0; j < segmentsU + 1; j++) {
                      Vec3.transformMat4(bottomPoints[i][j], bottomPoints[i][j], transform);
                      Vec3.transformMat4(topPoints[i][j], topPoints[i][j], transform);
                    }
                  }
                }

                for (let i = 0; i < hemiSegmentsV; i++) {
                  for (let j = 0; j < segmentsU; j++) {
                    this.addTriangle(bottomPoints[i + 1][j], bottomPoints[i][j + 1], bottomPoints[i][j], color, wireframe, depthTest, unlit);
                    this.addTriangle(bottomPoints[i + 1][j], bottomPoints[i + 1][j + 1], bottomPoints[i][j + 1], color, wireframe, depthTest, unlit);
                    this.addTriangle(topPoints[i][j], topPoints[i + 1][j + 1], topPoints[i + 1][j], color, wireframe, depthTest, unlit);
                    this.addTriangle(topPoints[i][j], topPoints[i][j + 1], topPoints[i + 1][j + 1], color, wireframe, depthTest, unlit);
                  }
                }

                const bottomCircle = bottomPoints[hemiSegmentsV];
                const topCircle = topPoints[hemiSegmentsV];

                for (let j = 0; j < segmentsU; j++) {
                  this.addTriangle(topCircle[j], bottomCircle[j + 1], bottomCircle[j], color, wireframe, depthTest, unlit);
                  this.addTriangle(topCircle[j], topCircle[j + 1], bottomCircle[j + 1], color, wireframe, depthTest, unlit);
                }
              }

              addCylinder(center, radius, height, color, segments = 32, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                const deltaPhi = Math.PI * 2.0 / segments;
                const bottomCenter = new Vec3(center.x, center.y - height / 2.0, center.z);
                const topCenter = new Vec3(center.x, center.y + height / 2.0, center.z);
                const bottomPoints = new Array();
                const topPoints = new Array();

                for (let i = 0; i < segments + 1; i++) {
                  const phi = i * deltaPhi;
                  const p = new Vec3(radius * Math.cos(phi), 0.0, radius * Math.sin(phi));
                  const p0 = new Vec3(p.x + bottomCenter.x, p.y + bottomCenter.y, p.z + bottomCenter.z);
                  const p1 = new Vec3(p.x + topCenter.x, p.y + topCenter.y, p.z + topCenter.z);
                  bottomPoints.push(p0);
                  topPoints.push(p1);
                }

                if (useTransform) {
                  Vec3.transformMat4(bottomCenter, bottomCenter, transform);
                  Vec3.transformMat4(topCenter, topCenter, transform);

                  for (let i = 0; i < segments + 1; i++) {
                    Vec3.transformMat4(bottomPoints[i], bottomPoints[i], transform);
                    Vec3.transformMat4(topPoints[i], topPoints[i], transform);
                  }
                }

                for (let i = 0; i < segments; i++) {
                  this.addTriangle(topCenter, topPoints[i + 1], topPoints[i], color, wireframe, depthTest, unlit);
                  this.addTriangle(bottomCenter, bottomPoints[i], bottomPoints[i + 1], color, wireframe, depthTest, unlit);
                  this.addTriangle(topPoints[i], bottomPoints[i + 1], bottomPoints[i], color, wireframe, depthTest, unlit);
                  this.addTriangle(topPoints[i], topPoints[i + 1], bottomPoints[i + 1], color, wireframe, depthTest, unlit);
                }
              }

              addCone(center, radius, height, color, segments = 32, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                const deltaPhi = Math.PI * 2.0 / segments;
                const bottomCenter = new Vec3(center.x, center.y - height / 2.0, center.z);
                const topCenter = new Vec3(center.x, center.y + height / 2.0, center.z);
                const bottomPoints = new Array();

                for (let i = 0; i < segments + 1; i++) {
                  const point = new Vec3(radius * Math.cos(i * deltaPhi), 0.0, radius * Math.sin(i * deltaPhi));
                  const p0 = new Vec3(point.x + bottomCenter.x, point.y + bottomCenter.y, point.z + bottomCenter.z);
                  bottomPoints.push(p0);
                }

                if (useTransform) {
                  Vec3.transformMat4(bottomCenter, bottomCenter, transform);
                  Vec3.transformMat4(topCenter, topCenter, transform);

                  for (let i = 0; i < segments + 1; i++) {
                    Vec3.transformMat4(bottomPoints[i], bottomPoints[i], transform);
                  }
                }

                for (let i = 0; i < segments; i++) {
                  this.addTriangle(topCenter, bottomPoints[i + 1], bottomPoints[i], color, wireframe, depthTest, unlit);
                  this.addTriangle(bottomCenter, bottomPoints[i], bottomPoints[i + 1], color, wireframe, depthTest, unlit);
                }
              }

              addCircle(center, radius, color, segments = 32, depthTest = true, useTransform = false, transform = new Mat4()) {
                const deltaPhi = Math.PI * 2.0 / segments;
                const points = new Array();

                for (let i = 0; i < segments + 1; i++) {
                  const point = new Vec3(radius * Math.cos(i * deltaPhi), 0.0, radius * Math.sin(i * deltaPhi));
                  const p0 = new Vec3(point.x + center.x, point.y + center.y, point.z + center.z);
                  points.push(p0);
                }

                if (useTransform) {
                  for (let i = 0; i < segments + 1; i++) {
                    Vec3.transformMat4(points[i], points[i], transform);
                  }
                }

                for (let i = 0; i < segments; i++) {
                  this.addLine(points[i], points[i + 1], color, depthTest);
                }
              }

              addArc(center, radius, color, startAngle, endAngle, segments = 32, depthTest = true, useTransform = false, transform = new Mat4()) {
                const startRadian = toRadian(startAngle);
                const endRadian = toRadian(endAngle);
                const deltaPhi = (endRadian - startRadian) / segments;
                const points = new Array();

                for (let i = 0; i < segments + 1; i++) {
                  const point = new Vec3(radius * Math.cos(i * deltaPhi + startRadian), 0.0, radius * Math.sin(i * deltaPhi + startRadian));
                  const p0 = new Vec3(point.x + center.x, point.y + center.y, point.z + center.z);
                  points.push(p0);
                }

                if (useTransform) {
                  for (let i = 0; i < segments + 1; i++) {
                    Vec3.transformMat4(points[i], points[i], transform);
                  }
                }

                for (let i = 0; i < segments; i++) {
                  this.addLine(points[i], points[i + 1], color, depthTest);
                }
              }

              addPolygon(center, radius, color, segments = 6, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                if (wireframe) {
                  this.addCircle(center, radius, color, segments, depthTest, useTransform, transform);
                } else {
                  this.addDisc(center, radius, color, segments, wireframe, depthTest, unlit, useTransform, transform);
                }
              }

              addDisc(center, radius, color, segments = 32, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                const deltaPhi = Math.PI * 2.0 / segments;
                const points = new Array();
                const newCenter = new Vec3(center);

                for (let i = 0; i < segments + 1; i++) {
                  const point = new Vec3(radius * Math.cos(i * deltaPhi), 0.0, radius * Math.sin(i * deltaPhi));
                  const p0 = new Vec3(point.x + newCenter.x, point.y + newCenter.y, point.z + newCenter.z);
                  points.push(p0);
                }

                if (useTransform) {
                  Vec3.transformMat4(newCenter, newCenter, transform);

                  for (let i = 0; i < segments + 1; i++) {
                    Vec3.transformMat4(points[i], points[i], transform);
                  }
                }

                for (let i = 0; i < segments; i++) {
                  this.addTriangle(newCenter, points[i], points[i + 1], color, wireframe, depthTest, unlit);
                }

                if (!wireframe) {
                  for (let i = 0; i < segments; i++) {
                    this.addTriangle(newCenter, points[i + 1], points[i], color, wireframe, depthTest, unlit);
                  }
                }
              }

              addSector(center, radius, color, startAngle, endAngle, segments = 32, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                const startRadian = toRadian(startAngle);
                const endRadian = toRadian(endAngle);
                const deltaPhi = (endRadian - startRadian) / segments;
                const points = new Array();
                const newCenter = new Vec3(center);

                for (let i = 0; i < segments + 1; i++) {
                  const point = new Vec3(radius * Math.cos(i * deltaPhi), 0.0, radius * Math.sin(i * deltaPhi));
                  const p0 = new Vec3(point.x + newCenter.x, point.y + newCenter.y, point.z + newCenter.z);
                  points.push(p0);
                }

                if (useTransform) {
                  Vec3.transformMat4(newCenter, newCenter, transform);

                  for (let i = 0; i < segments + 1; i++) {
                    Vec3.transformMat4(points[i], points[i], transform);
                  }
                }

                for (let i = 0; i < segments; i++) {
                  this.addTriangle(newCenter, points[i], points[i + 1], color, wireframe, depthTest, unlit);
                }

                if (!wireframe) {
                  for (let i = 0; i < segments; i++) {
                    this.addTriangle(newCenter, points[i + 1], points[i], color, wireframe, depthTest, unlit);
                  }
                }
              }

              addSphere(center, radius, color, segmentsU = 32, segmentsV = 16, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                const deltaPhi = Math.PI * 2.0 / segmentsU;
                const deltaTheta = Math.PI / segmentsV;
                const points = new Array();

                for (let i = 0; i < segmentsV + 1; i++) {
                  const list = new Array();
                  const theta = i * deltaTheta;
                  const sinTheta = Math.sin(theta);
                  const cosTheta = Math.cos(theta);

                  for (let j = 0; j < segmentsU + 1; j++) {
                    const phi = j * deltaPhi;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    const p = new Vec3(radius * sinTheta * cosPhi, radius * cosTheta, radius * sinTheta * sinPhi);
                    const p0 = new Vec3(center.x + p.x, center.y + p.y, center.z + p.z);
                    list.push(p0);
                  }

                  points.push(list);
                }

                if (useTransform) {
                  for (let i = 0; i < segmentsV + 1; i++) {
                    for (let j = 0; j < segmentsU + 1; j++) {
                      Vec3.transformMat4(points[i][j], points[i][j], transform);
                    }
                  }
                }

                for (let i = 0; i < segmentsV; i++) {
                  for (let j = 0; j < segmentsU; j++) {
                    this.addTriangle(points[i][j], points[i + 1][j + 1], points[i + 1][j], color, wireframe, depthTest, unlit);
                    this.addTriangle(points[i][j], points[i][j + 1], points[i + 1][j + 1], color, wireframe, depthTest, unlit);
                  }
                }
              }

              addTorus(center, bigRadius, radius, color, segmentsU = 32, segmentsV = 16, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                const deltaPhi = Math.PI * 2.0 / segmentsU;
                const deltaTheta = Math.PI * 2.0 / segmentsV;
                const points = new Array();

                for (let i = 0; i < segmentsU + 1; i++) {
                  const list = new Array();
                  const phi = i * deltaPhi;
                  const sinPhi = Math.sin(phi);
                  const cosPhi = Math.cos(phi);

                  for (let j = 0; j < segmentsV + 1; j++) {
                    const theta = j * deltaTheta;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    const p = new Vec3((bigRadius + radius * cosTheta) * cosPhi, radius * sinTheta, (bigRadius + radius * cosTheta) * sinPhi);
                    const p0 = new Vec3(center.x + p.x, center.y + p.y, center.z + p.z);
                    list.push(p0);
                  }

                  points.push(list);
                }

                if (useTransform) {
                  for (let i = 0; i < segmentsU + 1; i++) {
                    for (let j = 0; j < segmentsV + 1; j++) {
                      Vec3.transformMat4(points[i][j], points[i][j], transform);
                    }
                  }
                }

                for (let i = 0; i < segmentsU; i++) {
                  for (let j = 0; j < segmentsV; j++) {
                    this.addTriangle(points[i][j + 1], points[i + 1][j], points[i][j], color, wireframe, depthTest, unlit);
                    this.addTriangle(points[i][j + 1], points[i + 1][j + 1], points[i + 1][j], color, wireframe, depthTest, unlit);
                  }
                }
              }

              addOctahedron(center, radius, color, wireframe = true, depthTest = true, unlit = false, useTransform = false, transform = new Mat4()) {
                const points = new Array();
                points.push(new Vec3(radius + center.x, center.y, center.z));
                points.push(new Vec3(center.x, center.y, center.z - radius));
                points.push(new Vec3(-radius + center.x, center.y, center.z));
                points.push(new Vec3(center.x, center.y, center.z + radius));
                points.push(new Vec3(center.x, center.y + radius, center.z));
                points.push(new Vec3(center.x, center.y - radius, center.z));

                if (useTransform) {
                  for (let i = 0; i < points.length; i++) {
                    Vec3.transformMat4(points[i], points[i], transform);
                  }
                }

                if (wireframe) {
                  this.addLine(points[0], points[1], color, depthTest);
                  this.addLine(points[1], points[2], color, depthTest);
                  this.addLine(points[2], points[3], color, depthTest);
                  this.addLine(points[3], points[0], color, depthTest);
                  this.addLine(points[0], points[4], color, depthTest);
                  this.addLine(points[1], points[4], color, depthTest);
                  this.addLine(points[2], points[4], color, depthTest);
                  this.addLine(points[3], points[4], color, depthTest);
                  this.addLine(points[0], points[5], color, depthTest);
                  this.addLine(points[1], points[5], color, depthTest);
                  this.addLine(points[2], points[5], color, depthTest);
                  this.addLine(points[3], points[5], color, depthTest);
                } else {
                  this.addTriangle(points[0], points[1], points[4], color, wireframe, depthTest, unlit);
                  this.addTriangle(points[1], points[2], points[4], color, wireframe, depthTest, unlit);
                  this.addTriangle(points[2], points[3], points[4], color, wireframe, depthTest, unlit);
                  this.addTriangle(points[3], points[0], points[4], color, wireframe, depthTest, unlit);
                  this.addTriangle(points[0], points[3], points[5], color, wireframe, depthTest, unlit);
                  this.addTriangle(points[3], points[2], points[5], color, wireframe, depthTest, unlit);
                  this.addTriangle(points[2], points[1], points[5], color, wireframe, depthTest, unlit);
                  this.addTriangle(points[1], points[0], points[5], color, wireframe, depthTest, unlit);
                }
              }

              addBezier(v0, v1, v2, v3, color, segments = 32, depthTest = true, useTransform = false, transform = new Mat4()) {
                const deltaT = 1.0 / segments;
                const points = new Array();
                const newV0 = new Vec3(v0);
                const newV1 = new Vec3(v1);
                const newV2 = new Vec3(v2);
                const newV3 = new Vec3(v3);

                if (useTransform) {
                  Vec3.transformMat4(newV0, newV0, transform);
                  Vec3.transformMat4(newV1, newV1, transform);
                  Vec3.transformMat4(newV2, newV2, transform);
                  Vec3.transformMat4(newV3, newV3, transform);
                }

                for (let i = 0; i < segments + 1; i++) {
                  const t = i * deltaT;
                  const a = (1.0 - t) * (1.0 - t) * (1.0 - t);
                  const b = 3.0 * t * (1.0 - t) * (1.0 - t);
                  const c = 3.0 * t * t * (1.0 - t);
                  const d = t * t * t;
                  const p0 = new Vec3(a * newV0.x + b * newV1.x + c * newV2.x + d * newV3.x, a * newV0.y + b * newV1.y + c * newV2.y + d * newV3.y, a * newV0.z + b * newV1.z + c * newV2.z + d * newV3.z);
                  points.push(p0);
                }

                for (let i = 0; i < segments; i++) {
                  this.addLine(points[i], points[i + 1], color, depthTest);
                }
              }

              addMesh(center, vertices, color, depthTest = true, useTransform = false, transform = new Mat4()) {
                for (let i = 0; i < vertices.length; i += 3) {
                  const v0 = new Vec3(center.x + vertices[i].x, center.y + vertices[i].y, center.z + vertices[i].z);
                  const v1 = new Vec3(center.x + vertices[i + 1].x, center.y + vertices[i + 1].y, center.z + vertices[i + 1].z);
                  const v2 = new Vec3(center.x + vertices[i + 2].x, center.y + vertices[i + 2].y, center.z + vertices[i + 2].z);

                  if (useTransform) {
                    Vec3.transformMat4(v0, v0, transform);
                    Vec3.transformMat4(v1, v1, transform);
                    Vec3.transformMat4(v2, v2, transform);
                  }

                  this.addLine(v0, v1, color, depthTest);
                  this.addLine(v1, v2, color, depthTest);
                  this.addLine(v2, v0, color, depthTest);
                }
              }

              addIndexedMesh(center, vertices, indices, color, depthTest = true, useTransform = false, transform = new Mat4()) {
                for (let i = 0; i < indices.length; i += 3) {
                  const v0 = new Vec3(center.x + vertices[indices[i]].x, center.y + vertices[indices[i]].y, center.z + vertices[indices[i]].z);
                  const v1 = new Vec3(center.x + vertices[indices[i + 1]].x, center.y + vertices[indices[i + 1]].y, center.z + vertices[indices[i + 1]].z);
                  const v2 = new Vec3(center.x + vertices[indices[i + 2]].x, center.y + vertices[indices[i + 2]].y, center.z + vertices[indices[i + 2]].z);

                  if (useTransform) {
                    Vec3.transformMat4(v0, v0, transform);
                    Vec3.transformMat4(v1, v1, transform);
                    Vec3.transformMat4(v2, v2, transform);
                  }

                  this.addLine(v0, v1, color, depthTest);
                  this.addLine(v1, v2, color, depthTest);
                  this.addLine(v2, v0, color, depthTest);
                }
              }

            }

            const _matShadowView$1 = new Mat4();

            const _matShadowProj$1 = new Mat4();

            const _matShadowViewProj$1 = new Mat4();

            const _vec4ShadowInfo = new Vec4();

            class PipelineUBO {
              constructor() {
                this._globalUBO = new Float32Array(UBOGlobal.COUNT);
                this._cameraUBO = new Float32Array(UBOCamera.COUNT);
                this._shadowUBO = new Float32Array(UBOShadow.COUNT);
              }

              static updateGlobalUBOView(window, bufferView) {
                const root = legacyCC.director.root;
                const fv = bufferView;
                const shadingWidth = Math.floor(window.width);
                const shadingHeight = Math.floor(window.height);
                fv[UBOGlobal.TIME_OFFSET] = root.cumulativeTime;
                fv[UBOGlobal.TIME_OFFSET + 1] = root.frameTime;
                fv[UBOGlobal.TIME_OFFSET + 2] = legacyCC.director.getTotalFrames();
                fv[UBOGlobal.SCREEN_SIZE_OFFSET] = shadingWidth;
                fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1] = shadingHeight;
                fv[UBOGlobal.SCREEN_SIZE_OFFSET + 2] = 1.0 / shadingWidth;
                fv[UBOGlobal.SCREEN_SIZE_OFFSET + 3] = 1.0 / shadingHeight;
                fv[UBOGlobal.NATIVE_SIZE_OFFSET] = shadingWidth;
                fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1] = shadingHeight;
                fv[UBOGlobal.NATIVE_SIZE_OFFSET + 2] = 1.0 / fv[UBOGlobal.NATIVE_SIZE_OFFSET];
                fv[UBOGlobal.NATIVE_SIZE_OFFSET + 3] = 1.0 / fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1];
              }

              static updateCameraUBOView(pipeline, bufferView, camera) {
                const root = legacyCC.director.root;
                const scene = camera.scene ? camera.scene : legacyCC.director.getScene().renderScene;
                const mainLight = scene.mainLight;
                const sceneData = pipeline.pipelineSceneData;
                const ambient = sceneData.ambient;
                const fog = sceneData.fog;
                const cv = bufferView;
                const exposure = camera.exposure;
                const isHDR = sceneData.isHDR;
                cv[UBOCamera.SCREEN_SCALE_OFFSET] = sceneData.shadingScale;
                cv[UBOCamera.SCREEN_SCALE_OFFSET + 1] = sceneData.shadingScale;
                cv[UBOCamera.SCREEN_SCALE_OFFSET + 2] = 1.0 / cv[UBOCamera.SCREEN_SCALE_OFFSET];
                cv[UBOCamera.SCREEN_SCALE_OFFSET + 3] = 1.0 / cv[UBOCamera.SCREEN_SCALE_OFFSET + 1];
                cv[UBOCamera.EXPOSURE_OFFSET] = exposure;
                cv[UBOCamera.EXPOSURE_OFFSET + 1] = 1.0 / exposure;
                cv[UBOCamera.EXPOSURE_OFFSET + 2] = isHDR ? 1.0 : 0.0;
                cv[UBOCamera.EXPOSURE_OFFSET + 3] = 0.0;

                if (mainLight) {
                  Vec3.toArray(cv, mainLight.direction, UBOCamera.MAIN_LIT_DIR_OFFSET);
                  Vec3.toArray(cv, mainLight.color, UBOCamera.MAIN_LIT_COLOR_OFFSET);

                  if (mainLight.useColorTemperature) {
                    const colorTempRGB = mainLight.colorTemperatureRGB;
                    cv[UBOCamera.MAIN_LIT_COLOR_OFFSET] *= colorTempRGB.x;
                    cv[UBOCamera.MAIN_LIT_COLOR_OFFSET + 1] *= colorTempRGB.y;
                    cv[UBOCamera.MAIN_LIT_COLOR_OFFSET + 2] *= colorTempRGB.z;
                  }

                  if (isHDR) {
                    cv[UBOCamera.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * exposure;
                  } else {
                    cv[UBOCamera.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance;
                  }
                } else {
                  Vec3.toArray(cv, Vec3.UNIT_Z, UBOCamera.MAIN_LIT_DIR_OFFSET);
                  Vec4.toArray(cv, Vec4.ZERO, UBOCamera.MAIN_LIT_COLOR_OFFSET);
                }

                const skyColor = ambient.skyColor;

                if (isHDR) {
                  skyColor.w = ambient.skyIllum * exposure;
                } else {
                  skyColor.w = ambient.skyIllum;
                }

                cv[UBOCamera.AMBIENT_SKY_OFFSET + 0] = skyColor.x;
                cv[UBOCamera.AMBIENT_SKY_OFFSET + 1] = skyColor.y;
                cv[UBOCamera.AMBIENT_SKY_OFFSET + 2] = skyColor.z;
                cv[UBOCamera.AMBIENT_SKY_OFFSET + 3] = skyColor.w;
                cv[UBOCamera.AMBIENT_GROUND_OFFSET + 0] = ambient.groundAlbedo.x;
                cv[UBOCamera.AMBIENT_GROUND_OFFSET + 1] = ambient.groundAlbedo.y;
                cv[UBOCamera.AMBIENT_GROUND_OFFSET + 2] = ambient.groundAlbedo.z;
                cv[UBOCamera.AMBIENT_GROUND_OFFSET + 3] = ambient.mipmapCount;
                Mat4.toArray(cv, camera.matView, UBOCamera.MAT_VIEW_OFFSET);
                Mat4.toArray(cv, camera.node.worldMatrix, UBOCamera.MAT_VIEW_INV_OFFSET);
                Vec3.toArray(cv, camera.position, UBOCamera.CAMERA_POS_OFFSET);
                Mat4.toArray(cv, camera.matProj, UBOCamera.MAT_PROJ_OFFSET);
                Mat4.toArray(cv, camera.matProjInv, UBOCamera.MAT_PROJ_INV_OFFSET);
                Mat4.toArray(cv, camera.matViewProj, UBOCamera.MAT_VIEW_PROJ_OFFSET);
                Mat4.toArray(cv, camera.matViewProjInv, UBOCamera.MAT_VIEW_PROJ_INV_OFFSET);
                cv[UBOCamera.CAMERA_POS_OFFSET + 3] = this.getCombineSignY();
                const colorTempRGB = fog.colorArray;
                cv[UBOCamera.GLOBAL_FOG_COLOR_OFFSET] = colorTempRGB.x;
                cv[UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 1] = colorTempRGB.y;
                cv[UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 2] = colorTempRGB.z;
                cv[UBOCamera.GLOBAL_FOG_COLOR_OFFSET + 3] = colorTempRGB.z;
                cv[UBOCamera.GLOBAL_FOG_BASE_OFFSET] = fog.fogStart;
                cv[UBOCamera.GLOBAL_FOG_BASE_OFFSET + 1] = fog.fogEnd;
                cv[UBOCamera.GLOBAL_FOG_BASE_OFFSET + 2] = fog.fogDensity;
                cv[UBOCamera.GLOBAL_FOG_ADD_OFFSET] = fog.fogTop;
                cv[UBOCamera.GLOBAL_FOG_ADD_OFFSET + 1] = fog.fogRange;
                cv[UBOCamera.GLOBAL_FOG_ADD_OFFSET + 2] = fog.fogAtten;
                cv[UBOCamera.NEAR_FAR_OFFSET] = camera.nearClip;
                cv[UBOCamera.NEAR_FAR_OFFSET + 1] = camera.farClip;
                cv[UBOCamera.VIEW_PORT_OFFSET] = camera.viewport.x;
                cv[UBOCamera.VIEW_PORT_OFFSET + 1] = camera.viewport.y;
                cv[UBOCamera.VIEW_PORT_OFFSET + 1] = camera.viewport.z;
                cv[UBOCamera.VIEW_PORT_OFFSET + 1] = camera.viewport.w;
              }

              static updateShadowUBOView(pipeline, bufferView, camera) {
                const device = pipeline.device;
                const mainLight = camera.scene.mainLight;
                const sceneData = pipeline.pipelineSceneData;
                const shadowInfo = sceneData.shadows;
                const sv = bufferView;

                if (shadowInfo.enabled) {
                  if (mainLight && shadowInfo.type === ShadowType.ShadowMap) {
                    let near = 0.1;
                    let far = 0;
                    const matShadowView = shadowInfo.matShadowView;
                    const matShadowProj = shadowInfo.matShadowProj;
                    const matShadowViewProj = shadowInfo.matShadowViewProj;

                    if (shadowInfo.fixedArea) {
                      near = shadowInfo.near;
                      far = shadowInfo.far;
                    } else {
                      near = 0.1;
                      far = shadowInfo.shadowCameraFar;
                    }

                    Mat4.toArray(bufferView, matShadowView, UBOShadow.MAT_LIGHT_VIEW_OFFSET);
                    sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 0] = matShadowProj.m10;
                    sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 1] = matShadowProj.m14;
                    sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 2] = matShadowProj.m11;
                    sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 3] = matShadowProj.m15;
                    sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 0] = matShadowProj.m00;
                    sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 1] = matShadowProj.m05;
                    sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 2] = 1.0 / matShadowProj.m00;
                    sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 3] = 1.0 / matShadowProj.m05;
                    Mat4.toArray(bufferView, matShadowViewProj, UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET);
                    const linear = 0.0;
                    const packing = supportsFloatTexture(device) ? 0.0 : 1.0;
                    sv[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 0] = near;
                    sv[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 1] = far;
                    sv[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 2] = linear;
                    sv[UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 3] = 1.0 - shadowInfo.saturation;
                    sv[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = shadowInfo.size.x;
                    sv[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = shadowInfo.size.y;
                    sv[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = shadowInfo.pcf;
                    sv[UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = shadowInfo.bias;
                    sv[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 0.0;
                    sv[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = packing;
                    sv[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = shadowInfo.normalBias;
                    sv[UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0.0;
                  } else if (mainLight && shadowInfo.type === ShadowType.Planar) {
                    updatePlanarPROJ(shadowInfo, mainLight, sv);
                    updatePlanarNormalAndDistance(shadowInfo, sv);
                  }

                  Color.toArray(sv, shadowInfo.shadowColor, UBOShadow.SHADOW_COLOR_OFFSET);
                }
              }

              static updateShadowUBOLightView(pipeline, bufferView, light) {
                const device = pipeline.device;
                const shadowInfo = pipeline.pipelineSceneData.shadows;
                const sv = bufferView;
                const linear = 0.0;
                const packing = supportsFloatTexture(device) ? 0.0 : 1.0;
                let near = 0.1;
                let far = 0;
                const matShadowView = shadowInfo.matShadowView;
                const matShadowProj = shadowInfo.matShadowProj;
                const matShadowViewProj = shadowInfo.matShadowViewProj;

                switch (light.type) {
                  case LightType.DIRECTIONAL:
                    if (shadowInfo.fixedArea) {
                      near = shadowInfo.near;
                      far = shadowInfo.far;
                    } else {
                      near = 0.1;
                      far = shadowInfo.shadowCameraFar;
                    }

                    Mat4.toArray(bufferView, matShadowView, UBOShadow.MAT_LIGHT_VIEW_OFFSET);
                    sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 0] = matShadowProj.m10;
                    sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 1] = matShadowProj.m14;
                    sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 2] = matShadowProj.m11;
                    sv[UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET + 3] = matShadowProj.m15;
                    sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 0] = matShadowProj.m00;
                    sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 1] = matShadowProj.m05;
                    sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 2] = 1.0 / matShadowProj.m00;
                    sv[UBOShadow.SHADOW_PROJ_INFO_OFFSET + 3] = 1.0 / matShadowProj.m05;
                    Mat4.toArray(bufferView, matShadowViewProj, UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET);

                    _vec4ShadowInfo.set(near, far, linear, 1.0 - shadowInfo.saturation);

                    Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET);

                    _vec4ShadowInfo.set(0.0, packing, shadowInfo.normalBias, 0.0);

                    Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET);
                    break;

                  case LightType.SPOT:
                    Mat4.invert(_matShadowView$1, light.node.getWorldMatrix());
                    Mat4.toArray(sv, _matShadowView$1, UBOShadow.MAT_LIGHT_VIEW_OFFSET);
                    Mat4.perspective(_matShadowProj$1, light.angle, light.aspect, 0.001, light.range);
                    Mat4.multiply(_matShadowViewProj$1, _matShadowProj$1, _matShadowView$1);
                    Mat4.toArray(sv, _matShadowViewProj$1, UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET);

                    _vec4ShadowInfo.set(0.01, light.range, linear, 1.0 - shadowInfo.saturation);

                    Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET);

                    _vec4ShadowInfo.set(1.0, packing, shadowInfo.normalBias, 0.0);

                    Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET);
                    break;
                }

                _vec4ShadowInfo.set(shadowInfo.size.x, shadowInfo.size.y, shadowInfo.pcf, shadowInfo.bias);

                Vec4.toArray(sv, _vec4ShadowInfo, UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET);
                Color.toArray(sv, shadowInfo.shadowColor, UBOShadow.SHADOW_COLOR_OFFSET);
              }

              static getCombineSignY() {
                return PipelineUBO._combineSignY;
              }

              _initCombineSignY() {
                const device = this._device;
                PipelineUBO._combineSignY = device.capabilities.screenSpaceSignY * 0.5 + 0.5 << 1 | device.capabilities.clipSpaceSignY * 0.5 + 0.5;
              }

              activate(device, pipeline) {
                this._device = device;
                this._pipeline = pipeline;
                const ds = this._pipeline.descriptorSet;

                this._initCombineSignY();

                const globalUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOGlobal.SIZE, UBOGlobal.SIZE));
                ds.bindBuffer(UBOGlobal.BINDING, globalUBO);
                const cameraUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOCamera.SIZE, UBOCamera.SIZE));
                ds.bindBuffer(UBOCamera.BINDING, cameraUBO);
                const shadowUBO = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOShadow.SIZE, UBOShadow.SIZE));
                ds.bindBuffer(UBOShadow.BINDING, shadowUBO);
              }

              updateGlobalUBO(window) {
                const globalDSManager = this._pipeline.globalDSManager;
                const ds = this._pipeline.descriptorSet;
                const cmdBuffer = this._pipeline.commandBuffers;
                ds.update();
                PipelineUBO.updateGlobalUBOView(window, this._globalUBO);
                cmdBuffer[0].updateBuffer(ds.getBuffer(UBOGlobal.BINDING), this._globalUBO);
                globalDSManager.bindBuffer(UBOGlobal.BINDING, ds.getBuffer(UBOGlobal.BINDING));
                globalDSManager.update();
              }

              updateCameraUBO(camera) {
                const globalDSManager = this._pipeline.globalDSManager;
                const ds = this._pipeline.descriptorSet;
                const cmdBuffer = this._pipeline.commandBuffers;
                PipelineUBO.updateCameraUBOView(this._pipeline, this._cameraUBO, camera);
                cmdBuffer[0].updateBuffer(ds.getBuffer(UBOCamera.BINDING), this._cameraUBO);
                globalDSManager.bindBuffer(UBOCamera.BINDING, ds.getBuffer(UBOCamera.BINDING));
                globalDSManager.update();
              }

              updateShadowUBO(camera) {
                const sceneData = this._pipeline.pipelineSceneData;
                const shadowInfo = sceneData.shadows;
                if (!shadowInfo.enabled) return;
                const ds = this._pipeline.descriptorSet;
                const cmdBuffer = this._pipeline.commandBuffers;
                const shadowFrameBufferMap = sceneData.shadowFrameBufferMap;
                const mainLight = camera.scene.mainLight;

                if (mainLight && shadowFrameBufferMap.has(mainLight)) {
                  ds.bindTexture(UNIFORM_SHADOWMAP_BINDING, shadowFrameBufferMap.get(mainLight).colorTextures[0]);
                }

                PipelineUBO.updateShadowUBOView(this._pipeline, this._shadowUBO, camera);
                ds.update();
                cmdBuffer[0].updateBuffer(ds.getBuffer(UBOShadow.BINDING), this._shadowUBO);
              }

              updateShadowUBOLight(globalDS, light) {
                PipelineUBO.updateShadowUBOLightView(this._pipeline, this._shadowUBO, light);
                globalDS.bindTexture(UNIFORM_SHADOWMAP_BINDING, builtinResMgr.get('default-texture').getGFXTexture());
                globalDS.bindTexture(UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING, builtinResMgr.get('default-texture').getGFXTexture());
                globalDS.update();
                globalDS.getBuffer(UBOShadow.BINDING).update(this._shadowUBO);
              }

              updateShadowUBORange(offset, data) {
                if (data instanceof Mat4) {
                  Mat4.toArray(this._shadowUBO, data, offset);
                } else if (data instanceof Color) {
                  Color.toArray(this._shadowUBO, data, offset);
                }
              }

              destroy() {}

            }
            PipelineUBO._combineSignY = 0;

            var _dec$i, _dec2$6, _dec3$2, _dec4$1, _class$i, _class2$f, _descriptor$d, _descriptor2$9, _descriptor3$6, _temp$f;
            let RenderStage = (_dec$i = ccclass('RenderStage'), _dec2$6 = displayOrder(), _dec3$2 = displayOrder(), _dec4$1 = displayOrder(), _dec$i(_class$i = (_class2$f = (_temp$f = class RenderStage {
              constructor() {
                _initializerDefineProperty(this, "_name", _descriptor$d, this);

                _initializerDefineProperty(this, "_priority", _descriptor2$9, this);

                this._enabled = true;

                _initializerDefineProperty(this, "_tag", _descriptor3$6, this);
              }

              get name() {
                return this._name;
              }

              get priority() {
                return this._priority;
              }

              get tag() {
                return this._tag;
              }

              set enabled(val) {
                this._enabled = val;
              }

              get enabled() {
                return this._enabled;
              }

              initialize(info) {
                this._name = info.name;
                this._priority = info.priority;

                if (info.tag) {
                  this._tag = info.tag;
                }

                return true;
              }

              activate(pipeline, flow) {
                this._pipeline = pipeline;
                this._flow = flow;
              }

            }, _temp$f), (_descriptor$d = _applyDecoratedDescriptor(_class2$f.prototype, "_name", [_dec2$6, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$f.prototype, "_priority", [_dec3$2, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$f.prototype, "_tag", [_dec4$1, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$f)) || _class$i);
            legacyCC.RenderStage = RenderStage;

            var _dec$j, _dec2$7, _dec3$3, _dec4$2, _dec5, _dec6, _class$j, _class2$g, _descriptor$e, _descriptor2$a, _descriptor3$7, _descriptor4$5, _temp$g;
            let RenderFlow = (_dec$j = ccclass('RenderFlow'), _dec2$7 = displayOrder(), _dec3$3 = displayOrder(), _dec4$2 = displayOrder(), _dec5 = displayOrder(), _dec6 = type([RenderStage]), _dec$j(_class$j = (_class2$g = (_temp$g = class RenderFlow {
              constructor() {
                _initializerDefineProperty(this, "_name", _descriptor$e, this);

                _initializerDefineProperty(this, "_priority", _descriptor2$a, this);

                _initializerDefineProperty(this, "_tag", _descriptor3$7, this);

                _initializerDefineProperty(this, "_stages", _descriptor4$5, this);
              }

              get name() {
                return this._name;
              }

              get priority() {
                return this._priority;
              }

              get tag() {
                return this._tag;
              }

              get stages() {
                return this._stages;
              }

              get pipeline() {
                return this._pipeline;
              }

              initialize(info) {
                this._name = info.name;
                this._priority = info.priority;
                this._stages = info.stages;

                if (info.tag) {
                  this._tag = info.tag;
                }

                return true;
              }

              activate(pipeline) {
                this._pipeline = pipeline;

                this._stages.sort((a, b) => a.priority - b.priority);

                for (let i = 0, len = this._stages.length; i < len; i++) {
                  this._stages[i].activate(pipeline, this);
                }
              }

              render(camera) {
                for (let i = 0, len = this._stages.length; i < len; i++) {
                  if (this._stages[i].enabled) this._stages[i].render(camera);
                }
              }

              destroy() {
                for (let i = 0, len = this._stages.length; i < len; i++) {
                  this._stages[i].destroy();
                }

                this._stages.length = 0;
              }

            }, _temp$g), (_descriptor$e = _applyDecoratedDescriptor(_class2$g.prototype, "_name", [_dec2$7, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor2$a = _applyDecoratedDescriptor(_class2$g.prototype, "_priority", [_dec3$3, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$g.prototype, "_tag", [_dec4$2, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor4$5 = _applyDecoratedDescriptor(_class2$g.prototype, "_stages", [_dec5, _dec6, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$g)) || _class$j);
            legacyCC.RenderFlow = RenderFlow;

            let PipelineEventType;

            (function (PipelineEventType) {
              PipelineEventType["RENDER_FRAME_BEGIN"] = "render-frame-begin";
              PipelineEventType["RENDER_FRAME_END"] = "render-frame-end";
              PipelineEventType["RENDER_CAMERA_BEGIN"] = "render-camera-begin";
              PipelineEventType["RENDER_CAMERA_END"] = "render-camera-end";
              PipelineEventType["ATTACHMENT_SCALE_CAHNGED"] = "attachment-scale-changed";
            })(PipelineEventType || (PipelineEventType = exports('dT', {})));

            class PipelineEventProcessor extends EventTarget {
              constructor(...args) {
                super(...args);
                this.eventTargetOn = super.on;
                this.eventTargetOnce = super.once;
              }

              on(type, callback, target, once) {
                return this.eventTargetOn(type, callback, target, once);
              }

              once(type, callback, target) {
                return this.eventTargetOnce(type, callback, target);
              }

            } exports('g7', PipelineEventProcessor);

            var _dec$k, _dec2$8, _dec3$4, _dec4$3, _class$k, _class2$h, _descriptor$f, _descriptor2$b, _temp$h;
            const MAX_BLOOM_FILTER_PASS_NUM = 6;
            const tmpRect = new Rect$1();
            const tmpViewport = new Viewport();
            class BloomRenderData {
              constructor() {
                this.renderPass = null;
                this.sampler = null;
                this.prefiterTex = null;
                this.downsampleTexs = [];
                this.upsampleTexs = [];
                this.combineTex = null;
                this.prefilterFramebuffer = null;
                this.downsampleFramebuffers = [];
                this.upsampleFramebuffers = [];
                this.combineFramebuffer = null;
              }

            }
            class PipelineInputAssemblerData {
              constructor() {
                this.quadIB = null;
                this.quadVB = null;
                this.quadIA = null;
              }

            }
            let RenderPipeline = (_dec$k = ccclass('cc.RenderPipeline'), _dec2$8 = displayOrder(), _dec3$4 = displayOrder(), _dec4$3 = type([RenderFlow]), _dec$k(_class$k = (_class2$h = (_temp$h = class RenderPipeline extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_tag", _descriptor$f, this);

                _initializerDefineProperty(this, "_flows", _descriptor2$b, this);

                this._quadIB = null;
                this._quadVBOnscreen = null;
                this._quadVBOffscreen = null;
                this._quadIAOnscreen = null;
                this._quadIAOffscreen = null;
                this._eventProcessor = new PipelineEventProcessor();
                this._commandBuffers = [];
                this._pipelineUBO = new PipelineUBO();
                this._macros = {};
                this._constantMacros = '';
                this._profiler = null;
                this._geometryRenderer = new GeometryRenderer();
                this._pipelineRenderData = null;
                this._renderPasses = new Map();
                this._width = 0;
                this._height = 0;
                this._lastUsedRenderArea = new Rect$1();
                this._clusterEnabled = false;
                this._bloomEnabled = false;
              }

              get tag() {
                return this._tag;
              }

              get flows() {
                return this._flows;
              }

              get quadIAOnscreen() {
                return this._quadIAOnscreen;
              }

              get quadIAOffscreen() {
                return this._quadIAOffscreen;
              }

              getPipelineRenderData() {
                return this._pipelineRenderData;
              }

              get constantMacros() {
                return this._constantMacros;
              }

              get macros() {
                return this._macros;
              }

              get device() {
                return this._device;
              }

              get globalDSManager() {
                return this._globalDSManager;
              }

              get descriptorSetLayout() {
                return this._globalDSManager.descriptorSetLayout;
              }

              get descriptorSet() {
                return this._descriptorSet;
              }

              get commandBuffers() {
                return this._commandBuffers;
              }

              get pipelineUBO() {
                return this._pipelineUBO;
              }

              get pipelineSceneData() {
                return this._pipelineSceneData;
              }

              set profiler(value) {
                this._profiler = value;
              }

              get profiler() {
                return this._profiler;
              }

              get geometryRenderer() {
                return this._geometryRenderer;
              }

              set clusterEnabled(value) {
                this._clusterEnabled = value;
              }

              get clusterEnabled() {
                return this._clusterEnabled;
              }

              set bloomEnabled(value) {
                this._bloomEnabled = value;
              }

              get bloomEnabled() {
                return this._bloomEnabled;
              }

              initialize(info) {
                this._flows = info.flows;

                if (info.tag) {
                  this._tag = info.tag;
                }

                return true;
              }

              createRenderPass(clearFlags, colorFmt, depthFmt) {
                const device = this._device;
                const colorAttachment = new ColorAttachment();
                const depthStencilAttachment = new DepthStencilAttachment();
                colorAttachment.format = colorFmt;
                depthStencilAttachment.format = depthFmt;
                depthStencilAttachment.stencilStoreOp = StoreOp.DISCARD;
                depthStencilAttachment.depthStoreOp = StoreOp.DISCARD;

                if (!(clearFlags & ClearFlagBit.COLOR)) {
                  if (clearFlags & SKYBOX_FLAG) {
                    colorAttachment.loadOp = LoadOp.DISCARD;
                  } else {
                    colorAttachment.loadOp = LoadOp.LOAD;
                    colorAttachment.beginAccesses = [AccessType.COLOR_ATTACHMENT_WRITE];
                  }
                }

                if ((clearFlags & ClearFlagBit.DEPTH_STENCIL) !== ClearFlagBit.DEPTH_STENCIL) {
                  if (!(clearFlags & ClearFlagBit.DEPTH)) depthStencilAttachment.depthLoadOp = LoadOp.LOAD;
                  if (!(clearFlags & ClearFlagBit.STENCIL)) depthStencilAttachment.stencilLoadOp = LoadOp.LOAD;
                }

                depthStencilAttachment.beginAccesses = [AccessType.DEPTH_STENCIL_ATTACHMENT_WRITE];
                const renderPassInfo = new RenderPassInfo([colorAttachment], depthStencilAttachment);
                return device.createRenderPass(renderPassInfo);
              }

              getRenderPass(clearFlags, swapchain) {
                let renderPass = this._renderPasses.get(clearFlags);

                if (renderPass) {
                  return renderPass;
                }

                renderPass = this.createRenderPass(clearFlags, swapchain.colorTexture.format, swapchain.depthStencilTexture.format);

                this._renderPasses.set(clearFlags, renderPass);

                return renderPass;
              }

              applyFramebufferRatio(framebuffer) {
                const sceneData = this.pipelineSceneData;
                const width = this._width * sceneData.shadingScale;
                const height = this._height * sceneData.shadingScale;
                const colorTexArr = framebuffer.colorTextures;

                for (let i = 0; i < colorTexArr.length; i++) {
                  colorTexArr[i].resize(width, height);
                }

                if (framebuffer.depthStencilTexture) {
                  framebuffer.depthStencilTexture.resize(width, height);
                }

                framebuffer.destroy();
                framebuffer.initialize(new FramebufferInfo(framebuffer.renderPass, colorTexArr, framebuffer.depthStencilTexture));
              }

              generateRenderArea(camera, out) {
                const vp = camera.viewport;
                const w = camera.window.width;
                const h = camera.window.height;
                out.x = vp.x * w;
                out.y = vp.y * h;
                out.width = vp.width * w;
                out.height = vp.height * h;
              }

              generateViewport(camera, out) {
                this.generateRenderArea(camera, tmpRect);
                if (!out) out = tmpViewport;
                const shadingScale = this.pipelineSceneData.shadingScale;
                out.left = tmpRect.x * shadingScale;
                out.top = tmpRect.y * shadingScale;
                out.width = tmpRect.width * shadingScale;
                out.height = tmpRect.height * shadingScale;
                return out;
              }

              generateScissor(camera, out) {
                if (!out) out = tmpRect;
                this.generateRenderArea(camera, out);
                const shadingScale = this.pipelineSceneData.shadingScale;
                out.x *= shadingScale;
                out.y *= shadingScale;
                out.width *= shadingScale;
                out.height *= shadingScale;
                return out;
              }

              activate(swapchain) {
                const root = legacyCC.director.root;
                this._device = root.device;

                this._generateConstantMacros();

                this._globalDSManager = new GlobalDSManager(this);
                this._descriptorSet = this._globalDSManager.globalDescriptorSet;

                this._pipelineUBO.activate(this._device, this);

                this._macros.CC_USE_HDR = this._pipelineSceneData.isHDR;

                this._generateConstantMacros();

                this._pipelineSceneData.activate(this._device, this);

                this._geometryRenderer.activate(this._device, this);

                for (let i = 0; i < this._flows.length; i++) {
                  this._flows[i].activate(this);
                }

                return true;
              }

              _ensureEnoughSize(cameras) {}

              render(cameras) {
                if (cameras.length === 0) {
                  return;
                }

                this._commandBuffers[0].begin();

                this.emit(PipelineEventType.RENDER_FRAME_BEGIN, cameras);

                this._ensureEnoughSize(cameras);

                decideProfilerCamera(cameras);

                for (let i = 0; i < cameras.length; i++) {
                  const camera = cameras[i];

                  if (camera.scene) {
                    this.emit(PipelineEventType.RENDER_CAMERA_BEGIN, camera);
                    validPunctualLightsCulling(this, camera);
                    sceneCulling(this, camera);

                    this._pipelineUBO.updateGlobalUBO(camera.window);

                    this._pipelineUBO.updateCameraUBO(camera);

                    for (let j = 0; j < this._flows.length; j++) {
                      this._flows[j].render(camera);
                    }

                    this.emit(PipelineEventType.RENDER_CAMERA_END, camera);
                  }
                }

                this.emit(PipelineEventType.RENDER_FRAME_END, cameras);

                this._commandBuffers[0].end();

                this._device.queue.submit(this._commandBuffers);
              }

              _destroyQuadInputAssembler() {
                if (this._quadIB) {
                  this._quadIB.destroy();

                  this._quadIB = null;
                }

                if (this._quadVBOnscreen) {
                  this._quadVBOnscreen.destroy();

                  this._quadVBOnscreen = null;
                }

                if (this._quadVBOffscreen) {
                  this._quadVBOffscreen.destroy();

                  this._quadVBOffscreen = null;
                }

                if (this._quadIAOnscreen) {
                  this._quadIAOnscreen.destroy();

                  this._quadIAOnscreen = null;
                }

                if (this._quadIAOffscreen) {
                  this._quadIAOffscreen.destroy();

                  this._quadIAOffscreen = null;
                }
              }

              _destroyBloomData() {
                var _bloom$renderPass;

                const bloom = this._pipelineRenderData.bloom;
                if (bloom === null) return;
                if (bloom.prefiterTex) bloom.prefiterTex.destroy();
                if (bloom.prefilterFramebuffer) bloom.prefilterFramebuffer.destroy();

                for (let i = 0; i < bloom.downsampleTexs.length; ++i) {
                  bloom.downsampleTexs[i].destroy();
                  bloom.downsampleFramebuffers[i].destroy();
                }

                bloom.downsampleTexs.length = 0;
                bloom.downsampleFramebuffers.length = 0;

                for (let i = 0; i < bloom.upsampleTexs.length; ++i) {
                  bloom.upsampleTexs[i].destroy();
                  bloom.upsampleFramebuffers[i].destroy();
                }

                bloom.upsampleTexs.length = 0;
                bloom.upsampleFramebuffers.length = 0;
                if (bloom.combineTex) bloom.combineTex.destroy();
                if (bloom.combineFramebuffer) bloom.combineFramebuffer.destroy();
                (_bloom$renderPass = bloom.renderPass) === null || _bloom$renderPass === void 0 ? void 0 : _bloom$renderPass.destroy();
                this._pipelineRenderData.bloom = null;
              }

              _genQuadVertexData(surfaceTransform, renderArea) {
                const vbData = new Float32Array(4 * 4);
                const minX = renderArea.x / this._width;
                const maxX = (renderArea.x + renderArea.width) / this._width;
                let minY = renderArea.y / this._height;
                let maxY = (renderArea.y + renderArea.height) / this._height;

                if (this.device.capabilities.screenSpaceSignY > 0) {
                  const temp = maxY;
                  maxY = minY;
                  minY = temp;
                }

                let n = 0;

                switch (surfaceTransform) {
                  case SurfaceTransform.IDENTITY:
                    n = 0;
                    vbData[n++] = -1.0;
                    vbData[n++] = -1.0;
                    vbData[n++] = minX;
                    vbData[n++] = maxY;
                    vbData[n++] = 1.0;
                    vbData[n++] = -1.0;
                    vbData[n++] = maxX;
                    vbData[n++] = maxY;
                    vbData[n++] = -1.0;
                    vbData[n++] = 1.0;
                    vbData[n++] = minX;
                    vbData[n++] = minY;
                    vbData[n++] = 1.0;
                    vbData[n++] = 1.0;
                    vbData[n++] = maxX;
                    vbData[n++] = minY;
                    break;

                  case SurfaceTransform.ROTATE_90:
                    n = 0;
                    vbData[n++] = -1.0;
                    vbData[n++] = -1.0;
                    vbData[n++] = maxX;
                    vbData[n++] = maxY;
                    vbData[n++] = 1.0;
                    vbData[n++] = -1.0;
                    vbData[n++] = maxX;
                    vbData[n++] = minY;
                    vbData[n++] = -1.0;
                    vbData[n++] = 1.0;
                    vbData[n++] = minX;
                    vbData[n++] = maxY;
                    vbData[n++] = 1.0;
                    vbData[n++] = 1.0;
                    vbData[n++] = minX;
                    vbData[n++] = minY;
                    break;

                  case SurfaceTransform.ROTATE_180:
                    n = 0;
                    vbData[n++] = -1.0;
                    vbData[n++] = -1.0;
                    vbData[n++] = minX;
                    vbData[n++] = minY;
                    vbData[n++] = 1.0;
                    vbData[n++] = -1.0;
                    vbData[n++] = maxX;
                    vbData[n++] = minY;
                    vbData[n++] = -1.0;
                    vbData[n++] = 1.0;
                    vbData[n++] = minX;
                    vbData[n++] = maxY;
                    vbData[n++] = 1.0;
                    vbData[n++] = 1.0;
                    vbData[n++] = maxX;
                    vbData[n++] = maxY;
                    break;

                  case SurfaceTransform.ROTATE_270:
                    n = 0;
                    vbData[n++] = -1.0;
                    vbData[n++] = -1.0;
                    vbData[n++] = minX;
                    vbData[n++] = minY;
                    vbData[n++] = 1.0;
                    vbData[n++] = -1.0;
                    vbData[n++] = minX;
                    vbData[n++] = maxY;
                    vbData[n++] = -1.0;
                    vbData[n++] = 1.0;
                    vbData[n++] = maxX;
                    vbData[n++] = minY;
                    vbData[n++] = 1.0;
                    vbData[n++] = 1.0;
                    vbData[n++] = maxX;
                    vbData[n++] = maxY;
                    break;
                }

                return vbData;
              }

              _createQuadInputAssembler() {
                const inputAssemblerData = new PipelineInputAssemblerData();
                const vbStride = Float32Array.BYTES_PER_ELEMENT * 4;
                const vbSize = vbStride * 4;

                const quadVB = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE | MemoryUsageBit.HOST, vbSize, vbStride));

                if (!quadVB) {
                  return inputAssemblerData;
                }

                const ibStride = Uint8Array.BYTES_PER_ELEMENT;
                const ibSize = ibStride * 6;

                const quadIB = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibSize, ibStride));

                if (!quadIB) {
                  return inputAssemblerData;
                }

                const indices = new Uint8Array(6);
                indices[0] = 0;
                indices[1] = 1;
                indices[2] = 2;
                indices[3] = 1;
                indices[4] = 3;
                indices[5] = 2;
                quadIB.update(indices);
                const attributes = new Array(2);
                attributes[0] = new Attribute('a_position', Format.RG32F);
                attributes[1] = new Attribute('a_texCoord', Format.RG32F);

                const quadIA = this._device.createInputAssembler(new InputAssemblerInfo(attributes, [quadVB], quadIB));

                inputAssemblerData.quadIB = quadIB;
                inputAssemblerData.quadVB = quadVB;
                inputAssemblerData.quadIA = quadIA;
                return inputAssemblerData;
              }

              updateQuadVertexData(renderArea, window) {
                const cachedArea = this._lastUsedRenderArea;

                if (cachedArea.x === renderArea.x && cachedArea.y === renderArea.y && cachedArea.width === renderArea.width && cachedArea.height === renderArea.height) {
                  return;
                }

                const offData = this._genQuadVertexData(SurfaceTransform.IDENTITY, renderArea);

                this._quadVBOffscreen.update(offData);

                const onData = this._genQuadVertexData(window.swapchain && window.swapchain.surfaceTransform || SurfaceTransform.IDENTITY, renderArea);

                this._quadVBOnscreen.update(onData);

                cachedArea.copy(renderArea);
              }

              destroy() {
                var _this$_globalDSManage, _this$_pipelineSceneD;

                for (let i = 0; i < this._flows.length; i++) {
                  this._flows[i].destroy();
                }

                this._flows.length = 0;

                if (this._descriptorSet) {
                  this._descriptorSet.destroy();
                }

                (_this$_globalDSManage = this._globalDSManager) === null || _this$_globalDSManage === void 0 ? void 0 : _this$_globalDSManage.destroy();

                for (let i = 0; i < this._commandBuffers.length; i++) {
                  this._commandBuffers[i].destroy();
                }

                this._commandBuffers.length = 0;

                this._pipelineUBO.destroy();

                (_this$_pipelineSceneD = this._pipelineSceneData) === null || _this$_pipelineSceneD === void 0 ? void 0 : _this$_pipelineSceneD.destroy();

                this._geometryRenderer.destroy();

                return super.destroy();
              }

              _generateConstantMacros() {
                let str = '';
                str += `#define CC_DEVICE_SUPPORT_FLOAT_TEXTURE ${this.device.hasFeature(Feature$1.TEXTURE_FLOAT) ? 1 : 0}\n`;
                str += `#define CC_ENABLE_CLUSTERED_LIGHT_CULLING ${this._clusterEnabled ? 1 : 0}\n`;
                str += `#define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS ${this.device.capabilities.maxVertexUniformVectors}\n`;
                str += `#define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS ${this.device.capabilities.maxFragmentUniformVectors}\n`;
                str += `#define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT ${this.device.hasFeature(Feature$1.INPUT_ATTACHMENT_BENEFIT) ? 1 : 0}\n`;
                str += `#define CC_PLATFORM_ANDROID_AND_WEBGL ${systemInfo.os === OS.ANDROID && systemInfo.isBrowser ? 1 : 0}\n`;
                str += `#define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES ${macro.ENABLE_WEBGL_HIGHP_STRUCT_VALUES ? 1 : 0}\n`;
                this._constantMacros = str;
              }

              generateBloomRenderData() {
                if (this._pipelineRenderData.bloom != null) return;
                const bloom = this._pipelineRenderData.bloom = new BloomRenderData();
                const device = this.device;
                const colorAttachment = new ColorAttachment();
                colorAttachment.format = Format.RGBA8;
                colorAttachment.loadOp = LoadOp.CLEAR;
                colorAttachment.storeOp = StoreOp.STORE;
                colorAttachment.endAccesses = [AccessType.COLOR_ATTACHMENT_WRITE];
                bloom.renderPass = device.createRenderPass(new RenderPassInfo([colorAttachment]));
                let curWidth = this._width;
                let curHeight = this._height;
                bloom.prefiterTex = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA8, curWidth >> 1, curHeight >> 1));
                bloom.prefilterFramebuffer = device.createFramebuffer(new FramebufferInfo(bloom.renderPass, [bloom.prefiterTex]));
                curWidth >>= 1;
                curHeight >>= 1;

                for (let i = 0; i < MAX_BLOOM_FILTER_PASS_NUM; ++i) {
                  bloom.downsampleTexs.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA8, curWidth >> 1, curHeight >> 1)));
                  bloom.downsampleFramebuffers[i] = device.createFramebuffer(new FramebufferInfo(bloom.renderPass, [bloom.downsampleTexs[i]]));
                  bloom.upsampleTexs.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA8, curWidth, curHeight)));
                  bloom.upsampleFramebuffers[i] = device.createFramebuffer(new FramebufferInfo(bloom.renderPass, [bloom.upsampleTexs[i]]));
                  curWidth >>= 1;
                  curHeight >>= 1;
                }

                bloom.combineTex = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED, Format.RGBA8, this._width, this._height));
                bloom.combineFramebuffer = device.createFramebuffer(new FramebufferInfo(bloom.renderPass, [bloom.combineTex]));
                bloom.sampler = this.globalDSManager.linearSampler;
              }

              on(type, callback, target, once) {
                return this._eventProcessor.on(type, callback, target, once);
              }

              once(type, callback, target) {
                return this._eventProcessor.once(type, callback, target);
              }

              off(type, callback, target) {
                this._eventProcessor.off(type, callback, target);
              }

              emit(type, arg0, arg1, arg2, arg3, arg4) {
                this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
              }

              targetOff(typeOrTarget) {
                this._eventProcessor.targetOff(typeOrTarget);
              }

              removeAll(typeOrTarget) {
                this._eventProcessor.removeAll(typeOrTarget);
              }

              hasEventListener(type, callback, target) {
                return this._eventProcessor.hasEventListener(type, callback, target);
              }

            }, _temp$h), (_descriptor$f = _applyDecoratedDescriptor(_class2$h.prototype, "_tag", [_dec2$8, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$b = _applyDecoratedDescriptor(_class2$h.prototype, "_flows", [_dec3$4, _dec4$3, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$h)) || _class$k);
            legacyCC.RenderPipeline = RenderPipeline;

            function deepFlatten(strList, array) {
              for (const item of array) {
                if (Array.isArray(item)) {
                  deepFlatten(strList, item);
                } else {
                    strList.push(item);
                  }
              }
            }

            function flattenCodeArray(array) {
              const separator =  '';
              const strList = [];
              deepFlatten(strList, array);
              return strList.join(separator);
            }

            const Destroyed$2 = CCObject.Flags.Destroyed;
            const PersistentMask$2 = CCObject.Flags.PersistentMask;
            const DEFAULT = `${DELIMETER}default`;
            const IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE;
            const VAR = 'var ';
            const LOCAL_OBJ = 'o';
            const LOCAL_TEMP_OBJ = 't';
            const LOCAL_ARRAY = 'a';
            const LINE_INDEX_OF_NEW_OBJ = 0;
            const DEFAULT_MODULE_CACHE = {
              'cc.ClickEvent': false,
              'cc.PrefabInfo': false
            };
            const escapeForJS$1 = CCClass.escapeForJS;

            class Declaration {
              constructor(varName, expression) {
                this.varName = void 0;
                this.expression = void 0;
                this.varName = varName;
                this.expression = expression;
              }

              toString() {
                return `${VAR + this.varName}=${this.expression};`;
              }

            }

            function mergeDeclaration(statement, expression) {
              if (expression instanceof Declaration) {
                return new Declaration(expression.varName, statement + expression.expression);
              } else {
                return statement + expression;
              }
            }

            function writeAssignment(codeArray, statement, expression) {
              if (Array.isArray(expression)) {
                expression[0] = mergeDeclaration(statement, expression[0]);
                codeArray.push(expression);
              } else {
                codeArray.push(`${mergeDeclaration(statement, expression)};`);
              }
            }

            class Assignments {
              constructor(targetExpression) {
                this._exps = void 0;
                this._targetExp = void 0;
                this._exps = [];
                this._targetExp = targetExpression;
              }

              append(key, expression) {
                this._exps.push([key, expression]);
              }

              writeCode(codeArray) {
                let targetVar;

                if (this._exps.length > 1) {
                  codeArray.push(`${LOCAL_TEMP_OBJ}=${this._targetExp};`);
                  targetVar = LOCAL_TEMP_OBJ;
                } else if (this._exps.length === 1) {
                  targetVar = this._targetExp;
                } else {
                  return;
                }

                for (let i = 0; i < this._exps.length; i++) {
                  const pair = this._exps[i];
                  writeAssignment(codeArray, `${targetVar + getPropAccessor(pair[0])}=`, pair[1]);
                }
              }

            }

            Assignments.pool = void 0;
            Assignments.pool = new Pool$1(obj => {
              obj._exps.length = 0;
              obj._targetExp = null;
            }, 1);

            Assignments.pool.get = function (targetExpression) {
              const cache = this._get() || new Assignments();
              cache._targetExp = targetExpression;
              return cache;
            };

            function getPropAccessor(key) {
              return IDENTIFIER_RE$1.test(key) ? `.${key}` : `[${escapeForJS$1(key)}]`;
            }

            class Parser {
              constructor(obj, parent) {
                this.parent = void 0;
                this.objsToClear_iN$t = void 0;
                this.codeArray = void 0;
                this.objs = void 0;
                this.funcs = void 0;
                this.funcModuleCache = void 0;
                this.globalVariables = void 0;
                this.globalVariableId = void 0;
                this.localVariableId = void 0;
                this.result = void 0;
                this.parent = parent;
                this.objsToClear_iN$t = [];
                this.codeArray = [];
                this.objs = [];
                this.funcs = [];
                this.funcModuleCache = createMap();
                mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
                this.globalVariables = [];
                this.globalVariableId = 0;
                this.localVariableId = 0;
                this.codeArray.push(`${VAR + LOCAL_OBJ},${LOCAL_TEMP_OBJ};`, 'if(R){', `${LOCAL_OBJ}=R;`, '}else{', `${LOCAL_OBJ}=R=new ${this.getFuncModule(obj.constructor, true)}();`, '}');
                obj._iN$t = {
                  globalVar: 'R'
                };
                this.objsToClear_iN$t.push(obj);
                this.enumerateObject(this.codeArray, obj);
                let globalVariablesDeclaration;

                if (this.globalVariables.length > 0) {
                  globalVariablesDeclaration = `${VAR + this.globalVariables.join(',')};`;
                }

                const code = flattenCodeArray(['return (function(R){', globalVariablesDeclaration || [], this.codeArray, 'return o;', '})']);
                this.result = Function('O', 'F', code)(this.objs, this.funcs);

                for (let i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
                  this.objsToClear_iN$t[i]._iN$t = null;
                }

                this.objsToClear_iN$t.length = 0;
              }

              getFuncModule(func, usedInNew) {
                const clsName = getClassName(func);

                if (clsName) {
                  const cache = this.funcModuleCache[clsName];

                  if (cache) {
                    return cache;
                  } else if (cache === undefined) {
                    let clsNameIsModule = clsName.indexOf('.') !== -1;

                    if (clsNameIsModule) {
                      try {
                        clsNameIsModule = func === Function(`return ${clsName}`)();

                        if (clsNameIsModule) {
                          this.funcModuleCache[clsName] = clsName;
                          return clsName;
                        }
                      } catch (e) {}
                    }
                  }
                }

                let index = this.funcs.indexOf(func);

                if (index < 0) {
                  index = this.funcs.length;
                  this.funcs.push(func);
                }

                let res = `F[${index}]`;

                if (usedInNew) {
                  res = `(${res})`;
                }

                this.funcModuleCache[clsName] = res;
                return res;
              }

              getObjRef(obj) {
                let index = this.objs.indexOf(obj);

                if (index < 0) {
                  index = this.objs.length;
                  this.objs.push(obj);
                }

                return `O[${index}]`;
              }

              setValueType(codeArray, defaultValue, srcValue, targetExpression) {
                const assignments = Assignments.pool.get(targetExpression);
                let fastDefinedProps = defaultValue.constructor.__props__;

                if (!fastDefinedProps) {
                  fastDefinedProps = Object.keys(defaultValue);
                }

                for (let i = 0; i < fastDefinedProps.length; i++) {
                  const propName = fastDefinedProps[i];
                  const prop = srcValue[propName];

                  if (defaultValue[propName] === prop) {
                    continue;
                  }

                  const expression = this.enumerateField(srcValue, propName, prop);
                  assignments.append(propName, expression);
                }

                assignments.writeCode(codeArray);
                Assignments.pool.put(assignments);
              }

              enumerateCCClass(codeArray, obj, klass) {
                const props = klass.__values__;
                const attrs = getClassAttrs(klass);

                for (let p = 0; p < props.length; p++) {
                  const key = props[p];
                  const val = obj[key];
                  let defaultValue = attrs[key + DEFAULT];

                  if (equalsToDefault(defaultValue, val)) {
                    continue;
                  }

                  if (typeof val === 'object' && val instanceof legacyCC.ValueType) {
                    defaultValue = CCClass.getDefault(defaultValue);

                    if (defaultValue && defaultValue.constructor === val.constructor) {
                      const targetExpression = LOCAL_OBJ + getPropAccessor(key);
                      this.setValueType(codeArray, defaultValue, val, targetExpression);
                      continue;
                    }
                  }

                  this.setObjProp(codeArray, obj, key, val);
                }
              }

              instantiateArray(value) {
                if (value.length === 0) {
                  return '[]';
                }

                const arrayVar = LOCAL_ARRAY + ++this.localVariableId;
                const declaration = new Declaration(arrayVar, `new Array(${value.length})`);
                const codeArray = [declaration];
                value._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(value);

                for (let i = 0; i < value.length; ++i) {
                  const statement = `${arrayVar}[${i}]=`;
                  const expression = this.enumerateField(value, i, value[i]);
                  writeAssignment(codeArray, statement, expression);
                }

                return codeArray;
              }

              instantiateTypedArray(value) {
                const type = value.constructor.name;

                if (value.length === 0) {
                  return `new ${type}`;
                }

                const arrayVar = LOCAL_ARRAY + ++this.localVariableId;
                const declaration = new Declaration(arrayVar, `new ${type}(${value.length})`);
                const codeArray = [declaration];
                value._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(value);

                for (let i = 0; i < value.length; ++i) {
                  if (value[i] !== 0) {
                    const statement = `${arrayVar}[${i}]=`;
                    writeAssignment(codeArray, statement, value[i]);
                  }
                }

                return codeArray;
              }

              enumerateField(obj, key, value) {
                if (typeof value === 'object' && value) {
                  const _iN$t = value._iN$t;

                  if (_iN$t) {
                    let globalVar = _iN$t.globalVar;

                    if (!globalVar) {
                      globalVar = _iN$t.globalVar = `v${++this.globalVariableId}`;
                      this.globalVariables.push(globalVar);
                      const line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
                      _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(`${globalVar}=`, line);
                    }

                    return globalVar;
                  } else if (ArrayBuffer.isView(value)) {
                    return this.instantiateTypedArray(value);
                  } else if (Array.isArray(value)) {
                    return this.instantiateArray(value);
                  } else {
                    return this.instantiateObj(value);
                  }
                } else if (typeof value === 'function') {
                  return this.getFuncModule(value);
                } else if (typeof value === 'string') {
                  return escapeForJS$1(value);
                } else {
                  if (key === '_objFlags' && obj instanceof CCObject) {
                    value &= PersistentMask$2;
                  }

                  return value;
                }
              }

              setObjProp(codeArray, obj, key, value) {
                const statement = `${LOCAL_OBJ + getPropAccessor(key)}=`;
                const expression = this.enumerateField(obj, key, value);
                writeAssignment(codeArray, statement, expression);
              }

              enumerateObject(codeArray, obj) {
                const klass = obj.constructor;

                if (legacyCC.Class._isCCClass(klass)) {
                  this.enumerateCCClass(codeArray, obj, klass);
                } else {
                  for (const key in obj) {
                    if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
                      continue;
                    }

                    const value = obj[key];

                    if (typeof value === 'object' && value && value === obj._iN$t) {
                      continue;
                    }

                    this.setObjProp(codeArray, obj, key, value);
                  }
                }
              }

              instantiateObj(obj) {
                if (obj instanceof legacyCC.ValueType) {
                  return CCClass.getNewValueTypeCode(obj);
                }

                if (obj instanceof legacyCC.Asset) {
                  return this.getObjRef(obj);
                }

                if (obj._objFlags & Destroyed$2) {
                  return null;
                }

                let createCode;
                const ctor = obj.constructor;

                if (legacyCC.Class._isCCClass(ctor)) {
                  if (this.parent) {
                    if (this.parent instanceof legacyCC.Component) {
                      if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
                        return this.getObjRef(obj);
                      }
                    } else if (this.parent instanceof legacyCC._BaseNode) {
                      if (obj instanceof legacyCC._BaseNode) {
                        if (!obj.isChildOf(this.parent)) {
                          return this.getObjRef(obj);
                        }
                      } else if (obj instanceof legacyCC.Component) {
                        if (!obj.node.isChildOf(this.parent)) {
                          return this.getObjRef(obj);
                        }
                      }
                    }
                  }

                  createCode = new Declaration(LOCAL_OBJ, `new ${this.getFuncModule(ctor, true)}()`);
                } else if (ctor === Object) {
                  createCode = new Declaration(LOCAL_OBJ, '{}');
                } else if (!ctor) {
                  createCode = new Declaration(LOCAL_OBJ, 'Object.create(null)');
                } else {
                  return this.getObjRef(obj);
                }

                const codeArray = [createCode];
                obj._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(obj);
                this.enumerateObject(codeArray, obj);
                return ['(function(){', codeArray, 'return o;})();'];
              }

            }

            function equalsToDefault(def, value) {
              if (typeof def === 'function') {
                try {
                  def = def();
                } catch (e) {
                  return false;
                }
              }

              if (def === value) {
                return true;
              }

              if (def && value && typeof def === 'object' && typeof value === 'object' && def.constructor === value.constructor) {
                if (def instanceof legacyCC.ValueType) {
                  if (def.equals(value)) {
                    return true;
                  }
                } else if (Array.isArray(def)) {
                  return def.length === 0 && value.length === 0;
                } else if (def.constructor === Object) {
                  return isEmptyObject(def) && isEmptyObject(value);
                }
              }

              return false;
            }
            function compile(node) {
              const root = node instanceof legacyCC._BaseNode && node;
              const parser = new Parser(node, root);
              return parser.result;
            }

            class NodeUIProperties {
              get uiTransformComp() {
                if (!this._uiTransformComp) {
                  this._uiTransformComp = this._node.getComponent('cc.UITransform');
                }

                return this._uiTransformComp;
              }

              set uiTransformComp(value) {
                this._uiTransformComp = value;
              }

              get uiComp() {
                return this._uiComp;
              }

              set uiComp(comp) {
                if (this._uiComp && comp) {
                  warnID(12002);
                  return;
                }

                this._uiComp = comp;
              }

              get opacity() {
                return this._opacity;
              }

              get localOpacity() {
                return this._localOpacity;
              }

              set localOpacity(val) {
                this._localOpacity = val;
                NodeUIProperties.markOpacityTree(this._node);
              }

              constructor(node) {
                this._uiComp = null;
                this._opacity = 1;
                this._localOpacity = 1;
                this.opacityDirty = true;
                this._uiTransformComp = null;
                this._node = void 0;
                this._node = node;
              }

              applyOpacity(effectOpacity) {
                this._opacity = this._localOpacity * effectOpacity;
              }

              static markOpacityTree(node, isDirty = true) {
                node._uiProps.opacityDirty = isDirty;

                for (let i = 0, l = node.children.length; i < l; i++) {
                  const c = node.children[i];
                  NodeUIProperties.markOpacityTree(c, isDirty);
                }
              }

            } exports('e7', NodeUIProperties);

            const Destroying$1 = CCObject.Flags.Destroying;

            let NodeEventType;

            (function (NodeEventType) {
              NodeEventType["TOUCH_START"] = "touch-start";
              NodeEventType["TOUCH_MOVE"] = "touch-move";
              NodeEventType["TOUCH_END"] = "touch-end";
              NodeEventType["TOUCH_CANCEL"] = "touch-cancel";
              NodeEventType["MOUSE_DOWN"] = "mouse-down";
              NodeEventType["MOUSE_MOVE"] = "mouse-move";
              NodeEventType["MOUSE_UP"] = "mouse-up";
              NodeEventType["MOUSE_WHEEL"] = "mouse-wheel";
              NodeEventType["MOUSE_ENTER"] = "mouse-enter";
              NodeEventType["MOUSE_LEAVE"] = "mouse-leave";
              NodeEventType["KEY_DOWN"] = "keydown";
              NodeEventType["KEY_UP"] = "keyup";
              NodeEventType["DEVICEMOTION"] = "devicemotion";
              NodeEventType["TRANSFORM_CHANGED"] = "transform-changed";
              NodeEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
              NodeEventType["SIZE_CHANGED"] = "size-changed";
              NodeEventType["ANCHOR_CHANGED"] = "anchor-changed";
              NodeEventType["COLOR_CHANGED"] = "color-changed";
              NodeEventType["CHILD_ADDED"] = "child-added";
              NodeEventType["CHILD_REMOVED"] = "child-removed";
              NodeEventType["PARENT_CHANGED"] = "parent-changed";
              NodeEventType["NODE_DESTROYED"] = "node-destroyed";
              NodeEventType["LAYER_CHANGED"] = "layer-changed";
              NodeEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
              NodeEventType["ACTIVE_IN_HIERARCHY_CHANGED"] = "active-in-hierarchy-changed";
            })(NodeEventType || (NodeEventType = exports('e4', {})));

            var _dec$l, _class$l, _class2$i, _descriptor$g, _descriptor2$c, _descriptor3$8, _descriptor4$6, _descriptor5$3, _class3$8, _temp$i;
            const Destroying$2 = CCObject.Flags.Destroying;
            const DontDestroy$1 = CCObject.Flags.DontDestroy;
            const Deactivating$1 = CCObject.Flags.Deactivating;
            const TRANSFORM_ON = 1 << 0;
            const idGenerator$2 = new IDGenerator('Node');

            function getConstructor(typeOrClassName) {
              if (!typeOrClassName) {
                errorID(3804);
                return null;
              }

              if (typeof typeOrClassName === 'string') {
                return getClassByName(typeOrClassName);
              }

              return typeOrClassName;
            }

            let BaseNode = exports('ge', (_dec$l = ccclass('cc.BaseNode'), _dec$l(_class$l = (_class2$i = (_temp$i = _class3$8 = class BaseNode extends CCObject {
              get components() {
                return this._components;
              }

              get _persistNode() {
                return (this._objFlags & DontDestroy$1) > 0;
              }

              set _persistNode(value) {
                if (value) {
                  this._objFlags |= DontDestroy$1;
                } else {
                  this._objFlags &= ~DontDestroy$1;
                }
              }

              get name() {
                return this._name;
              }

              set name(value) {

                this._name = value;
              }

              get uuid() {
                return this._id;
              }

              get children() {
                return this._children;
              }

              get active() {
                return this._active;
              }

              set active(isActive) {
                isActive = !!isActive;

                if (this._active !== isActive) {
                  this._active = isActive;
                  const parent = this._parent;

                  if (parent) {
                    const couldActiveInScene = parent._activeInHierarchy;

                    if (couldActiveInScene) {
                      legacyCC.director._nodeActivator.activateNode(this, isActive);
                    }
                  }
                }
              }

              get activeInHierarchy() {
                return this._activeInHierarchy;
              }

              get parent() {
                return this._parent;
              }

              set parent(value) {
                this.setParent(value);
              }

              get scene() {
                return this._scene;
              }

              get eventProcessor() {
                return this._eventProcessor;
              }

              static _setScene(node) {
                node._updateScene();
              }

              static _findComponent(node, constructor) {
                const cls = constructor;
                const comps = node._components;

                if (cls._sealed) {
                  for (let i = 0; i < comps.length; ++i) {
                    const comp = comps[i];

                    if (comp.constructor === constructor) {
                      return comp;
                    }
                  }
                } else {
                  for (let i = 0; i < comps.length; ++i) {
                    const comp = comps[i];

                    if (comp instanceof constructor) {
                      return comp;
                    }
                  }
                }

                return null;
              }

              static _findComponents(node, constructor, components) {
                const cls = constructor;
                const comps = node._components;

                if (cls._sealed) {
                  for (let i = 0; i < comps.length; ++i) {
                    const comp = comps[i];

                    if (comp.constructor === constructor) {
                      components.push(comp);
                    }
                  }
                } else {
                  for (let i = 0; i < comps.length; ++i) {
                    const comp = comps[i];

                    if (comp instanceof constructor) {
                      components.push(comp);
                    }
                  }
                }
              }

              static _findChildComponent(children, constructor) {
                for (let i = 0; i < children.length; ++i) {
                  const node = children[i];

                  let comp = BaseNode._findComponent(node, constructor);

                  if (comp) {
                    return comp;
                  }

                  if (node._children.length > 0) {
                    comp = BaseNode._findChildComponent(node._children, constructor);

                    if (comp) {
                      return comp;
                    }
                  }
                }

                return null;
              }

              static _findChildComponents(children, constructor, components) {
                for (let i = 0; i < children.length; ++i) {
                  const node = children[i];

                  BaseNode._findComponents(node, constructor, components);

                  if (node._children.length > 0) {
                    BaseNode._findChildComponents(node._children, constructor, components);
                  }
                }
              }

              _updateScene() {
                if (this._parent == null) {
                  error('Node %s(%s) has not attached to a scene.', this.name, this.uuid);
                } else {
                  this._scene = this._parent._scene;
                }
              }

              constructor(name) {
                super(name);

                _initializerDefineProperty(this, "_parent", _descriptor$g, this);

                _initializerDefineProperty(this, "_children", _descriptor2$c, this);

                _initializerDefineProperty(this, "_active", _descriptor3$8, this);

                _initializerDefineProperty(this, "_components", _descriptor4$6, this);

                _initializerDefineProperty(this, "_prefab", _descriptor5$3, this);

                this._scene = null;
                this._activeInHierarchy = false;
                this._id = idGenerator$2.getNewId();
                this._name = void 0;
                this._eventProcessor = new legacyCC.NodeEventProcessor(this);
                this._eventMask = 0;
                this._siblingIndex = 0;
                this._originalSceneId = '';
                this._registerIfAttached =  undefined ;
                this._name = name !== undefined ? name : 'New Node';
              }

              attr(attrs) {
                mixin(this, attrs);
              }

              getParent() {
                return this._parent;
              }

              setParent(value, keepWorldTransform = false) {
                if (this._parent === value) {
                  return;
                }

                const oldParent = this._parent;
                const newParent = value;

                if ( oldParent && oldParent._objFlags & Deactivating$1) {
                  errorID(3821);
                }

                this._parent = newParent;
                this._siblingIndex = 0;

                this._onSetParent(oldParent, keepWorldTransform);

                if (this.emit) {
                  this.emit(NodeEventType.PARENT_CHANGED, oldParent);
                }

                if (oldParent) {
                  if (!(oldParent._objFlags & Destroying$2)) {
                    const removeAt = oldParent._children.indexOf(this);

                    oldParent._children.splice(removeAt, 1);

                    oldParent._updateSiblingIndex();

                    if (oldParent.emit) {
                      oldParent.emit(NodeEventType.CHILD_REMOVED, this);
                    }
                  }
                }

                if (newParent) {
                  if ( newParent._objFlags & Deactivating$1) {
                    errorID(3821);
                  }

                  newParent._children.push(this);

                  this._siblingIndex = newParent._children.length - 1;

                  if (newParent.emit) {
                    newParent.emit(NodeEventType.CHILD_ADDED, this);
                  }
                }

                this._onHierarchyChanged(oldParent);
              }

              getChildByUuid(uuid) {
                if (!uuid) {
                  log('Invalid uuid');
                  return null;
                }

                const locChildren = this._children;

                for (let i = 0, len = locChildren.length; i < len; i++) {
                  if (locChildren[i]._id === uuid) {
                    return locChildren[i];
                  }
                }

                return null;
              }

              getChildByName(name) {
                if (!name) {
                  log('Invalid name');
                  return null;
                }

                const locChildren = this._children;

                for (let i = 0, len = locChildren.length; i < len; i++) {
                  if (locChildren[i]._name === name) {
                    return locChildren[i];
                  }
                }

                return null;
              }

              getChildByPath(path) {
                const segments = path.split('/');
                let lastNode = this;

                for (let i = 0; i < segments.length; ++i) {
                  const segment = segments[i];

                  if (segment.length === 0) {
                    continue;
                  }

                  const next = lastNode.children.find(childNode => childNode.name === segment);

                  if (!next) {
                    return null;
                  }

                  lastNode = next;
                }

                return lastNode;
              }

              addChild(child) {
                child.setParent(this);
              }

              insertChild(child, siblingIndex) {
                child.parent = this;
                child.setSiblingIndex(siblingIndex);
              }

              getSiblingIndex() {
                return this._siblingIndex;
              }

              setSiblingIndex(index) {
                if (!this._parent) {
                  return;
                }

                if (this._parent._objFlags & Deactivating$1) {
                  errorID(3821);
                  return;
                }

                const siblings = this._parent._children;
                index = index !== -1 ? index : siblings.length - 1;
                const oldIndex = siblings.indexOf(this);

                if (index !== oldIndex) {
                  siblings.splice(oldIndex, 1);

                  if (index < siblings.length) {
                    siblings.splice(index, 0, this);
                  } else {
                    siblings.push(this);
                  }

                  this._parent._updateSiblingIndex();

                  if (this._onSiblingIndexChanged) {
                    this._onSiblingIndexChanged(index);
                  }
                }
              }

              walk(preFunc, postFunc) {
                let index = 1;
                let children = null;
                let curr = null;
                let i = 0;
                let stack = BaseNode._stacks[BaseNode._stackId];

                if (!stack) {
                  stack = [];

                  BaseNode._stacks.push(stack);
                }

                BaseNode._stackId++;
                stack.length = 0;
                stack[0] = this;
                let parent = null;
                let afterChildren = false;

                while (index) {
                  index--;
                  curr = stack[index];

                  if (!curr) {
                    continue;
                  }

                  if (!afterChildren && preFunc) {
                    preFunc(curr);
                  } else if (afterChildren && postFunc) {
                    postFunc(curr);
                  }

                  stack[index] = null;

                  if (afterChildren) {
                    if (parent === this._parent) break;
                    afterChildren = false;
                  } else {
                    if (curr._children.length > 0) {
                      parent = curr;
                      children = curr._children;
                      i = 0;
                      stack[index] = children[i];
                      index++;
                    } else {
                      stack[index] = curr;
                      index++;
                      afterChildren = true;
                    }

                    continue;
                  }

                  if (children) {
                    i++;

                    if (children[i]) {
                      stack[index] = children[i];
                      index++;
                    } else if (parent) {
                      stack[index] = parent;
                      index++;
                      afterChildren = true;

                      if (parent._parent) {
                        children = parent._parent._children;
                        i = children.indexOf(parent);
                        parent = parent._parent;
                      } else {
                        parent = null;
                        children = null;
                      }

                      if (i < 0) {
                        break;
                      }
                    }
                  }
                }

                stack.length = 0;
                BaseNode._stackId--;
              }

              removeFromParent() {
                if (this._parent) {
                  this._parent.removeChild(this);
                }
              }

              removeChild(child) {
                if (this._children.indexOf(child) > -1) {
                  child.parent = null;
                }
              }

              removeAllChildren() {
                const children = this._children;

                for (let i = children.length - 1; i >= 0; i--) {
                  const node = children[i];

                  if (node) {
                    node.parent = null;
                  }
                }

                this._children.length = 0;
              }

              isChildOf(parent) {
                let child = this;

                do {
                  if (child === parent) {
                    return true;
                  }

                  child = child._parent;
                } while (child);

                return false;
              }

              getComponent(typeOrClassName) {
                const constructor = getConstructor(typeOrClassName);

                if (constructor) {
                  return BaseNode._findComponent(this, constructor);
                }

                return null;
              }

              getComponents(typeOrClassName) {
                const constructor = getConstructor(typeOrClassName);
                const components = [];

                if (constructor) {
                  BaseNode._findComponents(this, constructor, components);
                }

                return components;
              }

              getComponentInChildren(typeOrClassName) {
                const constructor = getConstructor(typeOrClassName);

                if (constructor) {
                  return BaseNode._findChildComponent(this._children, constructor);
                }

                return null;
              }

              getComponentsInChildren(typeOrClassName) {
                const constructor = getConstructor(typeOrClassName);
                const components = [];

                if (constructor) {
                  BaseNode._findComponents(this, constructor, components);

                  BaseNode._findChildComponents(this._children, constructor, components);
                }

                return components;
              }

              addComponent(typeOrClassName) {

                let constructor;

                if (typeof typeOrClassName === 'string') {
                  constructor = getClassByName(typeOrClassName);

                  if (!constructor) {
                    if (legacyCC._RF.peek()) {
                      errorID(3808, typeOrClassName);
                    }

                    throw TypeError(getError(3807, typeOrClassName));
                  }
                } else {
                  if (!typeOrClassName) {
                    throw TypeError(getError(3804));
                  }

                  constructor = typeOrClassName;
                }

                if (typeof constructor !== 'function') {
                  throw TypeError(getError(3809));
                }

                if (!isChildClassOf(constructor, legacyCC.Component)) {
                  throw TypeError(getError(3810));
                }

                const reqComps = constructor._requireComponent;

                if (reqComps) {
                  if (Array.isArray(reqComps)) {
                    for (let i = 0; i < reqComps.length; i++) {
                      const reqComp = reqComps[i];

                      if (!this.getComponent(reqComp)) {
                        this.addComponent(reqComp);
                      }
                    }
                  } else {
                    const reqComp = reqComps;

                    if (!this.getComponent(reqComp)) {
                      this.addComponent(reqComp);
                    }
                  }
                }

                const component = new constructor();
                component.node = this;

                this._components.push(component);

                if (this._activeInHierarchy) {
                  legacyCC.director._nodeActivator.activateComp(component);
                }

                return component;
              }

              removeComponent(component) {
                if (!component) {
                  errorID(3813);
                  return;
                }

                let componentInstance = null;

                if (component instanceof Component) {
                  componentInstance = component;
                } else {
                  componentInstance = this.getComponent(component);
                }

                if (componentInstance) {
                  componentInstance.destroy();
                }
              }

              on(type, callback, target, useCapture = false) {
                switch (type) {
                  case NodeEventType.TRANSFORM_CHANGED:
                    this._eventMask |= TRANSFORM_ON;
                    break;
                }

                this._eventProcessor.on(type, callback, target, useCapture);
              }

              off(type, callback, target, useCapture = false) {
                this._eventProcessor.off(type, callback, target, useCapture);

                const hasListeners = this._eventProcessor.hasEventListener(type);

                if (!hasListeners) {
                  switch (type) {
                    case NodeEventType.TRANSFORM_CHANGED:
                      this._eventMask &= ~TRANSFORM_ON;
                      break;
                  }
                }
              }

              once(type, callback, target, useCapture) {
                this._eventProcessor.once(type, callback, target, useCapture);
              }

              emit(type, arg0, arg1, arg2, arg3, arg4) {
                this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
              }

              dispatchEvent(event) {
                this._eventProcessor.dispatchEvent(event);
              }

              hasEventListener(type, callback, target) {
                return this._eventProcessor.hasEventListener(type, callback, target);
              }

              targetOff(target) {
                this._eventProcessor.targetOff(target);

                if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(NodeEventType.TRANSFORM_CHANGED)) {
                  this._eventMask &= ~TRANSFORM_ON;
                }
              }

              destroy() {
                if (super.destroy()) {
                  this.active = false;
                  return true;
                }

                return false;
              }

              destroyAllChildren() {
                const children = this._children;

                for (let i = 0; i < children.length; ++i) {
                  children[i].destroy();
                }
              }

              _removeComponent(component) {
                if (!component) {
                  errorID(3814);
                  return;
                }

                if (!(this._objFlags & Destroying$2)) {
                  const i = this._components.indexOf(component);

                  if (i !== -1) {
                    this._components.splice(i, 1);
                  } else if (component.node !== this) {
                    errorID(3815);
                  }
                }
              }

              _updateSiblingIndex() {
                for (let i = 0; i < this._children.length; ++i) {
                  this._children[i]._siblingIndex = i;
                }

                this.emit(NodeEventType.SIBLING_ORDER_CHANGED);
              }

              _onSetParent(oldParent, keepWorldTransform = false) {
                if (this._parent) {
                  if ((oldParent == null || oldParent._scene !== this._parent._scene) && this._parent._scene != null) {
                    this.walk(BaseNode._setScene);
                  }
                }
              }

              _onPostActivated(active) {}

              _onBatchCreated(dontSyncChildPrefab) {
                if (this._parent) {
                  this._siblingIndex = this._parent.children.indexOf(this);
                }
              }

              _onPreDestroy() {
                this._onPreDestroyBase();
              }

              _onHierarchyChanged(oldParent) {
                return this._onHierarchyChangedBase(oldParent);
              }

              _instantiate(cloned, isSyncedNode) {
                if (!cloned) {
                  cloned = legacyCC.instantiate._clone(this, this);
                }

                const newPrefabInfo = cloned._prefab;

                cloned._parent = null;

                cloned._onBatchCreated(isSyncedNode);

                return cloned;
              }

              _onHierarchyChangedBase(oldParent) {
                const newParent = this._parent;

                if (this._persistNode && !(newParent instanceof legacyCC.Scene)) {
                  legacyCC.game.removePersistRootNode(this);
                }

                const shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);

                if (this._activeInHierarchy !== shouldActiveNow) {
                  legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
                }
              }

              _onPreDestroyBase() {
                this._objFlags |= Destroying$2;
                const parent = this._parent;
                const destroyByParent = !!parent && (parent._objFlags & Destroying$2) !== 0;

                if (!destroyByParent && EDITOR) {
                  this._registerIfAttached(false);
                }

                if (this._persistNode) {
                  legacyCC.game.removePersistRootNode(this);
                }

                if (!destroyByParent) {
                  if (parent) {
                    this.emit(NodeEventType.PARENT_CHANGED, this);

                    const childIndex = parent._children.indexOf(this);

                    parent._children.splice(childIndex, 1);

                    this._siblingIndex = 0;

                    parent._updateSiblingIndex();

                    if (parent.emit) {
                      parent.emit(NodeEventType.CHILD_REMOVED, this);
                    }
                  }
                }

                this.emit(NodeEventType.NODE_DESTROYED, this);

                this._eventProcessor.destroy();

                const children = this._children;

                for (let i = 0; i < children.length; ++i) {
                  children[i]._destroyImmediate();
                }

                const comps = this._components;

                for (let i = 0; i < comps.length; ++i) {
                  comps[i]._destroyImmediate();
                }

                return destroyByParent;
              }

            }, _class3$8.idGenerator = idGenerator$2, _class3$8._stacks = [[]], _class3$8._stackId = 0, _temp$i), (_applyDecoratedDescriptor(_class2$i.prototype, "_persistNode", [property], Object.getOwnPropertyDescriptor(_class2$i.prototype, "_persistNode"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "name", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "name"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "children", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "children"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "active", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "active"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "activeInHierarchy", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "activeInHierarchy"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "parent", [editable], Object.getOwnPropertyDescriptor(_class2$i.prototype, "parent"), _class2$i.prototype), _descriptor$g = _applyDecoratedDescriptor(_class2$i.prototype, "_parent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$c = _applyDecoratedDescriptor(_class2$i.prototype, "_children", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$i.prototype, "_active", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$i.prototype, "_components", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$i.prototype, "_prefab", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$i)) || _class$l));
            legacyCC._BaseNode = BaseNode;

            var _dec$m, _dec2$9, _class$m, _class2$j, _descriptor$h, _descriptor2$d, _descriptor3$9, _descriptor4$7, _descriptor5$4, _class3$9, _temp$j;
            const v3_a = new Vec3();
            const q_a = new Quat();
            const q_b = new Quat();
            const qt_1$1 = new Quat();
            const m3_1$2 = new Mat3();
            const m3_scaling = new Mat3();
            const m4_1$1 = new Mat4();
            const dirtyNodes = [];
            const nativeDirtyNodes = [];
            const view_tmp = [];

            class BookOfChange {
              constructor() {
                this._chunks = [];
                this._freelists = [];

                this._createChunk();
              }

              alloc() {
                const chunkCount = this._freelists.length;

                for (let i = 0; i < chunkCount; ++i) {
                  if (!this._freelists[i].length) continue;
                  return this._createView(i);
                }

                this._createChunk();

                return this._createView(chunkCount);
              }

              free(view, idx) {
                const chunkCount = this._freelists.length;

                for (let i = 0; i < chunkCount; ++i) {
                  if (this._chunks[i] !== view) continue;

                  this._freelists[i].push(idx);

                  return;
                }
              }

              clear() {
                const chunkCount = this._chunks.length;

                for (let i = 0; i < chunkCount; ++i) {
                  this._chunks[i].fill(0);
                }
              }

              _createChunk() {
                this._chunks.push(new Uint32Array(BookOfChange.CAPACITY_PER_CHUNK));

                const freelist = [];

                for (let i = BookOfChange.CAPACITY_PER_CHUNK - 1; i >= 0; i--) freelist.push(i);

                this._freelists.push(freelist);
              }

              _createView(chunkIdx) {
                view_tmp[0] = this._chunks[chunkIdx];
                view_tmp[1] = this._freelists[chunkIdx].pop();
                return view_tmp;
              }

            }

            BookOfChange.CAPACITY_PER_CHUNK = 256;
            const bookOfChange = new BookOfChange();
            const reserveContentsForAllSyncablePrefabTag = Symbol('ReserveContentsForAllSyncablePrefab');
            let Node$1 = exports('c1', (_dec$m = ccclass('cc.Node'), _dec2$9 = type(Vec3), _dec$m(_class$m = (_class2$j = (_temp$j = _class3$9 = class Node extends BaseNode {
              get _dirtyFlags() {
                return this._dirtyFlagsPri;
              }

              set _dirtyFlags(flags) {
                this._dirtyFlagsPri = flags;

                {
                  this._nativeDirtyFlag[0] = flags;
                }
              }

              _init() {
                const [chunk, offset] = bookOfChange.alloc();
                this._hasChangedFlagsChunk = chunk;
                this._hasChangedFlagsOffset = offset;
                const flagBuffer = new Uint32Array(chunk.buffer, chunk.byteOffset + offset * 4, 1);
                this._hasChangedFlags = flagBuffer;

                {
                  this._nodeHandle = NodePool.alloc();
                  this._pos = new Vec3(NodePool.getTypedArray(this._nodeHandle, NodeView.WORLD_POSITION));
                  this._rot = new Quat(NodePool.getTypedArray(this._nodeHandle, NodeView.WORLD_ROTATION));
                  this._scale = new Vec3(NodePool.getTypedArray(this._nodeHandle, NodeView.WORLD_SCALE));
                  this._lpos = new Vec3(NodePool.getTypedArray(this._nodeHandle, NodeView.LOCAL_POSITION));
                  this._lrot = new Quat(NodePool.getTypedArray(this._nodeHandle, NodeView.LOCAL_ROTATION));
                  this._lscale = new Vec3(NodePool.getTypedArray(this._nodeHandle, NodeView.LOCAL_SCALE));
                  this._mat = new Mat4(NodePool.getTypedArray(this._nodeHandle, NodeView.WORLD_MATRIX));
                  this._nativeLayer = NodePool.getTypedArray(this._nodeHandle, NodeView.LAYER);
                  this._nativeDirtyFlag = NodePool.getTypedArray(this._nodeHandle, NodeView.DIRTY_FLAG);

                  this._scale.set(1, 1, 1);

                  this._lscale.set(1, 1, 1);

                  this._nativeLayer[0] = this._layer;
                  this._nativeObj = new NativeNode();

                  this._nativeObj.initWithData(NodePool.getBuffer(this._nodeHandle), flagBuffer, nativeDirtyNodes);
                }
              }

              constructor(name) {
                super(name);
                this._uiProps = new NodeUIProperties(this);
                this._static = false;

                _initializerDefineProperty(this, "_lpos", _descriptor$h, this);

                _initializerDefineProperty(this, "_lrot", _descriptor2$d, this);

                _initializerDefineProperty(this, "_lscale", _descriptor3$9, this);

                _initializerDefineProperty(this, "_layer", _descriptor4$7, this);

                _initializerDefineProperty(this, "_euler", _descriptor5$4, this);

                this._dirtyFlagsPri = TransformBit.NONE;
                this._eulerDirty = false;
                this._nodeHandle = NULL_HANDLE;

                this._init();
              }

              static isNode(obj) {
                return obj instanceof Node && (obj.constructor === Node || !(obj instanceof legacyCC.Scene));
              }

              _onPreDestroy() {
                const result = this._onPreDestroyBase();

                {
                  if (this._nodeHandle) {
                    NodePool.free(this._nodeHandle);
                    this._nodeHandle = NULL_HANDLE;
                  }

                  this._nativeObj = null;
                }

                bookOfChange.free(this._hasChangedFlagsChunk, this._hasChangedFlagsOffset);
                return result;
              }

              get native() {
                return this._nativeObj;
              }

              get position() {
                return this._lpos;
              }

              set position(val) {
                this.setPosition(val);
              }

              get worldPosition() {
                this.updateWorldTransform();
                return this._pos;
              }

              set worldPosition(val) {
                this.setWorldPosition(val);
              }

              get rotation() {
                return this._lrot;
              }

              set rotation(val) {
                this.setRotation(val);
              }

              set eulerAngles(val) {
                this.setRotationFromEuler(val.x, val.y, val.z);
              }

              get eulerAngles() {
                if (this._eulerDirty) {
                  Quat.toEuler(this._euler, this._lrot);
                  this._eulerDirty = false;
                }

                return this._euler;
              }

              get angle() {
                return this._euler.z;
              }

              set angle(val) {
                Vec3.set(this._euler, 0, 0, val);
                Quat.fromAngleZ(this._lrot, val);
                this._eulerDirty = false;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              get worldRotation() {
                this.updateWorldTransform();
                return this._rot;
              }

              set worldRotation(val) {
                this.setWorldRotation(val);
              }

              get scale() {
                return this._lscale;
              }

              set scale(val) {
                this.setScale(val);
              }

              get worldScale() {
                this.updateWorldTransform();
                return this._scale;
              }

              set worldScale(val) {
                this.setWorldScale(val);
              }

              set matrix(val) {
                Mat4.toRTS(val, this._lrot, this._lpos, this._lscale);
                this.invalidateChildren(TransformBit.TRS);
                this._eulerDirty = true;

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.TRS);
                }
              }

              get worldMatrix() {
                this.updateWorldTransform();
                return this._mat;
              }

              get forward() {
                return Vec3.transformQuat(new Vec3(), Vec3.FORWARD, this.worldRotation);
              }

              set forward(dir) {
                const len = dir.length();
                Vec3.multiplyScalar(v3_a, dir, -1 / len);
                Quat.fromViewUp(q_a, v3_a);
                this.setWorldRotation(q_a);
              }

              get up() {
                return Vec3.transformQuat(new Vec3(), Vec3.UP, this.worldRotation);
              }

              get right() {
                return Vec3.transformQuat(new Vec3(), Vec3.RIGHT, this.worldRotation);
              }

              set layer(l) {
                this._layer = l;

                {
                  this._nativeLayer[0] = this._layer;
                }

                if (this._uiProps && this._uiProps.uiComp) {
                  this._uiProps.uiComp.setNodeDirty();

                  this._uiProps.uiComp.markForUpdateRenderData();
                }

                this.emit(NodeEventType.LAYER_CHANGED, this._layer);
              }

              get layer() {
                return this._layer;
              }

              get hasChangedFlags() {
                return this._hasChangedFlagsChunk[this._hasChangedFlagsOffset];
              }

              set hasChangedFlags(val) {
                this._hasChangedFlagsChunk[this._hasChangedFlagsOffset] = val;
              }

              [serializeTag](serializationOutput, context) {
                {
                  serializationOutput.writeThis();
                  return;
                }
              }

              setParent(value, keepWorldTransform = false) {
                if (keepWorldTransform) {
                  this.updateWorldTransform();
                }

                super.setParent(value, keepWorldTransform);

                {
                  this._nativeObj.setParent(this.parent ? this.parent.native : null);
                }
              }

              _onSetParent(oldParent, keepWorldTransform) {
                super._onSetParent(oldParent, keepWorldTransform);

                if (keepWorldTransform) {
                  const parent = this._parent;

                  if (parent) {
                    parent.updateWorldTransform();
                    Mat4.multiply(m4_1$1, Mat4.invert(m4_1$1, parent._mat), this._mat);
                    Mat4.toRTS(m4_1$1, this._lrot, this._lpos, this._lscale);
                  } else {
                    Vec3.copy(this._lpos, this._pos);
                    Quat.copy(this._lrot, this._rot);
                    Vec3.copy(this._lscale, this._scale);
                  }

                  this._eulerDirty = true;
                }

                this.invalidateChildren(TransformBit.TRS);
              }

              _onHierarchyChanged(oldParent) {
                this.eventProcessor.reattach();

                super._onHierarchyChangedBase(oldParent);
              }

              _onBatchCreated(dontSyncChildPrefab) {
                {
                  var _this$parent;

                  this._nativeLayer[0] = this._layer;

                  this._nativeObj.setParent((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.native);
                }

                this.hasChangedFlags = TransformBit.TRS;
                this._dirtyFlags |= TransformBit.TRS;
                const len = this._children.length;

                for (let i = 0; i < len; ++i) {
                  this._children[i]._siblingIndex = i;

                  this._children[i]._onBatchCreated(dontSyncChildPrefab);
                }
              }

              _onBeforeSerialize() {
                this.eulerAngles;
              }

              _onPostActivated(active) {
                if (active) {
                  this._eventProcessor.setEnabled(true);

                  this.invalidateChildren(TransformBit.TRS);

                  if (this._uiProps && this._uiProps.uiComp) {
                    this._uiProps.uiComp.setNodeDirty();

                    this._uiProps.uiComp.setTextureDirty();

                    this._uiProps.uiComp.markForUpdateRenderData();
                  }
                } else {
                  this._eventProcessor.setEnabled(false);
                }
              }

              translate(trans, ns) {
                const space = ns || NodeSpace.LOCAL;

                if (space === NodeSpace.LOCAL) {
                  Vec3.transformQuat(v3_a, trans, this._lrot);
                  this._lpos.x += v3_a.x;
                  this._lpos.y += v3_a.y;
                  this._lpos.z += v3_a.z;
                } else if (space === NodeSpace.WORLD) {
                  if (this._parent) {
                    Quat.invert(q_a, this._parent.worldRotation);
                    Vec3.transformQuat(v3_a, trans, q_a);
                    const scale = this.worldScale;
                    this._lpos.x += v3_a.x / scale.x;
                    this._lpos.y += v3_a.y / scale.y;
                    this._lpos.z += v3_a.z / scale.z;
                  } else {
                    this._lpos.x += trans.x;
                    this._lpos.y += trans.y;
                    this._lpos.z += trans.z;
                  }
                }

                this.invalidateChildren(TransformBit.POSITION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                }
              }

              rotate(rot, ns) {
                const space = ns || NodeSpace.LOCAL;
                Quat.normalize(q_a, rot);

                if (space === NodeSpace.LOCAL) {
                  Quat.multiply(this._lrot, this._lrot, q_a);
                } else if (space === NodeSpace.WORLD) {
                  const worldRot = this.worldRotation;
                  Quat.multiply(q_b, q_a, worldRot);
                  Quat.invert(q_a, worldRot);
                  Quat.multiply(q_b, q_a, q_b);
                  Quat.multiply(this._lrot, this._lrot, q_b);
                }

                this._eulerDirty = true;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              lookAt(pos, up) {
                this.getWorldPosition(v3_a);
                Vec3.subtract(v3_a, v3_a, pos);
                Vec3.normalize(v3_a, v3_a);
                Quat.fromViewUp(q_a, v3_a, up);
                this.setWorldRotation(q_a);
              }

              _setDirtyNode(idx, currNode) {
                dirtyNodes[idx] = currNode;

                {
                  nativeDirtyNodes[idx] = currNode.native;
                }
              }

              invalidateChildren(dirtyBit) {
                let i = 0;
                let j = 0;
                let l = 0;
                let cur;
                let c;
                let flag = 0;
                let children;
                let hasChangedFlags = 0;
                const childDirtyBit = dirtyBit | TransformBit.POSITION;
                dirtyNodes[0] = this;

                {
                  nativeDirtyNodes[0] = this.native;
                }

                while (i >= 0) {
                  cur = dirtyNodes[i--];
                  hasChangedFlags = cur._hasChangedFlags[0];
                  flag = cur._dirtyFlagsPri;

                  if (cur.isValid && (flag & hasChangedFlags & dirtyBit) !== dirtyBit) {
                    flag |= dirtyBit;
                    cur._dirtyFlagsPri = flag;

                    {
                      cur._nativeDirtyFlag[0] = flag;
                    }

                    cur._hasChangedFlags[0] = hasChangedFlags | dirtyBit;
                    children = cur._children;
                    l = children.length;

                    for (j = 0; j < l; j++) {
                      c = children[j];
                      dirtyNodes[++i] = c;

                      {
                        nativeDirtyNodes[i] = c.native;
                      }
                    }
                  }

                  dirtyBit = childDirtyBit;
                }
              }

              updateWorldTransform() {
                if (!this._dirtyFlags) {
                  return;
                }

                let cur = this;
                let i = 0;

                while (cur && cur._dirtyFlags) {
                  this._setDirtyNode(i++, cur);

                  cur = cur._parent;
                }

                let child;
                let dirtyBits = 0;

                while (i) {
                  child = dirtyNodes[--i];
                  dirtyBits |= child._dirtyFlags;

                  if (cur) {
                    if (dirtyBits & TransformBit.POSITION) {
                      Vec3.transformMat4(child._pos, child._lpos, cur._mat);
                      child._mat.m12 = child._pos.x;
                      child._mat.m13 = child._pos.y;
                      child._mat.m14 = child._pos.z;
                    }

                    if (dirtyBits & TransformBit.RS) {
                      Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale);
                      Mat4.multiply(child._mat, cur._mat, child._mat);

                      if (dirtyBits & TransformBit.ROTATION) {
                        Quat.multiply(child._rot, cur._rot, child._lrot);
                      }

                      Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, child._rot));
                      Mat3.multiplyMat4(m3_1$2, m3_1$2, child._mat);
                      child._scale.x = m3_1$2.m00;
                      child._scale.y = m3_1$2.m04;
                      child._scale.z = m3_1$2.m08;
                    }
                  } else {
                    if (dirtyBits & TransformBit.POSITION) {
                      Vec3.copy(child._pos, child._lpos);
                      child._mat.m12 = child._pos.x;
                      child._mat.m13 = child._pos.y;
                      child._mat.m14 = child._pos.z;
                    }

                    if (dirtyBits & TransformBit.RS) {
                      if (dirtyBits & TransformBit.ROTATION) {
                        Quat.copy(child._rot, child._lrot);
                      }

                      if (dirtyBits & TransformBit.SCALE) {
                        Vec3.copy(child._scale, child._lscale);
                        Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale);
                      }
                    }
                  }

                  child._dirtyFlags = TransformBit.NONE;
                  cur = child;
                }
              }

              setPosition(val, y, z) {
                if (y === undefined && z === undefined) {
                  Vec3.copy(this._lpos, val);
                } else if (z === undefined) {
                  Vec3.set(this._lpos, val, y, this._lpos.z);
                } else {
                  Vec3.set(this._lpos, val, y, z);
                }

                this.invalidateChildren(TransformBit.POSITION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                }
              }

              getPosition(out) {
                if (out) {
                  return Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
                }

                return Vec3.copy(new Vec3(), this._lpos);
              }

              setRotation(val, y, z, w) {
                if (y === undefined || z === undefined || w === undefined) {
                  Quat.copy(this._lrot, val);
                } else {
                  Quat.set(this._lrot, val, y, z, w);
                }

                this._eulerDirty = true;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              setRotationFromEuler(val, y, zOpt) {
                const z = zOpt === undefined ? this._euler.z : zOpt;

                if (y === undefined) {
                  Vec3.copy(this._euler, val);
                  Quat.fromEuler(this._lrot, val.x, val.y, val.z);
                } else {
                  Vec3.set(this._euler, val, y, z);
                  Quat.fromEuler(this._lrot, val, y, z);
                }

                this._eulerDirty = false;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              getRotation(out) {
                if (out) {
                  return Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w);
                }

                return Quat.copy(new Quat(), this._lrot);
              }

              setScale(val, y, z) {
                if (y === undefined && z === undefined) {
                  Vec3.copy(this._lscale, val);
                } else if (z === undefined) {
                  Vec3.set(this._lscale, val, y, this._lscale.z);
                } else {
                  Vec3.set(this._lscale, val, y, z);
                }

                this.invalidateChildren(TransformBit.SCALE);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
                }
              }

              getScale(out) {
                if (out) {
                  return Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
                }

                return Vec3.copy(new Vec3(), this._lscale);
              }

              inverseTransformPoint(out, p) {
                Vec3.copy(out, p);
                let cur = this;
                let i = 0;

                while (cur._parent) {
                  this._setDirtyNode(i++, cur);

                  cur = cur._parent;
                }

                while (i >= 0) {
                  Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale);
                  cur = dirtyNodes[--i];
                }

                return out;
              }

              setWorldPosition(val, y, z) {
                if (y === undefined || z === undefined) {
                  Vec3.copy(this._pos, val);
                } else {
                  Vec3.set(this._pos, val, y, z);
                }

                const parent = this._parent;
                const local = this._lpos;

                if (parent) {
                  parent.updateWorldTransform();
                  Vec3.transformMat4(local, this._pos, Mat4.invert(m4_1$1, parent._mat));
                } else {
                  Vec3.copy(local, this._pos);
                }

                this.invalidateChildren(TransformBit.POSITION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                }
              }

              getWorldPosition(out) {
                this.updateWorldTransform();

                if (out) {
                  return Vec3.copy(out, this._pos);
                }

                return Vec3.copy(new Vec3(), this._pos);
              }

              setWorldRotation(val, y, z, w) {
                if (y === undefined || z === undefined || w === undefined) {
                  Quat.copy(this._rot, val);
                } else {
                  Quat.set(this._rot, val, y, z, w);
                }

                if (this._parent) {
                  this._parent.updateWorldTransform();

                  Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
                } else {
                  Quat.copy(this._lrot, this._rot);
                }

                this._eulerDirty = true;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              setWorldRotationFromEuler(x, y, z) {
                Quat.fromEuler(this._rot, x, y, z);

                if (this._parent) {
                  this._parent.updateWorldTransform();

                  Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
                } else {
                  Quat.copy(this._lrot, this._rot);
                }

                this._eulerDirty = true;
                this.invalidateChildren(TransformBit.ROTATION);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                }
              }

              getWorldRotation(out) {
                this.updateWorldTransform();

                if (out) {
                  return Quat.copy(out, this._rot);
                }

                return Quat.copy(new Quat(), this._rot);
              }

              setWorldScale(val, y, z) {
                if (y === undefined || z === undefined) {
                  Vec3.copy(this._scale, val);
                } else {
                  Vec3.set(this._scale, val, y, z);
                }

                const parent = this._parent;

                if (parent) {
                  parent.updateWorldTransform();
                  Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, parent._rot));
                  Mat3.multiplyMat4(m3_1$2, m3_1$2, parent._mat);
                  m3_scaling.m00 = this._scale.x;
                  m3_scaling.m04 = this._scale.y;
                  m3_scaling.m08 = this._scale.z;
                  Mat3.multiply(m3_1$2, m3_scaling, Mat3.invert(m3_1$2, m3_1$2));
                  this._lscale.x = Vec3.set(v3_a, m3_1$2.m00, m3_1$2.m01, m3_1$2.m02).length();
                  this._lscale.y = Vec3.set(v3_a, m3_1$2.m03, m3_1$2.m04, m3_1$2.m05).length();
                  this._lscale.z = Vec3.set(v3_a, m3_1$2.m06, m3_1$2.m07, m3_1$2.m08).length();
                } else {
                  Vec3.copy(this._lscale, this._scale);
                }

                this.invalidateChildren(TransformBit.SCALE);

                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(NodeEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
                }
              }

              getWorldScale(out) {
                this.updateWorldTransform();

                if (out) {
                  return Vec3.copy(out, this._scale);
                }

                return Vec3.copy(new Vec3(), this._scale);
              }

              getWorldMatrix(out) {
                this.updateWorldTransform();
                const target = out || new Mat4();
                return Mat4.copy(target, this._mat);
              }

              getWorldRS(out) {
                this.updateWorldTransform();
                const target = out || new Mat4();
                Mat4.copy(target, this._mat);
                target.m12 = 0;
                target.m13 = 0;
                target.m14 = 0;
                return target;
              }

              getWorldRT(out) {
                this.updateWorldTransform();
                const target = out || new Mat4();
                return Mat4.fromRT(target, this._rot, this._pos);
              }

              setRTS(rot, pos, scale) {
                let dirtyBit = 0;

                if (rot) {
                  dirtyBit |= TransformBit.ROTATION;

                  if (rot.w !== undefined) {
                    Quat.copy(this._lrot, rot);
                    this._eulerDirty = true;
                  } else {
                    Vec3.copy(this._euler, rot);
                    Quat.fromEuler(this._lrot, rot.x, rot.y, rot.z);
                    this._eulerDirty = false;
                  }
                }

                if (pos) {
                  Vec3.copy(this._lpos, pos);
                  dirtyBit |= TransformBit.POSITION;
                }

                if (scale) {
                  Vec3.copy(this._lscale, scale);
                  dirtyBit |= TransformBit.SCALE;
                }

                if (dirtyBit) {
                  this.invalidateChildren(dirtyBit);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(NodeEventType.TRANSFORM_CHANGED, dirtyBit);
                  }
                }
              }

              pauseSystemEvents(recursive) {
                this._eventProcessor.setEnabled(false, recursive);
              }

              resumeSystemEvents(recursive) {
                this._eventProcessor.setEnabled(true, recursive);
              }

              static resetHasChangedFlags() {
                bookOfChange.clear();
              }

              static clearNodeArray() {
                if (Node.ClearFrame < Node.ClearRound && !EDITOR) {
                  Node.ClearFrame++;
                } else {
                  Node.ClearFrame = 0;
                  dirtyNodes.length = 0;
                  nativeDirtyNodes.length = 0;
                }
              }

              getPathInHierarchy() {
                let result = this.name;
                let curNode = this.parent;

                while (curNode && curNode instanceof Node) {
                  result = `${curNode.name}/${result}`;
                  curNode = curNode.parent;
                }

                return result;
              }

            }, _class3$9.EventType = NodeEventType, _class3$9.NodeSpace = NodeSpace, _class3$9.TransformDirtyBit = TransformBit, _class3$9.TransformBit = TransformBit, _class3$9.reserveContentsForAllSyncablePrefabTag = reserveContentsForAllSyncablePrefabTag, _class3$9.ClearFrame = 0, _class3$9.ClearRound = 1000, _temp$j), (_descriptor$h = _applyDecoratedDescriptor(_class2$j.prototype, "_lpos", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _descriptor2$d = _applyDecoratedDescriptor(_class2$j.prototype, "_lrot", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Quat();
              }
            }), _descriptor3$9 = _applyDecoratedDescriptor(_class2$j.prototype, "_lscale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(1, 1, 1);
              }
            }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$j.prototype, "_layer", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Layers.Enum.DEFAULT;
              }
            }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$j.prototype, "_euler", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _applyDecoratedDescriptor(_class2$j.prototype, "eulerAngles", [_dec2$9], Object.getOwnPropertyDescriptor(_class2$j.prototype, "eulerAngles"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "angle", [editable], Object.getOwnPropertyDescriptor(_class2$j.prototype, "angle"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "layer", [editable], Object.getOwnPropertyDescriptor(_class2$j.prototype, "layer"), _class2$j.prototype)), _class2$j)) || _class$m));
            legacyCC.Node = Node$1;

            var _dec$n, _class$n, _class2$k, _descriptor$i, _temp$k, _dec2$a, _dec3$5, _dec4$4, _dec5$1, _dec6$1, _class4$1, _class5$1, _descriptor2$e, _descriptor3$a, _descriptor4$8, _descriptor5$5, _descriptor6$1, _temp2$1, _dec7, _class7, _class8, _descriptor7$1, _temp3, _dec8, _dec9, _class10, _class11, _descriptor8$1, _descriptor9, _descriptor10, _temp4, _dec10, _dec11, _dec12, _class13, _class14, _descriptor11, _descriptor12, _temp5, _dec13, _dec14, _dec15, _class16, _class17, _descriptor13, _descriptor14, _temp6, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _class19, _class20, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _temp7, _dec22, _dec23, _dec24, _dec25, _class22, _class23, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _temp8;

            let TargetInfo = (_dec$n = ccclass('cc.TargetInfo'), _dec$n(_class$n = (_class2$k = (_temp$k = class TargetInfo {
              constructor() {
                _initializerDefineProperty(this, "localID", _descriptor$i, this);
              }

            }, _temp$k), (_descriptor$i = _applyDecoratedDescriptor(_class2$k.prototype, "localID", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$k)) || _class$n);
            let TargetOverrideInfo = (_dec2$a = ccclass('cc.TargetOverrideInfo'), _dec3$5 = type(CCObject), _dec4$4 = type(TargetInfo), _dec5$1 = type(Node$1), _dec6$1 = type(TargetInfo), _dec2$a(_class4$1 = (_class5$1 = (_temp2$1 = class TargetOverrideInfo {
              constructor() {
                _initializerDefineProperty(this, "source", _descriptor2$e, this);

                _initializerDefineProperty(this, "sourceInfo", _descriptor3$a, this);

                _initializerDefineProperty(this, "propertyPath", _descriptor4$8, this);

                _initializerDefineProperty(this, "target", _descriptor5$5, this);

                _initializerDefineProperty(this, "targetInfo", _descriptor6$1, this);
              }

            }, _temp2$1), (_descriptor2$e = _applyDecoratedDescriptor(_class5$1.prototype, "source", [serializable, _dec3$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$a = _applyDecoratedDescriptor(_class5$1.prototype, "sourceInfo", [serializable, _dec4$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor4$8 = _applyDecoratedDescriptor(_class5$1.prototype, "propertyPath", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor5$5 = _applyDecoratedDescriptor(_class5$1.prototype, "target", [serializable, _dec5$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor6$1 = _applyDecoratedDescriptor(_class5$1.prototype, "targetInfo", [serializable, _dec6$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class5$1)) || _class4$1);
            let CompPrefabInfo = (_dec7 = ccclass('cc.CompPrefabInfo'), _dec7(_class7 = (_class8 = (_temp3 = class CompPrefabInfo {
              constructor() {
                _initializerDefineProperty(this, "fileId", _descriptor7$1, this);
              }

            }, _temp3), (_descriptor7$1 = _applyDecoratedDescriptor(_class8.prototype, "fileId", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class8)) || _class7);
            let PropertyOverrideInfo = (_dec8 = ccclass('CCPropertyOverrideInfo'), _dec9 = type(TargetInfo), _dec8(_class10 = (_class11 = (_temp4 = class PropertyOverrideInfo {
              constructor() {
                _initializerDefineProperty(this, "targetInfo", _descriptor8$1, this);

                _initializerDefineProperty(this, "propertyPath", _descriptor9, this);

                _initializerDefineProperty(this, "value", _descriptor10, this);
              }

              isTarget(localID, propPath) {
              }

            }, _temp4), (_descriptor8$1 = _applyDecoratedDescriptor(_class11.prototype, "targetInfo", [serializable, _dec9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor9 = _applyDecoratedDescriptor(_class11.prototype, "propertyPath", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor10 = _applyDecoratedDescriptor(_class11.prototype, "value", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class11)) || _class10);
            let MountedChildrenInfo = (_dec10 = ccclass('cc.MountedChildrenInfo'), _dec11 = type(TargetInfo), _dec12 = type([Node$1]), _dec10(_class13 = (_class14 = (_temp5 = class MountedChildrenInfo {
              constructor() {
                _initializerDefineProperty(this, "targetInfo", _descriptor11, this);

                _initializerDefineProperty(this, "nodes", _descriptor12, this);
              }

              isTarget(localID) {
              }

            }, _temp5), (_descriptor11 = _applyDecoratedDescriptor(_class14.prototype, "targetInfo", [serializable, _dec11], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor12 = _applyDecoratedDescriptor(_class14.prototype, "nodes", [serializable, _dec12], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class14)) || _class13);
            let MountedComponentsInfo = (_dec13 = ccclass('cc.MountedComponentsInfo'), _dec14 = type(TargetInfo), _dec15 = type([Component]), _dec13(_class16 = (_class17 = (_temp6 = class MountedComponentsInfo {
              constructor() {
                _initializerDefineProperty(this, "targetInfo", _descriptor13, this);

                _initializerDefineProperty(this, "components", _descriptor14, this);
              }

              isTarget(localID) {
              }

            }, _temp6), (_descriptor13 = _applyDecoratedDescriptor(_class17.prototype, "targetInfo", [serializable, _dec14], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor14 = _applyDecoratedDescriptor(_class17.prototype, "components", [serializable, _dec15], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class17)) || _class16);
            let PrefabInstance = (_dec16 = ccclass('cc.PrefabInstance'), _dec17 = type(Node$1), _dec18 = type([MountedChildrenInfo]), _dec19 = type([MountedComponentsInfo]), _dec20 = type([PropertyOverrideInfo]), _dec21 = type([TargetInfo]), _dec16(_class19 = (_class20 = (_temp7 = class PrefabInstance {
              constructor() {
                _initializerDefineProperty(this, "fileId", _descriptor15, this);

                _initializerDefineProperty(this, "prefabRootNode", _descriptor16, this);

                _initializerDefineProperty(this, "mountedChildren", _descriptor17, this);

                _initializerDefineProperty(this, "mountedComponents", _descriptor18, this);

                _initializerDefineProperty(this, "propertyOverrides", _descriptor19, this);

                _initializerDefineProperty(this, "removedComponents", _descriptor20, this);

                this.targetMap = {};
              }

              findPropertyOverride(localID, propPath) {
              }

              removePropertyOverride(localID, propPath) {
              }

            }, _temp7), (_descriptor15 = _applyDecoratedDescriptor(_class20.prototype, "fileId", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor16 = _applyDecoratedDescriptor(_class20.prototype, "prefabRootNode", [serializable, _dec17], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor17 = _applyDecoratedDescriptor(_class20.prototype, "mountedChildren", [serializable, _dec18], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor18 = _applyDecoratedDescriptor(_class20.prototype, "mountedComponents", [serializable, _dec19], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor19 = _applyDecoratedDescriptor(_class20.prototype, "propertyOverrides", [serializable, _dec20], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor20 = _applyDecoratedDescriptor(_class20.prototype, "removedComponents", [serializable, _dec21], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class20)) || _class19);
            let PrefabInfo = (_dec22 = ccclass('cc.PrefabInfo'), _dec23 = type(Node$1), _dec24 = type(PrefabInstance), _dec25 = type([TargetOverrideInfo]), _dec22(_class22 = (_class23 = (_temp8 = class PrefabInfo {
              constructor() {
                _initializerDefineProperty(this, "root", _descriptor21, this);

                _initializerDefineProperty(this, "asset", _descriptor22, this);

                _initializerDefineProperty(this, "fileId", _descriptor23, this);

                _initializerDefineProperty(this, "instance", _descriptor24, this);

                _initializerDefineProperty(this, "targetOverrides", _descriptor25, this);

                _initializerDefineProperty(this, "nestedPrefabInstanceRoots", _descriptor26, this);
              }

            }, _temp8), (_descriptor21 = _applyDecoratedDescriptor(_class23.prototype, "root", [serializable, _dec23], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor22 = _applyDecoratedDescriptor(_class23.prototype, "asset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor23 = _applyDecoratedDescriptor(_class23.prototype, "fileId", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor24 = _applyDecoratedDescriptor(_class23.prototype, "instance", [serializable, _dec24], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor25 = _applyDecoratedDescriptor(_class23.prototype, "targetOverrides", [serializable, _dec25], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor26 = _applyDecoratedDescriptor(_class23.prototype, "nestedPrefabInstanceRoots", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class23)) || _class22);
            legacyCC._PrefabInfo = PrefabInfo;

            function createNodeWithPrefab(node) {
              const prefabInfo = node._prefab;

              if (!prefabInfo) {
                return;
              }

              const prefabInstance = prefabInfo.instance;

              if (!prefabInstance) {
                return;
              }

              if (!prefabInfo.asset) {
                {
                  errorID(3701, node.name);
                }

                prefabInfo.instance = undefined;
                return;
              }

              const _objFlags = node._objFlags;
              const _parent = node._parent;
              const _id = node._id;
              const _prefab = node._prefab;
              const editorExtras = node[editorExtrasTag];
              legacyCC.game._isCloning = true;

              {
                prefabInfo.asset._doInstantiate(node);
              }

              legacyCC.game._isCloning = false;
              node._objFlags = _objFlags;
              node._parent = _parent;
              node._id = _id;

              if (node._prefab) {
                node._prefab.instance = _prefab === null || _prefab === void 0 ? void 0 : _prefab.instance;
              }
            }
            function generateTargetMap(node, targetMap, isRoot) {
              var _node$_prefab;

              if (!targetMap) {
                return;
              }

              if (!node) {
                return;
              }

              let curTargetMap = targetMap;
              const prefabInstance = (_node$_prefab = node._prefab) === null || _node$_prefab === void 0 ? void 0 : _node$_prefab.instance;

              if (!isRoot && prefabInstance) {
                targetMap[prefabInstance.fileId] = {};
                curTargetMap = targetMap[prefabInstance.fileId];
              }

              const prefabInfo = node._prefab;

              if (prefabInfo) {
                curTargetMap[prefabInfo.fileId] = node;
              }

              const components = node.components;

              for (let i = 0; i < components.length; i++) {
                const comp = components[i];

                if (comp.__prefab) {
                  curTargetMap[comp.__prefab.fileId] = comp;
                }
              }

              for (let i = 0; i < node.children.length; i++) {
                const childNode = node.children[i];
                generateTargetMap(childNode, curTargetMap, false);
              }
            }
            function getTarget(localID, targetMap) {
              if (!localID) {
                return null;
              }

              let target = null;
              let targetIter = targetMap;

              for (let i = 0; i < localID.length; i++) {
                if (!targetIter) {
                  return null;
                }

                targetIter = targetIter[localID[i]];
              }

              target = targetIter;
              return target;
            }
            function applyMountedChildren(node, mountedChildren, targetMap) {
              if (!mountedChildren) {
                return;
              }

              for (let i = 0; i < mountedChildren.length; i++) {
                const childInfo = mountedChildren[i];

                if (childInfo && childInfo.targetInfo) {
                  const target = getTarget(childInfo.targetInfo.localID, targetMap);

                  if (!target) {
                    continue;
                  }

                  let curTargetMap = targetMap;
                  const localID = childInfo.targetInfo.localID;

                  if (localID.length > 0) {
                    for (let i = 0; i < localID.length - 1; i++) {
                      curTargetMap = curTargetMap[localID[i]];
                    }
                  }

                  if (childInfo.nodes) {
                    for (let i = 0; i < childInfo.nodes.length; i++) {
                      const childNode = childInfo.nodes[i];

                      if (!childNode) {
                        continue;
                      }

                      target._children.push(childNode);

                      childNode._parent = target;

                      generateTargetMap(childNode, curTargetMap, false);
                      childNode._siblingIndex = target._children.length - 1;
                      expandPrefabInstanceNode(childNode, true);
                    }
                  }
                }
              }
            }
            function applyMountedComponents(node, mountedComponents, targetMap) {
              if (!mountedComponents) {
                return;
              }

              for (let i = 0; i < mountedComponents.length; i++) {
                const componentsInfo = mountedComponents[i];

                if (componentsInfo && componentsInfo.targetInfo) {
                  const target = getTarget(componentsInfo.targetInfo.localID, targetMap);

                  if (!target) {
                    continue;
                  }

                  if (componentsInfo.components) {
                    for (let i = 0; i < componentsInfo.components.length; i++) {
                      const comp = componentsInfo.components[i];

                      if (!comp) {
                        continue;
                      }

                      comp.node = target;

                      target._components.push(comp);
                    }
                  }
                }
              }
            }
            function applyRemovedComponents(node, removedComponents, targetMap) {
              if (!removedComponents) {
                return;
              }

              for (let i = 0; i < removedComponents.length; i++) {
                const targetInfo = removedComponents[i];

                if (targetInfo) {
                  const target = getTarget(targetInfo.localID, targetMap);

                  if (!target || !target.node) {
                    continue;
                  }

                  const index = target.node.components.indexOf(target);

                  if (index >= 0) {
                    target.node._components.splice(index, 1);
                  }
                }
              }
            }
            function applyPropertyOverrides(node, propertyOverrides, targetMap) {
              if (propertyOverrides.length <= 0) {
                return;
              }

              let target = null;

              for (let i = 0; i < propertyOverrides.length; i++) {
                const propOverride = propertyOverrides[i];

                if (propOverride && propOverride.targetInfo) {
                  const targetInfo = propOverride.targetInfo;
                  target = getTarget(targetInfo.localID, targetMap);

                  if (!target) {
                    continue;
                  }

                  let targetPropOwner = target;
                  const propertyPath = propOverride.propertyPath.slice();

                  if (propertyPath.length > 0) {
                    const targetPropName = propertyPath.pop();

                    if (!targetPropName) {
                      continue;
                    }

                    for (let i = 0; i < propertyPath.length; i++) {
                      const propName = propertyPath[i];
                      targetPropOwner = targetPropOwner[propName];

                      if (!targetPropOwner) {
                        break;
                      }
                    }

                    if (!targetPropOwner) {
                      continue;
                    }

                    if (Array.isArray(targetPropOwner)) {
                      if (targetPropName === 'length') {
                        targetPropOwner[targetPropName] = propOverride.value;
                      } else {
                        const index = Number.parseInt(targetPropName);

                        if (Number.isInteger(index) && index < targetPropOwner.length) {
                          targetPropOwner[targetPropName] = propOverride.value;
                        }
                      }
                    } else if (targetPropOwner[targetPropName] instanceof ValueType) {
                      targetPropOwner[targetPropName].set(propOverride.value);
                    } else {
                      targetPropOwner[targetPropName] = propOverride.value;
                    }
                  }
                }
              }
            }
            function applyTargetOverrides(node) {
              var _node$_prefab2;

              const targetOverrides = (_node$_prefab2 = node._prefab) === null || _node$_prefab2 === void 0 ? void 0 : _node$_prefab2.targetOverrides;

              if (targetOverrides) {
                for (let i = 0; i < targetOverrides.length; i++) {
                  var _targetOverride$targe, _targetOverride$targe2;

                  const targetOverride = targetOverrides[i];
                  let source = targetOverride.source;
                  const sourceInfo = targetOverride.sourceInfo;

                  if (sourceInfo) {
                    var _targetOverride$sourc, _targetOverride$sourc2;

                    const sourceInstance = (_targetOverride$sourc = targetOverride.source) === null || _targetOverride$sourc === void 0 ? void 0 : (_targetOverride$sourc2 = _targetOverride$sourc._prefab) === null || _targetOverride$sourc2 === void 0 ? void 0 : _targetOverride$sourc2.instance;

                    if (sourceInstance && sourceInstance.targetMap) {
                      source = getTarget(sourceInfo.localID, sourceInstance.targetMap);
                    }
                  }

                  if (!source) {
                    continue;
                  }

                  let target = null;
                  const targetInfo = targetOverride.targetInfo;

                  if (!targetInfo) {
                    continue;
                  }

                  const targetInstance = (_targetOverride$targe = targetOverride.target) === null || _targetOverride$targe === void 0 ? void 0 : (_targetOverride$targe2 = _targetOverride$targe._prefab) === null || _targetOverride$targe2 === void 0 ? void 0 : _targetOverride$targe2.instance;

                  if (!targetInstance || !targetInstance.targetMap) {
                    continue;
                  }

                  target = getTarget(targetInfo.localID, targetInstance.targetMap);

                  if (!target) {
                    continue;
                  }

                  const propertyPath = targetOverride.propertyPath.slice();
                  let targetPropOwner = source;

                  if (propertyPath.length > 0) {
                    const targetPropName = propertyPath.pop();

                    if (!targetPropName) {
                      return;
                    }

                    for (let i = 0; i < propertyPath.length; i++) {
                      const propName = propertyPath[i];
                      targetPropOwner = targetPropOwner[propName];

                      if (!targetPropOwner) {
                        break;
                      }
                    }

                    if (!targetPropOwner) {
                      continue;
                    }

                    targetPropOwner[targetPropName] = target;
                  }
                }
              }
            }
            function expandPrefabInstanceNode(node, recursively = false) {
              const prefabInfo = node._prefab;
              const prefabInstance = prefabInfo === null || prefabInfo === void 0 ? void 0 : prefabInfo.instance;

              if (prefabInstance) {
                createNodeWithPrefab(node);
                const targetMap = {};
                prefabInstance.targetMap = targetMap;
                generateTargetMap(node, targetMap, true);
                applyMountedChildren(node, prefabInstance.mountedChildren, targetMap);
                applyRemovedComponents(node, prefabInstance.removedComponents, targetMap);
                applyMountedComponents(node, prefabInstance.mountedComponents, targetMap);
                applyPropertyOverrides(node, prefabInstance.propertyOverrides, targetMap);
              }

              if (recursively) {
                if (node && node.children) {
                  node.children.forEach(child => {
                    expandPrefabInstanceNode(child, true);
                  });
                }
              }
            }
            function expandNestedPrefabInstanceNode(node) {
              const prefabInfo = node._prefab;

              if (prefabInfo && prefabInfo.nestedPrefabInstanceRoots) {
                prefabInfo.nestedPrefabInstanceRoots.forEach(instanceNode => {
                  expandPrefabInstanceNode(instanceNode);
                });
              }
            }

            var utils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                TargetInfo: TargetInfo,
                TargetOverrideInfo: TargetOverrideInfo,
                CompPrefabInfo: CompPrefabInfo,
                PropertyOverrideInfo: PropertyOverrideInfo,
                MountedChildrenInfo: MountedChildrenInfo,
                MountedComponentsInfo: MountedComponentsInfo,
                PrefabInstance: PrefabInstance,
                PrefabInfo: PrefabInfo,
                createNodeWithPrefab: createNodeWithPrefab,
                generateTargetMap: generateTargetMap,
                getTarget: getTarget,
                applyMountedChildren: applyMountedChildren,
                applyMountedComponents: applyMountedComponents,
                applyRemovedComponents: applyRemovedComponents,
                applyPropertyOverrides: applyPropertyOverrides,
                applyTargetOverrides: applyTargetOverrides,
                expandPrefabInstanceNode: expandPrefabInstanceNode,
                expandNestedPrefabInstanceNode: expandNestedPrefabInstanceNode
            });

            var _dec$o, _class$o, _class2$l, _descriptor$j, _descriptor2$f, _descriptor3$b, _class3$a, _temp$l;
            const OptimizationPolicy = Enum({
              AUTO: 0,
              SINGLE_INSTANCE: 1,
              MULTI_INSTANCE: 2
            });
            let Prefab = exports('fC', (_dec$o = ccclass('cc.Prefab'), _dec$o(_class$o = (_class2$l = (_temp$l = _class3$a = class Prefab extends Asset {
              constructor() {
                super();

                _initializerDefineProperty(this, "data", _descriptor$j, this);

                _initializerDefineProperty(this, "optimizationPolicy", _descriptor2$f, this);

                _initializerDefineProperty(this, "persistent", _descriptor3$b, this);

                this._createFunction = void 0;
                this._instantiatedTimes = void 0;
                this._createFunction = null;
                this._instantiatedTimes = 0;
              }

              createNode(cb) {
                const node = legacyCC.instantiate(this);
                node.name = this.name;
                cb(null, node);
              }

              compileCreateFunction() {
                this._createFunction = compile(this.data);
              }

              _doInstantiate(rootToRedirect) {
                if (!this.data._prefab) {
                  warnID(3700);
                }

                if (!this._createFunction) {
                  this.compileCreateFunction();
                }

                return this._createFunction(rootToRedirect);
              }

              _instantiate() {
                let node;
                let useJit = false;

                {
                  if (this.optimizationPolicy === OptimizationPolicy.SINGLE_INSTANCE) {
                    useJit = false;
                  } else if (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE) {
                    useJit = true;
                  } else {
                    useJit = this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold;
                  }
                }

                if (useJit) {
                  node = this._doInstantiate();

                  this.data._instantiate(node);
                } else {
                  node = this.data._instantiate();
                }

                ++this._instantiatedTimes;
                return node;
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this.data = new Node$1();
                this.data.name = '(Missing Node)';
                const prefabInfo = new legacyCC._PrefabInfo();
                prefabInfo.asset = this;
                prefabInfo.root = this.data;
                this.data._prefab = prefabInfo;
              }

              validate() {
                return !!this.data;
              }

              onLoaded() {
                const rootNode = this.data;
                expandNestedPrefabInstanceNode(rootNode);
                applyTargetOverrides(rootNode);
              }

            }, _class3$a.OptimizationPolicy = OptimizationPolicy, _class3$a.OptimizationPolicyThreshold = 3, _temp$l), (_descriptor$j = _applyDecoratedDescriptor(_class2$l.prototype, "data", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$f = _applyDecoratedDescriptor(_class2$l.prototype, "optimizationPolicy", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return OptimizationPolicy.AUTO;
              }
            }), _descriptor3$b = _applyDecoratedDescriptor(_class2$l.prototype, "persistent", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class2$l)) || _class$o));
            js.value(Prefab, '_utils', utils);
            legacyCC.Prefab = Prefab;

            {
              obsolete(legacyCC, 'cc._Prefab', 'Prefab');
            }

            var _dec$p, _dec2$b, _dec3$6, _class$p, _class2$m, _descriptor$k, _temp$m;
            let PrefabLink = exports('fo', (_dec$p = ccclass('cc.PrefabLink'), _dec2$b = type(Prefab), _dec3$6 = visible(), _dec$p(_class$p = (_class2$m = (_temp$m = class PrefabLink extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "prefab", _descriptor$k, this);
              }

            }, _temp$m), (_descriptor$k = _applyDecoratedDescriptor(_class2$m.prototype, "prefab", [_dec2$b, serializable, _dec3$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$m)) || _class$p));

            const _vec3 = new Vec3();

            function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
              if (!out) {
                out = new Vec3();
              }

              mainCamera.convertToUINode(wpos, uiNode, out);
              const pos = uiNode.position;
              out.add(pos);
              return out;
            }
            function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
              if (!out) {
                out = new Vec3();
              }

              mainCamera.worldToScreen(wpos, out);
              out.x /= legacyCC.view.getScaleX();
              out.y /= legacyCC.view.getScaleY();
              return out;
            }
            const convertUtils = exports('fs', {
              WorldNode3DToLocalNodeUI,
              WorldNode3DToWorldNodeUI
            });
            legacyCC.pipelineUtils = convertUtils;
            replaceProperty(legacyCC.pipelineUtils, 'cc.pipelineUtils', [{
              name: 'WorldNode3DToLocalNodeUI',
              newName: 'convertToUINode',
              targetName: 'cc.Camera.prototype',

              customFunction(...args) {
                const camera = args[0];
                const out = args[3] || _vec3;
                camera.convertToUINode(args[1], args[2], out);
                out.add(args[2].position);
                return args[3] || out.clone();
              }

            }]);

            var _dec$q, _class$q, _temp$n;

            const _colorAttachment = new ColorAttachment();

            _colorAttachment.format = Format.RGBA8;
            _colorAttachment.beginAccesses = [AccessType.FRAGMENT_SHADER_READ_TEXTURE];
            _colorAttachment.endAccesses = [AccessType.FRAGMENT_SHADER_READ_TEXTURE];

            const _depthStencilAttachment = new DepthStencilAttachment();

            _depthStencilAttachment.format = Format.DEPTH_STENCIL;
            const passInfo = new RenderPassInfo([_colorAttachment], _depthStencilAttachment);
            const _windowInfo = {
              width: 1,
              height: 1,
              renderPassInfo: passInfo
            };
            let RenderTexture = exports('eb', (_dec$q = ccclass('cc.RenderTexture'), _dec$q(_class$q = (_temp$n = class RenderTexture extends TextureBase {
              constructor(...args) {
                super(...args);
                this._window = null;
              }

              get window() {
                return this._window;
              }

              initialize(info) {
                this._name = info.name || '';
                this._width = info.width;
                this._height = info.height;

                this._initWindow(info);
              }

              reset(info) {
                this.initialize(info);
              }

              destroy() {
                if (this._window) {
                  const root = legacyCC.director.root;
                  root === null || root === void 0 ? void 0 : root.destroyWindow(this._window);
                  this._window = null;
                }

                return super.destroy();
              }

              resize(width, height) {
                this._width = Math.floor(clamp(width, 1, 2048));
                this._height = Math.floor(clamp(height, 1, 2048));

                if (this._window) {
                  this._window.resize(this._width, this._height);
                }

                this.emit('resize', this._window);
              }

              _serialize(ctxForExporting) {

                return {};
              }

              _deserialize(serializedData, handle) {
                const data = serializedData;
                this._width = data.w;
                this._height = data.h;
                this._name = data.n;

                super._deserialize(data.base, handle);
              }

              getGFXTexture() {
                return this._window && this._window.framebuffer.colorTextures[0];
              }

              onLoaded() {
                this._initWindow();
              }

              _initWindow(info) {
                const root = legacyCC.director.root;
                _windowInfo.title = this._name;
                _windowInfo.width = this._width;
                _windowInfo.height = this._height;
                _windowInfo.renderPassInfo = info && info.passInfo ? info.passInfo : passInfo;

                if (this._window) {
                  this._window.destroy();

                  this._window.initialize(root.device, _windowInfo);
                } else {
                  this._window = root.createWindow(_windowInfo);
                }
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this._width = this._height = 1;

                this._initWindow();
              }

              validate() {
                return this.width >= 1 && this.width <= 2048 && this.height >= 1 && this.height <= 2048;
              }

              readPixels(x = 0, y = 0, width, height, buffer) {
                width = width || this.width;
                height = height || this.height;
                const gfxTexture = this.getGFXTexture();

                if (!gfxTexture) {
                  errorID(7606);
                  return null;
                }

                const needSize = 4 * width * height;

                if (buffer === undefined) {
                  buffer = new Uint8Array(needSize);
                } else if (buffer.length < needSize) {
                  errorID(7607, needSize);
                  return null;
                }

                const gfxDevice = this._getGFXDevice();

                const bufferViews = [];
                const regions = [];
                const region0 = new BufferTextureCopy();
                region0.texOffset.x = x;
                region0.texOffset.y = y;
                region0.texExtent.width = width;
                region0.texExtent.height = height;
                regions.push(region0);
                bufferViews.push(buffer);
                gfxDevice === null || gfxDevice === void 0 ? void 0 : gfxDevice.copyTextureToBuffers(gfxTexture, bufferViews, regions);
                return buffer;
              }

            }, _temp$n)) || _class$q));
            legacyCC.RenderTexture = RenderTexture;

            removeProperty(TextureBase.prototype, 'TextureBase.prototype', [{
              name: 'hasPremultipliedAlpha'
            }, {
              name: 'setPremultiplyAlpha'
            }, {
              name: 'setFlipY'
            }]);
            replaceProperty(RenderTexture.prototype, 'RenderTexture.prototype', [{
              name: 'getGFXWindow',

              customFunction() {
                return this._window;
              }

            }]);

            var _dec$r, _class$r, _class2$n, _temp$o;
            let BufferAsset = exports('fB', (_dec$r = ccclass('cc.BufferAsset'), _dec$r(_class$r = (_class2$n = (_temp$o = class BufferAsset extends Asset {
              constructor(...args) {
                super(...args);
                this._buffer = null;
              }

              get _nativeAsset() {
                return this._buffer;
              }

              set _nativeAsset(bin) {
                if (bin instanceof ArrayBuffer) {
                  this._buffer = bin;
                } else {
                  this._buffer = bin.buffer;
                }
              }

              buffer() {
                return this._buffer;
              }

              validate() {
                return !!this.buffer;
              }

            }, _temp$o), (_applyDecoratedDescriptor(_class2$n.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$n.prototype, "_nativeAsset"), _class2$n.prototype)), _class2$n)) || _class$r));
            legacyCC.BufferAsset = BufferAsset;

            const _typeMap = {
              [FormatType.UNORM]: 'Uint',
              [FormatType.SNORM]: 'Int',
              [FormatType.UINT]: 'Uint',
              [FormatType.INT]: 'Int',
              [FormatType.UFLOAT]: 'Float',
              [FormatType.FLOAT]: 'Float',
              default: 'Uint'
            };

            function _getDataViewType(info) {
              const type = _typeMap[info.type] || _typeMap.default;
              const bytes = info.size / info.count * 8;
              return `${type}${bytes}`;
            }

            function writeBuffer(target, data, format = Format.R32F, offset = 0, stride = 0) {
              const info = FormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              const writer = `set${_getDataViewType(info)}`;
              const componentBytesLength = info.size / info.count;
              const nSeg = Math.floor(data.length / info.count);
              const isLittleEndian = sys.isLittleEndian;

              for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
                const x = offset + stride * iSeg;

                for (let iComponent = 0; iComponent < info.count; ++iComponent) {
                  const y = x + componentBytesLength * iComponent;
                  target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian);
                }
              }
            }
            function readBuffer(target, format = Format.R32F, offset = 0, length = target.byteLength - offset, stride = 0, out = []) {
              const info = FormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              const reader = `get${_getDataViewType(info)}`;
              const componentBytesLength = info.size / info.count;
              const nSeg = Math.floor(length / stride);
              const isLittleEndian = sys.isLittleEndian;

              for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
                const x = offset + stride * iSeg;

                for (let iComponent = 0; iComponent < info.count; ++iComponent) {
                  const y = x + componentBytesLength * iComponent;
                  out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian);
                }
              }

              return out;
            }
            function mapBuffer(target, callback, format = Format.R32F, offset = 0, length = target.byteLength - offset, stride = 0, out) {
              if (!out) {
                out = new DataView(target.buffer.slice(target.byteOffset, target.byteOffset + target.byteLength));
              }

              const info = FormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              const writer = `set${_getDataViewType(info)}`;
              const reader = `get${_getDataViewType(info)}`;
              const componentBytesLength = info.size / info.count;
              const nSeg = Math.floor(length / stride);
              const isLittleEndian = sys.isLittleEndian;

              for (let iSeg = 0; iSeg < nSeg; ++iSeg) {
                const x = offset + stride * iSeg;

                for (let iComponent = 0; iComponent < info.count; ++iComponent) {
                  const y = x + componentBytesLength * iComponent;
                  const cur = target[reader](y, isLittleEndian);
                  out[writer](y, callback(cur, iComponent, target), isLittleEndian);
                }
              }

              return out;
            }

            class RenderingSubMesh {
              _init() {}

              constructor(vertexBuffers, attributes, primitiveMode, indexBuffer = null, indirectBuffer = null) {
                this.mesh = void 0;
                this.subMeshIdx = void 0;
                this._flatBuffers = [];
                this._jointMappedBuffers = void 0;
                this._jointMappedBufferIndices = void 0;
                this._vertexIdChannel = void 0;
                this._geometricInfo = void 0;
                this._vertexBuffers = void 0;
                this._attributes = void 0;
                this._indexBuffer = null;
                this._indirectBuffer = null;
                this._primitiveMode = void 0;
                this._iaInfo = void 0;
                this._attributes = attributes;
                this._vertexBuffers = vertexBuffers;
                this._indexBuffer = indexBuffer;
                this._indirectBuffer = indirectBuffer;
                this._primitiveMode = primitiveMode;
                this._iaInfo = new InputAssemblerInfo(attributes, vertexBuffers, indexBuffer, indirectBuffer);

                this._init();
              }

              get attributes() {
                return this._attributes;
              }

              get vertexBuffers() {
                return this._vertexBuffers;
              }

              get indexBuffer() {
                return this._indexBuffer;
              }

              get indirectBuffer() {
                return this._indirectBuffer;
              }

              get primitiveMode() {
                return this._primitiveMode;
              }

              get geometricInfo() {
                if (this._geometricInfo) {
                  return this._geometricInfo;
                }

                if (this.mesh === undefined) {
                  return {
                    positions: new Float32Array(),
                    indices: new Uint8Array(),
                    boundingBox: {
                      min: Vec3.ZERO,
                      max: Vec3.ZERO
                    }
                  };
                }

                if (this.subMeshIdx === undefined) {
                  return {
                    positions: new Float32Array(),
                    indices: new Uint8Array(),
                    boundingBox: {
                      min: Vec3.ZERO,
                      max: Vec3.ZERO
                    }
                  };
                }

                const {
                  mesh
                } = this;
                const index = this.subMeshIdx;
                const positions = mesh.readAttribute(index, AttributeName.ATTR_POSITION);
                const indices = mesh.readIndices(index);
                const max = new Vec3();
                const min = new Vec3();
                const pAttri = this.attributes.find(element => element.name === AttributeName.ATTR_POSITION);

                if (pAttri) {
                  const conut = FormatInfos[pAttri.format].count;

                  if (conut === 2) {
                    max.set(positions[0], positions[1], 0);
                    min.set(positions[0], positions[1], 0);
                  } else {
                    max.set(positions[0], positions[1], positions[2]);
                    min.set(positions[0], positions[1], positions[2]);
                  }

                  for (let i = 0; i < positions.length; i += conut) {
                    if (conut === 2) {
                      max.x = positions[i] > max.x ? positions[i] : max.x;
                      max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y;
                      min.x = positions[i] < min.x ? positions[i] : min.x;
                      min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y;
                    } else {
                      max.x = positions[i] > max.x ? positions[i] : max.x;
                      max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y;
                      max.z = positions[i + 2] > max.z ? positions[i + 2] : max.z;
                      min.x = positions[i] < min.x ? positions[i] : min.x;
                      min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y;
                      min.z = positions[i + 2] < min.z ? positions[i + 2] : min.z;
                    }
                  }
                }

                this._geometricInfo = {
                  positions,
                  indices,
                  boundingBox: {
                    max,
                    min
                  }
                };
                return this._geometricInfo;
              }

              get flatBuffers() {
                return this._flatBuffers;
              }

              genFlatBuffers() {
                if (this._flatBuffers.length || !this.mesh || this.subMeshIdx === undefined) {
                  return;
                }

                const {
                  mesh
                } = this;
                let idxCount = 0;
                const prim = mesh.struct.primitives[this.subMeshIdx];

                if (prim.indexView) {
                  idxCount = prim.indexView.count;
                }

                for (let i = 0; i < prim.vertexBundelIndices.length; i++) {
                  const bundleIdx = prim.vertexBundelIndices[i];
                  const vertexBundle = mesh.struct.vertexBundles[bundleIdx];
                  const vbCount = prim.indexView ? prim.indexView.count : vertexBundle.view.count;
                  const vbStride = vertexBundle.view.stride;
                  const vbSize = vbStride * vbCount;
                  const view = new Uint8Array(mesh.data.buffer, vertexBundle.view.offset, vertexBundle.view.length);
                  const sharedView = new Uint8Array(prim.indexView ? vbSize : vertexBundle.view.length);

                  if (!prim.indexView) {
                    sharedView.set(mesh.data.subarray(vertexBundle.view.offset, vertexBundle.view.offset + vertexBundle.view.length));

                    this._flatBuffers.push({
                      stride: vbStride,
                      count: vbCount,
                      buffer: sharedView
                    });

                    continue;
                  }

                  const ibView = mesh.readIndices(this.subMeshIdx);

                  for (let n = 0; n < idxCount; ++n) {
                    const idx = ibView[n];
                    const offset = n * vbStride;
                    const srcOffset = idx * vbStride;

                    for (let m = 0; m < vbStride; ++m) {
                      sharedView[offset + m] = view[srcOffset + m];
                    }
                  }

                  this._flatBuffers.push({
                    stride: vbStride,
                    count: vbCount,
                    buffer: sharedView
                  });
                }
              }

              get jointMappedBuffers() {
                if (this._jointMappedBuffers) {
                  return this._jointMappedBuffers;
                }

                const buffers = this._jointMappedBuffers = [];
                const indices = this._jointMappedBufferIndices = [];

                if (!this.mesh || this.subMeshIdx === undefined) {
                  return this._jointMappedBuffers = this.vertexBuffers;
                }

                const {
                  struct
                } = this.mesh;
                const prim = struct.primitives[this.subMeshIdx];

                if (!struct.jointMaps || prim.jointMapIndex === undefined || !struct.jointMaps[prim.jointMapIndex]) {
                  return this._jointMappedBuffers = this.vertexBuffers;
                }

                let jointFormat;
                let jointOffset;
                const {
                  device
                } = legacyCC.director.root;

                for (let i = 0; i < prim.vertexBundelIndices.length; i++) {
                  const bundle = struct.vertexBundles[prim.vertexBundelIndices[i]];
                  jointOffset = 0;
                  jointFormat = Format.UNKNOWN;

                  for (let j = 0; j < bundle.attributes.length; j++) {
                    const attr = bundle.attributes[j];

                    if (attr.name === AttributeName.ATTR_JOINTS) {
                      jointFormat = attr.format;
                      break;
                    }

                    jointOffset += FormatInfos[attr.format].size;
                  }

                  if (jointFormat) {
                    const data = new Uint8Array(this.mesh.data.buffer, bundle.view.offset, bundle.view.length);
                    const dataView = new DataView(data.slice().buffer);
                    const idxMap = struct.jointMaps[prim.jointMapIndex];
                    mapBuffer(dataView, cur => idxMap.indexOf(cur), jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    const buffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, bundle.view.length, bundle.view.stride));
                    buffer.update(dataView.buffer);
                    buffers.push(buffer);
                    indices.push(i);
                  } else {
                    buffers.push(this.vertexBuffers[prim.vertexBundelIndices[i]]);
                  }
                }

                if (this._vertexIdChannel) {
                  buffers.push(this._allocVertexIdBuffer(device));
                }

                return buffers;
              }

              get iaInfo() {
                return this._iaInfo;
              }

              destroy() {
                for (let i = 0; i < this.vertexBuffers.length; i++) {
                  this.vertexBuffers[i].destroy();
                }

                this.vertexBuffers.length = 0;

                if (this._indexBuffer) {
                  this._indexBuffer.destroy();

                  this._indexBuffer = null;
                }

                if (this._jointMappedBuffers && this._jointMappedBufferIndices) {
                  for (let i = 0; i < this._jointMappedBufferIndices.length; i++) {
                    this._jointMappedBuffers[this._jointMappedBufferIndices[i]].destroy();
                  }

                  this._jointMappedBuffers = undefined;
                  this._jointMappedBufferIndices = undefined;
                }

                if (this._indirectBuffer) {
                  this._indirectBuffer.destroy();

                  this._indirectBuffer = null;
                }
              }

              enableVertexIdChannel(device) {
                if (this._vertexIdChannel) {
                  return;
                }

                const streamIndex = this.vertexBuffers.length;
                const attributeIndex = this.attributes.length;

                const vertexIdBuffer = this._allocVertexIdBuffer(device);

                this._vertexBuffers.push(vertexIdBuffer);

                this._attributes.push(new Attribute('a_vertexId', Format.R32F, false, streamIndex));

                this._iaInfo.attributes = this._attributes;
                this._iaInfo.vertexBuffers = this._vertexBuffers;
                this._vertexIdChannel = {
                  stream: streamIndex,
                  index: attributeIndex
                };
              }

              _allocVertexIdBuffer(device) {
                const vertexCount = this.vertexBuffers.length === 0 || this.vertexBuffers[0].stride === 0 ? 0 : this.vertexBuffers[0].size / this.vertexBuffers[0].stride;
                const vertexIds = new Float32Array(vertexCount);

                for (let iVertex = 0; iVertex < vertexCount; ++iVertex) {
                  vertexIds[iVertex] = iVertex + 0.5;
                }

                const vertexIdBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vertexIds.byteLength, vertexIds.BYTES_PER_ELEMENT));
                vertexIdBuffer.update(vertexIds);
                return vertexIdBuffer;
              }

            } exports('d1', RenderingSubMesh);

            let SystemEventType;

            (function (SystemEventType) {
              SystemEventType["TOUCH_START"] = "touch-start";
              SystemEventType["TOUCH_MOVE"] = "touch-move";
              SystemEventType["TOUCH_END"] = "touch-end";
              SystemEventType["TOUCH_CANCEL"] = "touch-cancel";
              SystemEventType["MOUSE_DOWN"] = "mouse-down";
              SystemEventType["MOUSE_MOVE"] = "mouse-move";
              SystemEventType["MOUSE_UP"] = "mouse-up";
              SystemEventType["MOUSE_WHEEL"] = "mouse-wheel";
              SystemEventType["MOUSE_ENTER"] = "mouse-enter";
              SystemEventType["MOUSE_LEAVE"] = "mouse-leave";
              SystemEventType["KEY_DOWN"] = "keydown";
              SystemEventType["KEY_UP"] = "keyup";
              SystemEventType["DEVICEMOTION"] = "devicemotion";
              SystemEventType["TRANSFORM_CHANGED"] = "transform-changed";
              SystemEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
              SystemEventType["SIZE_CHANGED"] = "size-changed";
              SystemEventType["ANCHOR_CHANGED"] = "anchor-changed";
              SystemEventType["COLOR_CHANGED"] = "color-changed";
              SystemEventType["CHILD_ADDED"] = "child-added";
              SystemEventType["CHILD_REMOVED"] = "child-removed";
              SystemEventType["PARENT_CHANGED"] = "parent-changed";
              SystemEventType["NODE_DESTROYED"] = "node-destroyed";
              SystemEventType["LAYER_CHANGED"] = "layer-changed";
              SystemEventType["SIBLING_ORDER_CHANGED"] = "sibling-order-changed";
            })(SystemEventType || (SystemEventType = exports('eB', {})));

            let InputEventType;

            (function (InputEventType) {
              InputEventType["TOUCH_START"] = "touch-start";
              InputEventType["TOUCH_MOVE"] = "touch-move";
              InputEventType["TOUCH_END"] = "touch-end";
              InputEventType["TOUCH_CANCEL"] = "touch-cancel";
              InputEventType["MOUSE_DOWN"] = "mouse-down";
              InputEventType["MOUSE_MOVE"] = "mouse-move";
              InputEventType["MOUSE_UP"] = "mouse-up";
              InputEventType["MOUSE_WHEEL"] = "mouse-wheel";
              InputEventType["KEY_DOWN"] = "keydown";
              InputEventType["KEY_PRESSING"] = "key-pressing";
              InputEventType["KEY_UP"] = "keyup";
              InputEventType["DEVICEMOTION"] = "devicemotion";
            })(InputEventType || (InputEventType = exports('en', {})));

            legacyCC.SystemEventType = SystemEventType;

            const _cachedArray = new Array(16);

            let _currentHovered = null;
            let pos = new Vec2();
            const _touchEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_MOVE, NodeEventType.TOUCH_END, NodeEventType.TOUCH_CANCEL];
            const _mouseEvents = [NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_WHEEL];
            let DispatcherEventType;

            (function (DispatcherEventType) {
              DispatcherEventType[DispatcherEventType["ADD_POINTER_EVENT_PROCESSOR"] = 0] = "ADD_POINTER_EVENT_PROCESSOR";
              DispatcherEventType[DispatcherEventType["REMOVE_POINTER_EVENT_PROCESSOR"] = 1] = "REMOVE_POINTER_EVENT_PROCESSOR";
            })(DispatcherEventType || (DispatcherEventType = exports('el', {})));

            class NodeEventProcessor {
              get isEnabled() {
                return this._isEnabled;
              }

              setEnabled(value, recursive = false) {
                this._isEnabled = value;
                const node = this.node;
                const children = node.children;

                if (value) {
                  this._attachMask();
                }

                if (recursive && children.length > 0) {
                  for (let i = 0; i < children.length; ++i) {
                    const child = children[i];

                    child._eventProcessor.setEnabled(value, true);
                  }
                }
              }

              get node() {
                return this._node;
              }

              constructor(node) {
                this._isEnabled = false;
                this.claimedTouchIdList = [];
                this.maskList = null;
                this.cachedCameraPriority = 0;
                this.previousMouseIn = false;
                this.bubblingTarget = null;
                this.capturingTarget = null;
                this.shouldHandleEventMouse = false;
                this.shouldHandleEventTouch = false;
                this._node = void 0;
                this._node = node;
              }

              _searchComponentsInParent(ctor) {
                const node = this.node;

                if (ctor) {
                  let index = 0;
                  let list = [];

                  for (let curr = node; curr && Node$1.isNode(curr); curr = curr.parent, ++index) {
                    const comp = curr.getComponent(ctor);

                    if (comp) {
                      const next = {
                        index,
                        comp
                      };

                      if (list) {
                        list.push(next);
                      } else {
                        list = [next];
                      }
                    }
                  }

                  return list.length > 0 ? list : null;
                }

                return null;
              }

              _attachMask() {
                this.maskList = this._searchComponentsInParent(NodeEventProcessor._maskComp);
              }

              reattach() {
                let currentMaskList;
                this.node.walk(node => {
                  if (!currentMaskList) {
                    currentMaskList = this._searchComponentsInParent(NodeEventProcessor._maskComp);
                  }

                  node.eventProcessor.maskList = currentMaskList;
                });
              }

              destroy() {
                if (_currentHovered === this._node) {
                  _currentHovered = null;
                }

                if (this.capturingTarget) this.capturingTarget.clear();
                if (this.bubblingTarget) this.bubblingTarget.clear();
                NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
              }

              _isTouchEvent(type) {
                const index = _touchEvents.indexOf(type);

                return index !== -1;
              }

              _isMouseEvent(type) {
                const index = _mouseEvents.indexOf(type);

                return index !== -1;
              }

              _hasTouchListeners() {
                for (let i = 0; i < _touchEvents.length; ++i) {
                  const eventType = _touchEvents[i];

                  if (this.hasEventListener(eventType)) {
                    return true;
                  }
                }

                return false;
              }

              _hasMouseListeners() {
                for (let i = 0; i < _mouseEvents.length; ++i) {
                  const eventType = _mouseEvents[i];

                  if (this.hasEventListener(eventType)) {
                    return true;
                  }
                }

                return false;
              }

              _hasPointerListeners() {
                const has = this._hasTouchListeners();

                if (has) {
                  return true;
                }

                return this._hasMouseListeners();
              }

              _tryEmittingAddEvent(typeToAdd) {
                const isTouchEvent = this._isTouchEvent(typeToAdd);

                const isMouseEvent = this._isMouseEvent(typeToAdd);

                if (isTouchEvent) {
                  this.shouldHandleEventTouch = true;
                } else if (isMouseEvent) {
                  this.shouldHandleEventMouse = true;
                }

                if ((isTouchEvent || isMouseEvent) && !this._hasPointerListeners()) {
                  NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this);
                }
              }

              _newCallbacksInvoker() {
                const callbacksInvoker = new CallbacksInvoker();

                callbacksInvoker._registerOffCallback(() => {
                  if (this.shouldHandleEventTouch && !this._hasTouchListeners()) {
                    this.shouldHandleEventTouch = false;
                  }

                  if (this.shouldHandleEventMouse && !this._hasMouseListeners()) {
                    this.shouldHandleEventMouse = false;
                  }

                  if (!this._hasPointerListeners()) {
                    NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
                  }
                });

                return callbacksInvoker;
              }

              on(type, callback, target, useCapture) {
                this._tryEmittingAddEvent(type);

                useCapture = !!useCapture;
                let invoker;

                if (useCapture) {
                  var _this$capturingTarget;

                  invoker = (_this$capturingTarget = this.capturingTarget) !== null && _this$capturingTarget !== void 0 ? _this$capturingTarget : this.capturingTarget = this._newCallbacksInvoker();
                } else {
                  var _this$bubblingTarget;

                  invoker = (_this$bubblingTarget = this.bubblingTarget) !== null && _this$bubblingTarget !== void 0 ? _this$bubblingTarget : this.bubblingTarget = this._newCallbacksInvoker();
                }

                invoker.on(type, callback, target);
                return callback;
              }

              once(type, callback, target, useCapture) {
                this._tryEmittingAddEvent(type);

                useCapture = !!useCapture;
                let invoker;

                if (useCapture) {
                  var _this$capturingTarget2;

                  invoker = (_this$capturingTarget2 = this.capturingTarget) !== null && _this$capturingTarget2 !== void 0 ? _this$capturingTarget2 : this.capturingTarget = this._newCallbacksInvoker();
                } else {
                  var _this$bubblingTarget2;

                  invoker = (_this$bubblingTarget2 = this.bubblingTarget) !== null && _this$bubblingTarget2 !== void 0 ? _this$bubblingTarget2 : this.bubblingTarget = this._newCallbacksInvoker();
                }

                invoker.on(type, callback, target, true);
                return callback;
              }

              off(type, callback, target, useCapture) {
                var _invoker;

                useCapture = !!useCapture;
                let invoker;

                if (useCapture) {
                  invoker = this.capturingTarget;
                } else {
                  invoker = this.bubblingTarget;
                }

                (_invoker = invoker) === null || _invoker === void 0 ? void 0 : _invoker.off(type, callback, target);
              }

              targetOff(target) {
                var _this$capturingTarget3, _this$bubblingTarget3;

                (_this$capturingTarget3 = this.capturingTarget) === null || _this$capturingTarget3 === void 0 ? void 0 : _this$capturingTarget3.removeAll(target);
                (_this$bubblingTarget3 = this.bubblingTarget) === null || _this$bubblingTarget3 === void 0 ? void 0 : _this$bubblingTarget3.removeAll(target);

                if (this.shouldHandleEventTouch && !this._hasTouchListeners()) {
                  this.shouldHandleEventTouch = false;
                }

                if (this.shouldHandleEventMouse && !this._hasMouseListeners()) {
                  this.shouldHandleEventMouse = false;
                }

                if (!this._hasPointerListeners()) {
                  NodeEventProcessor.callbacksInvoker.emit(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this);
                }
              }

              emit(type, arg0, arg1, arg2, arg3, arg4) {
                var _this$bubblingTarget4;

                (_this$bubblingTarget4 = this.bubblingTarget) === null || _this$bubblingTarget4 === void 0 ? void 0 : _this$bubblingTarget4.emit(type, arg0, arg1, arg2, arg3, arg4);
              }

              dispatchEvent(event) {
                const owner = this.node;
                let target;
                let i = 0;
                event.target = owner;
                _cachedArray.length = 0;
                this.getCapturingTargets(event.type, _cachedArray);
                event.eventPhase = 1;

                for (i = _cachedArray.length - 1; i >= 0; --i) {
                  target = _cachedArray[i];

                  if (target.eventProcessor.capturingTarget) {
                    event.currentTarget = target;
                    target.eventProcessor.capturingTarget.emit(event.type, event, _cachedArray);

                    if (event.propagationStopped) {
                      _cachedArray.length = 0;
                      return;
                    }
                  }
                }

                _cachedArray.length = 0;
                event.eventPhase = 2;
                event.currentTarget = owner;

                if (this.capturingTarget) {
                  this.capturingTarget.emit(event.type, event);
                }

                if (!event.propagationImmediateStopped && this.bubblingTarget) {
                  this.bubblingTarget.emit(event.type, event);
                }

                if (!event.propagationStopped && event.bubbles) {
                  this.getBubblingTargets(event.type, _cachedArray);
                  event.eventPhase = 3;

                  for (i = 0; i < _cachedArray.length; ++i) {
                    target = _cachedArray[i];

                    if (target.eventProcessor.bubblingTarget) {
                      event.currentTarget = target;
                      target.eventProcessor.bubblingTarget.emit(event.type, event);

                      if (event.propagationStopped) {
                        _cachedArray.length = 0;
                        return;
                      }
                    }
                  }
                }

                _cachedArray.length = 0;
              }

              hasEventListener(type, callback, target) {
                let has = false;

                if (this.bubblingTarget) {
                  has = this.bubblingTarget.hasEventListener(type, callback, target);
                }

                if (!has && this.capturingTarget) {
                  has = this.capturingTarget.hasEventListener(type, callback, target);
                }

                return has;
              }

              getCapturingTargets(type, targets) {
                let parent = this._node.parent;

                while (parent) {
                  var _parent$eventProcesso;

                  if ((_parent$eventProcesso = parent.eventProcessor.capturingTarget) === null || _parent$eventProcesso === void 0 ? void 0 : _parent$eventProcesso.hasEventListener(type)) {
                    targets.push(parent);
                  }

                  parent = parent.parent;
                }
              }

              getBubblingTargets(type, targets) {
                let parent = this._node.parent;

                while (parent) {
                  var _parent$eventProcesso2;

                  if ((_parent$eventProcesso2 = parent.eventProcessor.bubblingTarget) === null || _parent$eventProcesso2 === void 0 ? void 0 : _parent$eventProcesso2.hasEventListener(type)) {
                    targets.push(parent);
                  }

                  parent = parent.parent;
                }
              }

              _handleEventMouse(eventMouse) {
                switch (eventMouse.type) {
                  case InputEventType.MOUSE_DOWN:
                    return this._handleMouseDown(eventMouse);

                  case InputEventType.MOUSE_MOVE:
                    return this._handleMouseMove(eventMouse);

                  case InputEventType.MOUSE_UP:
                    return this._handleMouseUp(eventMouse);

                  case InputEventType.MOUSE_WHEEL:
                    return this._handleMouseWheel(eventMouse);

                  default:
                    return false;
                }
              }

              _handleMouseDown(event) {
                const node = this._node;

                if (!node || !node._uiProps.uiTransformComp) {
                  return false;
                }

                pos = event.getUILocation();

                if (node._uiProps.uiTransformComp.isHit(pos)) {
                  event.type = NodeEventType.MOUSE_DOWN;
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  event.propagationStopped = true;
                  return true;
                }

                return false;
              }

              _handleMouseMove(event) {
                const node = this._node;

                if (!node || !node._uiProps.uiTransformComp) {
                  return false;
                }

                pos = event.getUILocation();

                const hit = node._uiProps.uiTransformComp.isHit(pos);

                if (hit) {
                  if (!this.previousMouseIn) {
                    if (_currentHovered && _currentHovered !== node) {
                      event.type = NodeEventType.MOUSE_LEAVE;

                      _currentHovered.dispatchEvent(event);

                      _currentHovered.eventProcessor.previousMouseIn = false;
                    }

                    _currentHovered = node;
                    event.type = NodeEventType.MOUSE_ENTER;
                    node.dispatchEvent(event);
                    this.previousMouseIn = true;
                  }

                  event.type = NodeEventType.MOUSE_MOVE;
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  event.propagationStopped = true;
                  return true;
                } else if (this.previousMouseIn) {
                  event.type = NodeEventType.MOUSE_LEAVE;
                  node.dispatchEvent(event);
                  this.previousMouseIn = false;
                  _currentHovered = null;
                }

                return false;
              }

              _handleMouseUp(event) {
                const node = this._node;

                if (!node || !node._uiProps.uiTransformComp) {
                  return false;
                }

                pos = event.getUILocation();

                if (node._uiProps.uiTransformComp.isHit(pos)) {
                  event.type = NodeEventType.MOUSE_UP;
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  event.propagationStopped = true;
                  return true;
                }

                return false;
              }

              _handleMouseWheel(event) {
                const node = this._node;

                if (!node || !node._uiProps.uiTransformComp) {
                  return false;
                }

                pos = event.getUILocation();

                if (node._uiProps.uiTransformComp.isHit(pos)) {
                  event.type = NodeEventType.MOUSE_WHEEL;
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  event.propagationStopped = true;
                  return true;
                }

                return false;
              }

              _handleEventTouch(eventTouch) {
                switch (eventTouch.type) {
                  case InputEventType.TOUCH_START:
                    return this._handleTouchStart(eventTouch);

                  case InputEventType.TOUCH_MOVE:
                    return this._handleTouchMove(eventTouch);

                  case InputEventType.TOUCH_END:
                    return this._handleTouchEnd(eventTouch);

                  case InputEventType.TOUCH_CANCEL:
                    return this._handleTouchCancel(eventTouch);

                  default:
                    return false;
                }
              }

              _handleTouchStart(event) {
                const node = this.node;

                if (!node || !node._uiProps.uiTransformComp) {
                  return false;
                }

                event.getUILocation(pos);

                if (node._uiProps.uiTransformComp.isHit(pos)) {
                  event.type = NodeEventType.TOUCH_START;
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  return true;
                }

                return false;
              }

              _handleTouchMove(event) {
                const node = this.node;

                if (!node || !node._uiProps.uiTransformComp) {
                  return false;
                }

                event.type = NodeEventType.TOUCH_MOVE;
                event.bubbles = true;
                node.dispatchEvent(event);
                return true;
              }

              _handleTouchEnd(event) {
                const node = this.node;

                if (!node || !node._uiProps.uiTransformComp) {
                  return;
                }

                event.getUILocation(pos);

                if (node._uiProps.uiTransformComp.isHit(pos)) {
                  event.type = NodeEventType.TOUCH_END;
                } else {
                  event.type = NodeEventType.TOUCH_CANCEL;
                }

                event.bubbles = true;
                node.dispatchEvent(event);
              }

              _handleTouchCancel(event) {
                const node = this.node;

                if (!node || !node._uiProps.uiTransformComp) {
                  return;
                }

                event.type = NodeEventType.TOUCH_CANCEL;
                event.bubbles = true;
                node.dispatchEvent(event);
              }

            } exports('ea', NodeEventProcessor);
            NodeEventProcessor._maskComp = null;
            NodeEventProcessor.callbacksInvoker = new CallbacksInvoker();
            legacyCC.NodeEventProcessor = NodeEventProcessor;

            const _v4$1 = new Vec4();

            const FogType = Enum({
              LINEAR: 0,
              EXP: 1,
              EXP_SQUARED: 2,
              LAYERED: 3
            });
            const FOG_TYPE_NONE = FogType.LAYERED + 1;
            class Fog {
              set enabled(val) {
                this._setEnable(val);

                if (!val) {
                  this._type = FOG_TYPE_NONE;

                  this._updatePipeline();
                } else {
                  this.activate();
                }
              }

              get enabled() {
                return this._enabled;
              }

              set accurate(val) {
                this._setAccurate(val);

                this._updatePipeline();
              }

              get accurate() {
                return this._accurate;
              }

              set fogColor(val) {
                this._fogColor.set(val);

                _v4$1.set(val.x, val.y, val.z, val.w);

                SRGBToLinear(this._colorArray, _v4$1);

                {
                  this._nativeObj.color = this._fogColor;
                }
              }

              get fogColor() {
                return this._fogColor;
              }

              get type() {
                return this._type;
              }

              set type(val) {
                this._setType(val);

                if (this.enabled) this._updatePipeline();
              }

              get fogDensity() {
                return this._fogDensity;
              }

              set fogDensity(val) {
                this._fogDensity = val;

                {
                  this._nativeObj.density = val;
                }
              }

              get fogStart() {
                return this._fogStart;
              }

              set fogStart(val) {
                this._fogStart = val;

                {
                  this._nativeObj.start = val;
                }
              }

              get fogEnd() {
                return this._fogEnd;
              }

              set fogEnd(val) {
                this._fogEnd = val;

                {
                  this._nativeObj.end = val;
                }
              }

              get fogAtten() {
                return this._fogAtten;
              }

              set fogAtten(val) {
                this._fogAtten = val;

                {
                  this._nativeObj.atten = val;
                }
              }

              get fogTop() {
                return this._fogTop;
              }

              set fogTop(val) {
                this._fogTop = val;

                {
                  this._nativeObj.top = val;
                }
              }

              get fogRange() {
                return this._fogRange;
              }

              set fogRange(val) {
                this._fogRange = val;

                {
                  this._nativeObj.range = val;
                }
              }

              get colorArray() {
                return this._colorArray;
              }

              get native() {
                return this._nativeObj;
              }

              constructor() {
                this._fogColor = new Color('#C8C8C8');
                this._colorArray = new Vec4(0.2, 0.2, 0.2, 1.0);
                this._enabled = false;
                this._accurate = false;
                this._type = 0;
                this._fogDensity = 0.3;
                this._fogStart = 0.5;
                this._fogEnd = 300;
                this._fogAtten = 5;
                this._fogTop = 1.5;
                this._fogRange = 1.2;

                {
                  this._nativeObj = new NativeFog();
                }
              }

              _setType(val) {
                this._type = this.enabled ? val : FOG_TYPE_NONE;

                {
                  this._nativeObj.type = this._type;
                }
              }

              _setEnable(val) {
                this._enabled = val;

                {
                  this._nativeObj.enabled = val;
                }
              }

              _setAccurate(val) {
                this._accurate = val;

                {
                  this._nativeObj.accurate = val;
                }
              }

              initialize(fogInfo) {
                this.fogColor = fogInfo.fogColor;

                this._setEnable(fogInfo.enabled);

                this._setAccurate(fogInfo.accurate);

                this._setType(fogInfo.type);

                this.fogDensity = fogInfo.fogDensity;
                this.fogStart = fogInfo.fogStart;
                this.fogEnd = fogInfo.fogEnd;
                this.fogAtten = fogInfo.fogAtten;
                this.fogTop = fogInfo.fogTop;
                this.fogRange = fogInfo.fogRange;
              }

              activate() {
                this._updatePipeline();
              }

              _updatePipeline() {
                const root = legacyCC.director.root;
                const value = this.enabled ? this.type : FOG_TYPE_NONE;
                const accurateValue = this.accurate ? 1 : 0;
                const pipeline = root.pipeline;

                if (pipeline.macros.CC_USE_FOG === value && pipeline.macros.CC_USE_ACCURATE_FOG === accurateValue) {
                  return;
                }

                pipeline.macros.CC_USE_FOG = value;
                pipeline.macros.CC_USE_ACCURATE_FOG = accurateValue;
                root.onGlobalPipelineStateChanged();
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              destroy() {
                this._destroy();
              }

            }
            legacyCC.Fog = Fog;

            var _dec$s, _dec2$c, _dec3$7, _dec4$5, _dec5$2, _dec6$2, _dec7$1, _dec8$1, _dec9$1, _dec10$1, _dec11$1, _class$s, _class2$o, _descriptor$l, _descriptor2$g, _descriptor3$c, _descriptor4$9, _descriptor5$6, _descriptor6$2, _temp$p, _dec12$1, _dec13$1, _dec14$1, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _dec26, _dec27, _class4$2, _class5$2, _descriptor7$2, _descriptor8$2, _descriptor9$1, _descriptor10$1, _descriptor11$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _temp2$2, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _dec61, _dec62, _dec63, _dec64, _dec65, _dec66, _class7$1, _class8$1, _descriptor15$1, _descriptor16$1, _descriptor17$1, _descriptor18$1, _descriptor19$1, _descriptor20$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _descriptor24$1, _class9, _temp3$1, _dec67, _dec68, _dec69, _dec70, _dec71, _dec72, _dec73, _dec74, _dec75, _dec76, _dec77, _dec78, _dec79, _dec80, _dec81, _dec82, _dec83, _dec84, _dec85, _dec86, _dec87, _dec88, _dec89, _dec90, _dec91, _dec92, _dec93, _dec94, _dec95, _dec96, _dec97, _dec98, _dec99, _dec100, _dec101, _dec102, _dec103, _dec104, _dec105, _dec106, _dec107, _dec108, _dec109, _dec110, _dec111, _dec112, _dec113, _dec114, _class10$1, _class11$1, _descriptor25$1, _descriptor26$1, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _descriptor33, _descriptor34, _descriptor35, _descriptor36, _descriptor37, _descriptor38, _descriptor39, _descriptor40, _descriptor41, _descriptor42, _temp4$1, _dec115, _dec116, _dec117, _dec118, _dec119, _dec120, _dec121, _dec122, _dec123, _dec124, _class13$1, _class14$1, _descriptor43, _descriptor44, _descriptor45, _descriptor46, _temp5$1, _dec125, _dec126, _class16$1, _class17$1, _descriptor47, _descriptor48, _descriptor49, _descriptor50, _descriptor51, _temp6$1;

            const _up = new Vec3(0, 1, 0);

            const _v3$2 = new Vec3();

            const _v4$2 = new Vec4();

            const _col = new Color();

            const _qt$1 = new Quat();

            const normalizeHDRColor = color => {
              const intensity = 1.0 / Math.max(Math.max(Math.max(color.x, color.y), color.z), 0.0001);

              if (intensity < 1.0) {
                color.x *= intensity;
                color.y *= intensity;
                color.z *= intensity;
              }
            };

            let AmbientInfo = (_dec$s = ccclass('cc.AmbientInfo'), _dec2$c = help(), _dec3$7 = formerlySerializedAs('_skyColor'), _dec4$5 = formerlySerializedAs('_skyIllum'), _dec5$2 = formerlySerializedAs('_groundAlbedo'), _dec6$2 = visible(), _dec7$1 = tooltip(), _dec8$1 = type(CCFloat), _dec9$1 = tooltip(), _dec10$1 = visible(), _dec11$1 = tooltip(), _dec$s(_class$s = _dec2$c(_class$s = (_class2$o = (_temp$p = class AmbientInfo {
              constructor() {
                _initializerDefineProperty(this, "_skyColorHDR", _descriptor$l, this);

                _initializerDefineProperty(this, "_skyIllumHDR", _descriptor2$g, this);

                _initializerDefineProperty(this, "_groundAlbedoHDR", _descriptor3$c, this);

                _initializerDefineProperty(this, "_skyColorLDR", _descriptor4$9, this);

                _initializerDefineProperty(this, "_skyIllumLDR", _descriptor5$6, this);

                _initializerDefineProperty(this, "_groundAlbedoLDR", _descriptor6$2, this);

                this._resource = null;
              }

              get skyColorHDR() {
                return this._skyColorHDR;
              }

              get groundAlbedoHDR() {
                return this._groundAlbedoHDR;
              }

              get skyIllumHDR() {
                return this._skyIllumHDR;
              }

              get skyColorLDR() {
                return this._skyColorLDR;
              }

              get groundAlbedoLDR() {
                return this._groundAlbedoLDR;
              }

              get skyIllumLDR() {
                return this._skyIllumLDR;
              }

              set skyLightingColor(val) {
                _v4$2.set(val.x, val.y, val.z, val.w);

                if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
                  this._skyColorHDR.set(_v4$2);
                } else {
                  this._skyColorLDR.set(_v4$2);
                }

                if (this._resource) {
                  this._resource.skyColor.set(_v4$2);
                }
              }

              get skyLightingColor() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                _v4$2.set(isHDR ? this._skyColorHDR : this._skyColorLDR);

                normalizeHDRColor(_v4$2);
                return _col.set(_v4$2.x * 255, _v4$2.y * 255, _v4$2.z * 255, 255);
              }

              set skyColor(val) {
                if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
                  this._skyColorHDR.set(val);
                } else {
                  this._skyColorLDR.set(val);
                }

                if (this._resource) {
                  this._resource.skyColor.set(val);
                }
              }

              set skyIllum(val) {
                if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
                  this._skyIllumHDR = val;
                } else {
                  this._skyIllumLDR = val;
                }

                if (this._resource) {
                  this._resource.skyIllum = val;
                }
              }

              get skyIllum() {
                if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
                  return this._skyIllumHDR;
                } else {
                  return this._skyIllumLDR;
                }
              }

              set groundLightingColor(val) {
                _v4$2.set(val.x, val.y, val.z, val.w);

                if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
                  this._groundAlbedoHDR.set(_v4$2);
                } else {
                  this._groundAlbedoLDR.set(_v4$2);
                }

                if (this._resource) {
                  this._resource.groundAlbedo.set(_v4$2);
                }
              }

              get groundLightingColor() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                _v4$2.set(isHDR ? this._groundAlbedoHDR : this._groundAlbedoLDR);

                normalizeHDRColor(_v4$2);
                return _col.set(_v4$2.x * 255, _v4$2.y * 255, _v4$2.z * 255, 255);
              }

              set groundAlbedo(val) {
                if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
                  this._groundAlbedoHDR.set(val);
                } else {
                  this._groundAlbedoLDR.set(val);
                }

                if (this._resource) {
                  this._resource.groundAlbedo.set(val);
                }
              }

              activate(resource) {
                this._resource = resource;

                this._resource.initialize(this);
              }

            }, _temp$p), (_descriptor$l = _applyDecoratedDescriptor(_class2$o.prototype, "_skyColorHDR", [serializable, _dec3$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec4(0.2, 0.5, 0.8, 1.0);
              }
            }), _descriptor2$g = _applyDecoratedDescriptor(_class2$o.prototype, "_skyIllumHDR", [serializable, _dec4$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Ambient.SKY_ILLUM;
              }
            }), _descriptor3$c = _applyDecoratedDescriptor(_class2$o.prototype, "_groundAlbedoHDR", [serializable, _dec5$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec4(0.2, 0.2, 0.2, 1.0);
              }
            }), _descriptor4$9 = _applyDecoratedDescriptor(_class2$o.prototype, "_skyColorLDR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec4(0.2, 0.5, 0.8, 1.0);
              }
            }), _descriptor5$6 = _applyDecoratedDescriptor(_class2$o.prototype, "_skyIllumLDR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Ambient.SKY_ILLUM;
              }
            }), _descriptor6$2 = _applyDecoratedDescriptor(_class2$o.prototype, "_groundAlbedoLDR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec4(0.2, 0.2, 0.2, 1.0);
              }
            }), _applyDecoratedDescriptor(_class2$o.prototype, "skyLightingColor", [_dec6$2, editable, _dec7$1], Object.getOwnPropertyDescriptor(_class2$o.prototype, "skyLightingColor"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "skyIllum", [editable, _dec8$1, _dec9$1], Object.getOwnPropertyDescriptor(_class2$o.prototype, "skyIllum"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "groundLightingColor", [_dec10$1, editable, _dec11$1], Object.getOwnPropertyDescriptor(_class2$o.prototype, "groundLightingColor"), _class2$o.prototype)), _class2$o)) || _class$s) || _class$s);
            legacyCC.AmbientInfo = AmbientInfo;
            let SkyboxInfo = (_dec12$1 = ccclass('cc.SkyboxInfo'), _dec13$1 = help(), _dec14$1 = type(TextureCube), _dec15$1 = formerlySerializedAs('_envmap'), _dec16$1 = type(TextureCube), _dec17$1 = type(TextureCube), _dec18$1 = type(TextureCube), _dec19$1 = visible(), _dec20$1 = tooltip(), _dec21$1 = tooltip(), _dec22$1 = tooltip(), _dec23$1 = tooltip(), _dec24$1 = type(TextureCube), _dec25$1 = tooltip(), _dec26 = visible(), _dec27 = type(TextureCube), _dec12$1(_class4$2 = _dec13$1(_class4$2 = (_class5$2 = (_temp2$2 = class SkyboxInfo {
              constructor() {
                _initializerDefineProperty(this, "_applyDiffuseMap", _descriptor7$2, this);

                _initializerDefineProperty(this, "_envmapHDR", _descriptor8$2, this);

                _initializerDefineProperty(this, "_envmapLDR", _descriptor9$1, this);

                _initializerDefineProperty(this, "_diffuseMapHDR", _descriptor10$1, this);

                _initializerDefineProperty(this, "_diffuseMapLDR", _descriptor11$1, this);

                _initializerDefineProperty(this, "_enabled", _descriptor12$1, this);

                _initializerDefineProperty(this, "_useIBL", _descriptor13$1, this);

                _initializerDefineProperty(this, "_useHDR", _descriptor14$1, this);

                this._resource = null;
              }

              set applyDiffuseMap(val) {
                this._applyDiffuseMap = val;

                if (this._resource) {
                  this._resource.useDiffuseMap = val;
                }
              }

              get applyDiffuseMap() {
                return this._applyDiffuseMap;
              }

              set enabled(val) {
                if (this._enabled === val) return;
                this._enabled = val;

                if (this._resource) {
                  this._resource.enabled = this._enabled;
                }
              }

              get enabled() {
                return this._enabled;
              }

              set useIBL(val) {
                this._useIBL = val;

                if (this._resource) {
                  this._resource.useIBL = this._useIBL;
                }
              }

              get useIBL() {
                return this._useIBL;
              }

              set useHDR(val) {
                legacyCC.director.root.pipeline.pipelineSceneData.isHDR = val;
                this._useHDR = val;

                if (this._resource) {
                  this.envmap = this._resource.envmap;
                  this.diffuseMap = this._resource.diffuseMap;

                  if (this.diffuseMap == null) {
                    this.applyDiffuseMap = false;
                  }
                }

                if (this._resource) {
                  this._resource.useHDR = this._useHDR;
                }
              }

              get useHDR() {
                legacyCC.director.root.pipeline.pipelineSceneData.isHDR = this._useHDR;
                return this._useHDR;
              }

              set envmap(val) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this._envmapHDR = val;
                } else {
                  this._envmapLDR = val;
                }

                if (!this._envmapHDR) {
                  this._diffuseMapHDR = null;
                  this._applyDiffuseMap = false;
                  this.useIBL = false;
                }

                if (this._resource) {
                  this._resource.setEnvMaps(this._envmapHDR, this._envmapLDR);

                  this._resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);

                  this._resource.useDiffuseMap = this._applyDiffuseMap;
                  this._resource.envmap = val;
                }
              }

              get envmap() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._envmapHDR;
                } else {
                  return this._envmapLDR;
                }
              }

              set diffuseMap(val) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this._diffuseMapHDR = val;
                } else {
                  this._diffuseMapLDR = val;
                }

                if (this._resource) {
                  this._resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);
                }
              }

              get diffuseMap() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._diffuseMapHDR;
                } else {
                  return this._diffuseMapLDR;
                }
              }

              activate(resource) {
                this._resource = resource;

                this._resource.initialize(this);

                this._resource.setEnvMaps(this._envmapHDR, this._envmapLDR);

                this._resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);

                this._resource.activate();
              }

            }, _temp2$2), (_descriptor7$2 = _applyDecoratedDescriptor(_class5$2.prototype, "_applyDiffuseMap", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor8$2 = _applyDecoratedDescriptor(_class5$2.prototype, "_envmapHDR", [serializable, _dec14$1, _dec15$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor9$1 = _applyDecoratedDescriptor(_class5$2.prototype, "_envmapLDR", [serializable, _dec16$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor10$1 = _applyDecoratedDescriptor(_class5$2.prototype, "_diffuseMapHDR", [serializable, _dec17$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor11$1 = _applyDecoratedDescriptor(_class5$2.prototype, "_diffuseMapLDR", [serializable, _dec18$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor12$1 = _applyDecoratedDescriptor(_class5$2.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor13$1 = _applyDecoratedDescriptor(_class5$2.prototype, "_useIBL", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor14$1 = _applyDecoratedDescriptor(_class5$2.prototype, "_useHDR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _applyDecoratedDescriptor(_class5$2.prototype, "applyDiffuseMap", [_dec19$1, editable, _dec20$1], Object.getOwnPropertyDescriptor(_class5$2.prototype, "applyDiffuseMap"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "enabled", [editable, _dec21$1], Object.getOwnPropertyDescriptor(_class5$2.prototype, "enabled"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "useIBL", [editable, _dec22$1], Object.getOwnPropertyDescriptor(_class5$2.prototype, "useIBL"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "useHDR", [editable, _dec23$1], Object.getOwnPropertyDescriptor(_class5$2.prototype, "useHDR"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "envmap", [editable, _dec24$1, _dec25$1], Object.getOwnPropertyDescriptor(_class5$2.prototype, "envmap"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "diffuseMap", [_dec26, editable, readOnly, _dec27], Object.getOwnPropertyDescriptor(_class5$2.prototype, "diffuseMap"), _class5$2.prototype)), _class5$2)) || _class4$2) || _class4$2);
            legacyCC.SkyboxInfo = SkyboxInfo;
            let FogInfo = (_dec28 = ccclass('cc.FogInfo'), _dec29 = help(), _dec30 = tooltip(), _dec31 = tooltip(), _dec32 = tooltip(), _dec33 = type(FogType), _dec34 = tooltip(), _dec35 = visible(), _dec36 = type(CCFloat), _dec37 = range(), _dec38 = rangeStep(), _dec39 = displayOrder(), _dec40 = tooltip(), _dec41 = visible(), _dec42 = type(CCFloat), _dec43 = rangeStep(), _dec44 = displayOrder(), _dec45 = tooltip(), _dec46 = visible(), _dec47 = type(CCFloat), _dec48 = rangeStep(), _dec49 = displayOrder(), _dec50 = tooltip(), _dec51 = visible(), _dec52 = type(CCFloat), _dec53 = rangeMin(), _dec54 = rangeStep(), _dec55 = displayOrder(), _dec56 = tooltip(), _dec57 = visible(), _dec58 = type(CCFloat), _dec59 = rangeStep(), _dec60 = displayOrder(), _dec61 = tooltip(), _dec62 = visible(), _dec63 = type(CCFloat), _dec64 = rangeStep(), _dec65 = displayOrder(), _dec66 = tooltip(), _dec28(_class7$1 = _dec29(_class7$1 = (_class8$1 = (_temp3$1 = _class9 = class FogInfo {
              constructor() {
                _initializerDefineProperty(this, "_type", _descriptor15$1, this);

                _initializerDefineProperty(this, "_fogColor", _descriptor16$1, this);

                _initializerDefineProperty(this, "_enabled", _descriptor17$1, this);

                _initializerDefineProperty(this, "_fogDensity", _descriptor18$1, this);

                _initializerDefineProperty(this, "_fogStart", _descriptor19$1, this);

                _initializerDefineProperty(this, "_fogEnd", _descriptor20$1, this);

                _initializerDefineProperty(this, "_fogAtten", _descriptor21$1, this);

                _initializerDefineProperty(this, "_fogTop", _descriptor22$1, this);

                _initializerDefineProperty(this, "_fogRange", _descriptor23$1, this);

                _initializerDefineProperty(this, "_accurate", _descriptor24$1, this);

                this._resource = null;
              }

              set enabled(val) {
                if (this._enabled === val) return;
                this._enabled = val;

                if (this._resource) {
                  this._resource.enabled = val;

                  if (val) {
                    this._resource.type = this._type;
                  }
                }
              }

              get enabled() {
                return this._enabled;
              }

              set accurate(val) {
                if (this._accurate === val) return;
                this._accurate = val;

                if (this._resource) {
                  this._resource.accurate = val;

                  if (val) {
                    this._resource.type = this._type;
                  }
                }
              }

              get accurate() {
                return this._accurate;
              }

              set fogColor(val) {
                this._fogColor.set(val);

                if (this._resource) {
                  this._resource.fogColor = this._fogColor;
                }
              }

              get fogColor() {
                return this._fogColor;
              }

              get type() {
                return this._type;
              }

              set type(val) {
                this._type = val;

                if (this._resource) {
                  this._resource.type = val;
                }
              }

              get fogDensity() {
                return this._fogDensity;
              }

              set fogDensity(val) {
                this._fogDensity = val;

                if (this._resource) {
                  this._resource.fogDensity = val;
                }
              }

              get fogStart() {
                return this._fogStart;
              }

              set fogStart(val) {
                this._fogStart = val;

                if (this._resource) {
                  this._resource.fogStart = val;
                }
              }

              get fogEnd() {
                return this._fogEnd;
              }

              set fogEnd(val) {
                this._fogEnd = val;

                if (this._resource) {
                  this._resource.fogEnd = val;
                }
              }

              get fogAtten() {
                return this._fogAtten;
              }

              set fogAtten(val) {
                this._fogAtten = val;

                if (this._resource) {
                  this._resource.fogAtten = val;
                }
              }

              get fogTop() {
                return this._fogTop;
              }

              set fogTop(val) {
                this._fogTop = val;

                if (this._resource) {
                  this._resource.fogTop = val;
                }
              }

              get fogRange() {
                return this._fogRange;
              }

              set fogRange(val) {
                this._fogRange = val;

                if (this._resource) {
                  this._resource.fogRange = val;
                }
              }

              activate(resource) {
                this._resource = resource;

                this._resource.initialize(this);

                this._resource.activate();
              }

            }, _class9.FogType = FogType, _temp3$1), (_descriptor15$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return FogType.LINEAR;
              }
            }), _descriptor16$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color('#C8C8C8');
              }
            }), _descriptor17$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor18$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogDensity", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.3;
              }
            }), _descriptor19$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogStart", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            }), _descriptor20$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogEnd", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 300;
              }
            }), _descriptor21$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogAtten", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor22$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogTop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.5;
              }
            }), _descriptor23$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogRange", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.2;
              }
            }), _descriptor24$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_accurate", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class8$1.prototype, "enabled", [editable, _dec30], Object.getOwnPropertyDescriptor(_class8$1.prototype, "enabled"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "accurate", [editable, _dec31], Object.getOwnPropertyDescriptor(_class8$1.prototype, "accurate"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogColor", [editable, _dec32], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogColor"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "type", [editable, _dec33, _dec34], Object.getOwnPropertyDescriptor(_class8$1.prototype, "type"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogDensity", [_dec35, _dec36, _dec37, _dec38, slide, _dec39, _dec40], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogDensity"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogStart", [_dec41, _dec42, _dec43, _dec44, _dec45], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogStart"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogEnd", [_dec46, _dec47, _dec48, _dec49, _dec50], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogEnd"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogAtten", [_dec51, _dec52, _dec53, _dec54, _dec55, _dec56], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogAtten"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogTop", [_dec57, _dec58, _dec59, _dec60, _dec61], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogTop"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogRange", [_dec62, _dec63, _dec64, _dec65, _dec66], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogRange"), _class8$1.prototype)), _class8$1)) || _class7$1) || _class7$1);
            let ShadowsInfo = (_dec67 = ccclass('cc.ShadowsInfo'), _dec68 = help(), _dec69 = tooltip(), _dec70 = type(ShadowType), _dec71 = visible(), _dec72 = visible(), _dec73 = tooltip(), _dec74 = type(CCFloat), _dec75 = tooltip(), _dec76 = visible(), _dec77 = range(), _dec78 = type(CCFloat), _dec79 = tooltip(), _dec80 = visible(), _dec81 = type(PCFType), _dec82 = tooltip(), _dec83 = visible(), _dec84 = type(CCInteger), _dec85 = visible(), _dec86 = type(CCFloat), _dec87 = tooltip(), _dec88 = visible(), _dec89 = type(CCFloat), _dec90 = tooltip(), _dec91 = visible(), _dec92 = type(ShadowSize), _dec93 = tooltip(), _dec94 = visible(), _dec95 = type(CCBoolean), _dec96 = tooltip(), _dec97 = visible(), _dec98 = type(CCFloat), _dec99 = tooltip(), _dec100 = visible(), _dec101 = type(CCFloat), _dec102 = tooltip(), _dec103 = visible(), _dec104 = range(), _dec105 = type(CCFloat), _dec106 = tooltip(), _dec107 = visible(), _dec108 = range(), _dec109 = type(CCFloat), _dec110 = tooltip(), _dec111 = visible(), _dec112 = type(CCFloat), _dec113 = tooltip(), _dec114 = visible(), _dec67(_class10$1 = _dec68(_class10$1 = (_class11$1 = (_temp4$1 = class ShadowsInfo {
              constructor() {
                _initializerDefineProperty(this, "_type", _descriptor25$1, this);

                _initializerDefineProperty(this, "_enabled", _descriptor26$1, this);

                _initializerDefineProperty(this, "_normal", _descriptor27, this);

                _initializerDefineProperty(this, "_distance", _descriptor28, this);

                _initializerDefineProperty(this, "_shadowColor", _descriptor29, this);

                _initializerDefineProperty(this, "_firstSetCSM", _descriptor30, this);

                _initializerDefineProperty(this, "_fixedArea", _descriptor31, this);

                _initializerDefineProperty(this, "_pcf", _descriptor32, this);

                _initializerDefineProperty(this, "_bias", _descriptor33, this);

                _initializerDefineProperty(this, "_normalBias", _descriptor34, this);

                _initializerDefineProperty(this, "_near", _descriptor35, this);

                _initializerDefineProperty(this, "_far", _descriptor36, this);

                _initializerDefineProperty(this, "_shadowDistance", _descriptor37, this);

                _initializerDefineProperty(this, "_invisibleOcclusionRange", _descriptor38, this);

                _initializerDefineProperty(this, "_orthoSize", _descriptor39, this);

                _initializerDefineProperty(this, "_maxReceived", _descriptor40, this);

                _initializerDefineProperty(this, "_size", _descriptor41, this);

                _initializerDefineProperty(this, "_saturation", _descriptor42, this);

                this._resource = null;
              }

              set enabled(val) {
                if (this._enabled === val) return;
                this._enabled = val;

                if (this._resource) {
                  this._resource.enabled = val;

                  if (val) {
                    this._resource.type = this._type;
                  }
                }
              }

              get enabled() {

                return this._enabled;
              }

              set type(val) {
                this._type = val;

                if (this._resource) {
                  this._resource.type = val;
                }
              }

              get type() {
                return this._type;
              }

              set shadowColor(val) {
                this._shadowColor.set(val);

                if (this._resource) {
                  this._resource.shadowColor = val;
                }
              }

              get shadowColor() {
                return this._shadowColor;
              }

              set normal(val) {
                Vec3.copy(this._normal, val);

                if (this._resource) {
                  this._resource.normal = val;
                }
              }

              get normal() {
                return this._normal;
              }

              set distance(val) {
                this._distance = val;

                if (this._resource) {
                  this._resource.distance = val;
                }
              }

              get distance() {
                return this._distance;
              }

              set saturation(val) {
                if (val > 1.0) {
                  this._saturation = val / val;

                  if (this._resource) {
                    this._resource.saturation = val / val;
                  }
                } else {
                  this._saturation = val;

                  if (this._resource) {
                    this._resource.saturation = val;
                  }
                }
              }

              get saturation() {
                return this._saturation;
              }

              set pcf(val) {
                this._pcf = val;

                if (this._resource) {
                  this._resource.pcf = val;
                }
              }

              get pcf() {
                return this._pcf;
              }

              set maxReceived(val) {
                this._maxReceived = val;

                if (this._resource) {
                  this._resource.maxReceived = val;
                }
              }

              get maxReceived() {
                return this._maxReceived;
              }

              set bias(val) {
                this._bias = val;

                if (this._resource) {
                  this._resource.bias = val;
                }
              }

              get bias() {
                return this._bias;
              }

              set normalBias(val) {
                this._normalBias = val;

                if (this._resource) {
                  this._resource.normalBias = val;
                }
              }

              get normalBias() {
                return this._normalBias;
              }

              set shadowMapSize(value) {
                this._size.set(value, value);

                if (this._resource) {
                  this._resource.size.set(value, value);

                  this._resource.shadowMapDirty = true;
                }
              }

              get shadowMapSize() {
                return this._size.x;
              }

              get size() {
                return this._size;
              }

              set fixedArea(val) {
                this._fixedArea = val;

                if (this._resource) {
                  this._resource.fixedArea = val;
                }
              }

              get fixedArea() {
                return this._fixedArea;
              }

              set near(val) {
                this._near = val;

                if (this._resource) {
                  this._resource.near = val;
                }
              }

              get near() {
                return this._near;
              }

              set far(val) {
                this._far = Math.min(val, Shadows.MAX_FAR);

                if (this._resource) {
                  this._resource.far = this._far;
                }
              }

              get far() {
                return this._far;
              }

              set invisibleOcclusionRange(val) {
                this._invisibleOcclusionRange = Math.min(val, Shadows.MAX_FAR);

                if (this._resource) {
                  this._resource.invisibleOcclusionRange = this._invisibleOcclusionRange;
                }
              }

              get invisibleOcclusionRange() {
                return this._invisibleOcclusionRange;
              }

              set shadowDistance(val) {
                this._shadowDistance = Math.min(val, Shadows.MAX_FAR);

                if (this._resource) {
                  this._resource.shadowDistance = this._shadowDistance;
                }
              }

              get shadowDistance() {
                return this._shadowDistance;
              }

              set orthoSize(val) {
                this._orthoSize = val;

                if (this._resource) {
                  this._resource.orthoSize = val;
                }
              }

              get orthoSize() {
                return this._orthoSize;
              }

              setPlaneFromNode(node) {
                node.getWorldRotation(_qt$1);
                this.normal = Vec3.transformQuat(_v3$2, _up, _qt$1);
                node.getWorldPosition(_v3$2);
                this.distance = Vec3.dot(this._normal, _v3$2);
              }

              activate(resource) {
                this.pcf = Math.min(this._pcf, PCFType.SOFT_2X);
                this._resource = resource;

                this._resource.initialize(this);

                this._resource.activate();
              }

            }, _temp4$1), (_descriptor25$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ShadowType.Planar;
              }
            }), _descriptor26$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor27 = _applyDecoratedDescriptor(_class11$1.prototype, "_normal", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(0, 1, 0);
              }
            }), _descriptor28 = _applyDecoratedDescriptor(_class11$1.prototype, "_distance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor29 = _applyDecoratedDescriptor(_class11$1.prototype, "_shadowColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color(0, 0, 0, 76);
              }
            }), _descriptor30 = _applyDecoratedDescriptor(_class11$1.prototype, "_firstSetCSM", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor31 = _applyDecoratedDescriptor(_class11$1.prototype, "_fixedArea", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor32 = _applyDecoratedDescriptor(_class11$1.prototype, "_pcf", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PCFType.HARD;
              }
            }), _descriptor33 = _applyDecoratedDescriptor(_class11$1.prototype, "_bias", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.00001;
              }
            }), _descriptor34 = _applyDecoratedDescriptor(_class11$1.prototype, "_normalBias", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor35 = _applyDecoratedDescriptor(_class11$1.prototype, "_near", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            }), _descriptor36 = _applyDecoratedDescriptor(_class11$1.prototype, "_far", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 10.0;
              }
            }), _descriptor37 = _applyDecoratedDescriptor(_class11$1.prototype, "_shadowDistance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 100;
              }
            }), _descriptor38 = _applyDecoratedDescriptor(_class11$1.prototype, "_invisibleOcclusionRange", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 200;
              }
            }), _descriptor39 = _applyDecoratedDescriptor(_class11$1.prototype, "_orthoSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor40 = _applyDecoratedDescriptor(_class11$1.prototype, "_maxReceived", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 4;
              }
            }), _descriptor41 = _applyDecoratedDescriptor(_class11$1.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(512, 512);
              }
            }), _descriptor42 = _applyDecoratedDescriptor(_class11$1.prototype, "_saturation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.75;
              }
            }), _applyDecoratedDescriptor(_class11$1.prototype, "enabled", [editable, _dec69], Object.getOwnPropertyDescriptor(_class11$1.prototype, "enabled"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "type", [editable, _dec70], Object.getOwnPropertyDescriptor(_class11$1.prototype, "type"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowColor", [_dec71], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowColor"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "normal", [_dec72, _dec73], Object.getOwnPropertyDescriptor(_class11$1.prototype, "normal"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "distance", [_dec74, _dec75, _dec76], Object.getOwnPropertyDescriptor(_class11$1.prototype, "distance"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "saturation", [editable, _dec77, slide, _dec78, _dec79, _dec80], Object.getOwnPropertyDescriptor(_class11$1.prototype, "saturation"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "pcf", [_dec81, _dec82, _dec83], Object.getOwnPropertyDescriptor(_class11$1.prototype, "pcf"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "maxReceived", [_dec84, _dec85], Object.getOwnPropertyDescriptor(_class11$1.prototype, "maxReceived"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "bias", [_dec86, _dec87, _dec88], Object.getOwnPropertyDescriptor(_class11$1.prototype, "bias"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "normalBias", [_dec89, _dec90, _dec91], Object.getOwnPropertyDescriptor(_class11$1.prototype, "normalBias"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowMapSize", [_dec92, _dec93, _dec94], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowMapSize"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "fixedArea", [_dec95, _dec96, _dec97], Object.getOwnPropertyDescriptor(_class11$1.prototype, "fixedArea"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "near", [_dec98, _dec99, _dec100], Object.getOwnPropertyDescriptor(_class11$1.prototype, "near"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "far", [_dec101, _dec102, _dec103], Object.getOwnPropertyDescriptor(_class11$1.prototype, "far"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "invisibleOcclusionRange", [editable, _dec104, slide, _dec105, _dec106, _dec107], Object.getOwnPropertyDescriptor(_class11$1.prototype, "invisibleOcclusionRange"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowDistance", [editable, _dec108, slide, _dec109, _dec110, _dec111], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowDistance"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "orthoSize", [_dec112, _dec113, _dec114], Object.getOwnPropertyDescriptor(_class11$1.prototype, "orthoSize"), _class11$1.prototype)), _class11$1)) || _class10$1) || _class10$1);
            legacyCC.ShadowsInfo = ShadowsInfo;
            const DEFAULT_WORLD_MIN_POS = new Vec3(-1024.0, -1024.0, -1024.0);
            const DEFAULT_WORLD_MAX_POS = new Vec3(1024.0, 1024.0, 1024.0);
            const DEFAULT_OCTREE_DEPTH = 8;
            let OctreeInfo = (_dec115 = ccclass('cc.OctreeInfo'), _dec116 = help(), _dec117 = tooltip(), _dec118 = tooltip(), _dec119 = displayName(), _dec120 = tooltip(), _dec121 = displayName(), _dec122 = range(), _dec123 = type(CCInteger), _dec124 = tooltip(), _dec115(_class13$1 = _dec116(_class13$1 = (_class14$1 = (_temp5$1 = class OctreeInfo {
              constructor() {
                _initializerDefineProperty(this, "_enabled", _descriptor43, this);

                _initializerDefineProperty(this, "_minPos", _descriptor44, this);

                _initializerDefineProperty(this, "_maxPos", _descriptor45, this);

                _initializerDefineProperty(this, "_depth", _descriptor46, this);

                this._resource = null;
              }

              set enabled(val) {
                if (this._enabled === val) return;
                this._enabled = val;

                if (this._resource) {
                  this._resource.enabled = val;
                }
              }

              get enabled() {
                return this._enabled;
              }

              set minPos(val) {
                this._minPos = val;

                if (this._resource) {
                  this._resource.minPos = val;
                }
              }

              get minPos() {
                return this._minPos;
              }

              set maxPos(val) {
                this._maxPos = val;

                if (this._resource) {
                  this._resource.maxPos = val;
                }
              }

              get maxPos() {
                return this._maxPos;
              }

              set depth(val) {
                this._depth = val;

                if (this._resource) {
                  this._resource.depth = val;
                }
              }

              get depth() {
                return this._depth;
              }

              activate(resource) {
                this._resource = resource;

                this._resource.initialize(this);
              }

            }, _temp5$1), (_descriptor43 = _applyDecoratedDescriptor(_class14$1.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor44 = _applyDecoratedDescriptor(_class14$1.prototype, "_minPos", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(DEFAULT_WORLD_MIN_POS);
              }
            }), _descriptor45 = _applyDecoratedDescriptor(_class14$1.prototype, "_maxPos", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(DEFAULT_WORLD_MAX_POS);
              }
            }), _descriptor46 = _applyDecoratedDescriptor(_class14$1.prototype, "_depth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return DEFAULT_OCTREE_DEPTH;
              }
            }), _applyDecoratedDescriptor(_class14$1.prototype, "enabled", [editable, _dec117], Object.getOwnPropertyDescriptor(_class14$1.prototype, "enabled"), _class14$1.prototype), _applyDecoratedDescriptor(_class14$1.prototype, "minPos", [editable, _dec118, _dec119], Object.getOwnPropertyDescriptor(_class14$1.prototype, "minPos"), _class14$1.prototype), _applyDecoratedDescriptor(_class14$1.prototype, "maxPos", [editable, _dec120, _dec121], Object.getOwnPropertyDescriptor(_class14$1.prototype, "maxPos"), _class14$1.prototype), _applyDecoratedDescriptor(_class14$1.prototype, "depth", [editable, _dec122, _dec123, _dec124], Object.getOwnPropertyDescriptor(_class14$1.prototype, "depth"), _class14$1.prototype)), _class14$1)) || _class13$1) || _class13$1);
            let SceneGlobals = (_dec125 = ccclass('cc.SceneGlobals'), _dec126 = type(SkyboxInfo), _dec125(_class16$1 = (_class17$1 = (_temp6$1 = class SceneGlobals {
              constructor() {
                _initializerDefineProperty(this, "ambient", _descriptor47, this);

                _initializerDefineProperty(this, "shadows", _descriptor48, this);

                _initializerDefineProperty(this, "_skybox", _descriptor49, this);

                _initializerDefineProperty(this, "fog", _descriptor50, this);

                _initializerDefineProperty(this, "octree", _descriptor51, this);
              }

              get skybox() {
                return this._skybox;
              }

              set skybox(value) {
                this._skybox = value;
              }

              activate() {
                const sceneData = legacyCC.director.root.pipeline.pipelineSceneData;
                this.skybox.activate(sceneData.skybox);
                this.ambient.activate(sceneData.ambient);
                this.shadows.activate(sceneData.shadows);
                this.fog.activate(sceneData.fog);
                this.octree.activate(sceneData.octree);
              }

            }, _temp6$1), (_descriptor47 = _applyDecoratedDescriptor(_class17$1.prototype, "ambient", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new AmbientInfo();
              }
            }), _descriptor48 = _applyDecoratedDescriptor(_class17$1.prototype, "shadows", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new ShadowsInfo();
              }
            }), _descriptor49 = _applyDecoratedDescriptor(_class17$1.prototype, "_skybox", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new SkyboxInfo();
              }
            }), _descriptor50 = _applyDecoratedDescriptor(_class17$1.prototype, "fog", [editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new FogInfo();
              }
            }), _applyDecoratedDescriptor(_class17$1.prototype, "skybox", [editable, _dec126], Object.getOwnPropertyDescriptor(_class17$1.prototype, "skybox"), _class17$1.prototype), _descriptor51 = _applyDecoratedDescriptor(_class17$1.prototype, "octree", [editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new OctreeInfo();
              }
            })), _class17$1)) || _class16$1);
            legacyCC.SceneGlobals = SceneGlobals;

            class Event {
              constructor(type, bubbles) {
                this.type = void 0;
                this.bubbles = void 0;
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = 0;
                this.propagationStopped = false;
                this.propagationImmediateStopped = false;
                this.type = type;
                this.bubbles = !!bubbles;
              }

              unuse() {
                this.type = Event.NO_TYPE;
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = Event.NONE;
                this.propagationStopped = false;
                this.propagationImmediateStopped = false;
              }

              reuse(type, bubbles) {
                this.type = type;
                this.bubbles = bubbles || false;
              }

              isStopped() {
                return this.propagationStopped || this.propagationImmediateStopped;
              }

              getCurrentTarget() {
                return this.currentTarget;
              }

              getType() {
                return this.type;
              }

            } exports('eC', Event);
            Event.NO_TYPE = 'no_type';
            Event.TOUCH = 'touch';
            Event.MOUSE = 'mouse';
            Event.KEYBOARD = 'keyboard';
            Event.ACCELERATION = 'acceleration';
            Event.NONE = 0;
            Event.CAPTURING_PHASE = 1;
            Event.AT_TARGET = 2;
            Event.BUBBLING_PHASE = 3;
            legacyCC.Event = Event;

            class EventAcceleration extends Event {
              constructor(acc, bubbles) {
                super(SystemEventType.DEVICEMOTION, bubbles);
                this.acc = void 0;
                this.acc = acc;
              }

            } exports('gH', EventAcceleration);
            Event.EventAcceleration = EventAcceleration;

            class EventKeyboard extends Event {
              get isPressed() {
                return this._isPressed;
              }

              constructor(keyCode, eventType, bubbles) {
                if (typeof eventType === 'boolean') {
                  const isPressed = eventType;
                  eventType = isPressed ? SystemEventType.KEY_DOWN : SystemEventType.KEY_UP;
                }

                super(eventType, bubbles);
                this.keyCode = void 0;
                this.rawEvent = void 0;
                this._isPressed = void 0;
                this._isPressed = eventType !== SystemEventType.KEY_UP;

                if (typeof keyCode === 'number') {
                  this.keyCode = keyCode;
                } else {
                  this.keyCode = keyCode.keyCode;
                  this.rawEvent = keyCode;
                }
              }

            } exports('gI', EventKeyboard);
            Event.EventKeyboard = EventKeyboard;

            class EventMouse extends Event {
              get eventType() {
                return this._eventType;
              }

              constructor(eventType, bubbles, prevLoc) {
                super(eventType, bubbles);
                this.movementX = 0;
                this.movementY = 0;
                this.preventSwallow = false;
                this._eventType = void 0;
                this._button = EventMouse.BUTTON_MISSING;
                this._x = 0;
                this._y = 0;
                this._prevX = 0;
                this._prevY = 0;
                this._scrollX = 0;
                this._scrollY = 0;
                this._eventType = eventType;

                if (prevLoc) {
                  this._prevX = prevLoc.x;
                  this._prevY = prevLoc.y;
                }
              }

              setScrollData(scrollX, scrollY) {
                this._scrollX = scrollX;
                this._scrollY = scrollY;
              }

              getScrollX() {
                return this._scrollX;
              }

              getScrollY() {
                return this._scrollY;
              }

              setLocation(x, y) {
                this._x = x;
                this._y = y;
              }

              getLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._x, this._y);
                return out;
              }

              getLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._x, legacyCC.view._designResolutionSize.height - this._y);
                return out;
              }

              getUILocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._x, this._y);

                legacyCC.view._convertToUISpace(out);

                return out;
              }

              getPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._prevX, this._prevY);
                return out;
              }

              getUIPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._prevX, this._prevY);

                legacyCC.view._convertToUISpace(out);

                return out;
              }

              getDelta(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, this._x - this._prevX, this._y - this._prevY);
                return out;
              }

              getDeltaX() {
                return this._x - this._prevX;
              }

              getDeltaY() {
                return this._y - this._prevY;
              }

              getUIDelta(out) {
                if (!out) {
                  out = new Vec2();
                }

                Vec2.set(out, (this._x - this._prevX) / legacyCC.view.getScaleX(), (this._y - this._prevY) / legacyCC.view.getScaleY());
                return out;
              }

              getUIDeltaX() {
                return (this._x - this._prevX) / legacyCC.view.getScaleX();
              }

              getUIDeltaY() {
                return (this._y - this._prevY) / legacyCC.view.getScaleY();
              }

              setButton(button) {
                this._button = button;
              }

              getButton() {
                return this._button;
              }

              getLocationX() {
                return this._x;
              }

              getLocationY() {
                return this._y;
              }

              getUILocationX() {
                const viewport = legacyCC.view.getViewportRect();
                return (this._x - viewport.x) / legacyCC.view.getScaleX();
              }

              getUILocationY() {
                const viewport = legacyCC.view.getViewportRect();
                return (this._y - viewport.y) / legacyCC.view.getScaleY();
              }

            } exports('gJ', EventMouse);
            EventMouse.BUTTON_MISSING = -1;
            EventMouse.BUTTON_LEFT = 0;
            EventMouse.BUTTON_RIGHT = 2;
            EventMouse.BUTTON_MIDDLE = 1;
            EventMouse.BUTTON_4 = 3;
            EventMouse.BUTTON_5 = 4;
            EventMouse.BUTTON_6 = 5;
            EventMouse.BUTTON_7 = 6;
            EventMouse.BUTTON_8 = 7;
            Event.EventMouse = EventMouse;

            const _vec2 = new Vec2();

            class EventTouch extends Event {
              constructor(changedTouches, bubbles, eventType, touches = []) {
                super(eventType, bubbles);
                this.touch = null;
                this.simulate = false;
                this.preventSwallow = false;
                this._eventCode = void 0;
                this._touches = void 0;
                this._allTouches = void 0;
                this._eventCode = eventType;
                this._touches = changedTouches || [];
                this._allTouches = touches;
              }

              getEventCode() {
                return this._eventCode;
              }

              getTouches() {
                return this._touches;
              }

              getAllTouches() {
                return this._allTouches;
              }

              setLocation(x, y) {
                if (this.touch) {
                  this.touch.setTouchInfo(this.touch.getID(), x, y);
                }
              }

              getLocation(out) {
                return this.touch ? this.touch.getLocation(out) : new Vec2();
              }

              getUILocation(out) {
                return this.touch ? this.touch.getUILocation(out) : new Vec2();
              }

              getLocationInView(out) {
                return this.touch ? this.touch.getLocationInView(out) : new Vec2();
              }

              getPreviousLocation(out) {
                return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
              }

              getStartLocation(out) {
                return this.touch ? this.touch.getStartLocation(out) : new Vec2();
              }

              getUIStartLocation(out) {
                return this.touch ? this.touch.getUIStartLocation(out) : new Vec2();
              }

              getID() {
                return this.touch ? this.touch.getID() : null;
              }

              getDelta(out) {
                return this.touch ? this.touch.getDelta(out) : new Vec2();
              }

              getUIDelta(out) {
                return this.touch ? this.touch.getUIDelta(out) : new Vec2();
              }

              getDeltaX() {
                return this.touch ? this.touch.getDelta(_vec2).x : 0;
              }

              getDeltaY() {
                return this.touch ? this.touch.getDelta(_vec2).y : 0;
              }

              getLocationX() {
                return this.touch ? this.touch.getLocationX() : 0;
              }

              getLocationY() {
                return this.touch ? this.touch.getLocationY() : 0;
              }

            } exports('eA', EventTouch);
            EventTouch.MAX_TOUCHES = 5;
            Event.EventTouch = EventTouch;

            class Acceleration {
              constructor(x = 0, y = 0, z = 0, timestamp = 0) {
                this.x = void 0;
                this.y = void 0;
                this.z = void 0;
                this.timestamp = void 0;
                this.x = x;
                this.y = y;
                this.z = z;
                this.timestamp = timestamp;
              }

            } exports('gK', Acceleration);

            let KeyCode;

            (function (KeyCode) {
              KeyCode[KeyCode["NONE"] = 0] = "NONE";
              KeyCode[KeyCode["BACKSPACE"] = 8] = "BACKSPACE";
              KeyCode[KeyCode["TAB"] = 9] = "TAB";
              KeyCode[KeyCode["ENTER"] = 13] = "ENTER";
              KeyCode[KeyCode["SHIFT_LEFT"] = 16] = "SHIFT_LEFT";
              KeyCode[KeyCode["CTRL_LEFT"] = 17] = "CTRL_LEFT";
              KeyCode[KeyCode["ALT_LEFT"] = 18] = "ALT_LEFT";
              KeyCode[KeyCode["PAUSE"] = 19] = "PAUSE";
              KeyCode[KeyCode["CAPS_LOCK"] = 20] = "CAPS_LOCK";
              KeyCode[KeyCode["ESCAPE"] = 27] = "ESCAPE";
              KeyCode[KeyCode["SPACE"] = 32] = "SPACE";
              KeyCode[KeyCode["PAGE_UP"] = 33] = "PAGE_UP";
              KeyCode[KeyCode["PAGE_DOWN"] = 34] = "PAGE_DOWN";
              KeyCode[KeyCode["END"] = 35] = "END";
              KeyCode[KeyCode["HOME"] = 36] = "HOME";
              KeyCode[KeyCode["ARROW_LEFT"] = 37] = "ARROW_LEFT";
              KeyCode[KeyCode["ARROW_UP"] = 38] = "ARROW_UP";
              KeyCode[KeyCode["ARROW_RIGHT"] = 39] = "ARROW_RIGHT";
              KeyCode[KeyCode["ARROW_DOWN"] = 40] = "ARROW_DOWN";
              KeyCode[KeyCode["INSERT"] = 45] = "INSERT";
              KeyCode[KeyCode["DELETE"] = 46] = "DELETE";
              KeyCode[KeyCode["DIGIT_0"] = 48] = "DIGIT_0";
              KeyCode[KeyCode["DIGIT_1"] = 49] = "DIGIT_1";
              KeyCode[KeyCode["DIGIT_2"] = 50] = "DIGIT_2";
              KeyCode[KeyCode["DIGIT_3"] = 51] = "DIGIT_3";
              KeyCode[KeyCode["DIGIT_4"] = 52] = "DIGIT_4";
              KeyCode[KeyCode["DIGIT_5"] = 53] = "DIGIT_5";
              KeyCode[KeyCode["DIGIT_6"] = 54] = "DIGIT_6";
              KeyCode[KeyCode["DIGIT_7"] = 55] = "DIGIT_7";
              KeyCode[KeyCode["DIGIT_8"] = 56] = "DIGIT_8";
              KeyCode[KeyCode["DIGIT_9"] = 57] = "DIGIT_9";
              KeyCode[KeyCode["KEY_A"] = 65] = "KEY_A";
              KeyCode[KeyCode["KEY_B"] = 66] = "KEY_B";
              KeyCode[KeyCode["KEY_C"] = 67] = "KEY_C";
              KeyCode[KeyCode["KEY_D"] = 68] = "KEY_D";
              KeyCode[KeyCode["KEY_E"] = 69] = "KEY_E";
              KeyCode[KeyCode["KEY_F"] = 70] = "KEY_F";
              KeyCode[KeyCode["KEY_G"] = 71] = "KEY_G";
              KeyCode[KeyCode["KEY_H"] = 72] = "KEY_H";
              KeyCode[KeyCode["KEY_I"] = 73] = "KEY_I";
              KeyCode[KeyCode["KEY_J"] = 74] = "KEY_J";
              KeyCode[KeyCode["KEY_K"] = 75] = "KEY_K";
              KeyCode[KeyCode["KEY_L"] = 76] = "KEY_L";
              KeyCode[KeyCode["KEY_M"] = 77] = "KEY_M";
              KeyCode[KeyCode["KEY_N"] = 78] = "KEY_N";
              KeyCode[KeyCode["KEY_O"] = 79] = "KEY_O";
              KeyCode[KeyCode["KEY_P"] = 80] = "KEY_P";
              KeyCode[KeyCode["KEY_Q"] = 81] = "KEY_Q";
              KeyCode[KeyCode["KEY_R"] = 82] = "KEY_R";
              KeyCode[KeyCode["KEY_S"] = 83] = "KEY_S";
              KeyCode[KeyCode["KEY_T"] = 84] = "KEY_T";
              KeyCode[KeyCode["KEY_U"] = 85] = "KEY_U";
              KeyCode[KeyCode["KEY_V"] = 86] = "KEY_V";
              KeyCode[KeyCode["KEY_W"] = 87] = "KEY_W";
              KeyCode[KeyCode["KEY_X"] = 88] = "KEY_X";
              KeyCode[KeyCode["KEY_Y"] = 89] = "KEY_Y";
              KeyCode[KeyCode["KEY_Z"] = 90] = "KEY_Z";
              KeyCode[KeyCode["NUM_0"] = 96] = "NUM_0";
              KeyCode[KeyCode["NUM_1"] = 97] = "NUM_1";
              KeyCode[KeyCode["NUM_2"] = 98] = "NUM_2";
              KeyCode[KeyCode["NUM_3"] = 99] = "NUM_3";
              KeyCode[KeyCode["NUM_4"] = 100] = "NUM_4";
              KeyCode[KeyCode["NUM_5"] = 101] = "NUM_5";
              KeyCode[KeyCode["NUM_6"] = 102] = "NUM_6";
              KeyCode[KeyCode["NUM_7"] = 103] = "NUM_7";
              KeyCode[KeyCode["NUM_8"] = 104] = "NUM_8";
              KeyCode[KeyCode["NUM_9"] = 105] = "NUM_9";
              KeyCode[KeyCode["NUM_MULTIPLY"] = 106] = "NUM_MULTIPLY";
              KeyCode[KeyCode["NUM_PLUS"] = 107] = "NUM_PLUS";
              KeyCode[KeyCode["NUM_SUBTRACT"] = 109] = "NUM_SUBTRACT";
              KeyCode[KeyCode["NUM_DECIMAL"] = 110] = "NUM_DECIMAL";
              KeyCode[KeyCode["NUM_DIVIDE"] = 111] = "NUM_DIVIDE";
              KeyCode[KeyCode["F1"] = 112] = "F1";
              KeyCode[KeyCode["F2"] = 113] = "F2";
              KeyCode[KeyCode["F3"] = 114] = "F3";
              KeyCode[KeyCode["F4"] = 115] = "F4";
              KeyCode[KeyCode["F5"] = 116] = "F5";
              KeyCode[KeyCode["F6"] = 117] = "F6";
              KeyCode[KeyCode["F7"] = 118] = "F7";
              KeyCode[KeyCode["F8"] = 119] = "F8";
              KeyCode[KeyCode["F9"] = 120] = "F9";
              KeyCode[KeyCode["F10"] = 121] = "F10";
              KeyCode[KeyCode["F11"] = 122] = "F11";
              KeyCode[KeyCode["F12"] = 123] = "F12";
              KeyCode[KeyCode["NUM_LOCK"] = 144] = "NUM_LOCK";
              KeyCode[KeyCode["SCROLL_LOCK"] = 145] = "SCROLL_LOCK";
              KeyCode[KeyCode["SEMICOLON"] = 186] = "SEMICOLON";
              KeyCode[KeyCode["EQUAL"] = 187] = "EQUAL";
              KeyCode[KeyCode["COMMA"] = 188] = "COMMA";
              KeyCode[KeyCode["DASH"] = 189] = "DASH";
              KeyCode[KeyCode["PERIOD"] = 190] = "PERIOD";
              KeyCode[KeyCode["SLASH"] = 191] = "SLASH";
              KeyCode[KeyCode["BACK_QUOTE"] = 192] = "BACK_QUOTE";
              KeyCode[KeyCode["BRACKET_LEFT"] = 219] = "BRACKET_LEFT";
              KeyCode[KeyCode["BACKSLASH"] = 220] = "BACKSLASH";
              KeyCode[KeyCode["BRACKET_RIGHT"] = 221] = "BRACKET_RIGHT";
              KeyCode[KeyCode["QUOTE"] = 222] = "QUOTE";
              KeyCode[KeyCode["SHIFT_RIGHT"] = 2000] = "SHIFT_RIGHT";
              KeyCode[KeyCode["CTRL_RIGHT"] = 2001] = "CTRL_RIGHT";
              KeyCode[KeyCode["ALT_RIGHT"] = 2002] = "ALT_RIGHT";
              KeyCode[KeyCode["NUM_ENTER"] = 2003] = "NUM_ENTER";
            })(KeyCode || (KeyCode = exports('ew', {})));

            const _vec2$1 = new Vec2();

            class Touch {
              get lastModified() {
                return this._lastModified;
              }

              constructor(x, y, id = 0) {
                this._point = new Vec2();
                this._prevPoint = new Vec2();
                this._lastModified = 0;
                this._id = 0;
                this._startPoint = new Vec2();
                this._startPointCaptured = false;
                this.setTouchInfo(id, x, y);
              }

              getLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._point.x, this._point.y);
                return out;
              }

              getLocationX() {
                return this._point.x;
              }

              getLocationY() {
                return this._point.y;
              }

              getUILocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._point.x, this._point.y);

                legacyCC.view._convertToUISpace(out);

                return out;
              }

              getUILocationX() {
                const viewport = legacyCC.view.getViewportRect();
                return (this._point.x - viewport.x) / legacyCC.view.getScaleX();
              }

              getUILocationY() {
                const viewport = legacyCC.view.getViewportRect();
                return (this._point.y - viewport.y) / legacyCC.view.getScaleY();
              }

              getPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._prevPoint.x, this._prevPoint.y);
                return out;
              }

              getUIPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._prevPoint.x, this._prevPoint.y);

                legacyCC.view._convertToUISpace(out);

                return out;
              }

              getStartLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._startPoint.x, this._startPoint.y);
                return out;
              }

              getUIStartLocation(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._startPoint.x, this._startPoint.y);

                legacyCC.view._convertToUISpace(out);

                return out;
              }

              getDelta(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._point);
                out.subtract(this._prevPoint);
                return out;
              }

              getUIDelta(out) {
                if (!out) {
                  out = new Vec2();
                }

                _vec2$1.set(this._point);

                _vec2$1.subtract(this._prevPoint);

                out.set(legacyCC.view.getScaleX(), legacyCC.view.getScaleY());
                Vec2.divide(out, _vec2$1, out);
                return out;
              }

              getLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._point.x, legacyCC.view._designResolutionSize.height - this._point.y);
                return out;
              }

              getPreviousLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._prevPoint.x, legacyCC.view._designResolutionSize.height - this._prevPoint.y);
                return out;
              }

              getStartLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._startPoint.x, legacyCC.view._designResolutionSize.height - this._startPoint.y);
                return out;
              }

              getID() {
                return this._id;
              }

              setTouchInfo(id = 0, x, y) {
                this._prevPoint = this._point;
                this._point = new Vec2(x || 0, y || 0);
                this._id = id;

                if (!this._startPointCaptured) {
                  this._startPoint = new Vec2(this._point);
                  this._startPointCaptured = true;
                }
              }

              setPoint(x, y) {
                if (typeof x === 'object') {
                  this._point.x = x.x;
                  this._point.y = x.y;
                } else {
                  this._point.x = x || 0;
                  this._point.y = y || 0;
                }

                this._lastModified = legacyCC.game.frameStartTime;
              }

              setPrevPoint(x, y) {
                if (typeof x === 'object') {
                  this._prevPoint = new Vec2(x.x, x.y);
                } else {
                  this._prevPoint = new Vec2(x || 0, y || 0);
                }

                this._lastModified = legacyCC.game.frameStartTime;
              }

            } exports('gL', Touch);
            legacyCC.Touch = Touch;

            class AccelerometerInputSource {
              constructor() {
                this._intervalInSeconds = 0.2;
                this._intervalId = void 0;
                this._isEnabled = false;
                this._eventTarget = new EventTarget();
                this._didAccelerateFunc = void 0;
                this._didAccelerateFunc = this._didAccelerate.bind(this);
              }

              _didAccelerate() {
                const deviceMotionValue = jsb.device.getDeviceMotionValue();
                let x = deviceMotionValue[3] * 0.1;
                let y = deviceMotionValue[4] * 0.1;
                const z = deviceMotionValue[5] * 0.1;
                const orientation = screenAdapter.orientation;
                const tmpX = x;

                if (orientation === Orientation.LANDSCAPE_RIGHT) {
                  x = -y;
                  y = tmpX;
                } else if (orientation === Orientation.LANDSCAPE_LEFT) {
                  x = y;
                  y = -tmpX;
                } else if (orientation === Orientation.PORTRAIT_UPSIDE_DOWN) {
                  x = -x;
                  y = -y;
                }

                if (systemInfo.os === OS.ANDROID || systemInfo.os === OS.OHOS) {
                  x = -x;
                  y = -y;
                }

                const timestamp = performance.now();
                const acceleration = new Acceleration(x, y, z, timestamp);
                const eventAcceleration = new EventAcceleration(acceleration);

                this._eventTarget.emit(InputEventType.DEVICEMOTION, eventAcceleration);
              }

              start() {
                if (this._intervalId) {
                  clearInterval(this._intervalId);
                }

                this._intervalId = setInterval(this._didAccelerateFunc, this._intervalInSeconds * 1000);
                jsb.device.setAccelerometerInterval(this._intervalInSeconds);
                jsb.device.setAccelerometerEnabled(true);
                this._isEnabled = true;
              }

              stop() {
                if (this._intervalId) {
                  clearInterval(this._intervalId);
                  this._intervalId = undefined;
                }

                jsb.device.setAccelerometerEnabled(false);
                this._isEnabled = false;
              }

              setInterval(intervalInMileseconds) {
                this._intervalInSeconds = intervalInMileseconds / 1000;
                jsb.device.setAccelerometerInterval(this._intervalInSeconds);

                if (this._isEnabled) {
                  jsb.device.setAccelerometerEnabled(false);
                  jsb.device.setAccelerometerEnabled(true);
                }
              }

              on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              }

            }

            const nativeKeyCode2KeyCode = {
              12: KeyCode.NUM_LOCK,
              10048: KeyCode.NUM_0,
              10049: KeyCode.NUM_1,
              10050: KeyCode.NUM_2,
              10051: KeyCode.NUM_3,
              10052: KeyCode.NUM_4,
              10053: KeyCode.NUM_5,
              10054: KeyCode.NUM_6,
              10055: KeyCode.NUM_7,
              10056: KeyCode.NUM_8,
              10057: KeyCode.NUM_9,
              20013: KeyCode.NUM_ENTER,
              20016: KeyCode.SHIFT_RIGHT,
              20017: KeyCode.CTRL_RIGHT,
              20018: KeyCode.ALT_RIGHT
            };

            function getKeyCode(keyCode) {
              return nativeKeyCode2KeyCode[keyCode] || keyCode;
            }

            class KeyboardInputSource {
              constructor() {
                this._eventTarget = new EventTarget();
                this._keyStateMap = {};

                this._registerEvent();
              }

              _registerEvent() {
                jsb.onKeyDown = event => {
                  const keyCode = getKeyCode(event.keyCode);

                  if (!this._keyStateMap[keyCode]) {
                    const eventKeyDown = this._getInputEvent(event, InputEventType.KEY_DOWN);

                    this._eventTarget.emit(InputEventType.KEY_DOWN, eventKeyDown);
                  } else {
                    const eventKeyPressing = this._getInputEvent(event, InputEventType.KEY_PRESSING);

                    this._eventTarget.emit(InputEventType.KEY_PRESSING, eventKeyPressing);
                  }

                  this._keyStateMap[keyCode] = true;
                };

                jsb.onKeyUp = event => {
                  const keyCode = getKeyCode(event.keyCode);

                  const eventKeyUp = this._getInputEvent(event, InputEventType.KEY_UP);

                  this._keyStateMap[keyCode] = false;

                  this._eventTarget.emit(InputEventType.KEY_UP, eventKeyUp);
                };
              }

              _getInputEvent(event, eventType) {
                const keyCode = getKeyCode(event.keyCode);
                const eventKeyboard = new EventKeyboard(keyCode, eventType);
                return eventKeyboard;
              }

              on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              }

            }

            class MouseInputSource {
              constructor() {
                this._eventTarget = new EventTarget();
                this._preMousePos = new Vec2();
                this._isPressed = false;

                this._registerEvent();
              }

              _getLocation(event) {
                const windowSize = screenAdapter.windowSize;
                const dpr = screenAdapter.devicePixelRatio;
                const x = event.x * dpr;
                const y = windowSize.height - event.y * dpr;
                return new Vec2(x, y);
              }

              _registerEvent() {
                jsb.onMouseDown = this._createCallback(InputEventType.MOUSE_DOWN);
                jsb.onMouseMove = this._createCallback(InputEventType.MOUSE_MOVE);
                jsb.onMouseUp = this._createCallback(InputEventType.MOUSE_UP);
                jsb.onMouseWheel = this._handleMouseWheel.bind(this);
              }

              _createCallback(eventType) {
                return mouseEvent => {
                  const location = this._getLocation(mouseEvent);

                  let button = mouseEvent.button;

                  switch (eventType) {
                    case InputEventType.MOUSE_DOWN:
                      this._isPressed = true;
                      break;

                    case InputEventType.MOUSE_UP:
                      this._isPressed = false;
                      break;

                    case InputEventType.MOUSE_MOVE:
                      if (!this._isPressed) {
                        button = EventMouse.BUTTON_MISSING;
                      }

                      break;
                  }

                  const eventMouse = new EventMouse(eventType, false, this._preMousePos);
                  eventMouse.setLocation(location.x, location.y);
                  eventMouse.setButton(button);
                  eventMouse.movementX = location.x - this._preMousePos.x;
                  eventMouse.movementY = this._preMousePos.y - location.y;

                  this._preMousePos.set(location.x, location.y);

                  this._eventTarget.emit(eventType, eventMouse);
                };
              }

              _handleMouseWheel(mouseEvent) {
                const eventType = InputEventType.MOUSE_WHEEL;

                const location = this._getLocation(mouseEvent);

                const button = mouseEvent.button;
                const eventMouse = new EventMouse(eventType, false, this._preMousePos);
                eventMouse.setLocation(location.x, location.y);
                eventMouse.setButton(button);
                eventMouse.movementX = location.x - this._preMousePos.x;
                eventMouse.movementY = this._preMousePos.y - location.y;
                const matchStandardFactor = 120;
                eventMouse.setScrollData(mouseEvent.wheelDeltaX * matchStandardFactor, mouseEvent.wheelDeltaY * matchStandardFactor);

                this._preMousePos.set(location.x, location.y);

                this._eventTarget.emit(eventType, eventMouse);
              }

              on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              }

            }

            const tempVec2 = new Vec2();

            class TouchManager {
              constructor() {
                this._touchMap = {};
                this._touches = void 0;
                this._maxTouches = 8;
                this._touches = new Array(this._maxTouches);
              }

              _cloneTouch(touch) {
                const touchID = touch.getID();
                touch.getStartLocation(tempVec2);
                const clonedTouch = new Touch(tempVec2.x, tempVec2.y, touchID);
                touch.getLocation(tempVec2);
                clonedTouch.setPoint(tempVec2.x, tempVec2.y);
                touch.getPreviousLocation(tempVec2);
                clonedTouch.setPrevPoint(tempVec2);
                return clonedTouch;
              }

              _createTouch(touchID, x, y) {
                if (touchID in this._touchMap) {
                  console.log('Cannot create the same touch object.');
                  return undefined;
                }

                const availableTouchIndex = this._getAvailableTouchIndex(touchID);

                if (availableTouchIndex === -1) {
                  console.log('The touches is more than MAX_TOUCHES.');
                  return undefined;
                }

                const touch = new Touch(x, y, touchID);
                this._touches[availableTouchIndex] = touch;
                this._touchMap[touchID] = availableTouchIndex;

                this._updateTouch(touch, x, y);

                return this._cloneTouch(touch);
              }

              releaseTouch(touchID) {
                if (!(touchID in this._touchMap)) {
                  return;
                }

                const availableTouchIndex = this._touchMap[touchID];
                this._touches[availableTouchIndex] = undefined;
                delete this._touchMap[touchID];
              }

              getTouch(touchID, x, y) {
                const availableTouchIndex = this._touchMap[touchID];
                let touch = this._touches[availableTouchIndex];

                if (!touch) {
                  touch = this._createTouch(touchID, x, y);
                } else {
                  this._updateTouch(touch, x, y);
                }

                return touch ? this._cloneTouch(touch) : undefined;
              }

              getAllTouches() {
                const touches = [];

                this._touches.forEach(touch => {
                  if (touch) {
                    const clonedTouch = this._cloneTouch(touch);

                    touches.push(clonedTouch);
                  }
                });

                return touches;
              }

              _updateTouch(touch, x, y) {
                touch.getLocation(tempVec2);
                touch.setPrevPoint(tempVec2);
                touch.setPoint(x, y);
              }

              _getAvailableTouchIndex(touchID) {
                const availableTouchIndex = this._touchMap[touchID];

                if (typeof availableTouchIndex !== 'undefined') {
                  return availableTouchIndex;
                }

                for (let i = 0; i < this._maxTouches; i++) {
                  if (!this._touches[i]) {
                    return i;
                  }
                }

                const now = performance.now();
                const TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT;

                for (let i = 0; i < this._maxTouches; i++) {
                  const touch = this._touches[i];

                  if (now - touch.lastModified > TOUCH_TIMEOUT) {
                    console.log(`The touches is more than MAX_TOUCHES, release touch id ${touch.getID()}.`);
                    this.releaseTouch(touch.getID());
                    return i;
                  }
                }

                return -1;
              }

            }

            const touchManager = new TouchManager();

            class TouchInputSource {
              constructor() {
                this._eventTarget = new EventTarget();

                this._registerEvent();
              }

              _registerEvent() {
                jsb.onTouchStart = this._createCallback(InputEventType.TOUCH_START);
                jsb.onTouchMove = this._createCallback(InputEventType.TOUCH_MOVE);
                jsb.onTouchEnd = this._createCallback(InputEventType.TOUCH_END);
                jsb.onTouchCancel = this._createCallback(InputEventType.TOUCH_CANCEL);
              }

              _createCallback(eventType) {
                return changedTouches => {
                  const handleTouches = [];
                  const length = changedTouches.length;
                  const windowSize = screenAdapter.windowSize;

                  for (let i = 0; i < length; ++i) {
                    const changedTouch = changedTouches[i];
                    const touchID = changedTouch.identifier;

                    if (touchID === null) {
                      continue;
                    }

                    const location = this._getLocation(changedTouch, windowSize);

                    const touch = touchManager.getTouch(touchID, location.x, location.y);

                    if (!touch) {
                      continue;
                    }

                    if (eventType === InputEventType.TOUCH_END || eventType === InputEventType.TOUCH_CANCEL) {
                      touchManager.releaseTouch(touchID);
                    }

                    handleTouches.push(touch);

                    if (!macro.ENABLE_MULTI_TOUCH) {
                      break;
                    }
                  }

                  if (handleTouches.length > 0) {
                    const eventTouch = new EventTouch(handleTouches, false, eventType, macro.ENABLE_MULTI_TOUCH ? touchManager.getAllTouches() : handleTouches);

                    this._eventTarget.emit(eventType, eventTouch);
                  }
                };
              }

              _getLocation(touch, windowSize) {
                const dpr = screenAdapter.devicePixelRatio;
                const x = touch.clientX * dpr;
                const y = windowSize.height - touch.clientY * dpr;
                return new Vec2(x, y);
              }

              on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              }

            }

            const pointerEventTypeMap = {
              [InputEventType.MOUSE_DOWN]: InputEventType.TOUCH_START,
              [InputEventType.MOUSE_MOVE]: InputEventType.TOUCH_MOVE,
              [InputEventType.MOUSE_UP]: InputEventType.TOUCH_END
            };
            class Input {
              constructor() {
                this._dispatchImmediately = !NATIVE;
                this._eventTarget = new EventTarget();
                this._touchInput = new TouchInputSource();
                this._mouseInput = new MouseInputSource();
                this._keyboardInput = new KeyboardInputSource();
                this._accelerometerInput = new AccelerometerInputSource();
                this._eventTouchList = [];
                this._eventMouseList = [];
                this._eventKeyboardList = [];
                this._eventAccelerationList = [];
                this._needSimulateTouchMoveEvent = false;

                this._registerEvent();
              }

              _simulateEventTouch(eventMouse) {
                const eventType = pointerEventTypeMap[eventMouse.type];
                const touchID = 0;
                const touch = touchManager.getTouch(touchID, eventMouse.getLocationX(), eventMouse.getLocationY());

                if (!touch) {
                  return;
                }

                const changedTouches = [touch];
                const eventTouch = new EventTouch(changedTouches, false, eventType, changedTouches);

                if (eventType === InputEventType.TOUCH_END) {
                  touchManager.releaseTouch(touchID);
                }

                this._dispatchOrPushEventTouch(eventTouch, this._eventTouchList);
              }

              _registerEvent() {
                if (sys.hasFeature(sys.Feature.INPUT_TOUCH)) {
                  const eventTouchList = this._eventTouchList;

                  this._touchInput.on(InputEventType.TOUCH_START, event => {
                    this._dispatchOrPushEventTouch(event, eventTouchList);
                  });

                  this._touchInput.on(InputEventType.TOUCH_MOVE, event => {
                    this._dispatchOrPushEventTouch(event, eventTouchList);
                  });

                  this._touchInput.on(InputEventType.TOUCH_END, event => {
                    this._dispatchOrPushEventTouch(event, eventTouchList);
                  });

                  this._touchInput.on(InputEventType.TOUCH_CANCEL, event => {
                    this._dispatchOrPushEventTouch(event, eventTouchList);
                  });
                }

                if (sys.hasFeature(sys.Feature.EVENT_MOUSE)) {
                  const eventMouseList = this._eventMouseList;

                  this._mouseInput.on(InputEventType.MOUSE_DOWN, event => {
                    this._needSimulateTouchMoveEvent = true;

                    this._simulateEventTouch(event);

                    this._dispatchOrPushEvent(event, eventMouseList);
                  });

                  this._mouseInput.on(InputEventType.MOUSE_MOVE, event => {
                    if (this._needSimulateTouchMoveEvent) {
                      this._simulateEventTouch(event);
                    }

                    this._dispatchOrPushEvent(event, eventMouseList);
                  });

                  this._mouseInput.on(InputEventType.MOUSE_UP, event => {
                    this._needSimulateTouchMoveEvent = false;

                    this._simulateEventTouch(event);

                    this._dispatchOrPushEvent(event, eventMouseList);
                  });

                  this._mouseInput.on(InputEventType.MOUSE_WHEEL, event => {
                    this._dispatchOrPushEvent(event, eventMouseList);
                  });
                }

                if (sys.hasFeature(sys.Feature.EVENT_KEYBOARD)) {
                  const eventKeyboardList = this._eventKeyboardList;

                  this._keyboardInput.on(InputEventType.KEY_DOWN, event => {
                    this._dispatchOrPushEvent(event, eventKeyboardList);
                  });

                  this._keyboardInput.on(InputEventType.KEY_PRESSING, event => {
                    this._dispatchOrPushEvent(event, eventKeyboardList);
                  });

                  this._keyboardInput.on(InputEventType.KEY_UP, event => {
                    this._dispatchOrPushEvent(event, eventKeyboardList);
                  });
                }

                if (sys.hasFeature(sys.Feature.EVENT_ACCELEROMETER)) {
                  const eventAccelerationList = this._eventAccelerationList;

                  this._accelerometerInput.on(InputEventType.DEVICEMOTION, event => {
                    this._dispatchOrPushEvent(event, eventAccelerationList);
                  });
                }
              }

              _clearEvents() {
                this._eventMouseList.length = 0;
                this._eventTouchList.length = 0;
                this._eventKeyboardList.length = 0;
                this._eventAccelerationList.length = 0;
              }

              _dispatchOrPushEvent(event, eventList) {
                if (this._dispatchImmediately) {
                  this._eventTarget.emit(event.type, event);
                } else {
                  eventList.push(event);
                }
              }

              _dispatchOrPushEventTouch(eventTouch, touchEventList) {
                if (this._dispatchImmediately) {
                  const touches = eventTouch.getTouches();
                  const touchesLength = touches.length;

                  for (let i = 0; i < touchesLength; ++i) {
                    eventTouch.touch = touches[i];
                    eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;

                    this._eventTarget.emit(eventTouch.type, eventTouch);
                  }
                } else {
                  touchEventList.push(eventTouch);
                }
              }

              _frameDispatchEvents() {
                const eventMouseList = this._eventMouseList;

                for (let i = 0, length = eventMouseList.length; i < length; ++i) {
                  const eventMouse = eventMouseList[i];

                  this._eventTarget.emit(eventMouse.type, eventMouse);
                }

                const eventTouchList = this._eventTouchList;

                for (let i = 0, length = eventTouchList.length; i < length; ++i) {
                  const eventTouch = eventTouchList[i];
                  const touches = eventTouch.getTouches();
                  const touchesLength = touches.length;

                  for (let j = 0; j < touchesLength; ++j) {
                    eventTouch.touch = touches[j];
                    eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;

                    this._eventTarget.emit(eventTouch.type, eventTouch);
                  }
                }

                const eventKeyboardList = this._eventKeyboardList;

                for (let i = 0, length = eventKeyboardList.length; i < length; ++i) {
                  const eventKeyboard = eventKeyboardList[i];

                  this._eventTarget.emit(eventKeyboard.type, eventKeyboard);
                }

                const eventAccelerationList = this._eventAccelerationList;

                for (let i = 0, length = eventAccelerationList.length; i < length; ++i) {
                  const eventAcceleration = eventAccelerationList[i];

                  this._eventTarget.emit(eventAcceleration.type, eventAcceleration);
                }

                this._clearEvents();
              }

              on(eventType, callback, target) {

                this._eventTarget.on(eventType, callback, target);

                return callback;
              }

              once(eventType, callback, target) {

                this._eventTarget.once(eventType, callback, target);

                return callback;
              }

              off(eventType, callback, target) {

                this._eventTarget.off(eventType, callback, target);
              }

              setAccelerometerEnabled(isEnable) {

                if (isEnable) {
                  this._accelerometerInput.start();
                } else {
                  this._accelerometerInput.stop();
                }
              }

              setAccelerometerInterval(intervalInMileSeconds) {

                this._accelerometerInput.setInterval(intervalInMileSeconds);
              }

            } exports('ek', Input);
            Input.EventType = InputEventType;
            const input = exports('ej', new Input());

            const pointerEvent2SystemEvent = exports('em', {
              [InputEventType.TOUCH_START]: `system-event-${InputEventType.TOUCH_START}`,
              [InputEventType.TOUCH_MOVE]: `system-event-${InputEventType.TOUCH_MOVE}`,
              [InputEventType.TOUCH_END]: `system-event-${InputEventType.TOUCH_END}`,
              [InputEventType.TOUCH_CANCEL]: `system-event-${InputEventType.TOUCH_CANCEL}`,
              [InputEventType.MOUSE_DOWN]: `system-event-${InputEventType.MOUSE_DOWN}`,
              [InputEventType.MOUSE_MOVE]: `system-event-${InputEventType.MOUSE_MOVE}`,
              [InputEventType.MOUSE_UP]: `system-event-${InputEventType.MOUSE_UP}`
            });
            const inputEvents = Object.values(InputEventType);
            class SystemEvent extends EventTarget {
              setAccelerometerEnabled(isEnabled) {
                input.setAccelerometerEnabled(isEnabled);
              }

              setAccelerometerInterval(interval) {
                input.setAccelerometerInterval(interval);
              }

              on(type, callback, target, once) {
                const registerMethod = once ? input.once : input.on;

                if (inputEvents.includes(type)) {
                  const mappedPointerType = pointerEvent2SystemEvent[type];

                  if (mappedPointerType) {
                    registerMethod.call(input, mappedPointerType, callback, target);
                  } else if (type === SystemEventType.KEY_DOWN) {
                    registerMethod.call(input, InputEventType.KEY_DOWN, callback, target);
                    registerMethod.call(input, InputEventType.KEY_PRESSING, callback, target, once);
                  } else {
                    registerMethod.call(input, type, callback, target);
                  }
                } else {
                  super.on(type, callback, target, once);
                }

                return callback;
              }

              off(type, callback, target) {
                if (inputEvents.includes(type)) {
                  const mappedPointerType = pointerEvent2SystemEvent[type];

                  if (mappedPointerType) {
                    input.off(mappedPointerType, callback, target);
                  } else if (type === SystemEventType.KEY_DOWN) {
                    input.off(InputEventType.KEY_DOWN, callback, target);
                    input.off(InputEventType.KEY_PRESSING, callback, target);
                  } else {
                    input.off(type, callback, target);
                  }
                } else {
                  super.off(type, callback, target);
                }
              }

            } exports('gM', SystemEvent);
            SystemEvent.EventType = SystemEventType;
            legacyCC.SystemEvent = SystemEvent;
            const systemEvent = exports('gN', new SystemEvent());
            legacyCC.systemEvent = systemEvent;

            replaceProperty(SystemEventType, 'Node.EventType', [{
              name: 'POSITION_PART',
              newName: 'TRANSFORM_CHANGED'
            }, {
              name: 'ROTATION_PART',
              newName: 'TRANSFORM_CHANGED'
            }, {
              name: 'SCALE_PART',
              newName: 'TRANSFORM_CHANGED'
            }]);
            replaceProperty(Event, 'Event', [{
              name: 'ACCELERATION',
              newName: 'DEVICEMOTION',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(Event, 'Event', [{
              name: 'TOUCH',
              suggest: 'please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead'
            }, {
              name: 'MOUSE',
              suggest: 'please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead'
            }, {
              name: 'KEYBOARD',
              suggest: 'please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead'
            }]);
            replaceProperty(EventMouse, 'EventMouse', ['DOWN', 'UP', 'MOVE'].map(item => ({
              name: item,
              newName: `MOUSE_${item}`,
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            })));
            replaceProperty(EventMouse, 'EventMouse', [{
              name: 'SCROLL',
              newName: 'MOUSE_WHEEL',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(EventMouse.prototype, 'EventMouse.prototype', [{
              name: 'eventType',
              suggest: 'please use EventMouse.prototype.type instead'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'BEGAN',
              newName: 'TOUCH_START',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'MOVED',
              newName: 'TOUCH_MOVE',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'ENDED',
              newName: 'TOUCH_END',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'CANCELLED',
              newName: 'TOUCH_CANCEL',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(EventTouch.prototype, 'EventTouch.prototype', [{
              name: 'getEventCode',
              suggest: 'please use EventTouch.prototype.type instead'
            }]);
            replaceProperty(EventTouch.prototype, 'EventTouch.prototype', [{
              name: 'getUILocationInView',
              newName: 'getLocationInView',
              target: EventTouch,
              targetName: 'EventTouch'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', ['back', 'menu', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '*', '+', '-', '/', ';', '=', ',', '.', '[', ']', 'dpadLeft', 'dpadRight', 'dpadUp', 'dpadDown', 'dpadCenter'].map(item => ({
              name: item
            })));
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'shift',
              suggest: 'please use KeyCode.SHIFT_LEFT instead'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'ctrl',
              suggest: 'please use KeyCode.CTRL_LEFT instead'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'alt',
              suggest: 'please use KeyCode.ALT_LEFT instead'
            }]);
            markAsWarning(macro, 'macro', [{
              name: 'KEY',
              suggest: 'please use KeyCode instead'
            }]);

            var _dec$t, _class$t;
            replaceProperty(BaseNode.prototype, 'BaseNode', [{
              name: 'childrenCount',
              newName: 'children.length',

              customGetter() {
                return this.children.length;
              }

            }]);
            replaceProperty(Node$1.prototype, 'Node', [{
              name: 'width',
              targetName: 'node.getComponent(UITransform)',

              customGetter() {
                return this._uiProps.uiTransformComp.width;
              },

              customSetter(value) {
                this._uiProps.uiTransformComp.width = value;
              }

            }, {
              name: 'height',
              targetName: 'node.getComponent(UITransform)',

              customGetter() {
                return this._uiProps.uiTransformComp.height;
              },

              customSetter(value) {
                this._uiProps.uiTransformComp.height = value;
              }

            }, {
              name: 'anchorX',
              targetName: 'node.getComponent(UITransform)',

              customGetter() {
                return this._uiProps.uiTransformComp.anchorX;
              },

              customSetter(value) {
                this._uiProps.uiTransformComp.anchorX = value;
              }

            }, {
              name: 'anchorY',
              targetName: 'node.getComponent(UITransform)',

              customGetter() {
                return this._uiProps.uiTransformComp.anchorY;
              },

              customSetter(value) {
                this._uiProps.uiTransformComp.anchorY = value;
              }

            }, {
              name: 'getAnchorPoint',
              targetName: 'node.getComponent(UITransform)',

              customFunction(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._uiProps.uiTransformComp.anchorPoint);
                return out;
              }

            }, {
              name: 'setAnchorPoint',
              targetName: 'node.getComponent(UITransform)',

              customFunction(point, y) {
                this._uiProps.uiTransformComp.setAnchorPoint(point, y);
              }

            }, {
              name: 'getContentSize',
              targetName: 'node.getComponent(UITransform)',

              customFunction(out) {
                if (!out) {
                  out = new Size();
                }

                out.set(this._uiProps.uiTransformComp.contentSize);
                return out;
              }

            }, {
              name: 'setContentSize',
              targetName: 'node.getComponent(UITransform)',

              customFunction(size, height) {
                if (typeof size === 'number') {
                  this._uiProps.uiTransformComp.setContentSize(size, height);
                } else {
                  this._uiProps.uiTransformComp.setContentSize(size);
                }
              }

            }]);
            removeProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
              name: 'aspect'
            }, {
              name: 'selfShadow'
            }, {
              name: 'linear'
            }, {
              name: 'packing'
            }, {
              name: 'autoAdapt'
            }]);
            removeProperty(Node$1.prototype, 'Node.prototype', [{
              name: 'addLayer'
            }, {
              name: 'removeLayer'
            }]);
            removeProperty(Layers, 'Layers', [{
              name: 'All'
            }, {
              name: 'RaycastMask'
            }, {
              name: 'check'
            }]);
            replaceProperty(Layers, 'Layers', [{
              name: 'Default',
              newName: 'DEFAULT',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Always',
              newName: 'ALWAYS',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'IgnoreRaycast',
              newName: 'IGNORE_RAYCAST',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Gizmos',
              newName: 'GIZMOS',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Editor',
              newName: 'EDITOR',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'UI',
              newName: 'UI_3D',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'UI2D',
              newName: 'UI_2D',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'SceneGizmo',
              newName: 'SCENE_GIZMO',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'makeInclusiveMask',
              newName: 'makeMaskInclude',
              target: Layers,
              targetName: 'Layers'
            }, {
              name: 'makeExclusiveMask',
              newName: 'makeMaskExclude',
              target: Layers,
              targetName: 'Layers'
            }]);
            removeProperty(Layers.Enum, 'Layers.Enum', [{
              name: 'ALWAYS'
            }]);
            removeProperty(Layers.BitMask, 'Layers.BitMask', [{
              name: 'ALWAYS'
            }]);
            const HideInHierarchy$1 = CCObject.Flags.HideInHierarchy;
            const DontSave$1 = CCObject.Flags.DontSave;
            let PrivateNode = exports('gg', (_dec$t = ccclass('cc.PrivateNode'), _dec$t(_class$t = class PrivateNode extends Node$1 {
              constructor(name) {
                super(name);
                warnID(12003, this.name);
                this.hideFlags |= DontSave$1 | HideInHierarchy$1;
              }

            }) || _class$t));

            replaceProperty(SystemEventType, 'SystemEventType', ['MOUSE_ENTER', 'MOUSE_LEAVE', 'TRANSFORM_CHANGED', 'SCENE_CHANGED_FOR_PERSISTS', 'SIZE_CHANGED', 'ANCHOR_CHANGED', 'COLOR_CHANGED', 'CHILD_ADDED', 'CHILD_REMOVED', 'PARENT_CHANGED', 'NODE_DESTROYED', 'LAYER_CHANGED', 'SIBLING_ORDER_CHANGED'].map(name => ({
              name,
              target: Node$1.EventType,
              targetName: 'Node.EventType'
            })));
            replaceProperty(Node$1.EventType, 'Node.EventType', [{
              name: 'DEVICEMOTION',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }, {
              name: 'KEY_DOWN',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }, {
              name: 'KEY_UP',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            legacyCC.PrivateNode = PrivateNode;

            var _dec$u, _class$u, _class2$p, _descriptor$m, _descriptor2$h, _temp$q;
            let Scene = exports('eD', (_dec$u = ccclass('cc.Scene'), _dec$u(_class$u = (_class2$p = (_temp$q = class Scene extends BaseNode {
              get renderScene() {
                return this._renderScene;
              }

              get globals() {
                return this._globals;
              }

              _updateScene() {
                this._scene = this;
              }

              get native() {
                return this._nativeObj;
              }

              _init() {
                {
                  this._nativeObj = new NativeScene();
                }
              }

              constructor(name) {
                super(name);

                _initializerDefineProperty(this, "autoReleaseAssets", _descriptor$m, this);

                _initializerDefineProperty(this, "_globals", _descriptor2$h, this);

                this.dependAssets = null;
                this._renderScene = null;
                this._inited = void 0;
                this._prefabSyncedInLiveReload = false;
                this._pos = Vec3.ZERO;
                this._rot = Quat.IDENTITY;
                this._scale = Vec3.ONE;
                this._mat = Mat4.IDENTITY;
                this._dirtyFlags = 0;
                this._lpos = Vec3.ZERO;
                this._lrot = Quat.IDENTITY;
                this._lscale = Vec3.ONE;
                this._activeInHierarchy = false;

                if (legacyCC.director && legacyCC.director.root) {
                  this._renderScene = legacyCC.director.root.createScene({});
                }

                this._inited = legacyCC.game ? !legacyCC.game._isCloning : true;

                this._init();
              }

              destroy() {
                const success = CCObject.prototype.destroy.call(this);

                if (success) {
                  const children = this._children;

                  for (let i = 0; i < children.length; ++i) {
                    children[i].active = false;
                  }
                }

                if (this._renderScene) legacyCC.director.root.destroyScene(this._renderScene);
                this._active = false;
                this._activeInHierarchy = false;
                return success;
              }

              addComponent() {
                throw new Error(getError(3822));
              }

              _onHierarchyChanged() {}

              _onBatchCreated(dontSyncChildPrefab) {
                super._onBatchCreated(dontSyncChildPrefab);

                const len = this._children.length;

                for (let i = 0; i < len; ++i) {
                  this.children[i]._siblingIndex = i;

                  this._children[i]._onBatchCreated(dontSyncChildPrefab);
                }
              }

              getPosition(out) {
                return Vec3.copy(out || new Vec3(), Vec3.ZERO);
              }

              getRotation(out) {
                return Quat.copy(out || new Quat(), Quat.IDENTITY);
              }

              getScale(out) {
                return Vec3.copy(out || new Vec3(), Vec3.ONE);
              }

              getWorldPosition(out) {
                return Vec3.copy(out || new Vec3(), Vec3.ZERO);
              }

              getWorldRotation(out) {
                return Quat.copy(out || new Quat(), Quat.IDENTITY);
              }

              getWorldScale(out) {
                return Vec3.copy(out || new Vec3(), Vec3.ONE);
              }

              getWorldMatrix(out) {
                return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
              }

              getWorldRS(out) {
                return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
              }

              getWorldRT(out) {
                return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
              }

              get position() {
                return Vec3.ZERO;
              }

              get worldPosition() {
                return Vec3.ZERO;
              }

              get rotation() {
                return Quat.IDENTITY;
              }

              get worldRotation() {
                return Quat.IDENTITY;
              }

              get scale() {
                return Vec3.ONE;
              }

              get worldScale() {
                return Vec3.ONE;
              }

              get eulerAngles() {
                return Vec3.ZERO;
              }

              get worldMatrix() {
                return Mat4.IDENTITY;
              }

              updateWorldTransform() {}

              _instantiate() {}

              _load() {
                if (!this._inited) {

                  expandNestedPrefabInstanceNode(this);
                  applyTargetOverrides(this);

                  this._onBatchCreated(EDITOR );

                  this._inited = true;
                }

                this.walk(BaseNode._setScene);
              }

              _activate(active) {
                active = active !== false;

                legacyCC.director._nodeActivator.activateNode(this, active);

                {
                  this._globals.activate();

                  if (this._renderScene) {
                    this._renderScene.activate();
                  }
                }
              }

            }, _temp$q), (_applyDecoratedDescriptor(_class2$p.prototype, "globals", [editable], Object.getOwnPropertyDescriptor(_class2$p.prototype, "globals"), _class2$p.prototype), _descriptor$m = _applyDecoratedDescriptor(_class2$p.prototype, "autoReleaseAssets", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$h = _applyDecoratedDescriptor(_class2$p.prototype, "_globals", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new SceneGlobals();
              }
            })), _class2$p)) || _class$u));
            legacyCC.Scene = Scene;

            function find(path, referenceNode) {
              if (!referenceNode) {
                const scene = legacyCC.director.getScene();

                if (!scene) {

                  return null;
                }

                referenceNode = scene;
              }

              return referenceNode.getChildByPath(path);
            }
            legacyCC.find = find;

            const fastRemoveAt$2 = array.fastRemoveAt;
            const IsStartCalled$1 = CCObject.Flags.IsStartCalled;
            const IsOnEnableCalled$1 = CCObject.Flags.IsOnEnableCalled;
            const IsEditorOnEnableCalled$1 = CCObject.Flags.IsEditorOnEnableCalled;

            function sortedIndex(array, comp) {
              const order = comp.constructor._executionOrder;
              const id = comp._id;
              let l = 0;

              for (let h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                const test = array[m];
                const testOrder = test.constructor._executionOrder;

                if (testOrder > order) {
                  h = m - 1;
                } else if (testOrder < order) {
                  l = m + 1;
                } else {
                  const testId = test._id;

                  if (testId > id) {
                    h = m - 1;
                  } else if (testId < id) {
                    l = m + 1;
                  } else {
                    return m;
                  }
                }
              }

              return ~l;
            }

            function stableRemoveInactive(iterator, flagToClear) {
              const array = iterator.array;
              let next = iterator.i + 1;

              while (next < array.length) {
                const comp = array[next];

                if (comp.node._activeInHierarchy) {
                  ++next;
                } else {
                  iterator.removeAt(next);

                  if (flagToClear) {
                    comp._objFlags &= ~flagToClear;
                  }
                }
              }
            }

            class LifeCycleInvoker {
              constructor(invokeFunc) {
                this._zero = void 0;
                this._neg = void 0;
                this._pos = void 0;
                this._invoke = void 0;
                const Iterator = MutableForwardIterator;
                this._zero = new Iterator([]);
                this._neg = new Iterator([]);
                this._pos = new Iterator([]);

                this._invoke = invokeFunc;
              }

            }
            LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;

            function compareOrder(a, b) {
              return a.constructor._executionOrder - b.constructor._executionOrder;
            }

            class OneOffInvoker extends LifeCycleInvoker {
              add(comp) {
                const order = comp.constructor._executionOrder;
                (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
              }

              remove(comp) {
                const order = comp.constructor._executionOrder;
                (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
              }

              cancelInactive(flagToClear) {
                stableRemoveInactive(this._zero, flagToClear);
                stableRemoveInactive(this._neg, flagToClear);
                stableRemoveInactive(this._pos, flagToClear);
              }

              invoke() {
                const compsNeg = this._neg;

                if (compsNeg.array.length > 0) {
                  compsNeg.array.sort(compareOrder);

                  this._invoke(compsNeg);

                  compsNeg.array.length = 0;
                }

                this._invoke(this._zero);

                this._zero.array.length = 0;
                const compsPos = this._pos;

                if (compsPos.array.length > 0) {
                  compsPos.array.sort(compareOrder);

                  this._invoke(compsPos);

                  compsPos.array.length = 0;
                }
              }

            }

            class ReusableInvoker extends LifeCycleInvoker {
              add(comp) {
                const order = comp.constructor._executionOrder;

                if (order === 0) {
                  this._zero.array.push(comp);
                } else {
                  const array = order < 0 ? this._neg.array : this._pos.array;
                  const i = sortedIndex(array, comp);

                  if (i < 0) {
                    array.splice(~i, 0, comp);
                  }
                }
              }

              remove(comp) {
                const order = comp.constructor._executionOrder;

                if (order === 0) {
                  this._zero.fastRemove(comp);
                } else {
                  const iterator = order < 0 ? this._neg : this._pos;
                  const i = sortedIndex(iterator.array, comp);

                  if (i >= 0) {
                    iterator.removeAt(i);
                  }
                }
              }

              invoke(dt) {
                if (this._neg.array.length > 0) {
                  this._invoke(this._neg, dt);
                }

                this._invoke(this._zero, dt);

                if (this._pos.array.length > 0) {
                  this._invoke(this._pos, dt);
                }
              }

            }

            function createInvokeImplJit(code, useDt, ensureFlag) {
              const body = `${'var a=it.array;' + 'for(it.i=0;it.i<a.length;++it.i){' + 'var c=a[it.i];'}${code}}`;
              const fastPath = useDt ? Function('it', 'dt', body) : Function('it', body);
              const singleInvoke = Function('c', 'dt', code);
              return createInvokeImpl(singleInvoke, fastPath, ensureFlag);
            }
            function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
              return (iterator, dt) => {
                try {
                  fastPath(iterator, dt);
                } catch (e) {
                  legacyCC._throw(e);

                  const array = iterator.array;

                  if (ensureFlag) {
                    array[iterator.i]._objFlags |= ensureFlag;
                  }

                  ++iterator.i;

                  for (; iterator.i < array.length; ++iterator.i) {
                    try {
                      singleInvoke(array[iterator.i], dt);
                    } catch (e) {
                      legacyCC._throw(e);

                      if (ensureFlag) {
                        array[iterator.i]._objFlags |= ensureFlag;
                      }
                    }
                  }
                }
              };
            }
            const invokeStart =  createInvokeImplJit(`c.start();c._objFlags|=${IsStartCalled$1}`, false, IsStartCalled$1) ;
            const invokeUpdate =  createInvokeImplJit('c.update(dt)', true) ;
            const invokeLateUpdate =  createInvokeImplJit('c.lateUpdate(dt)', true) ;
            const invokeOnEnable =  iterator => {
              const compScheduler = legacyCC.director._compScheduler;
              const array = iterator.array;

              for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                const comp = array[iterator.i];

                if (comp._enabled) {
                  comp.onEnable();
                  const deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

                  if (!deactivatedDuringOnEnable) {
                    compScheduler._onEnabled(comp);
                  }
                }
              }
            };
            class ComponentScheduler {
              constructor() {
                this._deferredComps = [];
                this.unscheduleAll();
              }

              unscheduleAll() {
                this.startInvoker = new OneOffInvoker(invokeStart);
                this.updateInvoker = new ReusableInvoker(invokeUpdate);
                this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate);
                this._updating = false;
              }

              _onEnabled(comp) {
                legacyCC.director.getScheduler().resumeTarget(comp);
                comp._objFlags |= IsOnEnableCalled$1;

                if (this._updating) {
                  this._deferredComps.push(comp);
                } else {
                  this._scheduleImmediate(comp);
                }
              }

              _onDisabled(comp) {
                legacyCC.director.getScheduler().pauseTarget(comp);
                comp._objFlags &= ~IsOnEnableCalled$1;

                const index = this._deferredComps.indexOf(comp);

                if (index >= 0) {
                  fastRemoveAt$2(this._deferredComps, index);
                  return;
                }

                if (comp.start && !(comp._objFlags & IsStartCalled$1)) {
                  this.startInvoker.remove(comp);
                }

                if (comp.update) {
                  this.updateInvoker.remove(comp);
                }

                if (comp.lateUpdate) {
                  this.lateUpdateInvoker.remove(comp);
                }
              }

              enableComp(comp, invoker) {
                if (!(comp._objFlags & IsOnEnableCalled$1)) {
                  if (comp.onEnable) {
                    if (invoker) {
                      invoker.add(comp);
                      return;
                    } else {
                      comp.onEnable();
                      const deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

                      if (deactivatedDuringOnEnable) {
                        return;
                      }
                    }
                  }

                  this._onEnabled(comp);
                }
              }

              disableComp(comp) {
                if (comp._objFlags & IsOnEnableCalled$1) {
                  if (comp.onDisable) {
                    comp.onDisable();
                  }

                  this._onDisabled(comp);
                }
              }

              startPhase() {
                this._updating = true;
                this.startInvoker.invoke();

                this._startForNewComps();
              }

              updatePhase(dt) {
                this.updateInvoker.invoke(dt);
              }

              lateUpdatePhase(dt) {
                this.lateUpdateInvoker.invoke(dt);
                this._updating = false;

                this._startForNewComps();
              }

              _startForNewComps() {
                if (this._deferredComps.length > 0) {
                  this._deferredSchedule();

                  this.startInvoker.invoke();
                }
              }

              _scheduleImmediate(comp) {
                if (typeof comp.start === 'function' && !(comp._objFlags & IsStartCalled$1)) {
                  this.startInvoker.add(comp);
                }

                if (typeof comp.update === 'function') {
                  this.updateInvoker.add(comp);
                }

                if (typeof comp.lateUpdate === 'function') {
                  this.lateUpdateInvoker.add(comp);
                }
              }

              _deferredSchedule() {
                const comps = this._deferredComps;

                for (let i = 0, len = comps.length; i < len; i++) {
                  this._scheduleImmediate(comps[i]);
                }

                comps.length = 0;
              }

            }

            const MAX_POOL_SIZE = 4;
            const IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted;
            const IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted;
            const IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled;
            const Deactivating$2 = CCObject.Flags.Deactivating;

            class UnsortedInvoker extends LifeCycleInvoker {
              add(comp) {
                this._zero.array.push(comp);
              }

              remove(comp) {
                this._zero.fastRemove(comp);
              }

              cancelInactive(flagToClear) {
                LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
              }

              invoke() {
                this._invoke(this._zero);

                this._zero.array.length = 0;
              }

            }

            const invokePreload =  createInvokeImplJit('c.__preload();') ;
            const invokeOnLoad =  createInvokeImplJit(`c.onLoad();c._objFlags|=${IsOnLoadCalled$2}`, false, IsOnLoadCalled$2) ;
            const activateTasksPool = new Pool$1(MAX_POOL_SIZE);

            activateTasksPool.get = function getActivateTask() {
              console.error('pptest activateTasksPool')
              const task = this._get() || {
                preload: new UnsortedInvoker(invokePreload),
                onLoad: new OneOffInvoker(invokeOnLoad),
                onEnable: new OneOffInvoker(invokeOnEnable)
              };
              task.preload._zero.i = -1;
              let invoker = task.onLoad;
              invoker._zero.i = -1;
              invoker._neg.i = -1;
              invoker._pos.i = -1;
              invoker = task.onEnable;
              invoker._zero.i = -1;
              invoker._neg.i = -1;
              invoker._pos.i = -1;
              return task;
            };

            function _componentCorrupted(node, comp, index) {
              errorID(3817, node.name, index);
              console.log('Corrupted component value:', comp);

              if (comp) {
                node._removeComponent(comp);
              } else {
                array.removeAt(node._components, index);
              }
            }

            class NodeActivator {
              constructor() {
                this.resetComp = void 0;
                this.reset();
              }

              reset() {
                this._activatingStack = [];
              }

              activateNode(node, active) {
                console.error('pptest activateNode')
                if (active) {
                  const task = activateTasksPool.get();

                  this._activatingStack.push(task);

                  this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);

                  task.preload.invoke();
                  task.onLoad.invoke();
                  task.onEnable.invoke();

                  this._activatingStack.pop();

                  activateTasksPool.put(task);
                } else {
                  this._deactivateNodeRecursively(node);

                  const stack = this._activatingStack;

                  for (const lastTask of stack) {
                    lastTask.preload.cancelInactive(IsPreloadStarted$1);
                    lastTask.onLoad.cancelInactive(IsOnLoadStarted$1);
                    lastTask.onEnable.cancelInactive();
                  }
                }

                node.emit(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, node);
              }

              activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (!isValid(comp, true)) {
                  return;
                }

                if (!(comp._objFlags & IsPreloadStarted$1)) {
                  comp._objFlags |= IsPreloadStarted$1;

                  if (comp.__preload) {
                    if (preloadInvoker) {
                      preloadInvoker.add(comp);
                    } else {
                      comp.__preload();
                    }
                  }
                }

                if (!(comp._objFlags & IsOnLoadStarted$1)) {
                  comp._objFlags |= IsOnLoadStarted$1;

                  if (comp.onLoad) {
                    if (onLoadInvoker) {
                      onLoadInvoker.add(comp);
                    } else {
                      comp.onLoad();
                      comp._objFlags |= IsOnLoadCalled$2;
                    }
                  } else {
                    comp._objFlags |= IsOnLoadCalled$2;
                  }
                }

                if (comp._enabled) {
                  {
                    assertIsTrue(comp.node, getError(3823, comp.uuid, comp.name));
                  }

                  const deactivatedOnLoading = !comp.node._activeInHierarchy;

                  if (deactivatedOnLoading) {
                    return;
                  }

                  legacyCC.director._compScheduler.enableComp(comp, onEnableInvoker);
                }
              }

              destroyComp(comp) {
                legacyCC.director._compScheduler.disableComp(comp);

                if (comp.onDestroy && comp._objFlags & IsOnLoadCalled$2) {
                  comp.onDestroy();
                }
              }

              _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (node._objFlags & Deactivating$2) {
                  errorID(3816, node.name);
                  return;
                }

                node._activeInHierarchy = true;
                let originCount = node._components.length;

                for (let i = 0; i < originCount; ++i) {
                  const component = node._components[i];

                  if (component instanceof legacyCC.Component) {
                    this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
                  } else {
                    _componentCorrupted(node, component, i);

                    --i;
                    --originCount;
                  }
                }

                for (let i = 0, len = node._children.length; i < len; ++i) {
                  const child = node._children[i];

                  if (child._active) {
                    this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                  }
                }

                node._onPostActivated(true);
              }

              _deactivateNodeRecursively(node) {

                node._objFlags |= Deactivating$2;
                node._activeInHierarchy = false;
                const originCount = node._components.length;

                for (let c = 0; c < originCount; ++c) {
                  const component = node._components[c];

                  if (component._enabled) {
                    legacyCC.director._compScheduler.disableComp(component);

                    if (node._activeInHierarchy) {
                      node._objFlags &= ~Deactivating$2;
                      return;
                    }
                  }
                }

                for (let i = 0, len = node._children.length; i < len; ++i) {
                  const child = node._children[i];

                  if (child._activeInHierarchy) {
                    this._deactivateNodeRecursively(child);

                    if (node._activeInHierarchy) {
                      node._objFlags &= ~Deactivating$2;
                      return;
                    }
                  }
                }

                node._onPostActivated(false);

                node._objFlags &= ~Deactivating$2;
              }

            } exports('gf', NodeActivator);

            var _dec$v, _class$v, _class2$q, _descriptor$n, _temp$r;
            let SceneAsset = exports('fD', (_dec$v = ccclass('cc.SceneAsset'), _dec$v(_class$v = (_class2$q = (_temp$r = class SceneAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "scene", _descriptor$n, this);
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this.scene = new Scene('New Scene');
              }

              validate() {
                return !!this.scene;
              }

            }, _temp$r), (_descriptor$n = _applyDecoratedDescriptor(_class2$q.prototype, "scene", [editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$q)) || _class$v));
            legacyCC.SceneAsset = SceneAsset;

            var _dec$w, _class$w, _class2$r, _descriptor$o, _temp$s;
            let TextAsset = exports('eW', (_dec$w = ccclass('cc.TextAsset'), _dec$w(_class$w = (_class2$r = (_temp$s = class TextAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "text", _descriptor$o, this);
              }

              toString() {
                return this.text;
              }

            }, _temp$s), (_descriptor$o = _applyDecoratedDescriptor(_class2$r.prototype, "text", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$r)) || _class$w));
            legacyCC.TextAsset = TextAsset;

            var _dec$x, _class$x, _class2$s, _descriptor$p, _temp$t;
            let JsonAsset = exports('fE', (_dec$x = ccclass('cc.JsonAsset'), _dec$x(_class$x = (_class2$s = (_temp$t = class JsonAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "json", _descriptor$p, this);
              }

            }, _temp$t), (_descriptor$p = _applyDecoratedDescriptor(_class2$s.prototype, "json", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$s)) || _class$x));
            legacyCC.JsonAsset = JsonAsset;

            const GEOMETRY_RENDERER_TECHNIQUE_COUNT = 6;
            class PipelineSceneData {
              _init() {
                {
                  this._nativeObj = new NativePipelineSharedSceneData();
                  this._nativeObj.fog = this.fog.native;
                  this._nativeObj.ambient = this.ambient.native;
                  this._nativeObj.skybox = this.skybox.native;
                  this._nativeObj.shadow = this.shadows.native;
                  this._nativeObj.octree = this.octree.native;
                }
              }

              get native() {
                return this._nativeObj;
              }

              get isHDR() {
                return this._isHDR;
              }

              set isHDR(val) {
                this._isHDR = val;

                {
                  this._nativeObj.isHDR = val;
                }
              }

              get shadingScale() {
                return this._shadingScale;
              }

              set shadingScale(val) {
                if (this._shadingScale !== val) {
                  this._shadingScale = val;

                  {
                    this._nativeObj.shadingScale = val;
                  }

                  this._pipeline.emit(PipelineEventType.ATTACHMENT_SCALE_CAHNGED, val);
                }
              }

              constructor() {
                this.fog = new Fog();
                this.ambient = new Ambient();
                this.skybox = new Skybox();
                this.shadows = new Shadows();
                this.octree = new Octree();
                this.validPunctualLights = [];
                this.renderObjects = [];
                this.castShadowObjects = [];
                this.dirShadowObjects = [];
                this.shadowFrameBufferMap = new Map();
                this._geometryRendererMaterials = [];
                this._geometryRendererPasses = [];
                this._geometryRendererShaders = [];
                this._occlusionQueryVertexBuffer = null;
                this._occlusionQueryIndicesBuffer = null;
                this._occlusionQueryInputAssembler = null;
                this._occlusionQueryMaterial = null;
                this._occlusionQueryShader = null;
                this._isHDR = true;
                this._shadingScale = 1.0;

                this._init();

                this.shadingScale = 1.0;
              }

              activate(device, pipeline) {
                this._device = device;
                this._pipeline = pipeline;
                this.initGeometryRendererMaterials();
                this.initOcclusionQuery();
                return true;
              }

              initGeometryRendererMaterials() {
                let offset = 0;

                for (let tech = 0; tech < GEOMETRY_RENDERER_TECHNIQUE_COUNT; tech++) {
                  this._geometryRendererMaterials[tech] = new Material();
                  this._geometryRendererMaterials[tech]._uuid = `geometry-renderer-material-${tech}`;

                  this._geometryRendererMaterials[tech].initialize({
                    effectName: 'geometry-renderer',
                    technique: tech
                  });

                  for (let pass = 0; pass < this._geometryRendererMaterials[tech].passes.length; ++pass) {
                    this._geometryRendererPasses[offset] = this._geometryRendererMaterials[tech].passes[pass];
                    this._geometryRendererShaders[offset] = this._geometryRendererMaterials[tech].passes[pass].getShaderVariant();
                    offset++;
                  }
                }

                {
                  const nativePasses = [];
                  const nativeShaders = [];

                  for (let pass = 0; pass < this._geometryRendererPasses.length; ++pass) {
                    nativePasses.push(this._geometryRendererPasses[pass].native);
                    nativeShaders.push(this._geometryRendererShaders[pass]);
                  }

                  this._nativeObj.geometryRendererPasses = nativePasses;
                  this._nativeObj.geometryRendererShaders = nativeShaders;
                }
              }

              get geometryRendererPasses() {
                return this._geometryRendererPasses;
              }

              get geometryRendererShaders() {
                return this._geometryRendererShaders;
              }

              initOcclusionQuery() {
                if (!this._occlusionQueryInputAssembler) {
                  this._occlusionQueryInputAssembler = this._createOcclusionQueryIA();

                  {
                    this._nativeObj.occlusionQueryInputAssembler = this._occlusionQueryInputAssembler;
                  }
                }

                if (!this._occlusionQueryMaterial) {
                  const mat = new Material();
                  mat._uuid = 'default-occlusion-query-material';
                  mat.initialize({
                    effectName: 'occlusion-query'
                  });
                  this._occlusionQueryMaterial = mat;
                  this._occlusionQueryShader = mat.passes[0].getShaderVariant();

                  {
                    this._nativeObj.occlusionQueryPass = this._occlusionQueryMaterial.passes[0].native;
                    this._nativeObj.occlusionQueryShader = this._occlusionQueryShader;
                  }
                }
              }

              getOcclusionQueryPass() {
                return this._occlusionQueryMaterial.passes[0];
              }

              onGlobalPipelineStateChanged() {}

              destroy() {
                var _this$_occlusionQuery, _this$_occlusionQuery2, _this$_occlusionQuery3;

                this.ambient.destroy();
                this.skybox.destroy();
                this.fog.destroy();
                this.shadows.destroy();
                this.octree.destroy();
                this.validPunctualLights.length = 0;
                (_this$_occlusionQuery = this._occlusionQueryInputAssembler) === null || _this$_occlusionQuery === void 0 ? void 0 : _this$_occlusionQuery.destroy();
                this._occlusionQueryInputAssembler = null;
                (_this$_occlusionQuery2 = this._occlusionQueryVertexBuffer) === null || _this$_occlusionQuery2 === void 0 ? void 0 : _this$_occlusionQuery2.destroy();
                this._occlusionQueryVertexBuffer = null;
                (_this$_occlusionQuery3 = this._occlusionQueryIndicesBuffer) === null || _this$_occlusionQuery3 === void 0 ? void 0 : _this$_occlusionQuery3.destroy();
                this._occlusionQueryIndicesBuffer = null;

                {
                  this._nativeObj = null;
                }
              }

              _createOcclusionQueryIA() {
                const device = this._device;
                const vertices = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1]);
                const vbStride = Float32Array.BYTES_PER_ELEMENT * 3;
                const vbSize = vbStride * 8;
                this._occlusionQueryVertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbSize, vbStride));

                this._occlusionQueryVertexBuffer.update(vertices);

                const indices = new Uint16Array([0, 2, 1, 1, 2, 3, 4, 5, 6, 5, 7, 6, 1, 3, 7, 1, 7, 5, 0, 4, 6, 0, 6, 2, 0, 1, 5, 0, 5, 4, 2, 6, 7, 2, 7, 3]);
                const ibStride = Uint16Array.BYTES_PER_ELEMENT;
                const ibSize = ibStride * 36;
                this._occlusionQueryIndicesBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibSize, ibStride));

                this._occlusionQueryIndicesBuffer.update(indices);

                const attributes = [new Attribute('a_position', Format.RGB32F)];
                const info = new InputAssemblerInfo(attributes, [this._occlusionQueryVertexBuffer], this._occlusionQueryIndicesBuffer);
                const inputAssembler = device.createInputAssembler(info);
                return inputAssembler;
              }

            }

            let AntiAliasing;

            (function (AntiAliasing) {
              AntiAliasing[AntiAliasing["NONE"] = 0] = "NONE";
              AntiAliasing[AntiAliasing["FXAA"] = 1] = "FXAA";
            })(AntiAliasing || (AntiAliasing = {}));

            const BLOOM_PREFILTERPASS_INDEX = 0;
            const BLOOM_DOWNSAMPLEPASS_INDEX = 1;
            const BLOOM_UPSAMPLEPASS_INDEX = BLOOM_DOWNSAMPLEPASS_INDEX + MAX_BLOOM_FILTER_PASS_NUM;
            const BLOOM_COMBINEPASS_INDEX = BLOOM_UPSAMPLEPASS_INDEX + MAX_BLOOM_FILTER_PASS_NUM;
            class DeferredPipelineSceneData extends PipelineSceneData {
              constructor(...args) {
                super(...args);
                this._antiAliasing = AntiAliasing.NONE;
              }

              set antiAliasing(value) {
                this._antiAliasing = value;

                if (this._postprocessMaterial) {
                  const defines = this._postprocessMaterial.passes[0].defines;
                  Object.assign(defines, {
                    ANTIALIAS_TYPE: value
                  });
                  const renderMat = new Material();
                  renderMat.initialize({
                    effectAsset: this._postprocessMaterial.effectAsset,
                    defines
                  });

                  for (let i = 0; i < renderMat.passes.length; ++i) {
                    renderMat.passes[i].tryCompile();
                  }

                  this._postprocessMaterial = renderMat;
                }
              }

              get antiAliasing() {
                return this._antiAliasing;
              }

              get bloomMaterial() {
                return this._bloomMaterial;
              }

              set bloomMaterial(mat) {
                if (this._bloomMaterial === mat || !mat) return;
                this._bloomMaterial = mat;
                this.updatePipelinePassInfo();
              }

              get postprocessMaterial() {
                return this._postprocessMaterial;
              }

              set postprocessMaterial(mat) {
                if (this._postprocessMaterial === mat || !mat) return;
                this._postprocessMaterial = mat;
                this.updatePipelinePassInfo();
              }

              onGlobalPipelineStateChanged() {
                this.updatePipelinePassInfo();
              }

              updateBloomPass() {
                if (!this._bloomMaterial) return;
                const prefilterPass = this._bloomMaterial.passes[BLOOM_PREFILTERPASS_INDEX];
                prefilterPass.beginChangeStatesSilently();
                prefilterPass.tryCompile();
                prefilterPass.endChangeStatesSilently();
                const downsamplePasses = [];
                const upsamplePasses = [];

                for (let i = 0; i < MAX_BLOOM_FILTER_PASS_NUM; ++i) {
                  const downsamplePass = this._bloomMaterial.passes[BLOOM_DOWNSAMPLEPASS_INDEX + i];
                  downsamplePass.beginChangeStatesSilently();
                  downsamplePass.tryCompile();
                  downsamplePass.endChangeStatesSilently();
                  const upsamplePass = this._bloomMaterial.passes[BLOOM_UPSAMPLEPASS_INDEX + i];
                  upsamplePass.beginChangeStatesSilently();
                  upsamplePass.tryCompile();
                  upsamplePass.endChangeStatesSilently();
                  downsamplePasses.push(downsamplePass.native);
                  upsamplePasses.push(upsamplePass.native);
                }

                const combinePass = this._bloomMaterial.passes[BLOOM_COMBINEPASS_INDEX];
                combinePass.beginChangeStatesSilently();
                combinePass.tryCompile();
                combinePass.endChangeStatesSilently();

                {
                  this._nativeObj.bloomPrefilterPassShader = prefilterPass.getShaderVariant();
                  this._nativeObj.bloomPrefilterPass = prefilterPass.native;
                  this._nativeObj.bloomDownsamplePassShader = this._bloomMaterial.passes[BLOOM_DOWNSAMPLEPASS_INDEX].getShaderVariant();
                  this._nativeObj.bloomDownsamplePass = downsamplePasses;
                  this._nativeObj.bloomUpsamplePassShader = this._bloomMaterial.passes[BLOOM_UPSAMPLEPASS_INDEX].getShaderVariant();
                  this._nativeObj.bloomUpsamplePass = upsamplePasses;
                  this._nativeObj.bloomCombinePassShader = combinePass.getShaderVariant();
                  this._nativeObj.bloomCombinePass = combinePass.native;
                }
              }

              updatePostProcessPass() {
                if (!this.postprocessMaterial) return;
                const passPost = this.postprocessMaterial.passes[0];
                passPost.beginChangeStatesSilently();
                passPost.tryCompile();
                passPost.endChangeStatesSilently();

                {
                  this._nativeObj.pipelinePostPassShader = passPost.getShaderVariant();
                  this._nativeObj.pipelinePostPass = passPost.native;
                }
              }

              initPipelinePassInfo() {
                const deferredMat = new Material();
                deferredMat._uuid = 'builtin-deferred-material';
                deferredMat.initialize({
                  effectName: 'deferred-lighting'
                });

                for (let i = 0; i < deferredMat.passes.length; ++i) {
                  deferredMat.passes[i].tryCompile();
                }

                this._deferredLightingMaterial = deferredMat;
                const bloomMat = new Material();
                bloomMat._uuid = 'builtin-bloom-material';
                bloomMat.initialize({
                  effectName: 'bloom'
                });

                for (let i = 0; i < bloomMat.passes.length; ++i) {
                  bloomMat.passes[i].tryCompile();
                }

                this._bloomMaterial = bloomMat;
                const postMat = new Material();
                postMat._uuid = 'builtin-post-process-material';

                if (macro.ENABLE_ANTIALIAS_FXAA) {
                  this._antiAliasing = AntiAliasing.FXAA;
                }

                postMat.initialize({
                  effectName: 'post-process',
                  defines: {
                    ANTIALIAS_TYPE: this._antiAliasing
                  }
                });

                for (let i = 0; i < postMat.passes.length; ++i) {
                  postMat.passes[i].tryCompile();
                }

                this._postprocessMaterial = postMat;
                this.updatePipelinePassInfo();
              }

              get deferredLightingMaterial() {
                return this._deferredLightingMaterial;
              }

              set deferredLightingMaterial(mat) {
                if (this._deferredLightingMaterial === mat || !mat) return;
                this._deferredLightingMaterial = mat;
                this.updatePipelinePassInfo();
              }

              updatePipelinePassInfo() {
                this.updateBloomPass();
                this.updatePostProcessPass();
                this.updateDeferredPassInfo();
              }

              activate(device, pipeline) {
                super.activate(device, pipeline);
                this.initPipelinePassInfo();
                return true;
              }

              updateDeferredPassInfo() {
                this.updateDeferredLightPass();
              }

              updateDeferredLightPass() {
                if (!this._deferredLightingMaterial) return;

                if (this.shadows.enabled) {
                  this._pipeline.macros.CC_RECEIVE_SHADOW = 1;
                }

                const passLit = this._deferredLightingMaterial.passes[0];
                passLit.beginChangeStatesSilently();
                passLit.tryCompile();
                passLit.endChangeStatesSilently();

                {
                  this._nativeObj.deferredLightPassShader = passLit.getShaderVariant();
                  this._nativeObj.deferredLightPass = passLit.native;
                }
              }

            }

            nr.getPhaseID = getPhaseID;
            const RenderPipeline$1 = exports('fR', nr.RenderPipeline);
            const RenderFlow$1 = exports('fS', nr.RenderFlow);
            const RenderStage$1 = exports('fT', nr.RenderStage);
            const InstancedBuffer$1 = exports('fU', nr.InstancedBuffer);
            const PipelineStateManager$1 = exports('fV', nr.PipelineStateManager);
            let instancedBufferProto = nr.InstancedBuffer;
            let oldGetFunc = instancedBufferProto.get;
            let getOrCreatePipelineState = nr.PipelineStateManager.getOrCreatePipelineState;

            nr.PipelineStateManager.getOrCreatePipelineState = function (device, pass, shader, renderPass, ia) {
              return getOrCreatePipelineState.call(device, pass.native, shader, renderPass, ia);
            };

            function createDefaultPipeline() {
              const pipeline = new ForwardPipeline();
              pipeline.init();
              return pipeline;
            }
            class ForwardPipeline extends nr.ForwardPipeline {
              constructor() {
                super();
                this.pipelineSceneData = new PipelineSceneData();
                this.geometryRenderer = new GeometryRenderer();
                this._tag = 0;
                this._flows = [];
                this.renderTextures = [];
                this.materials = [];
              }

              on(type, callback, target, once) {}

              once(type, callback, target) {}

              off(type, callback, target) {}

              emit(type, arg0, arg1, arg2, arg3, arg4) {}

              targetOff(typeOrTarget) {}

              removeAll(typeOrTarget) {}

              hasEventListener(type, callback, target) {
                return false;
              }

              init() {
                this.setPipelineSharedSceneData(this.pipelineSceneData.native);
                this.setGeometryRenderer(this.geometryRenderer.native);

                for (let i = 0; i < this._flows.length; i++) {
                  this._flows[i].init(this);
                }

                const info = new nr.RenderPipelineInfo(this._tag, this._flows);
                this.initialize(info);
              }

              activate(swapchain) {
                this.geometryRenderer.activate(legacyCC.director.root.device, this);
                return super.activate(swapchain) && this.pipelineSceneData.activate(legacyCC.director.root.device, this);
              }

              render(cameras) {
                this.geometryRenderer.flush();
                let nativeObjs = [];

                for (let i = 0, len = cameras.length; i < len; ++i) {
                  nativeObjs.push(cameras[i].native);
                }

                super.render(nativeObjs);
              }

              set profiler(value) {
                this.setProfiler(value && value.native);
              }

              destroy() {
                this.pipelineSceneData.destroy();
                this.geometryRenderer.destroy();
                super.destroy();
              }

            } exports('fX', ForwardPipeline);
            addon(ForwardPipeline.prototype, Asset.prototype);
            const ForwardOnLoaded = ForwardPipeline.prototype.onLoaded;

            ForwardPipeline.prototype.onLoaded = function () {
              if (ForwardOnLoaded) ForwardOnLoaded.call(this);
              this.init();
            };

            class ForwardFlow extends nr.ForwardFlow {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this._stages = [];
              }

              init(pipeline) {
                for (let i = 0; i < this._stages.length; i++) {
                  this._stages[i].init(pipeline);
                }

                const info = new nr.RenderFlowInfo(this._name, this._priority, this._tag, this._stages);
                this.initialize(info);
              }

            } exports('fY', ForwardFlow);
            class ShadowFlow extends nr.ShadowFlow {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this._stages = [];
              }

              init(pipeline) {
                for (let i = 0; i < this._stages.length; i++) {
                  this._stages[i].init(pipeline);
                }

                const info = new nr.RenderFlowInfo(this._name, this._priority, this._tag, this._stages);
                this.initialize(info);
              }

            } exports('fZ', ShadowFlow);
            class ForwardStage extends nr.ForwardStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
              }

              init(pipeline) {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                const info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('f_', ForwardStage);
            class ShadowStage extends nr.ShadowStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
              }

              init(pipeline) {
                const info = new nr.RenderStageInfo(this._name, this._priority, this._tag, []);
                this.initialize(info);
              }

            } exports('f$', ShadowStage);
            class RenderQueueDesc {
              constructor() {
                this.isTransparent = false;
                this.sortMode = 0;
                this.stages = [];
                this.isTransparent = false;
                this.sortMode = 0;
                this.stages = [];
              }

              init() {
                return new nr.RenderQueueDesc(this.isTransparent, this.sortMode, this.stages);
              }

            } exports('g0', RenderQueueDesc);
            class DeferredPipeline extends nr.DeferredPipeline {
              constructor() {
                super();
                this.pipelineSceneData = new DeferredPipelineSceneData();
                this.geometryRenderer = new GeometryRenderer();
                this._tag = 0;
                this._flows = [];
                this.renderTextures = [];
                this.materials = [];
              }

              on(type, callback, target, once) {}

              once(type, callback, target) {}

              off(type, callback, target) {}

              emit(type, arg0, arg1, arg2, arg3, arg4) {}

              targetOff(typeOrTarget) {}

              removeAll(typeOrTarget) {}

              hasEventListener(type, callback, target) {
                return false;
              }

              init() {
                this.setPipelineSharedSceneData(this.pipelineSceneData.native);
                this.setGeometryRenderer(this.geometryRenderer.native);

                for (let i = 0; i < this._flows.length; i++) {
                  this._flows[i].init(this);
                }

                let info = new nr.RenderPipelineInfo(this._tag, this._flows);
                this.initialize(info);
              }

              activate(swapchain) {
                this.geometryRenderer.activate(legacyCC.director.root.device, this);
                return super.activate(swapchain) && this.pipelineSceneData.activate(legacyCC.director.root.device, this);
              }

              render(cameras) {
                this.geometryRenderer.flush();
                let nativeObjs = [];

                for (let i = 0, len = cameras.length; i < len; ++i) {
                  nativeObjs.push(cameras[i].native);
                }

                super.render(nativeObjs);
              }

              set profiler(value) {
                this.setProfiler(value && value.native);
              }

              destroy() {
                this.fog.destroy();
                this.ambient.destroy();
                this.skybox.destroy();
                this.shadows.destroy();
                this.pipelineSceneData.destroy();
                this.geometryRenderer.destroy();
                super.destroy();
              }

            } exports('g1', DeferredPipeline);
            addon(DeferredPipeline.prototype, Asset.prototype);
            const DeferredOnLoaded = DeferredPipeline.prototype.onLoaded;

            DeferredPipeline.prototype.onLoaded = function () {
              if (DeferredOnLoaded) DeferredOnLoaded.call(this);
              this.init();
            };

            class MainFlow extends nr.MainFlow {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this._stages = [];
              }

              init(pipeline) {
                for (let i = 0; i < this._stages.length; i++) {
                  this._stages[i].init(pipeline);
                }

                let info = new nr.RenderFlowInfo(this._name, this._priority, this._tag, this._stages);
                this.initialize(info);
              }

            } exports('g2', MainFlow);
            class GbufferStage extends nr.GbufferStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
              }

              init(pipeline) {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                let info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('g3', GbufferStage);
            class LightingStage extends nr.LightingStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
                this._deferredMaterial = null;
              }

              init(pipeline) {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                pipeline.pipelineSceneData.deferredLightingMaterial = this._deferredMaterial;
                let info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('g4', LightingStage);
            class BloomStage extends nr.BloomStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
                this._bloomMaterial = null;
              }

              init(pipeline) {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                pipeline.pipelineSceneData.bloomMaterial = this._bloomMaterial;
                let info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('g5', BloomStage);
            class PostProcessStage extends nr.PostProcessStage {
              constructor() {
                super();
                this._name = 0;
                this._priority = 0;
                this._tag = 0;
                this.renderQueues = [];
                this._postProcessMaterial = null;
              }

              init(pipeline) {
                const queues = [];

                for (let i = 0; i < this.renderQueues.length; i++) {
                  queues.push(this.renderQueues[i].init());
                }

                pipeline.pipelineSceneData.postprocessMaterial = this._postProcessMaterial;
                let info = new nr.RenderStageInfo(this._name, this._priority, this._tag, queues);
                this.initialize(info);
              }

            } exports('g6', PostProcessStage);
            setClassName('DeferredPipeline', DeferredPipeline);
            setClassName('MainFlow', MainFlow);
            setClassName('GbufferStage', GbufferStage);
            setClassName('LightingStage', LightingStage);
            setClassName('BloomStage', BloomStage);
            setClassName('PostProcessStage', PostProcessStage);
            setClassName('ForwardPipeline', ForwardPipeline);
            setClassName('ForwardFlow', ForwardFlow);
            setClassName('ShadowFlow', ShadowFlow);
            setClassName('ForwardStage', ForwardStage);
            setClassName('ShadowStage', ShadowStage);
            setClassName('RenderQueueDesc', RenderQueueDesc);

            const v2_0 = new Vec2();
            class SplashScreen {
              set splashFinish(v) {
                this._splashFinish = v;

                this._tryToStart();
              }

              set loadFinish(v) {
                this._loadFinish = v;

                this._tryToStart();
              }

              pauseRendering() {
                this.isPause = true;
              }

              resumeRendering() {
                this.isPause = false;
              }

              main(root) {
                if (root == null) {
                  error('RENDER ROOT IS NULL.');
                  return;
                }

                if (window._CCSettings && window._CCSettings.splashScreen) {
                  const setting = this.settings = window._CCSettings.splashScreen;
                  setting.totalTime = this.settings.totalTime != null ? this.settings.totalTime : 3000;
                  setting.base64src = this.settings.base64src || '';
                  setting.effect = this.settings.effect || 'FADE-INOUT';
                  setting.clearColor = this.settings.clearColor || new Color$1(0.88, 0.88, 0.88, 1);
                  setting.displayRatio = this.settings.displayRatio != null ? this.settings.displayRatio : 0.4;
                  setting.displayWatermark = this.settings.displayWatermark != null ? this.settings.displayWatermark : true;
                } else {
                  this.settings = {
                    totalTime: 3000,
                    base64src: '',
                    effect: 'FADE-INOUT',
                    clearColor: new Color$1(0.88, 0.88, 0.88, 1),
                    displayRatio: 0.4,
                    displayWatermark: true
                  };
                }

                if (this.settings.base64src === '' || this.settings.totalTime <= 0) {
                  if (this.callBack) {
                    this.callBack();
                  }

                  this.callBack = null;
                  this.settings = null;
                  this._directCall = true;
                } else {
                  legacyCC.view.resizeWithBrowserSize(true);
                  const designRes = window._CCSettings.designResolution;

                  if (designRes) {
                    legacyCC.view.setDesignResolutionSize(designRes.width, designRes.height, designRes.policy);
                  } else {
                    legacyCC.view.setDesignResolutionSize(960, 640, 4);
                  }

                  this.device = root.device;
                  this.swapchain = root.mainWindow.swapchain;
                  this.framebuffer = root.mainWindow.framebuffer;
                  legacyCC.game.once(legacyCC.Game.EVENT_GAME_INITED, () => {
                    legacyCC.director._lateUpdate = performance.now();
                  }, legacyCC.director);
                  this.callBack = null;
                  this.cancelAnimate = false;
                  this.startTime = -1;
                  this.preInit();
                  this.logoImage = new Image();
                  this.logoImage.onload = this.init.bind(this);
                  this.logoImage.src = this.settings.base64src;
                }
              }

              setOnFinish(cb) {
                if (this._directCall) {
                  if (cb) {
                    SplashScreen._ins = undefined;
                    cb();
                    return;
                  }
                }

                this.callBack = cb;
              }

              _tryToStart() {
                if (this._splashFinish && this._loadFinish) {
                  if (this.callBack) {
                    this.callBack();
                    this.hide();
                    legacyCC.game.resume();
                  }
                }
              }

              preInit() {
                const clearColor = this.settings.clearColor;
                this.clearColors = [new Color$1(clearColor.x, clearColor.y, clearColor.z, clearColor.w)];
                const {
                  device,
                  swapchain
                } = this;
                this.renderArea = new Rect$1(0, 0, swapchain.width, swapchain.height);
                this.cmdBuff = device.commandBuffer;
                const verts = new Float32Array([0.5, 0.5, 1, 0, -0.5, 0.5, 0, 0, 0.5, -0.5, 1, 1, -0.5, -0.5, 0, 1]);
                const vbStride = Float32Array.BYTES_PER_ELEMENT * 4;
                const vbSize = vbStride * 4;
                this.vertexBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, vbSize, vbStride));
                this.vertexBuffers.update(verts);
                const indices = new Uint16Array([0, 1, 2, 1, 3, 2]);
                const ibStride = Uint16Array.BYTES_PER_ELEMENT;
                const ibSize = ibStride * 6;
                this.indicesBuffers = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, ibSize, ibStride));
                this.indicesBuffers.update(indices);
                const attributes = [new Attribute('a_position', Format.RG32F), new Attribute('a_texCoord', Format.RG32F)];
                const IAInfo = new InputAssemblerInfo(attributes, [this.vertexBuffers], this.indicesBuffers);
                this.quadAssmebler = device.createInputAssembler(IAInfo);
                this.projection = new Mat4();
                Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
              }

              init() {
                this.initLogo();
                if (this.settings.displayWatermark) this.initWarterMark();

                const animate = time => {
                  if (this.cancelAnimate) return;
                  const settings = this.settings;
                  const {
                    device,
                    swapchain
                  } = this;
                  Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY, swapchain.surfaceTransform);
                  const dw = swapchain.width;
                  const dh = swapchain.height;
                  const refW = dw < dh ? dw : dh;
                  if (this.startTime < 0) this.startTime = time;
                  const elapsedTime = time - this.startTime;
                  const percent = clamp01(elapsedTime / settings.totalTime);
                  let u_p = cubicOut(percent);
                  if (settings.effect === 'NONE') u_p = 1.0;
                  const logoTW = this.logoTexture.width;
                  const logoTH = this.logoTexture.height;
                  const logoW = refW * settings.displayRatio;
                  let scaleX = logoW * logoTW / logoTH;
                  let scaleY = logoW;

                  if (swapchain.surfaceTransform === SurfaceTransform.ROTATE_90 || swapchain.surfaceTransform === SurfaceTransform.ROTATE_270) {
                    scaleX = logoW * dw / dh;
                    scaleY = logoW * logoTH / logoTW * dh / dw;
                  }

                  this.logoMat.setProperty('resolution', v2_0.set(dw, dh), 0);
                  this.logoMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
                  this.logoMat.setProperty('translate', v2_0.set(dw * 0.5, dh * 0.5), 0);
                  this.logoMat.setProperty('percent', u_p);
                  this.logoMat.setProperty('u_projection', this.projection);
                  this.logoMat.passes[0].update();

                  if (settings.displayWatermark && this.watermarkMat) {
                    const wartermarkW = refW * 0.5;
                    const wartermarkTW = this.watermarkTexture.width;
                    const wartermarkTH = this.watermarkTexture.height;
                    let scaleX = wartermarkW;
                    let scaleY = wartermarkW * wartermarkTH / wartermarkTW;

                    if (swapchain.surfaceTransform === SurfaceTransform.ROTATE_90 || swapchain.surfaceTransform === SurfaceTransform.ROTATE_270) {
                      scaleX = wartermarkW * 0.5;
                      scaleY = wartermarkW * dw / dh * 0.5;
                    }

                    this.watermarkMat.setProperty('resolution', v2_0.set(dw, dh), 0);
                    this.watermarkMat.setProperty('scale', v2_0.set(scaleX, scaleY), 0);
                    this.watermarkMat.setProperty('translate', v2_0.set(dw * 0.5, dh * 0.1), 0);
                    this.watermarkMat.setProperty('percent', u_p);
                    this.watermarkMat.setProperty('u_projection', this.projection);
                    this.watermarkMat.passes[0].update();
                  }

                  if (!this.isPause) {
                    this.frame();
                    if (elapsedTime > settings.totalTime) this.splashFinish = true;
                  }

                  requestAnimationFrame(animate);
                };

                legacyCC.game.pause();
                this.handle = requestAnimationFrame(animate);
              }

              hide() {
                cancelAnimationFrame(this.handle);
                this.cancelAnimate = true;
                setTimeout(this.destroy.bind(this));
              }

              initLogo() {
                const device = this.device;
                this.logoMat = new Material();
                this.logoMat.initialize({
                  effectName: 'splash-screen'
                });
                const samplerInfo = new SamplerInfo();
                samplerInfo.addressU = Address.CLAMP;
                samplerInfo.addressV = Address.CLAMP;
                samplerInfo.addressW = Address.CLAMP;
                this.sampler = device.getSampler(samplerInfo);
                this.logoTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, this.logoImage.width, this.logoImage.height));
                const pass = this.logoMat.passes[0];
                const binding = pass.getBinding('mainTexture');
                pass.bindTexture(binding, this.logoTexture);
                this.shader = pass.getShaderVariant();
                const descriptorSet = pass.descriptorSet;
                descriptorSet.bindSampler(binding, this.sampler);
                descriptorSet.update();
                const region = new BufferTextureCopy();
                region.texExtent.width = this.logoImage.width;
                region.texExtent.height = this.logoImage.height;
                region.texExtent.depth = 1;
                device.copyTexImagesToTexture([this.logoImage], this.logoTexture, [region]);
              }

              initWarterMark() {
                const wartemarkImg = document.createElement('canvas');
                wartemarkImg.width = 330;
                wartemarkImg.height = 30;
                wartemarkImg.style.width = `${wartemarkImg.width}`;
                wartemarkImg.style.height = `${wartemarkImg.height}`;
                const ctx = wartemarkImg.getContext('2d');
                ctx.font = `${18}px Arial`;
                ctx.textBaseline = 'top';
                ctx.textAlign = 'left';
                ctx.fillStyle = '`#424242`';
                const text = 'Powered by Cocos Creator';
                const textMetrics = ctx.measureText(text);
                ctx.fillText(text, (330 - textMetrics.width) / 2, 6);
                const region = new BufferTextureCopy();
                region.texExtent.width = wartemarkImg.width;
                region.texExtent.height = wartemarkImg.height;
                region.texExtent.depth = 1;
                this.watermarkTexture = this.device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, wartemarkImg.width, wartemarkImg.height));
                this.device.copyTexImagesToTexture([wartemarkImg], this.watermarkTexture, [region]);
                this.watermarkMat = new Material();
                this.watermarkMat.initialize({
                  effectName: 'splash-screen'
                });
                const pass = this.watermarkMat.passes[0];
                const binding = pass.getBinding('mainTexture');
                pass.bindTexture(binding, this.watermarkTexture);
                pass.descriptorSet.update();
              }

              frame() {
                const {
                  device,
                  swapchain
                } = this;
                device.acquire([swapchain]);
                const cmdBuff = this.cmdBuff;
                const framebuffer = this.framebuffer;
                const renderArea = this.renderArea;
                renderArea.width = swapchain.width;
                renderArea.height = swapchain.height;
                cmdBuff.begin();
                cmdBuff.beginRenderPass(framebuffer.renderPass, framebuffer, renderArea, this.clearColors, 1.0, 0);
                const logoPass = this.logoMat.passes[0];
                const logoPso = PipelineStateManager$1.getOrCreatePipelineState(device, logoPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                cmdBuff.bindPipelineState(logoPso);
                cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, logoPass.descriptorSet);
                cmdBuff.bindInputAssembler(this.quadAssmebler);
                cmdBuff.draw(this.quadAssmebler);

                if (this.settings.displayWatermark && this.watermarkMat) {
                  const wartermarkPass = this.watermarkMat.passes[0];
                  const watermarkPso = PipelineStateManager$1.getOrCreatePipelineState(device, wartermarkPass, this.shader, framebuffer.renderPass, this.quadAssmebler);
                  cmdBuff.bindPipelineState(watermarkPso);
                  cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, wartermarkPass.descriptorSet);
                  cmdBuff.bindInputAssembler(this.quadAssmebler);
                  cmdBuff.draw(this.quadAssmebler);
                }

                cmdBuff.endRenderPass();
                cmdBuff.end();
                device.flushCommands([cmdBuff]);
                device.queue.submit([cmdBuff]);
                device.present();
              }

              destroy() {
                this.callBack = null;
                this.device = null;
                this.swapchain = null;
                this.clearColors = null;
                if (this.logoImage.destroy) this.logoImage.destroy();
                this.logoImage = null;
                this.framebuffer = null;
                this.renderArea = null;
                this.cmdBuff = null;
                this.shader = null;
                this.logoMat.destroy();
                this.logoMat = null;
                this.logoTexture.destroy();
                this.logoTexture = null;
                this.quadAssmebler.destroy();
                this.quadAssmebler = null;
                this.vertexBuffers.destroy();
                this.vertexBuffers = null;
                this.indicesBuffers.destroy();
                this.indicesBuffers = null;
                this.sampler = null;

                if (this.watermarkTexture) {
                  this.watermarkMat.destroy();
                  this.watermarkMat = null;
                  this.watermarkTexture.destroy();
                  this.watermarkTexture = null;
                }

                this.settings = null;
                SplashScreen._ins = undefined;
              }

              static get instance() {
                if (!SplashScreen._ins) {
                  SplashScreen._ins = new SplashScreen();
                }

                return SplashScreen._ins;
              }

              constructor() {
                this.handle = 0;
                this.callBack = null;
                this.cancelAnimate = false;
                this.startTime = -1;
                this.isPause = false;
                this._splashFinish = false;
                this._loadFinish = false;
                this._directCall = false;
              }

            }
            SplashScreen._ins = void 0;
            legacyCC.internal.SplashScreen = SplashScreen;

            class System {
              constructor() {
                this._id = '';
                this._priority = 0;
                this._executeInEditMode = false;
              }

              set priority(value) {
                this._priority = value;
              }

              get priority() {
                return this._priority;
              }

              set id(id) {
                this._id = id;
              }

              get id() {
                return this._id;
              }

              static sortByPriority(a, b) {
                if (a._priority < b._priority) {
                  return 1;
                } else if (a._priority > b.priority) {
                  return -1;
                } else {
                  return 0;
                }
              }

              init() {}

              update(dt) {}

              postUpdate(dt) {}

            } exports('cl', System);
            System.Priority = Enum({
              LOW: 0,
              MEDIUM: 100,
              HIGH: 200,
              SCHEDULER: 1 << 31 >>> 0
            });

            const MAX_POOL_SIZE$1 = 20;
            const idGenerator$3 = new IDGenerator('Scheduler');

            class ListEntry {
              constructor(target, priority, paused, markedForDeletion) {
                this.target = void 0;
                this.priority = void 0;
                this.paused = void 0;
                this.markedForDeletion = void 0;
                this.target = target;
                this.priority = priority;
                this.paused = paused;
                this.markedForDeletion = markedForDeletion;
              }

            }

            ListEntry.get = (target, priority, paused, markedForDeletion) => {
              let result = ListEntry._listEntries.pop();

              if (result) {
                result.target = target;
                result.priority = priority;
                result.paused = paused;
                result.markedForDeletion = markedForDeletion;
              } else {
                result = new ListEntry(target, priority, paused, markedForDeletion);
              }

              return result;
            };

            ListEntry.put = entry => {
              if (ListEntry._listEntries.length < MAX_POOL_SIZE$1) {
                entry.target = null;

                ListEntry._listEntries.push(entry);
              }
            };

            ListEntry._listEntries = [];

            class HashUpdateEntry {
              constructor(list, entry, target, callback) {
                this.list = void 0;
                this.entry = void 0;
                this.target = void 0;
                this.callback = void 0;
                this.list = list;
                this.entry = entry;
                this.target = target;
                this.callback = callback;
              }

            }

            HashUpdateEntry.get = (list, entry, target, callback) => {
              let result = HashUpdateEntry._hashUpdateEntries.pop();

              if (result) {
                result.list = list;
                result.entry = entry;
                result.target = target;
                result.callback = callback;
              } else {
                result = new HashUpdateEntry(list, entry, target, callback);
              }

              return result;
            };

            HashUpdateEntry.put = entry => {
              if (HashUpdateEntry._hashUpdateEntries.length < MAX_POOL_SIZE$1) {
                entry.list = entry.entry = entry.target = entry.callback = null;

                HashUpdateEntry._hashUpdateEntries.push(entry);
              }
            };

            HashUpdateEntry._hashUpdateEntries = [];

            class HashTimerEntry {
              constructor(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
                this.timers = void 0;
                this.target = void 0;
                this.timerIndex = void 0;
                this.currentTimer = void 0;
                this.currentTimerSalvaged = void 0;
                this.paused = void 0;
                this.timers = timers;
                this.target = target;
                this.timerIndex = timerIndex;
                this.currentTimer = currentTimer;
                this.currentTimerSalvaged = currentTimerSalvaged;
                this.paused = paused;
              }

            }

            HashTimerEntry.get = (timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) => {
              let result = HashTimerEntry._hashTimerEntries.pop();

              if (result) {
                result.timers = timers;
                result.target = target;
                result.timerIndex = timerIndex;
                result.currentTimer = currentTimer;
                result.currentTimerSalvaged = currentTimerSalvaged;
                result.paused = paused;
              } else {
                result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
              }

              return result;
            };

            HashTimerEntry.put = entry => {
              if (HashTimerEntry._hashTimerEntries.length < MAX_POOL_SIZE$1) {
                entry.timers = entry.target = entry.currentTimer = null;

                HashTimerEntry._hashTimerEntries.push(entry);
              }
            };

            HashTimerEntry._hashTimerEntries = [];

            class CallbackTimer {
              constructor() {
                this._lock = void 0;
                this._scheduler = void 0;
                this._elapsed = void 0;
                this._runForever = void 0;
                this._useDelay = void 0;
                this._timesExecuted = void 0;
                this._repeat = void 0;
                this._delay = void 0;
                this._interval = void 0;
                this._target = void 0;
                this._callback = void 0;
                this._lock = false;
                this._scheduler = null;
                this._elapsed = -1;
                this._runForever = false;
                this._useDelay = false;
                this._timesExecuted = 0;
                this._repeat = 0;
                this._delay = 0;
                this._interval = 0;
                this._target = null;
                this._callback = null;
              }

              initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
                this._lock = false;
                this._scheduler = scheduler;
                this._target = target;
                this._callback = callback;
                this._elapsed = -1;
                this._interval = seconds;
                this._delay = delay;
                this._useDelay = this._delay > 0;
                this._repeat = repeat;
                this._runForever = this._repeat === legacyCC.macro.REPEAT_FOREVER;
                return true;
              }

              getInterval() {
                return this._interval;
              }

              setInterval(interval) {
                this._interval = interval;
              }

              update(dt) {
                if (this._elapsed === -1) {
                  this._elapsed = 0;
                  this._timesExecuted = 0;
                } else {
                  this._elapsed += dt;

                  if (this._runForever && !this._useDelay) {
                    if (this._elapsed >= this._interval) {
                      this.trigger();
                      this._elapsed = 0;
                    }
                  } else {
                    if (this._useDelay) {
                      if (this._elapsed >= this._delay) {
                        this.trigger();
                        this._elapsed -= this._delay;
                        this._timesExecuted += 1;
                        this._useDelay = false;
                      }
                    } else if (this._elapsed >= this._interval) {
                      this.trigger();
                      this._elapsed = 0;
                      this._timesExecuted += 1;
                    }

                    if (this._callback && !this._runForever && this._timesExecuted > this._repeat) {
                      this.cancel();
                    }
                  }
                }
              }

              getCallback() {
                return this._callback;
              }

              trigger() {
                if (this._target && this._callback) {
                  this._lock = true;

                  this._callback.call(this._target, this._elapsed);

                  this._lock = false;
                }
              }

              cancel() {
                this._scheduler.unschedule(this._callback, this._target);
              }

            }

            CallbackTimer._timers = [];

            CallbackTimer.get = () => CallbackTimer._timers.pop() || new CallbackTimer();

            CallbackTimer.put = timer => {
              if (CallbackTimer._timers.length < MAX_POOL_SIZE$1 && !timer._lock) {
                timer._scheduler = timer._target = timer._callback = null;

                CallbackTimer._timers.push(timer);
              }
            };

            class Scheduler extends System {
              static enableForTarget(target) {
                let found = false;

                if (target.uuid) {
                  found = true;
                } else if (target.id) {
                  found = true;
                }

                if (!found) {
                  if (target.__instanceId) {
                    warnID(1513);
                  } else {
                    target.id = idGenerator$3.getNewId();
                  }
                }
              }

              constructor() {
                super();
                this._timeScale = void 0;
                this._updatesNegList = void 0;
                this._updates0List = void 0;
                this._updatesPosList = void 0;
                this._hashForUpdates = void 0;
                this._hashForTimers = void 0;
                this._currentTarget = void 0;
                this._currentTargetSalvaged = void 0;
                this._updateHashLocked = void 0;
                this._arrayForTimers = void 0;
                this._timeScale = 1.0;
                this._updatesNegList = [];
                this._updates0List = [];
                this._updatesPosList = [];
                this._hashForUpdates = createMap(true);
                this._hashForTimers = createMap(true);
                this._currentTarget = null;
                this._currentTargetSalvaged = false;
                this._updateHashLocked = false;
                this._arrayForTimers = [];
              }

              setTimeScale(timeScale) {
                this._timeScale = timeScale;
              }

              getTimeScale() {
                return this._timeScale;
              }

              update(dt) {
                this._updateHashLocked = true;

                if (this._timeScale !== 1) {
                  dt *= this._timeScale;
                }

                let i;
                let list;
                let len;
                let entry;

                for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
                  entry = list[i];

                  if (!entry.paused && !entry.markedForDeletion) {
                    entry.target.update(dt);
                  }
                }

                for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
                  entry = list[i];

                  if (!entry.paused && !entry.markedForDeletion) {
                    entry.target.update(dt);
                  }
                }

                for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
                  entry = list[i];

                  if (!entry.paused && !entry.markedForDeletion) {
                    entry.target.update(dt);
                  }
                }

                let elt;
                const arr = this._arrayForTimers;

                for (i = 0; i < arr.length; i++) {
                  elt = arr[i];
                  this._currentTarget = elt;
                  this._currentTargetSalvaged = false;

                  if (!elt.paused) {
                    for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
                      elt.currentTimer = elt.timers[elt.timerIndex];
                      elt.currentTimerSalvaged = false;
                      elt.currentTimer.update(dt);
                      elt.currentTimer = null;
                    }
                  }

                  if (this._currentTargetSalvaged && this._currentTarget.timers.length === 0) {
                    this._removeHashElement(this._currentTarget);

                    --i;
                  }
                }

                for (i = 0, list = this._updatesNegList; i < list.length;) {
                  entry = list[i];

                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }

                for (i = 0, list = this._updates0List; i < list.length;) {
                  entry = list[i];

                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }

                for (i = 0, list = this._updatesPosList; i < list.length;) {
                  entry = list[i];

                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }

                this._updateHashLocked = false;
                this._currentTarget = null;
              }

              schedule(callback, target, interval, repeat, delay, paused) {
                if (typeof callback !== 'function') {
                  const tmp = callback;
                  callback = target;
                  target = tmp;
                }

                if (arguments.length === 3 || arguments.length === 4 || arguments.length === 5) {
                  paused = !!repeat;
                  repeat = legacyCC.macro.REPEAT_FOREVER;
                  delay = 0;
                }

                assertID(target, 1502);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                let element = this._hashForTimers[targetId];

                if (!element) {
                  element = HashTimerEntry.get(null, target, 0, null, null, paused);

                  this._arrayForTimers.push(element);

                  this._hashForTimers[targetId] = element;
                } else if (element.paused !== paused) {
                  warnID(1511);
                }

                let timer;
                let i;

                if (element.timers == null) {
                  element.timers = [];
                } else {
                  for (i = 0; i < element.timers.length; ++i) {
                    timer = element.timers[i];

                    if (timer && callback === timer._callback) {
                      logID(1507, timer.getInterval(), interval);
                      timer._interval = interval;
                      return;
                    }
                  }
                }

                timer = CallbackTimer.get();
                timer.initWithCallback(this, callback, target, interval, repeat, delay);
                element.timers.push(timer);

                if (this._currentTarget === element && this._currentTargetSalvaged) {
                  this._currentTargetSalvaged = false;
                }
              }

              scheduleUpdate(target, priority, paused) {
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const hashElement = this._hashForUpdates[targetId];

                if (hashElement && hashElement.entry) {
                  if (hashElement.entry.priority !== priority) {
                    if (this._updateHashLocked) {
                      logID(1506);
                      hashElement.entry.markedForDeletion = false;
                      hashElement.entry.paused = paused;
                      return;
                    } else {
                      this.unscheduleUpdate(target);
                    }
                  } else {
                    hashElement.entry.markedForDeletion = false;
                    hashElement.entry.paused = paused;
                    return;
                  }
                }

                const listElement = ListEntry.get(target, priority, paused, false);
                let ppList;

                if (priority === 0) {
                  ppList = this._updates0List;

                  this._appendIn(ppList, listElement);
                } else {
                  ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;

                  this._priorityIn(ppList, listElement, priority);
                }

                this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
              }

              unschedule(callback, target) {
                if (!target || !callback) {
                  return;
                }

                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  const timers = element.timers;

                  for (let i = 0, li = timers.length; i < li; i++) {
                    const timer = timers[i];

                    if (callback === timer._callback) {
                      if (timer === element.currentTimer && !element.currentTimerSalvaged) {
                        element.currentTimerSalvaged = true;
                      }

                      timers.splice(i, 1);
                      CallbackTimer.put(timer);

                      if (element.timerIndex >= i) {
                        element.timerIndex--;
                      }

                      if (timers.length === 0) {
                        if (this._currentTarget === element) {
                          this._currentTargetSalvaged = true;
                        } else {
                          this._removeHashElement(element);
                        }
                      }

                      return;
                    }
                  }
                }
              }

              unscheduleUpdate(target) {
                if (!target) {
                  return;
                }

                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForUpdates[targetId];

                if (element) {
                  if (this._updateHashLocked) {
                    element.entry.markedForDeletion = true;
                  } else {
                    this._removeUpdateFromHash(element.entry);
                  }
                }
              }

              unscheduleAllForTarget(target) {
                if (!target) {
                  return;
                }

                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  const timers = element.timers;

                  if (timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged) {
                    element.currentTimerSalvaged = true;
                  }

                  for (let i = 0, l = timers.length; i < l; i++) {
                    CallbackTimer.put(timers[i]);
                  }

                  timers.length = 0;

                  if (this._currentTarget === element) {
                    this._currentTargetSalvaged = true;
                  } else {
                    this._removeHashElement(element);
                  }
                }

                this.unscheduleUpdate(target);
              }

              unscheduleAll() {
                this.unscheduleAllWithMinPriority(System.Priority.SCHEDULER);
              }

              unscheduleAllWithMinPriority(minPriority) {
                let i;
                let element;
                const arr = this._arrayForTimers;

                for (i = arr.length - 1; i >= 0; i--) {
                  element = arr[i];
                  this.unscheduleAllForTarget(element.target);
                }

                let entry;
                let temp_length = 0;

                if (minPriority < 0) {
                  for (i = 0; i < this._updatesNegList.length;) {
                    temp_length = this._updatesNegList.length;
                    entry = this._updatesNegList[i];

                    if (entry && entry.priority >= minPriority) {
                      this.unscheduleUpdate(entry.target);
                    }

                    if (temp_length === this._updatesNegList.length) {
                      i++;
                    }
                  }
                }

                if (minPriority <= 0) {
                  for (i = 0; i < this._updates0List.length;) {
                    temp_length = this._updates0List.length;
                    entry = this._updates0List[i];

                    if (entry) {
                      this.unscheduleUpdate(entry.target);
                    }

                    if (temp_length === this._updates0List.length) {
                      i++;
                    }
                  }
                }

                for (i = 0; i < this._updatesPosList.length;) {
                  temp_length = this._updatesPosList.length;
                  entry = this._updatesPosList[i];

                  if (entry && entry.priority >= minPriority) {
                    this.unscheduleUpdate(entry.target);
                  }

                  if (temp_length === this._updatesPosList.length) {
                    i++;
                  }
                }
              }

              isScheduled(callback, target) {
                assertID(callback, 1508);
                assertID(target, 1509);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return false;
                }

                const element = this._hashForTimers[targetId];

                if (!element) {
                  return false;
                }

                if (element.timers == null) {
                  return false;
                } else {
                  const timers = element.timers;

                  for (let i = 0; i < timers.length; ++i) {
                    const timer = timers[i];

                    if (callback === timer._callback) {
                      return true;
                    }
                  }

                  return false;
                }
              }

              pauseAllTargets() {
                return this.pauseAllTargetsWithMinPriority(System.Priority.SCHEDULER);
              }

              pauseAllTargetsWithMinPriority(minPriority) {
                const idsWithSelectors = [];
                let element;
                const locArrayForTimers = this._arrayForTimers;
                let i;
                let li;

                for (i = 0, li = locArrayForTimers.length; i < li; i++) {
                  element = locArrayForTimers[i];

                  if (element) {
                    element.paused = true;
                    idsWithSelectors.push(element.target);
                  }
                }

                let entry;

                if (minPriority < 0) {
                  for (i = 0; i < this._updatesNegList.length; i++) {
                    entry = this._updatesNegList[i];

                    if (entry) {
                      if (entry.priority >= minPriority) {
                        entry.paused = true;
                        idsWithSelectors.push(entry.target);
                      }
                    }
                  }
                }

                if (minPriority <= 0) {
                  for (i = 0; i < this._updates0List.length; i++) {
                    entry = this._updates0List[i];

                    if (entry) {
                      entry.paused = true;
                      idsWithSelectors.push(entry.target);
                    }
                  }
                }

                for (i = 0; i < this._updatesPosList.length; i++) {
                  entry = this._updatesPosList[i];

                  if (entry) {
                    if (entry.priority >= minPriority) {
                      entry.paused = true;
                      idsWithSelectors.push(entry.target);
                    }
                  }
                }

                return idsWithSelectors;
              }

              resumeTargets(targetsToResume) {
                if (!targetsToResume) {
                  return;
                }

                for (let i = 0; i < targetsToResume.length; i++) {
                  this.resumeTarget(targetsToResume[i]);
                }
              }

              pauseTarget(target) {
                assertID(target, 1503);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  element.paused = true;
                }

                const elementUpdate = this._hashForUpdates[targetId];

                if (elementUpdate) {
                  elementUpdate.entry.paused = true;
                }
              }

              resumeTarget(target) {
                assertID(target, 1504);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  element.paused = false;
                }

                const elementUpdate = this._hashForUpdates[targetId];

                if (elementUpdate) {
                  elementUpdate.entry.paused = false;
                }
              }

              isTargetPaused(target) {
                assertID(target, 1505);
                const targetId = target.uuid || target.id;

                if (!targetId) {
                  errorID(1510);
                  return false;
                }

                const element = this._hashForTimers[targetId];

                if (element) {
                  return element.paused;
                }

                const elementUpdate = this._hashForUpdates[targetId];

                if (elementUpdate) {
                  return elementUpdate.entry.paused;
                }

                return false;
              }

              _removeHashElement(element) {
                const targetId = element.target.uuid || element.target.id;
                delete this._hashForTimers[targetId];
                const arr = this._arrayForTimers;

                for (let i = 0, l = arr.length; i < l; i++) {
                  if (arr[i] === element) {
                    arr.splice(i, 1);
                    break;
                  }
                }

                HashTimerEntry.put(element);
              }

              _removeUpdateFromHash(entry) {
                const targetId = entry.target.uuid || entry.target.id;
                const element = this._hashForUpdates[targetId];

                if (element) {
                  const list = element.list;
                  const listEntry = element.entry;

                  for (let i = 0, l = list.length; i < l; i++) {
                    if (list[i] === listEntry) {
                      list.splice(i, 1);
                      break;
                    }
                  }

                  delete this._hashForUpdates[targetId];
                  ListEntry.put(listEntry);
                  HashUpdateEntry.put(element);
                }
              }

              _priorityIn(ppList, listElement, priority) {
                for (let i = 0; i < ppList.length; i++) {
                  if (priority < ppList[i].priority) {
                    ppList.splice(i, 0, listElement);
                    return;
                  }
                }

                ppList.push(listElement);
              }

              _appendIn(ppList, listElement) {
                ppList.push(listElement);
              }

            } exports('fQ', Scheduler);
            Scheduler.ID = 'scheduler';
            legacyCC.Scheduler = Scheduler;

            const orientationMap$1 = {
              [Orientation.PORTRAIT]: SurfaceTransform.IDENTITY,
              [Orientation.LANDSCAPE_RIGHT]: SurfaceTransform.ROTATE_90,
              [Orientation.PORTRAIT_UPSIDE_DOWN]: SurfaceTransform.ROTATE_180,
              [Orientation.LANDSCAPE_LEFT]: SurfaceTransform.ROTATE_270
            };
            class RenderWindow {
              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              get swapchain() {
                return this._swapchain;
              }

              get framebuffer() {
                return this._framebuffer;
              }

              get cameras() {
                return this._cameras;
              }

              static registerCreateFunc(root) {
                root._createWindowFun = _root => new RenderWindow(_root);
              }

              get native() {
                return this._nativeObj;
              }

              constructor(root) {
                this._title = '';
                this._width = 1;
                this._height = 1;
                this._swapchain = null;
                this._renderPass = null;
                this._colorTextures = [];
                this._depthStencilTexture = null;
                this._cameras = [];
                this._hasOnScreenAttachments = false;
                this._hasOffScreenAttachments = false;
                this._framebuffer = null;
              }

              initialize(device, info) {
                this._init();

                if (info.title !== undefined) {
                  this._title = info.title;
                }

                if (info.swapchain !== undefined) {
                  this._swapchain = info.swapchain;
                }

                this._width = info.width;
                this._height = info.height;
                this._renderPass = device.createRenderPass(info.renderPassInfo);

                if (info.swapchain) {
                  this._setSwapchain(info.swapchain);

                  this._colorTextures.push(info.swapchain.colorTexture);

                  this._depthStencilTexture = info.swapchain.depthStencilTexture;
                } else {
                  for (let i = 0; i < info.renderPassInfo.colorAttachments.length; i++) {
                    this._colorTextures.push(device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.COLOR_ATTACHMENT | TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_SRC, info.renderPassInfo.colorAttachments[i].format, this._width, this._height)));
                  }

                  if (info.renderPassInfo.depthStencilAttachment.format !== Format.UNKNOWN) {
                    this._depthStencilTexture = device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.DEPTH_STENCIL_ATTACHMENT | TextureUsageBit.SAMPLED, info.renderPassInfo.depthStencilAttachment.format, this._width, this._height));
                  }
                }

                this._setFrameBuffer(device.createFramebuffer(new FramebufferInfo(this._renderPass, this._colorTextures, this._depthStencilTexture)));

                return true;
              }

              destroy() {
                this.clearCameras();

                if (this._framebuffer) {
                  this._framebuffer.destroy();

                  this._framebuffer = null;
                }

                if (this._depthStencilTexture) {
                  this._depthStencilTexture.destroy();

                  this._depthStencilTexture = null;
                }

                for (let i = 0; i < this._colorTextures.length; i++) {
                  const colorTexture = this._colorTextures[i];

                  if (colorTexture) {
                    colorTexture.destroy();
                  }
                }

                this._colorTextures.length = 0;

                this._destroy();
              }

              resize(width, height) {
                if (this._swapchain) {
                  this._swapchain.resize(width, height, orientationMap$1[screenAdapter.orientation]);

                  this._width = this._swapchain.width;
                  this._height = this._swapchain.height;
                } else {
                  for (let i = 0; i < this._colorTextures.length; i++) {
                    this._colorTextures[i].resize(width, height);
                  }

                  if (this._depthStencilTexture) {
                    this._depthStencilTexture.resize(width, height);
                  }

                  this._width = width;
                  this._height = height;
                }

                if (this.framebuffer) {
                  this.framebuffer.destroy();
                  this.framebuffer.initialize(new FramebufferInfo(this._renderPass, this._colorTextures, this._depthStencilTexture));
                }

                for (const camera of this._cameras) {
                  camera.resize(width, height);
                }
              }

              extractRenderCameras(cameras) {
                for (let j = 0; j < this._cameras.length; j++) {
                  const camera = this._cameras[j];

                  if (camera.enabled) {
                    camera.update();
                    cameras.push(camera);
                  }
                }
              }

              attachCamera(camera) {
                for (let i = 0; i < this._cameras.length; i++) {
                  if (this._cameras[i] === camera) {
                    return;
                  }
                }

                this._cameras.push(camera);

                this.sortCameras();
              }

              detachCamera(camera) {
                for (let i = 0; i < this._cameras.length; ++i) {
                  if (this._cameras[i] === camera) {
                    this._cameras.splice(i, 1);

                    return;
                  }
                }
              }

              clearCameras() {
                this._cameras.length = 0;
              }

              sortCameras() {
                this._cameras.sort((a, b) => a.priority - b.priority);
              }

              _init() {
                {
                  this._nativeObj = new NativeRenderWindow();
                }
              }

              _destroy() {
                {
                  this._nativeObj = null;
                }
              }

              _setSwapchain(val) {
                this._swapchain = val;

                {
                  this._nativeObj.swapchain = val;
                }
              }

              _setFrameBuffer(val) {
                this._framebuffer = val;

                {
                  this._nativeObj.frameBuffer = val;
                }
              }

            }

            class Root {
              _init() {
                {
                  this._naitveObj = new NativeRoot();
                }
              }

              _destroy() {
                {
                  this._naitveObj = null;
                }
              }

              _setCumulativeTime(deltaTime) {
                this._cumulativeTime += deltaTime;

                {
                  this._naitveObj.cumulativeTime = this._cumulativeTime;
                }
              }

              _setFrameTime(deltaTime) {
                this._frameTime = deltaTime;

                {
                  this._naitveObj.frameTime = deltaTime;
                }
              }

              get device() {
                return this._device;
              }

              get mainWindow() {
                return this._mainWindow;
              }

              set curWindow(window) {
                this._curWindow = window;
              }

              get curWindow() {
                return this._curWindow;
              }

              set tempWindow(window) {
                this._tempWindow = window;
              }

              get tempWindow() {
                return this._tempWindow;
              }

              get windows() {
                return this._windows;
              }

              get pipeline() {
                return this._pipeline;
              }

              get batcher2D() {
                return this._batcher;
              }

              get scenes() {
                return this._scenes;
              }

              get cumulativeTime() {
                return this._cumulativeTime;
              }

              get frameTime() {
                return this._frameTime;
              }

              get frameCount() {
                return this._frameCount;
              }

              get fps() {
                return this._fps;
              }

              set fixedFPS(fps) {
                if (fps > 0) {
                  this._fixedFPS = fps;
                  this._fixedFPSFrameTime = 1000.0 / fps;
                } else {
                  this._fixedFPSFrameTime = 0;
                }
              }

              get fixedFPS() {
                return this._fixedFPS;
              }

              get dataPoolManager() {
                return this._dataPoolMgr;
              }

              get useDeferredPipeline() {
                return this._useDeferredPipeline;
              }

              constructor(device) {
                this._createSceneFun = null;
                this._createWindowFun = null;
                this._device = void 0;
                this._windows = [];
                this._mainWindow = null;
                this._curWindow = null;
                this._tempWindow = null;
                this._pipeline = null;
                this._batcher = null;
                this._dataPoolMgr = void 0;
                this._scenes = [];
                this._modelPools = new Map();
                this._cameraPool = null;
                this._lightPools = new Map();
                this._fpsTime = 0;
                this._frameCount = 0;
                this._fps = 0;
                this._fixedFPS = 0;
                this._useDeferredPipeline = false;
                this._fixedFPSFrameTime = 0;
                this._cumulativeTime = 0;
                this._frameTime = 0;
                this._device = device;
                this._dataPoolMgr = legacyCC.internal.DataPoolManager && new legacyCC.internal.DataPoolManager(device);
                RenderScene.registerCreateFunc(this);
                RenderWindow.registerCreateFunc(this);
                this._cameraPool = new Pool(() => new Camera(this._device), 4, cam => cam.destroy());
              }

              initialize(info) {
                this._init();

                const swapchain = legacyCC.game._swapchain;
                const colorAttachment = new ColorAttachment();
                colorAttachment.format = swapchain.colorTexture.format;
                const depthStencilAttachment = new DepthStencilAttachment();
                depthStencilAttachment.format = swapchain.depthStencilTexture.format;
                depthStencilAttachment.depthStoreOp = StoreOp.DISCARD;
                depthStencilAttachment.stencilStoreOp = StoreOp.DISCARD;
                const renderPassInfo = new RenderPassInfo([colorAttachment], depthStencilAttachment);
                this._mainWindow = this.createWindow({
                  title: 'rootMainWindow',
                  width: swapchain.width,
                  height: swapchain.height,
                  renderPassInfo,
                  swapchain
                });
                this._curWindow = this._mainWindow;
                return Promise.resolve(builtinResMgr.initBuiltinRes(this._device));
              }

              destroy() {
                this.destroyScenes();

                if (this._pipeline) {
                  this._pipeline.destroy();

                  this._pipeline = null;
                }

                if (this._batcher) {
                  this._batcher.destroy();

                  this._batcher = null;
                }

                this._curWindow = null;
                this._mainWindow = null;
                this.dataPoolManager.clear();

                this._destroy();
              }

              resize(width, height) {
                for (const window of this._windows) {
                  if (window.swapchain) {
                    window.resize(width, height);
                  }
                }
              }

              setRenderPipeline(rppl) {
                if (rppl instanceof DeferredPipeline) {
                  this._useDeferredPipeline = true;
                }

                let isCreateDefaultPipeline = false;

                if (!rppl) {
                  rppl = createDefaultPipeline();
                  isCreateDefaultPipeline = true;
                }

                this._pipeline = rppl;

                if (!this._useDeferredPipeline || !this.device.hasFeature(Feature$1.COMPUTE_SHADER)) {
                  this._pipeline.clusterEnabled = false;
                }

                this._pipeline.bloomEnabled = false;

                if (!this._pipeline.activate(this._mainWindow.swapchain)) {
                  if (isCreateDefaultPipeline) {
                    this._pipeline.destroy();
                  }

                  this._pipeline = null;
                  return false;
                }

                const scene = legacyCC.director.getScene();

                if (scene) {
                  scene.globals.activate();
                }

                this.onGlobalPipelineStateChanged();

                if (!this._batcher && legacyCC.internal.Batcher2D) {
                  this._batcher = new legacyCC.internal.Batcher2D(this);

                  if (!this._batcher.initialize()) {
                    this.destroy();
                    return false;
                  }
                }

                return true;
              }

              onGlobalPipelineStateChanged() {
                for (let i = 0; i < this._scenes.length; i++) {
                  this._scenes[i].onGlobalPipelineStateChanged();
                }

                this._pipeline.pipelineSceneData.onGlobalPipelineStateChanged();
              }

              activeWindow(window) {
                this._curWindow = window;
              }

              resetCumulativeTime() {
                this._setCumulativeTime(0);
              }

              frameMove(deltaTime) {
                this._setFrameTime(deltaTime);

                ++this._frameCount;

                this._setCumulativeTime(deltaTime);

                this._fpsTime += deltaTime;

                if (this._fpsTime > 1.0) {
                  this._fps = this._frameCount;
                  this._frameCount = 0;
                  this._fpsTime = 0.0;
                }

                for (let i = 0; i < this._scenes.length; ++i) {
                  this._scenes[i].removeBatches();
                }

                if (this._batcher) this._batcher.update();
                const windows = this._windows;
                const cameraList = [];

                for (let i = 0; i < windows.length; i++) {
                  const window = windows[i];
                  window.extractRenderCameras(cameraList);
                }

                if (this._pipeline && cameraList.length > 0) {
                  this._device.acquire([legacyCC.game._swapchain]);

                  const scenes = this._scenes;
                  const stamp = legacyCC.director.getTotalFrames();
                  if (this._batcher) this._batcher.uploadBuffers();

                  for (let i = 0; i < scenes.length; i++) {
                    scenes[i].update(stamp);
                  }

                  legacyCC.director.emit(legacyCC.Director.EVENT_BEFORE_COMMIT);
                  cameraList.sort((a, b) => a.priority - b.priority);

                  this._pipeline.render(cameraList);

                  this._device.present();
                }

                if (this._batcher) this._batcher.reset();
              }

              createWindow(info) {
                const window = this._createWindowFun(this);

                window.initialize(this.device, info);

                this._windows.push(window);

                return window;
              }

              destroyWindow(window) {
                for (let i = 0; i < this._windows.length; ++i) {
                  if (this._windows[i] === window) {
                    window.destroy();

                    this._windows.splice(i, 1);

                    return;
                  }
                }
              }

              destroyWindows() {
                for (const window of this._windows) {
                  window.destroy();
                }

                this._windows.length = 0;
              }

              createScene(info) {
                const scene = this._createSceneFun(this);

                scene.initialize(info);

                this._scenes.push(scene);

                return scene;
              }

              destroyScene(scene) {
                for (let i = 0; i < this._scenes.length; ++i) {
                  if (this._scenes[i] === scene) {
                    scene.destroy();

                    this._scenes.splice(i, 1);

                    return;
                  }
                }
              }

              destroyScenes() {
                for (const scene of this._scenes) {
                  scene.destroy();
                }

                this._scenes.length = 0;
              }

              createModel(ModelCtor) {
                let p = this._modelPools.get(ModelCtor);

                if (!p) {
                  this._modelPools.set(ModelCtor, new Pool(() => new ModelCtor(), 10, obj => obj.destroy()));

                  p = this._modelPools.get(ModelCtor);
                }

                const model = p.alloc();
                model.initialize();
                return model;
              }

              destroyModel(m) {
                const p = this._modelPools.get(m.constructor);

                if (p) {
                  p.free(m);

                  if (m.scene) {
                    m.scene.removeModel(m);
                  }
                } else {
                  warnID(1300, m.constructor.name);
                }

                m.destroy();
              }

              createCamera() {
                return this._cameraPool.alloc();
              }

              createLight(LightCtor) {
                let l = this._lightPools.get(LightCtor);

                if (!l) {
                  this._lightPools.set(LightCtor, new Pool(() => new LightCtor(), 4, obj => obj.destroy()));

                  l = this._lightPools.get(LightCtor);
                }

                const light = l.alloc();
                light.initialize();
                return light;
              }

              destroyLight(l) {
                const p = this._lightPools.get(l.constructor);

                if (p) {
                  p.free(l);

                  if (l.scene) {
                    switch (l.type) {
                      case LightType.SPHERE:
                        l.scene.removeSphereLight(l);
                        break;

                      case LightType.SPOT:
                        l.scene.removeSpotLight(l);
                        break;
                    }
                  }
                }

                l.destroy();
              }

            }
            legacyCC.Root = Root;

            class Game extends EventTarget {
              constructor(...args) {
                super(...args);
                this.frame = null;
                this.container = null;
                this.canvas = null;
                this.renderType = -1;
                this.eventTargetOn = super.on;
                this.eventTargetOnce = super.once;
                this.config = {};
                this.onStart = null;
                this.frameTime = 1000 / 60;
                this.collisionMatrix = [];
                this.groupList = [];
                this._persistRootNodes = {};
                this._gfxDevice = null;
                this._swapchain = null;
                this._configLoaded = false;
                this._isCloning = false;
                this._inited = false;
                this._engineInited = false;
                this._rendererInitialized = false;
                this._paused = true;
                this._frameRate = 60;
                this._intervalId = 0;
                this._initTime = 0;
                this._startTime = 0;
                this._deltaTime = 0.0;
              }

              get inited() {
                return this._inited;
              }

              get frameRate() {
                return this._frameRate;
              }

              set frameRate(frameRate) {
                if (typeof frameRate !== 'number') {
                  frameRate = parseInt(frameRate, 10);

                  if (Number.isNaN(frameRate)) {
                    frameRate = 60;
                  }
                }

                this._frameRate = frameRate;
                this.frameTime = 1000 / frameRate;

                this._setAnimFrame();
              }

              get deltaTime() {
                return this._deltaTime;
              }

              get totalTime() {
                return performance.now() - this._initTime;
              }

              get frameStartTime() {
                return this._startTime;
              }

              setFrameRate(frameRate) {
                this.frameRate = frameRate;
              }

              getFrameRate() {
                return this.frameRate;
              }

              step() {
                legacyCC.director.tick(this.frameTime / 1000);
              }

              pause() {
                if (this._paused) {
                  return;
                }

                this._paused = true;

                if (this._intervalId) {
                  window.cAF(this._intervalId);
                  this._intervalId = 0;
                }
              }

              resume() {
                if (!this._paused) {
                  return;
                }

                input._clearEvents();

                if (this._intervalId) {
                  window.cAF(this._intervalId);
                  this._intervalId = 0;
                }

                this._paused = false;

                this._updateCallback();

                this._intervalId = window.rAF(this._frameCB);
              }

              isPaused() {
                return this._paused;
              }

              restart() {
                const endFramePromise = new Promise(resolve => legacyCC.director.once(legacyCC.Director.EVENT_END_FRAME, () => resolve()));
                return endFramePromise.then(() => {
                  for (const id in this._persistRootNodes) {
                    this.removePersistRootNode(this._persistRootNodes[id]);
                  }

                  legacyCC.director.getScene().destroy();

                  legacyCC.Object._deferredDestroy();

                  legacyCC.director.reset();
                  legacyCC.profiler.reset();
                  this.pause();
                  return this._setRenderPipelineNShowSplash().then(() => {
                    this.resume();

                    this._safeEmit(Game.EVENT_RESTART);
                  });
                });
              }

              end() {
                systemInfo.close();
              }

              on(type, callback, target, once) {
                if (this._engineInited && type === Game.EVENT_ENGINE_INITED || this._inited && type === Game.EVENT_GAME_INITED || this._rendererInitialized && type === Game.EVENT_RENDERER_INITED) {
                  callback.call(target);
                }

                return this.eventTargetOn(type, callback, target, once);
              }

              once(type, callback, target) {
                if (this._engineInited && type === Game.EVENT_ENGINE_INITED) {
                  return callback.call(target);
                }

                return this.eventTargetOnce(type, callback, target);
              }

              init(config) {
                this._initConfig(config);

                if (this.config.assetOptions) {
                  legacyCC.assetManager.init(this.config.assetOptions);
                }

                if (this.config.layers) {
                  const userLayers = this.config.layers;

                  for (let i = 0; i < userLayers.length; i++) {
                    const layer = userLayers[i];
                    const bitNum = log2(layer.value);
                    Layers.addLayer(layer.name, bitNum);
                  }
                }

                return this._initEngine().then(() => {
                  {
                    this._initEvents();
                  }

                  if (legacyCC.director.root && legacyCC.director.root.dataPoolManager) {
                    legacyCC.director.root.dataPoolManager.jointTexturePool.registerCustomTextureLayouts(config.customJointTextureLayouts);
                  }

                  return this._engineInited;
                });
              }

              run(configOrCallback, onStart) {
                let initPromise;

                if (typeof configOrCallback !== 'function' && configOrCallback) {
                  initPromise = this.init(configOrCallback);
                  this.onStart = onStart !== null && onStart !== void 0 ? onStart : null;
                } else {
                  this.onStart = configOrCallback !== null && configOrCallback !== void 0 ? configOrCallback : null;
                }

                garbageCollectionManager.init();
                return Promise.resolve(initPromise).then(() => this._setRenderPipelineNShowSplash()).then(() => {
                  {
                    screen._init({
                      configOrientation: 'auto',
                      exactFitScreen: true
                    });
                  }
                });
              }

              addPersistRootNode(node) {
                if (!legacyCC.Node.isNode(node) || !node.uuid) {
                  warnID(3800);
                  return;
                }

                const id = node.uuid;

                if (!this._persistRootNodes[id]) {
                  const scene = legacyCC.director._scene;

                  if (legacyCC.isValid(scene)) {
                    if (!node.parent) {
                      node.parent = scene;
                    } else if (!(node.parent instanceof legacyCC.Scene)) {
                      warnID(3801);
                      return;
                    } else if (node.parent !== scene) {
                      warnID(3802);
                      return;
                    } else {
                      node._originalSceneId = scene.uuid;
                    }
                  }

                  this._persistRootNodes[id] = node;
                  node._persistNode = true;

                  legacyCC.assetManager._releaseManager._addPersistNodeRef(node);
                }
              }

              removePersistRootNode(node) {
                const id = node.uuid || '';

                if (node === this._persistRootNodes[id]) {
                  delete this._persistRootNodes[id];
                  node._persistNode = false;
                  node._originalSceneId = '';

                  legacyCC.assetManager._releaseManager._removePersistNodeRef(node);
                }
              }

              isPersistRootNode(node) {
                return !!node._persistNode;
              }

              _initEngine() {
                this._initDevice();

                const director = legacyCC.director;
                return Promise.resolve(director._init()).then(() => {
                  legacyCC.view.init();
                  log(`Cocos Creator v${engineVersion}`);
                  this.emit(Game.EVENT_ENGINE_INITED);
                  this._engineInited = true;

                  if (legacyCC.internal.dynamicAtlasManager) {
                    legacyCC.internal.dynamicAtlasManager.enabled = !macro.CLEANUP_IMAGE_CACHE;
                  }
                });
              }

              _setAnimFrame() {
                const frameRate = this._frameRate;

                {
                  jsb.setPreferredFramesPerSecond(frameRate);
                  window.rAF = window.requestAnimationFrame;
                  window.cAF = window.cancelAnimationFrame;
                }
              }

              _stTime(callback) {
                const currTime = performance.now();
                const elapseTime = Math.max(0, currTime - this._startTime);
                const timeToCall = Math.max(0, this.frameTime - elapseTime);
                const id = window.setTimeout(callback, timeToCall);
                return id;
              }

              _ctTime(id) {
                window.clearTimeout(id);
              }

              _calculateDT(now) {
                if (!now) now = performance.now();
                this._deltaTime = now > this._startTime ? (now - this._startTime) / 1000 : 0;

                if (this._deltaTime > Game.DEBUG_DT_THRESHOLD) {
                  this._deltaTime = this.frameTime / 1000;
                }

                this._startTime = now;
                return this._deltaTime;
              }

              _updateCallback() {
                const director = legacyCC.director;
                let callback;

                {
                  callback = time => {
                    director.tick(this._calculateDT(time));
                    this._intervalId = window.rAF(this._frameCB);
                  };
                }

                this._frameCB = callback;
              }

              _runMainLoop() {
                if (!this._inited || EDITOR ) {
                  return;
                }

                const config = this.config;
                const director = legacyCC.director;
                setDisplayStats(!!config.showFPS);
                director.startAnimation();
                this.resume();
              }

              _initConfig(config) {
                if (typeof config.debugMode !== 'number') {
                  config.debugMode = DebugMode.NONE;
                }

                config.exposeClassName = !!config.exposeClassName;

                if (typeof config.frameRate !== 'number') {
                  config.frameRate = 60;
                }

                const renderMode = config.renderMode;

                if (typeof renderMode !== 'number' || renderMode > 3 || renderMode < 0) {
                  config.renderMode = 0;
                }

                config.showFPS = !!config.showFPS;

                _resetDebugSetting(config.debugMode);

                this.config = config;
                this._configLoaded = true;
                this.frameRate = config.frameRate;
              }

              _determineRenderType() {
                const config = this.config;
                const userRenderMode = parseInt(config.renderMode, 10);
                this.renderType = Game.RENDER_TYPE_CANVAS;
                let supportRender = false;

                if (userRenderMode === 1) {
                  this.renderType = Game.RENDER_TYPE_CANVAS;
                  supportRender = true;
                } else if (userRenderMode === 0 || userRenderMode === 2) {
                  this.renderType = Game.RENDER_TYPE_WEBGL;
                  supportRender = true;
                } else if (userRenderMode === 3) {
                  this.renderType = Game.RENDER_TYPE_HEADLESS;
                  supportRender = true;
                }

                if (!supportRender) {
                  throw new Error(getError(3820, userRenderMode));
                }
              }

              _initDevice() {
                if (this._rendererInitialized) {
                  return;
                }

                const adapter = this.config.adapter;

                if (adapter) {
                  this.canvas = adapter.canvas;
                  this.frame = adapter.frame;
                  this.container = adapter.container;
                }

                this._determineRenderType();

                if (this.renderType === Game.RENDER_TYPE_WEBGL) {
                  const deviceInfo = new DeviceInfo(bindingMappingInfo);

                  if ( window.gfx) {
                    this._gfxDevice = gfx.DeviceManager.create(deviceInfo);
                  } else {
                    let useWebGL2 = !!window.WebGL2RenderingContext;
                    const userAgent = window.navigator.userAgent.toLowerCase();

                    if (userAgent.indexOf('safari') !== -1 && userAgent.indexOf('chrome') === -1 || sys.browserType === BrowserType.UC) {
                        useWebGL2 = false;
                      }

                    const deviceCtors = [];

                    if (useWebGL2 && legacyCC.WebGL2Device) {
                      deviceCtors.push(legacyCC.WebGL2Device);
                    }

                    if (legacyCC.WebGLDevice) {
                      deviceCtors.push(legacyCC.WebGLDevice);
                    }

                    if (legacyCC.EmptyDevice) {
                      deviceCtors.push(legacyCC.EmptyDevice);
                    }

                    Device.canvas = this.canvas;

                    for (let i = 0; i < deviceCtors.length; i++) {
                      this._gfxDevice = new deviceCtors[i]();

                      if (this._gfxDevice.initialize(deviceInfo)) {
                        break;
                      }
                    }
                  }
                } else if (this.renderType === Game.RENDER_TYPE_HEADLESS && legacyCC.EmptyDevice) {
                  this._gfxDevice = new legacyCC.EmptyDevice();

                  this._gfxDevice.initialize(new DeviceInfo(bindingMappingInfo));
                }

                if (!this._gfxDevice) {
                  error('can not support canvas rendering in 3D');
                  this.renderType = Game.RENDER_TYPE_CANVAS;
                  return;
                }

                const swapchainInfo = new SwapchainInfo(this.canvas);
                const windowSize = screen.windowSize;
                swapchainInfo.width = windowSize.width;
                swapchainInfo.height = windowSize.height;
                this._swapchain = this._gfxDevice.createSwapchain(swapchainInfo);

                this.canvas.oncontextmenu = () => false;
              }

              _initEvents() {
                systemInfo.on('show', this._onShow, this);
                systemInfo.on('hide', this._onHide, this);
              }

              _onHide() {
                this.emit(Game.EVENT_HIDE);
                this.pause();
              }

              _onShow() {
                this.emit(Game.EVENT_SHOW);
                this.resume();
              }

              _setRenderPipelineNShowSplash() {
                return Promise.resolve(this._setupRenderPipeline()).then(() => Promise.resolve(this._showSplashScreen()).then(() => {
                  this._inited = true;
                  this._initTime = performance.now();

                  this._runMainLoop();

                  this._safeEmit(Game.EVENT_GAME_INITED);

                  if (this.onStart) {
                    this.onStart();
                  }
                }));
              }

              _setupRenderPipeline() {
                const {
                  renderPipeline
                } = this.config;

                if (!renderPipeline) {
                  return this._setRenderPipeline();
                }

                return new Promise((resolve, reject) => {
                  legacyCC.assetManager.loadAny(renderPipeline, (err, asset) => err || !(asset instanceof RenderPipeline$1) ? reject(err) : resolve(asset));
                }).then(asset => {
                  this._setRenderPipeline(asset);
                }).catch(reason => {
                  warn(reason);
                  warn(`Failed load render pipeline: ${renderPipeline}, engine failed to initialize, will fallback to default pipeline`);

                  this._setRenderPipeline();
                });
              }

              _showSplashScreen() {
                if ( legacyCC.internal.SplashScreen) {
                  const splashScreen = legacyCC.internal.SplashScreen.instance;
                  splashScreen.main(legacyCC.director.root);
                  return new Promise(resolve => {
                    splashScreen.setOnFinish(() => resolve());
                    splashScreen.loadFinish = true;
                  });
                }

                return null;
              }

              _setRenderPipeline(rppl) {
                if (!legacyCC.director.root.setRenderPipeline(rppl)) {
                  this._setRenderPipeline();
                }

                this._rendererInitialized = true;

                this._safeEmit(Game.EVENT_RENDERER_INITED);
              }

              _safeEmit(event) {
                {
                  this.emit(event);
                }
              }

            } exports('dD', Game);
            Game.EVENT_HIDE = 'game_on_hide';
            Game.EVENT_SHOW = 'game_on_show';
            Game.EVENT_LOW_MEMORY = 'game_on_low_memory';
            Game.EVENT_GAME_INITED = 'game_inited';
            Game.EVENT_ENGINE_INITED = 'engine_inited';
            Game.EVENT_RENDERER_INITED = 'renderer_inited';
            Game.EVENT_RESTART = 'game_on_restart';
            Game.RENDER_TYPE_CANVAS = 0;
            Game.RENDER_TYPE_WEBGL = 1;
            Game.RENDER_TYPE_OPENGL = 2;
            Game.RENDER_TYPE_HEADLESS = 3;
            Game.DEBUG_DT_THRESHOLD = 1;
            legacyCC.Game = Game;
            const game = exports('dC', legacyCC.game = new Game());

            class Director extends EventTarget {
              constructor() {
                super();
                this._compScheduler = void 0;
                this._nodeActivator = void 0;
                this._invalid = void 0;
                this._paused = void 0;
                this._root = void 0;
                this._loadingScene = void 0;
                this._scene = void 0;
                this._totalFrames = void 0;
                this._scheduler = void 0;
                this._systems = void 0;
                this._invalid = false;
                this._paused = false;
                this._root = null;
                this._loadingScene = '';
                this._scene = null;
                this._totalFrames = 0;
                this._scheduler = new Scheduler();
                this._compScheduler = new ComponentScheduler();
                this._nodeActivator = new NodeActivator();
                this._systems = [];
                game.once(Game.EVENT_RENDERER_INITED, this._initOnRendererInitialized, this);
              }

              calculateDeltaTime(now) {}

              end() {
                this.once(Director.EVENT_END_FRAME, () => {
                  this.purgeDirector();
                });
              }

              pause() {
                if (this._paused) {
                  return;
                }

                this._paused = true;
              }

              purgeDirector() {
                this._scheduler.unscheduleAll();

                this._compScheduler.unscheduleAll();

                this._nodeActivator.reset();

                {
                  if (legacyCC.isValid(this._scene)) {
                    this._scene.destroy();
                  }

                  this._scene = null;
                }

                this.stopAnimation();
                legacyCC.assetManager.releaseAll();
              }

              reset() {
                this.purgeDirector();
                this.emit(Director.EVENT_RESET);
                this.startAnimation();
              }

              runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
                if (scene instanceof SceneAsset) scene = scene.scene;
                assertID(scene instanceof Scene, 1216);

                {
                  console.time('InitScene');
                }

                scene._load();

                {
                  console.timeEnd('InitScene');
                }

                {
                  console.time('AttachPersist');
                }

                const persistNodeList = Object.keys(game._persistRootNodes).map(x => game._persistRootNodes[x]);

                for (let i = 0; i < persistNodeList.length; i++) {
                  const node = persistNodeList[i];
                  node.emit(legacyCC.Node.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
                  const existNode = scene.uuid === node._originalSceneId && scene.getChildByUuid(node.uuid);

                  if (existNode) {
                    const index = existNode.getSiblingIndex();

                    existNode._destroyImmediate();

                    scene.insertChild(node, index);
                  } else {
                    node.parent = scene;
                  }
                }

                {
                  console.timeEnd('AttachPersist');
                }

                const oldScene = this._scene;

                {
                  console.time('Destroy');
                }

                if (legacyCC.isValid(oldScene)) {
                  oldScene.destroy();
                }

                {
                  {
                    console.time('AutoRelease');
                  }

                  legacyCC.assetManager._releaseManager._autoRelease(oldScene, scene, game._persistRootNodes);

                  {
                    console.timeEnd('AutoRelease');
                  }
                }

                this._scene = null;

                CCObject._deferredDestroy();

                {
                  console.timeEnd('Destroy');
                }

                if (onBeforeLoadScene) {
                  onBeforeLoadScene();
                }

                this.emit(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
                this._scene = scene;

                {
                  console.time('Activate');
                }

                scene._activate();

                {
                  console.timeEnd('Activate');
                }

                if (this._root) {
                  this._root.resetCumulativeTime();
                }

                this.startAnimation();

                if (onLaunched) {
                  onLaunched(null, scene);
                }

                this.emit(legacyCC.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
              }

              runScene(scene, onBeforeLoadScene, onLaunched) {
                if (scene instanceof SceneAsset) scene = scene.scene;
                assertID(scene, 1205);
                assertID(scene instanceof Scene, 1216);

                scene._load();

                this.once(legacyCC.Director.EVENT_END_FRAME, () => {
                  this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
                });
              }

              loadScene(sceneName, onLaunched, onUnloaded) {
                if (this._loadingScene) {
                  warnID(1208, sceneName, this._loadingScene);
                  return false;
                }

                const bundle = legacyCC.assetManager.bundles.find(bundle => {
                    console.error('pptest load scene ' + bundle.name)
                    return !!bundle.getSceneInfo(sceneName)
                });

                if (bundle) {
                  this.emit(legacyCC.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
                  this._loadingScene = sceneName;
                  console.time(`LoadScene ${sceneName}`);
                  bundle.loadScene(sceneName, (err, scene) => {
                    console.timeEnd(`LoadScene ${sceneName}`);
                    this._loadingScene = '';

                    if (err) {
                      error(err);

                      if (onLaunched) {
                        onLaunched(err);
                      }
                    } else {
                      this.runSceneImmediate(scene, onUnloaded, onLaunched);
                    }
                  });
                  return true;
                } else {
                  errorID(1209, sceneName);
                  return false;
                }
              }

              preloadScene(sceneName, onProgress, onLoaded) {
                const bundle = legacyCC.assetManager.bundles.find(bundle => !!bundle.getSceneInfo(sceneName));

                if (bundle) {
                  bundle.preloadScene(sceneName, null, onProgress, onLoaded);
                } else {
                  const err = `Can not preload the scene "${sceneName}" because it is not in the build settings.`;

                  if (onLoaded) {
                    onLoaded(new Error(err));
                  }

                  error(`preloadScene: ${err}`);
                }
              }

              resume() {
                if (!this._paused) {
                  return;
                }

                this._paused = false;
              }

              get root() {
                return this._root;
              }

              getScene() {
                return this._scene;
              }

              getDeltaTime() {
                return game.deltaTime;
              }

              getTotalTime() {
                return game.totalTime;
              }

              getCurrentTime() {
                return game.frameStartTime;
              }

              getTotalFrames() {
                return this._totalFrames;
              }

              isPaused() {
                return this._paused;
              }

              getScheduler() {
                return this._scheduler;
              }

              setScheduler(scheduler) {
                if (this._scheduler !== scheduler) {
                  this.unregisterSystem(this._scheduler);
                  this._scheduler = scheduler;
                  this.registerSystem(Scheduler.ID, scheduler, 200);
                }
              }

              registerSystem(name, sys, priority) {
                sys.id = name;
                sys.priority = priority;
                sys.init();

                this._systems.push(sys);

                this._systems.sort(System.sortByPriority);
              }

              unregisterSystem(sys) {
                array.fastRemove(this._systems, sys);

                this._systems.sort(System.sortByPriority);
              }

              getSystem(name) {
                return this._systems.find(sys => sys.id === name);
              }

              getAnimationManager() {
                return this.getSystem(legacyCC.AnimationManager.ID);
              }

              startAnimation() {
                this._invalid = false;
              }

              stopAnimation() {
                this._invalid = true;
              }

              mainLoop(now) {
                let dt;

                {
                  dt = game._calculateDT(now);
                }

                this.tick(dt);
              }

              tick(dt) {
                if (!this._invalid) {
                  this.emit(Director.EVENT_BEGIN_FRAME);

                  {
                    input._frameDispatchEvents();
                  }

                  if (!this._paused) {
                    this.emit(Director.EVENT_BEFORE_UPDATE);

                    this._compScheduler.startPhase();

                    this._compScheduler.updatePhase(dt);

                    for (let i = 0; i < this._systems.length; ++i) {
                      this._systems[i].update(dt);
                    }

                    this._compScheduler.lateUpdatePhase(dt);

                    this.emit(Director.EVENT_AFTER_UPDATE);

                    CCObject._deferredDestroy();

                    for (let i = 0; i < this._systems.length; ++i) {
                      this._systems[i].postUpdate(dt);
                    }
                  }

                  this.emit(Director.EVENT_BEFORE_DRAW);

                  this._root.frameMove(dt);

                  this.emit(Director.EVENT_AFTER_DRAW);
                  Node$1.resetHasChangedFlags();
                  Node$1.clearNodeArray();
                  containerManager.update(dt);
                  this.emit(Director.EVENT_END_FRAME);
                  this._totalFrames++;
                }
              }

              _initOnRendererInitialized() {
                this._totalFrames = 0;
                this._paused = false;
                this.registerSystem(Scheduler.ID, this._scheduler, 200);
                this.emit(Director.EVENT_INIT);
              }

              _init() {
                this._root = new Root(game._gfxDevice);
                const rootInfo = {};
                return this._root.initialize(rootInfo).catch(error => {
                  errorID(1217);
                  return Promise.reject(error);
                });
              }

            } exports('cn', Director);
            Director.EVENT_INIT = 'director_init';
            Director.EVENT_RESET = 'director_reset';
            Director.EVENT_BEFORE_SCENE_LOADING = 'director_before_scene_loading';
            Director.EVENT_BEFORE_SCENE_LAUNCH = 'director_before_scene_launch';
            Director.EVENT_AFTER_SCENE_LAUNCH = 'director_after_scene_launch';
            Director.EVENT_BEFORE_UPDATE = 'director_before_update';
            Director.EVENT_AFTER_UPDATE = 'director_after_update';
            Director.EVENT_BEFORE_DRAW = 'director_before_draw';
            Director.EVENT_AFTER_DRAW = 'director_after_draw';
            Director.EVENT_BEFORE_COMMIT = 'director_before_commit';
            Director.EVENT_BEFORE_PHYSICS = 'director_before_physics';
            Director.EVENT_AFTER_PHYSICS = 'director_after_physics';
            Director.EVENT_BEGIN_FRAME = 'director_begin_frame';
            Director.EVENT_END_FRAME = 'director_end_frame';
            Director.instance = void 0;
            legacyCC.Director = Director;
            const director = exports('cm', Director.instance = legacyCC.director = new Director());

            const vmath = {};
            replaceProperty(vmath, 'vmath', [{
              name: 'vec2',
              newName: 'Vec2',
              target: math,
              targetName: 'math'
            }, {
              name: 'vec3',
              newName: 'Vec3',
              target: math,
              targetName: 'math'
            }, {
              name: 'vec4',
              newName: 'Vec4',
              target: math,
              targetName: 'math'
            }, {
              name: 'quat',
              newName: 'Quat',
              target: math,
              targetName: 'math'
            }, {
              name: 'mat3',
              newName: 'Mat3',
              target: math,
              targetName: 'math'
            }, {
              name: 'mat4',
              newName: 'Mat4',
              target: math,
              targetName: 'math'
            }, {
              name: 'color4',
              newName: 'Color',
              target: math,
              targetName: 'math'
            }, {
              name: 'rect',
              newName: 'Rect',
              target: math,
              targetName: 'math'
            }, {
              name: 'approx',
              newName: 'approx',
              target: math,
              targetName: 'math'
            }, {
              name: 'EPSILON',
              newName: 'EPSILON',
              target: math,
              targetName: 'math'
            }, {
              name: 'equals',
              newName: 'equals',
              target: math,
              targetName: 'math'
            }, {
              name: 'clamp',
              newName: 'clamp',
              target: math,
              targetName: 'math'
            }, {
              name: 'clamp01',
              newName: 'clamp01',
              target: math,
              targetName: 'math'
            }, {
              name: 'lerp',
              newName: 'lerp',
              target: math,
              targetName: 'math'
            }, {
              name: 'toRadian',
              newName: 'toRadian',
              target: math,
              targetName: 'math'
            }, {
              name: 'toDegree',
              newName: 'toDegree',
              target: math,
              targetName: 'math'
            }, {
              name: 'random',
              newName: 'random',
              target: math,
              targetName: 'math'
            }, {
              name: 'randomRange',
              newName: 'randomRange',
              target: math,
              targetName: 'math'
            }, {
              name: 'randomRangeInt',
              newName: 'randomRangeInt',
              target: math,
              targetName: 'math'
            }, {
              name: 'pseudoRandom',
              newName: 'pseudoRandom',
              target: math,
              targetName: 'math'
            }, {
              name: 'pseudoRandomRangeInt',
              newName: 'pseudoRandomRangeInt',
              target: math,
              targetName: 'math'
            }, {
              name: 'nextPow2',
              newName: 'nextPow2',
              target: math,
              targetName: 'math'
            }, {
              name: 'repeat',
              newName: 'repeat',
              target: math,
              targetName: 'math'
            }, {
              name: 'pingPong',
              newName: 'pingPong',
              target: math,
              targetName: 'math'
            }, {
              name: 'inverseLerp',
              newName: 'inverseLerp',
              target: math,
              targetName: 'math'
            }]);
            legacyCC.vmath = vmath;
            replaceProperty(Scheduler.prototype, 'Scheduler.prototype', [{
              name: 'enableForTarget',
              newName: 'enableForTarget',
              target: Scheduler,
              targetName: 'Scheduler'
            }]);
            replaceProperty(Scheduler, 'Scheduler', [{
              name: 'PRIORITY_SYSTEM',
              newName: 'System.Priority.SCHEDULER',

              customGetter() {
                return System.Priority.SCHEDULER;
              }

            }]);
            removeProperty(Scheduler, 'Scheduler', [{
              name: 'PRIORITY_NON_SYSTEM',
              suggest: 'Use enum` System.Priority` instead'
            }]);
            replaceProperty(SubModel.prototype, 'SubModel.prototype', [{
              name: 'subMeshData',
              newName: 'subMesh'
            }]);
            removeProperty(SubModel.prototype, 'SubModel.prototype', [{
              name: 'getSubModel',
              suggest: 'Use `subModels[i]` instead'
            }, {
              name: 'subModelNum',
              suggest: 'Use `subModels.length` instead'
            }]);
            replaceProperty(Root.prototype, 'Root.prototype', [{
              name: 'ui',
              newName: 'batcher2D'
            }]);
            markAsWarning(game, 'game', [{
              name: 'collisionMatrix'
            }, {
              name: 'groupList'
            }]);
            markAsWarning(Director.prototype, 'director', [{
              name: 'calculateDeltaTime'
            }, {
              name: 'getDeltaTime',
              suggest: 'Use game.deltaTime instead'
            }, {
              name: 'getTotalTime',
              suggest: 'Use game.totalTime instead'
            }, {
              name: 'getCurrentTime',
              suggest: 'Use game.frameStartTime instead'
            }]);
            removeProperty(Director.prototype, 'director', [{
              name: 'setAnimationInterval',
              suggest: 'please use game.frameRate instead'
            }, {
              name: 'getAnimationInterval',
              suggest: 'please use game.frameRate instead'
            }, {
              name: 'getRunningScene',
              suggest: 'please use getScene instead'
            }, {
              name: 'setDepthTest',
              suggest: 'please use camera API instead'
            }, {
              name: 'setClearColor',
              suggest: 'please use camera API instead'
            }, {
              name: 'getWinSize',
              suggest: 'please use view.getVisibleSize instead'
            }, {
              name: 'getWinSizeInPixels'
            }, {
              name: 'purgeCachedData',
              suggest: 'please use assetManager.releaseAll instead'
            }, {
              name: 'convertToGL'
            }, {
              name: 'convertToUI'
            }]);

            const visibleRect = exports('e5', {
              topLeft: legacyCC.v2(0, 0),
              topRight: legacyCC.v2(0, 0),
              top: legacyCC.v2(0, 0),
              bottomLeft: legacyCC.v2(0, 0),
              bottomRight: legacyCC.v2(0, 0),
              bottom: legacyCC.v2(0, 0),
              center: legacyCC.v2(0, 0),
              left: legacyCC.v2(0, 0),
              right: legacyCC.v2(0, 0),
              width: 0,
              height: 0,

              init(visibleRect_) {
                const w = this.width = visibleRect_.width;
                const h = this.height = visibleRect_.height;
                const l = visibleRect_.x;
                const b = visibleRect_.y;
                const t = b + h;
                const r = l + w;
                this.topLeft.x = l;
                this.topLeft.y = t;
                this.topRight.x = r;
                this.topRight.y = t;
                this.top.x = l + w / 2;
                this.top.y = t;
                this.bottomLeft.x = l;
                this.bottomLeft.y = b;
                this.bottomRight.x = r;
                this.bottomRight.y = b;
                this.bottom.x = l + w / 2;
                this.bottom.y = b;
                this.center.x = l + w / 2;
                this.center.y = b + h / 2;
                this.left.x = l;
                this.left.y = b + h / 2;
                this.right.x = r;
                this.right.y = b + h / 2;
              }

            });
            legacyCC.visibleRect = visibleRect;

            const localWinSize = new Size();
            const orientationMap$2 = {
              [macro.ORIENTATION_AUTO]: Orientation.AUTO,
              [macro.ORIENTATION_LANDSCAPE]: Orientation.LANDSCAPE,
              [macro.ORIENTATION_PORTRAIT]: Orientation.PORTRAIT
            };
            class View extends EventTarget {
              constructor() {
                super();
                this._designResolutionSize = void 0;
                this._scaleX = void 0;
                this._scaleY = void 0;
                this._viewportRect = void 0;
                this._visibleRect = void 0;
                this._autoFullScreen = void 0;
                this._retinaEnabled = void 0;
                this._resizeCallback = void 0;
                this._resolutionPolicy = void 0;
                this._rpExactFit = void 0;
                this._rpShowAll = void 0;
                this._rpNoBorder = void 0;
                this._rpFixedHeight = void 0;
                this._rpFixedWidth = void 0;
                const _strategyer = ContainerStrategy;
                const _strategy = ContentStrategy;
                this._designResolutionSize = new Size(0, 0);
                this._scaleX = 1;
                this._scaleY = 1;
                this._viewportRect = new Rect(0, 0, 0, 0);
                this._visibleRect = new Rect(0, 0, 0, 0);
                this._autoFullScreen = false;
                this._retinaEnabled = false;
                this._resizeCallback = null;
                this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
                this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
                this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
                this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
                this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
                this._resolutionPolicy = this._rpShowAll;
              }

              init() {
                const windowSize = screen.windowSize;
                const w = windowSize.width;
                const h = windowSize.height;
                this._designResolutionSize.width = w;
                this._designResolutionSize.height = h;
                this._viewportRect.width = w;
                this._viewportRect.height = h;
                this._visibleRect.width = w;
                this._visibleRect.height = h;
                localWinSize.width = this._visibleRect.width;
                localWinSize.height = this._visibleRect.height;

                if (visibleRect) {
                  visibleRect.init(this._visibleRect);
                }

                screenAdapter.on('window-resize', this._updateAdaptResult, this);
                screenAdapter.on('orientation-change', this._updateAdaptResult, this);
                screenAdapter.on('fullscreen-change', this._updateAdaptResult, this);
              }

              resizeWithBrowserSize(enabled) {
                screenAdapter.handleResizeEvent = enabled;
              }

              setResizeCallback(callback) {
                if (typeof callback === 'function' || callback == null) {
                  this._resizeCallback = callback;
                }
              }

              setOrientation(orientation) {
                screenAdapter.orientation = orientationMap$2[orientation];
              }

              adjustViewportMeta(enabled) {}

              enableRetina(enabled) {
                this._retinaEnabled = !!enabled;
              }

              isRetinaEnabled() {
                return this._retinaEnabled;
              }

              enableAutoFullScreen(enabled) {
                if (enabled === this._autoFullScreen) {
                  return;
                }

                this._autoFullScreen = enabled;

                if (enabled) {
                  screen.requestFullScreen().catch(e => {});
                }
              }

              isAutoFullScreenEnabled() {
                return this._autoFullScreen;
              }

              setCanvasSize(width, height) {
                screenAdapter.resolutionScale = 1;
                const dpr = screenAdapter.devicePixelRatio;
                const windowSize = new Size(width * dpr, height * dpr);
                screen.windowSize = windowSize;
              }

              getCanvasSize() {
                return screen.windowSize;
              }

              getFrameSize() {
                const dpr = screenAdapter.devicePixelRatio;
                const sizeInCssPixels = screen.windowSize;
                sizeInCssPixels.width /= dpr;
                sizeInCssPixels.height /= dpr;
                return sizeInCssPixels;
              }

              setFrameSize(width, height) {
                const dpr = screenAdapter.devicePixelRatio;
                screen.windowSize = new Size(width * dpr, height * dpr);
              }

              getVisibleSize() {
                return new Size(this._visibleRect.width, this._visibleRect.height);
              }

              getVisibleSizeInPixel() {
                return new Size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
              }

              getVisibleOrigin() {
                return new Vec2(this._visibleRect.x, this._visibleRect.y);
              }

              getVisibleOriginInPixel() {
                return new Vec2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
              }

              getResolutionPolicy() {
                return this._resolutionPolicy;
              }

              _updateResolutionPolicy(resolutionPolicy) {
                if (resolutionPolicy instanceof ResolutionPolicy) {
                  this._resolutionPolicy = resolutionPolicy;
                } else {
                  const _locPolicy = ResolutionPolicy;

                  if (resolutionPolicy === _locPolicy.EXACT_FIT) {
                    this._resolutionPolicy = this._rpExactFit;
                  }

                  if (resolutionPolicy === _locPolicy.SHOW_ALL) {
                    this._resolutionPolicy = this._rpShowAll;
                  }

                  if (resolutionPolicy === _locPolicy.NO_BORDER) {
                    this._resolutionPolicy = this._rpNoBorder;
                  }

                  if (resolutionPolicy === _locPolicy.FIXED_HEIGHT) {
                    this._resolutionPolicy = this._rpFixedHeight;
                  }

                  if (resolutionPolicy === _locPolicy.FIXED_WIDTH) {
                    this._resolutionPolicy = this._rpFixedWidth;
                  }
                }
              }

              setResolutionPolicy(resolutionPolicy) {
                this._updateResolutionPolicy(resolutionPolicy);

                const designedResolution = view.getDesignResolutionSize();
                view.setDesignResolutionSize(designedResolution.width, designedResolution.height, resolutionPolicy);
              }

              setDesignResolutionSize(width, height, resolutionPolicy) {
                if (!(width > 0 && height > 0)) {
                  errorID(2200);
                  return;
                }

                this._updateResolutionPolicy(resolutionPolicy);

                const policy = this._resolutionPolicy;

                if (policy) {
                  policy.preApply(this);
                }

                this._designResolutionSize.width = width;
                this._designResolutionSize.height = height;
                const result = policy.apply(this, this._designResolutionSize);

                if (result.scale && result.scale.length === 2) {
                  this._scaleX = result.scale[0];
                  this._scaleY = result.scale[1];
                }

                if (result.viewport) {
                  const vp = this._viewportRect;
                  const vb = this._visibleRect;
                  const rv = result.viewport;
                  vp.x = rv.x;
                  vp.y = rv.y;
                  vp.width = rv.width;
                  vp.height = rv.height;
                  vb.x = 0;
                  vb.y = 0;
                  vb.width = rv.width / this._scaleX;
                  vb.height = rv.height / this._scaleY;
                }

                policy.postApply(this);
                localWinSize.width = this._visibleRect.width;
                localWinSize.height = this._visibleRect.height;

                if (visibleRect) {
                  visibleRect.init(this._visibleRect);
                }

                this.emit('design-resolution-changed');
              }

              getDesignResolutionSize() {
                return new Size(this._designResolutionSize.width, this._designResolutionSize.height);
              }

              setRealPixelResolution(width, height, resolutionPolicy) {

                this.setDesignResolutionSize(width, height, resolutionPolicy);
              }

              getViewportRect() {
                return this._viewportRect;
              }

              getScaleX() {
                return this._scaleX;
              }

              getScaleY() {
                return this._scaleY;
              }

              getDevicePixelRatio() {
                return screenAdapter.devicePixelRatio;
              }

              convertToLocationInView(tx, ty, relatedPos, out = new Vec2()) {
                const x = screenAdapter.devicePixelRatio * (tx - relatedPos.left);
                const y = screenAdapter.devicePixelRatio * (relatedPos.top + relatedPos.height - ty);

                if (screenAdapter.isFrameRotated) {
                  out.x = screen.windowSize.width - y;
                  out.y = x;
                } else {
                  out.x = x;
                  out.y = y;
                }

                return out;
              }

              _convertToUISpace(point) {
                const viewport = this._viewportRect;
                point.x = (point.x - viewport.x) / this._scaleX;
                point.y = (point.y - viewport.y) / this._scaleY;
              }

              _updateAdaptResult() {
                var _this$_resizeCallback;

                legacyCC.director.root.resize(screen.windowSize.width, screen.windowSize.height);
                const width = this._designResolutionSize.width;
                const height = this._designResolutionSize.height;

                if (width > 0) {
                  this.setDesignResolutionSize(width, height, this._resolutionPolicy);
                }

                this.emit('canvas-resize');
                (_this$_resizeCallback = this._resizeCallback) === null || _this$_resizeCallback === void 0 ? void 0 : _this$_resizeCallback.call(this);
              }

            } exports('eG', View);
            View.instance = void 0;

            class ContainerStrategy {
              constructor() {
                this.name = 'ContainerStrategy';
              }

              preApply(_view) {}

              apply(_view, designedResolution) {}

              postApply(_view) {}

              _setupCanvas() {
                const locCanvas = game.canvas;

                if (locCanvas) {
                  const windowSize = screen.windowSize;
                  locCanvas.width = windowSize.width;
                  locCanvas.height = windowSize.height;
                }
              }

            }

            ContainerStrategy.EQUAL_TO_FRAME = void 0;
            ContainerStrategy.PROPORTION_TO_FRAME = void 0;

            class ContentStrategy {
              constructor() {
                this.name = 'ContentStrategy';
                this._result = void 0;
                this._result = {
                  scale: [1, 1],
                  viewport: null
                };
              }

              preApply(_view) {}

              apply(_view, designedResolution) {
                return {
                  scale: [1, 1]
                };
              }

              postApply(_view) {}

              _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                if (Math.abs(containerW - contentW) < 2) {
                  contentW = containerW;
                }

                if (Math.abs(containerH - contentH) < 2) {
                  contentH = containerH;
                }

                const viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                this._result.scale = [scaleX, scaleY];
                this._result.viewport = viewport;
                return this._result;
              }

            }

            ContentStrategy.EXACT_FIT = void 0;
            ContentStrategy.SHOW_ALL = void 0;
            ContentStrategy.NO_BORDER = void 0;
            ContentStrategy.FIXED_HEIGHT = void 0;
            ContentStrategy.FIXED_WIDTH = void 0;

            (() => {
              class EqualToFrame extends ContainerStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'EqualToFrame';
                }

                apply(_view, designedResolution) {
                  screenAdapter.isProportionalToFrame = false;

                  this._setupCanvas();
                }

              }

              class ProportionalToFrame extends ContainerStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'ProportionalToFrame';
                }

                apply(_view, designedResolution) {
                  screenAdapter.isProportionalToFrame = true;

                  this._setupCanvas();
                }

              }

              ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
              ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();

              class ExactFit extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'ExactFit';
                }

                apply(_view, designedResolution) {
                  const windowSize = screen.windowSize;
                  const containerW = windowSize.width;
                  const containerH = windowSize.height;
                  const scaleX = containerW / designedResolution.width;
                  const scaleY = containerH / designedResolution.height;
                  return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
                }

              }

              class ShowAll extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'ShowAll';
                }

                apply(_view, designedResolution) {
                  const windowSize = screen.windowSize;
                  const containerW = windowSize.width;
                  const containerH = windowSize.height;
                  const designW = designedResolution.width;
                  const designH = designedResolution.height;
                  const scaleX = containerW / designW;
                  const scaleY = containerH / designH;
                  let scale = 0;
                  let contentW;
                  let contentH;

                  if (scaleX < scaleY) {
                    scale = scaleX;
                    contentW = containerW;
                    contentH = designH * scale;
                  } else {
                    scale = scaleY;
                    contentW = designW * scale;
                    contentH = containerH;
                  }

                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }

              }

              class NoBorder extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'NoBorder';
                }

                apply(_view, designedResolution) {
                  const windowSize = screen.windowSize;
                  const containerW = windowSize.width;
                  const containerH = windowSize.height;
                  const designW = designedResolution.width;
                  const designH = designedResolution.height;
                  const scaleX = containerW / designW;
                  const scaleY = containerH / designH;
                  let scale;
                  let contentW;
                  let contentH;

                  if (scaleX < scaleY) {
                    scale = scaleY;
                    contentW = designW * scale;
                    contentH = containerH;
                  } else {
                    scale = scaleX;
                    contentW = containerW;
                    contentH = designH * scale;
                  }

                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }

              }

              class FixedHeight extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'FixedHeight';
                }

                apply(_view, designedResolution) {
                  const windowSize = screen.windowSize;
                  const containerW = windowSize.width;
                  const containerH = windowSize.height;
                  const designH = designedResolution.height;
                  const scale = containerH / designH;
                  const contentW = containerW;
                  const contentH = containerH;
                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }

              }

              class FixedWidth extends ContentStrategy {
                constructor(...args) {
                  super(...args);
                  this.name = 'FixedWidth';
                }

                apply(_view, designedResolution) {
                  const windowSize = screen.windowSize;
                  const containerW = windowSize.width;
                  const containerH = windowSize.height;
                  const designW = designedResolution.width;
                  const scale = containerW / designW;
                  const contentW = containerW;
                  const contentH = containerH;
                  return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }

              }

              ContentStrategy.EXACT_FIT = new ExactFit();
              ContentStrategy.SHOW_ALL = new ShowAll();
              ContentStrategy.NO_BORDER = new NoBorder();
              ContentStrategy.FIXED_HEIGHT = new FixedHeight();
              ContentStrategy.FIXED_WIDTH = new FixedWidth();
            })();

            class ResolutionPolicy {
              constructor(containerStg, contentStg) {
                this.name = 'ResolutionPolicy';
                this._containerStrategy = void 0;
                this._contentStrategy = void 0;
                this._containerStrategy = null;
                this._contentStrategy = null;
                this.setContainerStrategy(containerStg);
                this.setContentStrategy(contentStg);
              }

              get canvasSize() {
                return screen.windowSize;
              }

              preApply(_view) {
                this._contentStrategy.preApply(_view);
              }

              apply(_view, designedResolution) {
                this._containerStrategy.apply(_view, designedResolution);

                return this._contentStrategy.apply(_view, designedResolution);
              }

              postApply(_view) {
                this._contentStrategy.postApply(_view);
              }

              setContainerStrategy(containerStg) {
                if (containerStg instanceof ContainerStrategy) {
                  this._containerStrategy = containerStg;
                }
              }

              setContentStrategy(contentStg) {
                if (contentStg instanceof ContentStrategy) {
                  this._contentStrategy = contentStg;
                }
              }

            } exports('fP', ResolutionPolicy);
            ResolutionPolicy.EXACT_FIT = 0;
            ResolutionPolicy.NO_BORDER = 1;
            ResolutionPolicy.SHOW_ALL = 2;
            ResolutionPolicy.FIXED_HEIGHT = 3;
            ResolutionPolicy.FIXED_WIDTH = 4;
            ResolutionPolicy.UNKNOWN = 5;
            ResolutionPolicy.ContainerStrategy = ContainerStrategy;
            ResolutionPolicy.ContentStrategy = ContentStrategy;
            legacyCC.ResolutionPolicy = ResolutionPolicy;
            const view = exports('ed', View.instance = legacyCC.view = new View());
            legacyCC.winSize = localWinSize;

            removeProperty(View.prototype, 'View.prototype', [{
              name: 'isAntiAliasEnabled',
              suggest: 'The API of Texture2d have been largely modified, no alternative'
            }, {
              name: 'enableAntiAlias',
              suggest: 'The API of Texture2d have been largely modified, no alternative'
            }]);
            markAsWarning(View.prototype, 'View.prototype', [{
              name: 'adjustViewportMeta'
            }, {
              name: 'enableAutoFullScreen',
              suggest: 'use screen.requestFullScreen() instead.'
            }, {
              name: 'isAutoFullScreenEnabled'
            }, {
              name: 'setCanvasSize',
              suggest: 'setting size in CSS pixels is not recommended, please use screen.windowSize instead.'
            }, {
              name: 'getCanvasSize',
              suggest: 'please use screen.windowSize instead.'
            }, {
              name: 'getFrameSize',
              suggest: 'getting size in CSS pixels is not recommended, please use screen.windowSize instead.'
            }, {
              name: 'setFrameSize',
              suggest: 'setting size in CSS pixels is not recommended, please use screen.windowSize instead.'
            }, {
              name: 'getDevicePixelRatio',
              suggest: 'devicePixelRatio is a concept on web standard'
            }, {
              name: 'convertToLocationInView'
            }, {
              name: 'enableRetina'
            }, {
              name: 'isRetinaEnabled'
            }]);
            markAsWarning(legacyCC, 'cc', [{
              name: 'winSize',
              suggest: 'please use view.getVisibleSize() instead.'
            }]);
            markAsWarning(sys, 'sys', [{
              name: 'capabilities',
              suggest: 'please use sys.hasFeature() method instead.'
            }]);
            replaceProperty(sys, 'sys', ['UNKNOWN', 'ENGLISH', 'CHINESE', 'FRENCH', 'ITALIAN', 'GERMAN', 'SPANISH', 'DUTCH', 'RUSSIAN', 'KOREAN', 'JAPANESE', 'HUNGARIAN', 'PORTUGUESE', 'ARABIC', 'NORWEGIAN', 'POLISH', 'TURKISH', 'UKRAINIAN', 'ROMANIAN', 'BULGARIAN'].map(item => ({
              name: `LANGUAGE_${item}`,
              newName: item,
              target: sys.Language,
              targetName: 'sys.Language'
            })));
            replaceProperty(sys, 'sys', ['UNKNOWN', 'IOS', 'ANDROID', 'WINDOWS', 'LINUX', 'OSX'].map(item => ({
              name: `OS_${item}`,
              newName: item,
              target: sys.OS,
              targetName: 'sys.OS'
            })));
            replaceProperty(sys, 'sys', ['UNKNOWN', 'WECHAT', 'ANDROID', 'IE', 'EDGE', 'QQ', 'MOBILE_QQ', 'UC', 'UCBS', 'BAIDU_APP', 'BAIDU', 'MAXTHON', 'OPERA', 'OUPENG', 'MIUI', 'FIREFOX', 'SAFARI', 'CHROME', 'LIEBAO', 'QZONE', 'SOUGOU', 'HUAWEI'].map(item => ({
              name: `BROWSER_TYPE_${item}`,
              newName: item,
              target: sys.BrowserType,
              targetName: 'sys.BrowserType'
            })));
            replaceProperty(sys, 'sys', [{
              name: 'BROWSER_TYPE_360',
              newName: 'BROWSER_360',
              target: sys.BrowserType,
              targetName: 'sys.BrowserType'
            }]);
            replaceProperty(sys, 'sys', ['UNKNOWN', 'EDITOR_PAGE', 'EDITOR_CORE', 'MOBILE_BROWSER', 'DESKTOP_BROWSER', 'WIN32', 'MACOS', 'IOS', 'ANDROID', 'OHOS', 'WECHAT_GAME', 'BAIDU_MINI_GAME', 'XIAOMI_QUICK_GAME', 'ALIPAY_MINI_GAME', 'BYTEDANCE_MINI_GAME', 'OPPO_MINI_GAME', 'VIVO_MINI_GAME', 'HUAWEI_QUICK_GAME', 'COCOSPLAY', 'LINKSURE_MINI_GAME', 'QTT_MINI_GAME'].map(item => ({
              name: item,
              target: sys.Platform,
              targetName: 'sys.Platform'
            })));
            replaceProperty(sys, 'sys', [{
              name: 'IPHONE',
              newName: 'IOS',
              target: sys.Platform,
              targetName: 'sys.Platform'
            }, {
              name: 'IPAD',
              newName: 'IOS',
              target: sys.Platform,
              targetName: 'sys.Platform'
            }]);
            removeProperty(sys, 'sys', ['LINUX', 'BLACKBERRY', 'NACL', 'EMSCRIPTEN', 'TIZEN', 'WINRT', 'WP8', 'QQ_PLAY', 'FB_PLAYABLE_ADS'].map(item => ({
              name: item
            })));
            replaceProperty(sys, 'sys', [{
              name: 'windowPixelResolution',
              target: screen,
              targetName: 'screen',
              newName: 'windowSize'
            }]);
            markAsWarning(screen, 'screen', [{
              name: 'autoFullScreen',
              suggest: 'please use screen.requestFullScreen() instead.'
            }, {
              name: 'disableAutoFullScreen'
            }]);

            const isMatchByWord = (path, test) => {
              if (path.length > test.length) {
                const nextAscii = path.charCodeAt(test.length);
                return nextAscii === 47;
              }

              return true;
            };

            const processOptions = options => {

              let uuids = options.uuids;
              const paths = options.paths;
              const types = options.types;
              const bundles = options.deps;
              const realEntries = options.paths = Object.create(null);

              if (options.debug === false) {
                for (let i = 0, l = uuids.length; i < l; i++) {
                  uuids[i] = decodeUuid(uuids[i]);
                }

                for (const id in paths) {
                  const entry = paths[id];
                  const type = entry[1];
                  entry[1] = types[type];
                }
              } else {
                const out = Object.create(null);

                for (let i = 0, l = uuids.length; i < l; i++) {
                  const uuid = uuids[i];
                  uuids[i] = out[uuid] = decodeUuid(uuid);
                }

                uuids = out;
              }

              for (const id in paths) {
                const entry = paths[id];
                realEntries[uuids[id]] = entry;
              }

              const scenes = options.scenes;

              for (const name in scenes) {
                const uuid = scenes[name];
                scenes[name] = uuids[uuid];
              }

              const packs = options.packs;

              for (const packId in packs) {
                const packedIds = packs[packId];

                for (let j = 0; j < packedIds.length; ++j) {
                  packedIds[j] = uuids[packedIds[j]];
                }
              }

              const versions = options.versions;

              if (versions) {
                for (const folder in versions) {
                  const entries = versions[folder];

                  for (let i = 0; i < entries.length; i += 2) {
                    const uuid = entries[i];
                    entries[i] = uuids[uuid] || uuid;
                  }
                }
              }

              const redirect = options.redirect;

              if (redirect) {
                for (let i = 0; i < redirect.length; i += 2) {
                  redirect[i] = uuids[redirect[i]];
                  redirect[i + 1] = bundles[redirect[i + 1]];
                }
              }

              const extensionMap = options.extensionMap;

              if (extensionMap) {
                for (const ext in options.extensionMap) {
                  if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
                    continue;
                  }

                  options.extensionMap[ext].forEach((uuid, index) => {
                    options.extensionMap[ext][index] = uuids[uuid] || uuid;
                  });
                }
              }
            };

            class Config {
              constructor() {
                this.name = '';
                this.base = '';
                this.importBase = '';
                this.nativeBase = '';
                this.deps = null;
                this.assetInfos = new Cache();
                this.scenes = new Cache();
                this.paths = new Cache();
              }

              init(options) {
                processOptions(options);
                this.importBase = options.importBase || '';
                this.nativeBase = options.nativeBase || '';
                this.base = options.base || '';
                this.name = options.name || '';
                this.deps = options.deps || [];

                this._initUuid(options.uuids);

                this._initPath(options.paths);

                this._initScene(options.scenes);

                this._initPackage(options.packs);

                this._initVersion(options.versions);

                this._initRedirect(options.redirect);

                for (const ext in options.extensionMap) {
                  if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
                    continue;
                  }

                  options.extensionMap[ext].forEach(uuid => {
                    const assetInfo = this.assetInfos.get(uuid);

                    if (assetInfo) {
                      assetInfo.extension = ext;
                    }
                  });
                }
              }

              getInfoWithPath(path, type) {
                if (!path) {
                  return null;
                }

                path = normalize(path);
                const items = this.paths.get(path);

                if (items) {
                  if (type) {
                    for (let i = 0, l = items.length; i < l; i++) {
                      const assetInfo = items[i];

                      if (js.isChildClassOf(assetInfo.ctor, type)) {
                        return assetInfo;
                      }
                    }
                  } else {
                    return items[0];
                  }
                }

                return null;
              }

              getDirWithPath(path, type, out) {
                path = normalize(path);

                if (path[path.length - 1] === '/') {
                  path = path.slice(0, -1);
                }

                const infos = out || [];
                this.paths.forEach((items, p) => {
                  if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                    for (let i = 0, l = items.length; i < l; i++) {
                      const entry = items[i];

                      if (!type || js.isChildClassOf(entry.ctor, type)) {
                        infos.push(entry);
                      }
                    }
                  }
                });
                return infos;
              }

              getAssetInfo(uuid) {
                return this.assetInfos.get(uuid) || null;
              }

              getSceneInfo(name) {
                if (!name.endsWith('.scene')) {
                  name += '.scene';
                }

                if (name[0] !== '/' && !name.startsWith('db://')) {
                  name = `/${name}`;
                }

                const info = this.scenes.find((val, key) => {
                console.error('pptest get scene info ' + val + ' ' + key + ' ' + name)
                    return key.endsWith(name)
                });
                return info;
              }

              destroy() {
                this.paths.destroy();
                this.scenes.destroy();
                this.assetInfos.destroy();
              }

              _initUuid(uuidList) {
                if (!uuidList) {
                  return;
                }

                this.assetInfos.clear();

                for (let i = 0, l = uuidList.length; i < l; i++) {
                  const uuid = uuidList[i];
                  this.assetInfos.add(uuid, {
                    uuid
                  });
                }
              }

              _initPath(pathList) {
                if (!pathList) {
                  return;
                }

                const paths = this.paths;
                paths.clear();

                for (const uuid in pathList) {
                  const info = pathList[uuid];
                  const path = info[0];
                  const type = info[1];
                  const isSubAsset = info.length === 3;
                  const assetInfo = this.assetInfos.get(uuid);
                  assetInfo.path = path;
                  assetInfo.ctor = js._getClassById(type);

                  if (paths.has(path)) {
                    if (isSubAsset) {
                      paths.get(path).push(assetInfo);
                    } else {
                      paths.get(path).unshift(assetInfo);
                    }
                  } else {
                    paths.add(path, [assetInfo]);
                  }
                }
              }

              _initScene(sceneList) {
                if (!sceneList) {
                  return;
                }

                const scenes = this.scenes;
                scenes.clear();
                const assetInfos = this.assetInfos;

                for (const sceneName in sceneList) {
                  const uuid = sceneList[sceneName];
                  const assetInfo = assetInfos.get(uuid);
                  assetInfo.url = sceneName;
                  scenes.add(sceneName, assetInfo);
                }
              }

              _initPackage(packageList) {
                if (!packageList) {
                  return;
                }

                const assetInfos = this.assetInfos;

                for (const packUuid in packageList) {
                  const uuids = packageList[packUuid];
                  const pack = {
                    uuid: packUuid,
                    packedUuids: uuids,
                    ext: '.json'
                  };
                  assetInfos.add(packUuid, pack);

                  for (let i = 0, l = uuids.length; i < l; i++) {
                    const uuid = uuids[i];
                    const assetInfo = assetInfos.get(uuid);
                    const assetPacks = assetInfo.packs;

                    if (assetPacks) {
                      if (l === 1) {
                        assetPacks.unshift(pack);
                      } else {
                        assetPacks.push(pack);
                      }
                    } else {
                      assetInfo.packs = [pack];
                    }
                  }
                }
              }

              _initVersion(versions) {
                if (!versions) {
                  return;
                }

                const assetInfos = this.assetInfos;
                let entries = versions.import;

                if (entries) {
                  for (let i = 0, l = entries.length; i < l; i += 2) {
                    const uuid = entries[i];
                    const assetInfo = assetInfos.get(uuid);
                    assetInfo.ver = entries[i + 1];
                  }
                }

                entries = versions.native;

                if (entries) {
                  for (let i = 0, l = entries.length; i < l; i += 2) {
                    const uuid = entries[i];
                    const assetInfo = assetInfos.get(uuid);
                    assetInfo.nativeVer = entries[i + 1];
                  }
                }
              }

              _initRedirect(redirect) {
                if (!redirect) {
                  return;
                }

                const assetInfos = this.assetInfos;

                for (let i = 0, l = redirect.length; i < l; i += 2) {
                  const uuid = redirect[i];
                  const assetInfo = assetInfos.get(uuid);
                  assetInfo.redirect = redirect[i + 1];
                }
              }

            }

            function visitAsset(asset, deps) {
              if (!asset._uuid) {
                return;
              }

              deps.push(asset._uuid);
            }

            function visitComponent(comp, deps) {
              const props = Object.getOwnPropertyNames(comp);

              for (let i = 0; i < props.length; i++) {
                const propName = props[i];

                if (propName === 'node' || propName === '__eventTargets') {
                  continue;
                }

                const value = comp[propName];

                if (typeof value === 'object' && value) {
                  if (Array.isArray(value)) {
                    for (let j = 0; j < value.length; j++) {
                      const val = value[j];

                      if (val instanceof Asset) {
                        visitAsset(val, deps);
                      }
                    }
                  } else if (!value.constructor || value.constructor === Object) {
                    const keys = Object.getOwnPropertyNames(value);

                    for (let j = 0; j < keys.length; j++) {
                      const val = value[keys[j]];

                      if (val instanceof Asset) {
                        visitAsset(val, deps);
                      }
                    }
                  } else if (value instanceof Asset) {
                    visitAsset(value, deps);
                  }
                }
              }
            }

            function visitNode(node, deps) {
              for (let i = 0; i < node._components.length; i++) {
                visitComponent(node._components[i], deps);
              }

              for (let i = 0; i < node._children.length; i++) {
                visitNode(node._children[i], deps);
              }
            }

            function descendOpRef(asset, refs, exclude, op) {
              exclude.push(asset._uuid);
              const depends = dependUtil.getDeps(asset._uuid);

              for (let i = 0, l = depends.length; i < l; i++) {
                const dependAsset = assets.get(depends[i]);

                if (!dependAsset) {
                  continue;
                }

                const uuid = dependAsset._uuid;

                if (!(uuid in refs)) {
                  refs[uuid] = dependAsset.refCount + op;
                } else {
                  refs[uuid] += op;
                }

                if (exclude.includes(uuid)) {
                  continue;
                }

                descendOpRef(dependAsset, refs, exclude, op);
              }
            }

            const _temp$u = [];

            function checkCircularReference(asset) {
              const refs = Object.create(null);
              refs[asset._uuid] = asset.refCount;
              descendOpRef(asset, refs, _temp$u, -1);
              _temp$u.length = 0;

              if (refs[asset._uuid] !== 0) {
                return refs[asset._uuid];
              }

              for (const uuid in refs) {
                if (refs[uuid] !== 0) {
                  descendOpRef(assets.get(uuid), refs, _temp$u, 1);
                }
              }

              _temp$u.length = 0;
              return refs[asset._uuid];
            }

            class ReleaseManager {
              constructor() {
                this._persistNodeDeps = new Cache();
                this._toDelete = new Cache();
                this._eventListener = false;
              }

              init() {
                this._persistNodeDeps.clear();

                this._toDelete.clear();
              }

              _addPersistNodeRef(node) {
                const deps = [];
                visitNode(node, deps);

                for (let i = 0, l = deps.length; i < l; i++) {
                  const dependAsset = assets.get(deps[i]);

                  if (dependAsset) {
                    dependAsset.addRef();
                  }
                }

                this._persistNodeDeps.add(node.uuid, deps);
              }

              _removePersistNodeRef(node) {
                if (!this._persistNodeDeps.has(node.uuid)) {
                  return;
                }

                const deps = this._persistNodeDeps.get(node.uuid);

                for (let i = 0, l = deps.length; i < l; i++) {
                  const dependAsset = assets.get(deps[i]);

                  if (dependAsset) {
                    dependAsset.decRef();
                  }
                }

                this._persistNodeDeps.remove(node.uuid);
              }

              _autoRelease(oldScene, newScene, persistNodes) {
                if (oldScene) {
                  const childs = dependUtil.getDeps(oldScene.uuid);

                  for (let i = 0, l = childs.length; i < l; i++) {
                    const asset = assets.get(childs[i]);

                    if (asset) {
                      asset.decRef( oldScene.autoReleaseAssets);
                    }
                  }

                  const dependencies = dependUtil._depends.get(oldScene.uuid);

                  if (dependencies && dependencies.persistDeps) {
                    const persistDeps = dependencies.persistDeps;

                    for (let i = 0, l = persistDeps.length; i < l; i++) {
                      const asset = assets.get(persistDeps[i]);

                      if (asset) {
                        asset.decRef( oldScene.autoReleaseAssets);
                      }
                    }
                  }

                  if (oldScene.uuid !== newScene.uuid) {
                    dependUtil.remove(oldScene.uuid);
                  }
                }

                const sceneDeps = dependUtil._depends.get(newScene.uuid);

                if (sceneDeps) {
                  sceneDeps.persistDeps = [];
                }

                for (const key in persistNodes) {
                  const node = persistNodes[key];

                  const deps = this._persistNodeDeps.get(node.uuid);

                  for (const dep of deps) {
                    const dependAsset = assets.get(dep);

                    if (dependAsset) {
                      dependAsset.addRef();
                    }
                  }

                  if (!sceneDeps) {
                    continue;
                  }

                  sceneDeps.persistDeps.push(...deps);
                }
              }

              tryRelease(asset, force = false) {
                if (!(asset instanceof Asset)) {
                  return;
                }

                if (force) {
                  this._free(asset, force);

                  return;
                }

                this._toDelete.add(asset._uuid, asset);

                if (!this._eventListener) {
                  this._eventListener = true;
                  callInNextTick(this._freeAssets.bind(this));
                }
              }

              _freeAssets() {
                this._eventListener = false;

                this._toDelete.forEach(asset => {
                  this._free(asset);
                });

                this._toDelete.clear();
              }

              _free(asset, force = false) {
                const uuid = asset._uuid;

                this._toDelete.remove(uuid);

                if (!isValid(asset, true)) {
                  return;
                }

                if (!force) {
                  if (asset.refCount > 0) {
                    if (checkCircularReference(asset) > 0) {
                      return;
                    }
                  }
                }

                assets.remove(uuid);
                const depends = dependUtil.getDeps(uuid);

                for (let i = 0, l = depends.length; i < l; i++) {
                  const dependAsset = assets.get(depends[i]);

                  if (dependAsset) {
                    dependAsset.decRef(false);

                    {
                      this._free(dependAsset, false);
                    }
                  }
                }

                {
                  asset.destroy();
                }

                dependUtil.remove(uuid);
              }

            }

            var releaseManager = new ReleaseManager();

            let defaultProgressCallback = null;
            function setDefaultProgressCallback(onProgress) {
              defaultProgressCallback = onProgress;
            }
            function clear$1(task, clearRef) {
              for (let i = 0, l = task.input.length; i < l; i++) {
                const item = task.input[i];

                if (clearRef) {
                  if (!item.isNative && item.content instanceof Asset) {
                    item.content.decRef(false);
                  }
                }

                item.recycle();
              }

              task.input = null;
            }
            function urlAppendTimestamp(url, append) {
              if (append) {
                if (/\?/.test(url)) {
                  return `${url}&_t=${Date.now()}`;
                }

                return `${url}?_t=${Date.now()}`;
              }

              return url;
            }
            function retry(process, times, wait, onComplete, index = 0) {
              process(index, (err, result) => {
                index++;

                if (!err || index > times) {
                  if (onComplete) {
                    onComplete(err, result);
                  }
                } else {
                  setTimeout(() => {
                    retry(process, times, wait, onComplete, index);
                  }, wait);
                }
              });
            }
            function getDepends(uuid, data, exclude, depends, config) {
              try {
                const info = dependUtil.parse(uuid, data);

                for (let i = 0, l = info.deps.length; i < l; i++) {
                  const dep = info.deps[i];

                  if (!(dep in exclude)) {
                    exclude[dep] = true;
                    depends.push({
                      uuid: dep,
                      bundle: config && config.name
                    });
                  }
                }

                if (info.nativeDep) {
                  if (config) {
                    info.nativeDep.bundle = config.name;
                  }

                  depends.push({ ...info.nativeDep
                  });
                }
              } catch (e) {
                error(e.message, e.stack);
              }
            }
            function cache(id, asset, cacheAsset) {
              if (!asset) {
                return;
              }

              cacheAsset = cacheAsset !== undefined ? cacheAsset : legacyCC.assetManager.cacheAsset;

              if (!isScene(asset) && cacheAsset && !asset.isDefault) {
                assets.add(id, asset);
              }
            }
            function setProperties(uuid, asset, assetsMap) {
              let missingAsset = false;
              const depends = dependMap.get(asset);

              if (depends) {

                for (let i = 0, l = depends.length; i < l; i++) {
                  const depend = depends[i];
                  const dependAsset = assetsMap[`${depend.uuid}@import`];

                  if (!dependAsset) {
                    {
                      error(`The asset ${depend.uuid} is missing!`);
                    }

                    if (depend.type && depend.type !== Asset) {
                      const placeHolder = new depend.type();
                      placeHolder.initDefault(depend.uuid);
                      depend.owner[depend.prop] = placeHolder;
                    }

                    missingAsset = true;
                  } else {
                    depend.owner[depend.prop] = dependAsset.addRef();
                  }
                }

                dependMap.delete(asset);
              }

              if (nativeDependMap.has(asset)) {
                if (assetsMap[`${uuid}@native`]) {
                  asset._nativeAsset = assetsMap[`${uuid}@native`];
                } else {
                  missingAsset = true;
                  console.error(`the native asset of ${uuid} is missing!`);
                }

                nativeDependMap.delete(asset);
              }

              return missingAsset;
            }
            function gatherAsset(task) {
              const source = task.source;

              if (!task.options.__outputAsArray__ && source.length === 1) {
                task.output = source[0].content;
              } else {
                const output = task.output = [];

                for (let i = 0, l = source.length; i < l; i++) {
                  output.push(source[i].content);
                }
              }
            }
            function forEach(array, process, onComplete) {
              let count = 0;
              const errs = [];
              const length = array.length;

              if (length === 0 && onComplete) {
                onComplete(errs);
              }

              const cb = err => {
                if (err) {
                  errs.push(err);
                }

                count++;

                if (count === length) {
                  if (onComplete) {
                    onComplete(errs);
                  }
                }
              };

              for (let i = 0; i < length; i++) {
                process(array[i], cb);
              }
            }
            function parseParameters(options, onProgress, onComplete) {
              let optionsOut = options;
              let onProgressOut = onProgress;
              let onCompleteOut = onComplete;

              if (onComplete === undefined) {
                const isCallback = typeof options === 'function';

                if (onProgress) {
                  onCompleteOut = onProgress;

                  if (!isCallback) {
                    onProgressOut = null;
                  }
                } else if (onProgress === undefined && isCallback) {
                  onCompleteOut = options;
                  optionsOut = null;
                  onProgressOut = null;
                }

                if (onProgress !== undefined && isCallback) {
                  onProgressOut = options;
                  optionsOut = null;
                }
              }

              return {
                options: optionsOut || Object.create(null),
                onProgress: onProgressOut,
                onComplete: onCompleteOut
              };
            }
            function parseLoadResArgs(type, onProgress, onComplete) {
              let typeOut = type;
              let onProgressOut = onProgress;
              let onCompleteOut = onComplete;

              if (onComplete === undefined) {
                const isValidType = js.isChildClassOf(type, Asset);

                if (onProgress) {
                  onCompleteOut = onProgress;

                  if (isValidType) {
                    onProgressOut = null;
                  }
                } else if (onProgress === undefined && !isValidType) {
                  onCompleteOut = type;
                  onProgressOut = null;
                  typeOut = null;
                }

                if (onProgress !== undefined && !isValidType) {
                  onProgressOut = type;
                  typeOut = null;
                }
              }

              return {
                type: typeOut,
                onProgress: onProgressOut || defaultProgressCallback,
                onComplete: onCompleteOut
              };
            }
            function checkCircleReference(owner, uuid, map, checked = {}) {
              const item = map[uuid];

              if (!item || checked[uuid]) {
                return false;
              }

              checked[uuid] = true;
              let result = false;
              const deps = dependUtil.getDeps(uuid);

              if (deps) {
                for (let i = 0, l = deps.length; i < l; i++) {
                  const dep = deps[i];

                  if (dep === owner || checkCircleReference(owner, dep, map, checked)) {
                    result = true;
                    break;
                  }
                }
              }

              return result;
            }
            function asyncify(cb) {
              return (p1, p2) => {
                if (!cb) {
                  return;
                }

                const refs = [];

                if (Array.isArray(p2)) {
                  p2.forEach(x => x instanceof Asset && refs.push(x.addRef()));
                } else if (p2 instanceof Asset) {
                  refs.push(p2.addRef());
                }

                callInNextTick(() => {
                  refs.forEach(x => x.decRef(false));
                  cb(p1, p2);
                });
              };
            }

            class Bundle {
              constructor() {
                this._config = new Config();
              }

              get config() {
                return this._config;
              }

              get name() {
                return this._config.name;
              }

              get deps() {
                return this._config.deps;
              }

              get base() {
                return this._config.base;
              }

              getInfoWithPath(path, type) {
                return this._config.getInfoWithPath(path, type);
              }

              getDirWithPath(path, type, out) {
                return this._config.getDirWithPath(path, type, out);
              }

              getAssetInfo(uuid) {
                return this._config.getAssetInfo(uuid);
              }

              getSceneInfo(name) {
                return this._config.getSceneInfo(name);
              }

              init(options) {
                this._config.init(options);

                bundles.add(options.name, this);
              }

              load(paths, type, onProgress, onComplete) {
                const {
                  type: _type,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseLoadResArgs(type, onProgress, onComplete);
                const options = {
                  __requestType__: RequestType.PATH,
                  type: _type,
                  bundle: this.name,
                  __outputAsArray__: Array.isArray(paths)
                };
                legacyCC.assetManager.loadAny(paths, options, onProg, onComp);
              }

              preload(paths, type, onProgress, onComplete) {
                const {
                  type: _type,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseLoadResArgs(type, onProgress, onComplete);
                legacyCC.assetManager.preloadAny(paths, {
                  __requestType__: RequestType.PATH,
                  type: _type,
                  bundle: this.name
                }, onProg, onComp);
              }

              loadDir(dir, type, onProgress, onComplete) {
                const {
                  type: _type,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseLoadResArgs(type, onProgress, onComplete);
                legacyCC.assetManager.loadAny(dir, {
                  __requestType__: RequestType.DIR,
                  type: _type,
                  bundle: this.name,
                  __outputAsArray__: true
                }, onProg, onComp);
              }

              preloadDir(dir, type, onProgress, onComplete) {
                const {
                  type: _type,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseLoadResArgs(type, onProgress, onComplete);
                legacyCC.assetManager.preloadAny(dir, {
                  __requestType__: RequestType.DIR,
                  type: _type,
                  bundle: this.name
                }, onProg, onComp);
              }

              loadScene(sceneName, options, onProgress, onComplete) {
                const {
                  options: opts,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseParameters(options, onProgress, onComplete);
                opts.preset = opts.preset || 'scene';
                opts.bundle = this.name;
                legacyCC.assetManager.loadAny({
                  scene: sceneName
                }, opts, onProg, (err, sceneAsset) => {
                  if (err) {
                    error(err.message, err.stack);
                  } else if (sceneAsset instanceof SceneAsset && sceneAsset.scene) {
                    const scene = sceneAsset.scene;
                    scene._id = sceneAsset._uuid;
                    scene.name = sceneAsset.name;
                  } else {
                    err = new Error(`The asset ${sceneAsset._uuid} is not a scene`);
                  }

                  if (onComp) {
                    onComp(err, sceneAsset);
                  }
                });
              }

              preloadScene(sceneName, options, onProgress, onComplete) {
                const {
                  options: opts,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseParameters(options, onProgress, onComplete);
                opts.bundle = this.name;
                legacyCC.assetManager.preloadAny({
                  scene: sceneName
                }, opts, onProg, err => {
                  if (err) {
                    errorID(1210, sceneName, err.message);
                  }

                  if (onComp) {
                    onComp(err);
                  }
                });
              }

              get(path, type) {
                const info = this.getInfoWithPath(path, type);

                if (info) {
                  return assets.get(info.uuid) || null;
                }

                return null;
              }

              release(path, type) {
                const asset = this.get(path, type);

                if (asset) {
                  releaseManager.tryRelease(asset, true);
                }
              }

              releaseUnusedAssets() {
                assets.forEach(asset => {
                  const info = this.getAssetInfo(asset._uuid);

                  if (info && !info.redirect) {
                    releaseManager.tryRelease(asset);
                  }
                });
              }

              releaseAll() {
                assets.forEach(asset => {
                  const info = this.getAssetInfo(asset._uuid);

                  if (info && !info.redirect) {
                    releaseManager.tryRelease(asset, true);
                  }
                });
              }

              _destroy() {
                this._config.destroy();
              }

            }
            const resources = exports('g9', new Bundle());
            legacyCC.resources = resources;

            function downloadDomImage(url, options, onComplete) {
              const img = new Image();

              if (window.location.protocol !== 'file:') {
                img.crossOrigin = 'anonymous';
              }

              function loadCallback() {
                img.removeEventListener('load', loadCallback);
                img.removeEventListener('error', errorCallback);

                if (onComplete) {
                  onComplete(null, img);
                }
              }

              function errorCallback() {
                img.removeEventListener('load', loadCallback);
                img.removeEventListener('error', errorCallback);

                if (onComplete) {
                  onComplete(new Error(getError(4930, url)));
                }
              }

              img.addEventListener('load', loadCallback);
              img.addEventListener('error', errorCallback);
              img.src = url;
              return img;
            }

            function downloadFile(url, options, onProgress, onComplete) {
              const xhr = new XMLHttpRequest();
              const errInfo = `download failed: ${url}, status: `;
              xhr.open('GET', url, true);

              if (options.xhrResponseType !== undefined) {
                xhr.responseType = options.xhrResponseType;
              }

              if (options.xhrWithCredentials !== undefined) {
                xhr.withCredentials = options.xhrWithCredentials;
              }

              if (options.xhrMimeType !== undefined && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.xhrMimeType);
              }

              if (options.xhrTimeout !== undefined) {
                xhr.timeout = options.xhrTimeout;
              }

              if (options.xhrHeader) {
                for (const header in options.xhrHeader) {
                  xhr.setRequestHeader(header, options.xhrHeader[header]);
                }
              }

              xhr.onload = () => {
                if (xhr.status === 200 || xhr.status === 0) {
                  if (onComplete) {
                    onComplete(null, xhr.response);
                  }
                } else if (onComplete) {
                  onComplete(new Error(`${errInfo}${xhr.status}(no response)`));
                }
              };

              if (onProgress) {
                xhr.onprogress = e => {
                  if (e.lengthComputable) {
                    onProgress(e.loaded, e.total);
                  }
                };
              }

              xhr.onerror = () => {
                if (onComplete) {
                  onComplete(new Error(`${errInfo}${xhr.status}(error)`));
                }
              };

              xhr.ontimeout = () => {
                if (onComplete) {
                  onComplete(new Error(`${errInfo}${xhr.status}(time out)`));
                }
              };

              xhr.onabort = () => {
                if (onComplete) {
                  onComplete(new Error(`${errInfo}${xhr.status}(abort)`));
                }
              };

              xhr.send(null);
              return xhr;
            }

            const downloaded = {};
            function downloadScript(url, options, onComplete) {
              if (downloaded[url]) {
                if (onComplete) {
                  onComplete(null);
                }

                return null;
              }

              const script = document.createElement('script');

              if (window.location.protocol !== 'file:') {
                script.crossOrigin = 'anonymous';
              }

              script.async = options.scriptAsyncLoading || false;
              script.src = url;

              function loadHandler() {
                script.parentNode.removeChild(script);
                script.removeEventListener('load', loadHandler, false);
                script.removeEventListener('error', errorHandler, false);
                downloaded[url] = true;

                if (onComplete) {
                  onComplete(null);
                }
              }

              function errorHandler() {
                script.parentNode.removeChild(script);
                script.removeEventListener('load', loadHandler, false);
                script.removeEventListener('error', errorHandler, false);

                if (onComplete) {
                  onComplete(new Error(getError(4928, url)));
                }
              }

              script.addEventListener('load', loadHandler, false);
              script.addEventListener('error', errorHandler, false);
              document.body.appendChild(script);
              return script;
            }

            const REGEX = /^(?:\w+:\/\/|\.+\/).+/;

            const downloadImage = (url, options, onComplete) => {
              const func = sys.hasFeature(sys.Feature.IMAGE_BITMAP) && legacyCC.assetManager.allowImageBitmap ? downloadBlob : downloadDomImage;
              func(url, options, onComplete);
            };

            const downloadBlob = (url, options, onComplete) => {
              options.xhrResponseType = 'blob';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };

            const downloadJson = (url, options, onComplete) => {
              options.xhrResponseType = 'json';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };

            const downloadArrayBuffer = (url, options, onComplete) => {
              options.xhrResponseType = 'arraybuffer';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };

            const downloadCCON = (url, options, onComplete) => {
              downloadJson(url, options, (err, json) => {
                if (err) {
                  onComplete(err);
                  return;
                }

                const cconPreface = parseCCONJson(json);
                const chunkPromises = Promise.all(cconPreface.chunks.map(chunk => new Promise((resolve, reject) => {
                  downloadArrayBuffer(`${mainFileName(url)}${chunk}`, {}, (errChunk, chunkBuffer) => {
                    if (err) {
                      reject(err);
                    } else {
                      resolve(new Uint8Array(chunkBuffer));
                    }
                  });
                })));
                chunkPromises.then(chunks => {
                  const ccon = new CCON(cconPreface.document, chunks);
                  onComplete(null, ccon);
                }).catch(err => {
                  onComplete(err);
                });
              });
            };

            const downloadCCONB = (url, options, onComplete) => {
              downloadArrayBuffer(url, options, (err, arrayBuffer) => {
                if (err) {
                  onComplete(err);
                  return;
                }

                try {
                  const ccon = decodeCCONBinary(new Uint8Array(arrayBuffer));
                  onComplete(null, ccon);
                } catch (err) {
                  onComplete(err);
                }
              });
            };

            const downloadText = (url, options, onComplete) => {
              options.xhrResponseType = 'text';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };

            const downloadBundle = (nameOrUrl, options, onComplete) => {
              const bundleName = basename(nameOrUrl);
              let url = nameOrUrl;

              if (!REGEX.test(url)) {
                if (downloader.remoteBundles.indexOf(bundleName) !== -1) {
                  url = `${downloader.remoteServerAddress}remote/${bundleName}`;
                } else {
                  url = `assets/${bundleName}`;
                }
              }

              const version = options.version || downloader.bundleVers[bundleName];
              let count = 0;
              const config = `${url}/config.${version ? `${version}.` : ''}json`;
              let out = null;
              let error = null;
              downloadJson(config, options, (err, response) => {
                error = err;
                out = response;

                if (out) {
                  out.base = `${url}/`;
                }

                if (++count === 2) {
                  onComplete(error, out);
                }
              });
              const jspath = `${url}/index.${version ? `${version}.` : ''}js`;
              downloadScript(jspath, options, err => {
                error = err;

                if (++count === 2) {
                  onComplete(err, out);
                }
              });
            };

            class Downloader {
              constructor() {
                this.maxConcurrency = 6;
                this.maxRequestsPerFrame = 6;
                this.maxRetryCount =  3 ;
                this.appendTimeStamp = !!EDITOR;
                this.limited = !EDITOR;
                this.retryInterval = 2000;
                this.bundleVers = null;
                this.remoteBundles = [];
                this.downloadDomImage = downloadDomImage;
                this.downloadDomAudio = null;
                this.downloadFile = downloadFile;
                this.downloadScript = downloadScript;
                this._downloaders = {
                  '.png': downloadImage,
                  '.jpg': downloadImage,
                  '.bmp': downloadImage,
                  '.jpeg': downloadImage,
                  '.gif': downloadImage,
                  '.ico': downloadImage,
                  '.tiff': downloadImage,
                  '.webp': downloadImage,
                  '.image': downloadImage,
                  '.pvr': downloadArrayBuffer,
                  '.pkm': downloadArrayBuffer,
                  '.astc': downloadArrayBuffer,
                  '.txt': downloadText,
                  '.xml': downloadText,
                  '.vsh': downloadText,
                  '.fsh': downloadText,
                  '.atlas': downloadText,
                  '.tmx': downloadText,
                  '.tsx': downloadText,
                  '.json': downloadJson,
                  '.ExportJson': downloadJson,
                  '.plist': downloadText,
                  '.ccon': downloadCCON,
                  '.cconb': downloadCCONB,
                  '.fnt': downloadText,
                  '.binary': downloadArrayBuffer,
                  '.bin': downloadArrayBuffer,
                  '.dbbin': downloadArrayBuffer,
                  '.skel': downloadArrayBuffer,
                  '.js': downloadScript,
                  bundle: downloadBundle,
                  default: downloadText
                };
                this._downloading = new Cache();
                this._queue = [];
                this._queueDirty = false;
                this._totalNum = 0;
                this._totalNumThisPeriod = 0;
                this._lastDate = -1;
                this._checkNextPeriod = false;
                this._remoteServerAddress = '';
                this._maxInterval = 1 / 30;
              }

              get remoteServerAddress() {
                return this._remoteServerAddress;
              }

              init(remoteServerAddress = '', bundleVers = {}, remoteBundles = []) {
                this._downloading.clear();

                this._queue.length = 0;
                this._remoteServerAddress = remoteServerAddress;
                this.bundleVers = bundleVers;
                this.remoteBundles = remoteBundles;
              }

              register(type, handler) {
                if (typeof type === 'object') {
                  mixin(this._downloaders, type);
                } else {
                  this._downloaders[type] = handler;
                }
              }

              download(id, url, type, options, onComplete) {
                const file = files.get(id);

                if (file) {
                  onComplete(null, file);
                  return;
                }

                const downloadCallbacks = this._downloading.get(id);

                if (downloadCallbacks) {
                  downloadCallbacks.push(onComplete);

                  const request = this._queue.find(x => x.id === id);

                  if (!request) {
                    return;
                  }

                  const priority = options.priority || 0;

                  if (request.priority < priority) {
                    request.priority = priority;
                    this._queueDirty = true;
                  }

                  return;
                }

                const maxRetryCount = typeof options.maxRetryCount !== 'undefined' ? options.maxRetryCount : this.maxRetryCount;
                const maxConcurrency = typeof options.maxConcurrency !== 'undefined' ? options.maxConcurrency : this.maxConcurrency;
                const maxRequestsPerFrame = typeof options.maxRequestsPerFrame !== 'undefined' ? options.maxRequestsPerFrame : this.maxRequestsPerFrame;
                const handler = this._downloaders[type] || this._downloaders.default;

                const process = (index, callback) => {
                  if (index === 0) {
                    this._downloading.add(id, [onComplete]);
                  }

                  if (!this.limited) {
                    handler(urlAppendTimestamp(url, this.appendTimeStamp), options, callback);
                    return;
                  }

                  this._updateTime();

                  const done = (err, data) => {
                    this._totalNum--;

                    this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);

                    callback(err, data);
                  };

                  if (this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
                    handler(urlAppendTimestamp(url, this.appendTimeStamp), options, done);
                    this._totalNum++;
                    this._totalNumThisPeriod++;
                  } else {
                    this._queue.push({
                      id,
                      priority: options.priority || 0,
                      url,
                      options,
                      done,
                      handler
                    });

                    this._queueDirty = true;

                    if (this._totalNum < maxConcurrency) {
                      this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
                    }
                  }
                };

                const finale = (err, result) => {
                  if (!err) {
                    files.add(id, result);
                  }

                  const callbacks = this._downloading.remove(id);

                  for (let i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, result);
                  }
                };

                retry(process, maxRetryCount, this.retryInterval, finale);
              }

              loadSubpackage(name, completeCallback) {
                legacyCC.assetManager.loadBundle(name, null, completeCallback);
              }

              _updateTime() {
                const now = performance.now();
                const deltaTime = legacyCC.game.deltaTime;
                const interval = deltaTime > this._maxInterval ? this._maxInterval : deltaTime;

                if (now - this._lastDate > interval * 1000) {
                  this._totalNumThisPeriod = 0;
                  this._lastDate = now;
                }
              }

              _handleQueue(maxConcurrency, maxRequestsPerFrame) {
                this._checkNextPeriod = false;

                this._updateTime();

                while (this._queue.length > 0 && this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
                  if (this._queueDirty) {
                    this._queue.sort((a, b) => a.priority - b.priority);

                    this._queueDirty = false;
                  }

                  const request = this._queue.pop();

                  if (!request) {
                    break;
                  }

                  this._totalNum++;
                  this._totalNumThisPeriod++;
                  request.handler(urlAppendTimestamp(request.url, this.appendTimeStamp), request.options, request.done);
                }

                this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
              }

              _handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame) {
                if (!this._checkNextPeriod && this._queue.length > 0) {
                  callInNextTick(this._handleQueue.bind(this), maxConcurrency, maxRequestsPerFrame);
                  this._checkNextPeriod = true;
                }
              }

            }
            const downloader = exports('ca', new Downloader());

            function createImageAsset(id, data, options, onComplete) {
              let out = null;
              let err = null;

              try {
                out = new ImageAsset();
                out._nativeUrl = id;
                out._nativeAsset = data;
              } catch (e) {
                err = e;
              }

              onComplete(err, out);
            }

            function createJsonAsset(id, data, options, onComplete) {
              const out = new JsonAsset();
              out.json = data;
              onComplete(null, out);
            }

            function createTextAsset(id, data, options, onComplete) {
              const out = new TextAsset();
              out.text = data;
              onComplete(null, out);
            }

            function createBufferAsset(id, data, options, onComplete) {
              const out = new BufferAsset();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }

            function createAsset(id, data, options, onComplete) {
              const out = new Asset();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }

            function createBundle(id, data, options, onComplete) {
              console.error('pptest create bundles ' + JSON.stringify(data))
              let bundle = bundles.get(data.name);

              if (!bundle) {
                bundle = data.name === BuiltinBundleName.RESOURCES ? resources : new Bundle();
                data.base = data.base || `${id}/`;
                bundle.init(data);
              }

              module.import(`virtual:///prerequisite-imports/${bundle.name}`).then(() => {
                onComplete(null, bundle);
              }).catch(onComplete);
            }

            class Factory {
              constructor() {
                this._creating = new Cache();
                this._producers = {
                  '.png': createImageAsset,
                  '.jpg': createImageAsset,
                  '.bmp': createImageAsset,
                  '.jpeg': createImageAsset,
                  '.gif': createImageAsset,
                  '.ico': createImageAsset,
                  '.tiff': createImageAsset,
                  '.webp': createImageAsset,
                  '.image': createImageAsset,
                  '.pvr': createImageAsset,
                  '.pkm': createImageAsset,
                  '.txt': createTextAsset,
                  '.xml': createTextAsset,
                  '.vsh': createTextAsset,
                  '.fsh': createTextAsset,
                  '.atlas': createTextAsset,
                  '.tmx': createTextAsset,
                  '.tsx': createTextAsset,
                  '.fnt': createTextAsset,
                  '.json': createJsonAsset,
                  '.ExportJson': createJsonAsset,
                  '.binary': createBufferAsset,
                  '.bin': createBufferAsset,
                  '.dbbin': createBufferAsset,
                  '.skel': createBufferAsset,
                  bundle: createBundle,
                  default: createAsset
                };
              }

              register(type, handler) {
                if (typeof type === 'object') {
                  js.mixin(this._producers, type);
                } else {
                  this._producers[type] = handler;
                }
              }

              create(id, data, type, options, onComplete) {
                const handler = this._producers[type] || this._producers.default;
                const asset = assets.get(id);

                if (!options.reloadAsset && asset) {
                  onComplete(null, asset);
                  return;
                }

                const creating = this._creating.get(id);

                if (creating) {
                  creating.push(onComplete);
                  return;
                }

                this._creating.add(id, [onComplete]);

                handler(id, data, options, (err, result) => {
                  if (!err && result instanceof Asset) {
                    result._uuid = id;
                    cache(id, result, options.cacheAsset);
                  }

                  const callbacks = this._creating.remove(id);

                  for (let i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, result);
                  }
                });
              }

            }
            var factory = exports('cb', new Factory());

            class PackManager {
              constructor() {
                this._loading = new Cache();
                this._unpackers = {
                  '.json': this.unpackJson
                };
              }

              unpackJson(pack, json, options, onComplete) {
                let out = js.createMap(true);
                let err = null;

                if (Array.isArray(json)) {
                  json = unpackJSONs(json);

                  if (json.length !== pack.length) {
                    errorID(4915);
                  }

                  for (let i = 0; i < pack.length; i++) {
                    out[`${pack[i]}@import`] = json[i];
                  }
                } else {
                  const textureType = js._getClassId(Texture2D);

                  const imageAssetType = js._getClassId(ImageAsset);

                  if (json.type === textureType && json.data) {
                    const datas = json.data;

                    if (datas.length !== pack.length) {
                      errorID(4915);
                    }

                    for (let i = 0; i < pack.length; i++) {
                      out[`${pack[i]}@import`] = packCustomObjData(textureType, {
                        base: datas[i][0],
                        mipmaps: datas[i][1]
                      });
                    }
                  } else if (json.type === imageAssetType && json.data) {
                    const datas = json.data;

                    if (datas.length !== pack.length) {
                      errorID(4915);
                    }

                    for (let i = 0; i < pack.length; i++) {
                      out[`${pack[i]}@import`] = datas[i];
                    }
                  } else {
                    err = new Error('unmatched type pack!');
                    out = null;
                  }
                }

                onComplete(err, out);
              }

              init() {
                this._loading.clear();
              }

              register(type, handler) {
                if (typeof type === 'object') {
                  js.mixin(this._unpackers, type);
                } else {
                  this._unpackers[type] = handler;
                }
              }

              unpack(pack, data, type, options, onComplete) {
                if (!data) {
                  onComplete(new Error('package data is wrong!'));
                  return;
                }

                const unpacker = this._unpackers[type];
                unpacker(pack, data, options, onComplete);
              }

              load(item, options, onComplete) {
                if (item.isNative || !item.info || !item.info.packs) {
                  downloader.download(item.id, item.url, item.ext, item.options, onComplete);
                  return;
                }

                if (files.has(item.id)) {
                  onComplete(null, files.get(item.id));
                  return;
                }

                const packs = item.info.packs;
                let pack = packs.find(val => this._loading.has(val.uuid));

                if (pack) {
                  this._loading.get(pack.uuid).push({
                    onComplete,
                    id: item.id
                  });

                  return;
                }

                pack = packs[0];

                this._loading.add(pack.uuid, [{
                  onComplete,
                  id: item.id
                }]);

                const url = transform(pack.uuid, {
                  ext: pack.ext,
                  bundle: item.config.name
                });
                downloader.download(pack.uuid, url, pack.ext, item.options, (err, data) => {
                  files.remove(pack.uuid);

                  if (err) {
                    error(err.message, err.stack);
                  }

                  this.unpack(pack.packedUuids, data, pack.ext, item.options, (err2, result) => {
                    if (!err2) {
                      for (const id in result) {
                        files.add(id, result[id]);
                      }
                    }

                    const callbacks = this._loading.remove(pack.uuid);

                    for (let i = 0, l = callbacks.length; i < l; i++) {
                      const cb = callbacks[i];

                      if (err || err2) {
                        cb.onComplete(err || err2);
                        continue;
                      }

                      const unpackedData = result[cb.id];

                      if (!unpackedData) {
                        cb.onComplete(new Error('can not retrieve data from package'));
                      } else {
                        cb.onComplete(null, unpackedData);
                      }
                    }
                  });
                });
              }

            }
            var packManager = new PackManager();

            function fetch$1(task, done) {
              let firstTask = false;

              if (!task.progress) {
                task.progress = {
                  finish: 0,
                  total: task.input.length,
                  canInvoke: true
                };
                firstTask = true;
              }

              const {
                options,
                progress
              } = task;
              const depends = [];
              const total = progress.total;
              const exclude = options.__exclude__ = options.__exclude__ || Object.create(null);
              task.output = [];
              forEach(task.input, (item, cb) => {
                if (!item.isNative && assets.has(item.uuid)) {
                  const asset = assets.get(item.uuid);
                  item.content = asset.addRef();
                  task.output.push(item);

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }

                  cb();
                  return;
                }

                packManager.load(item, task.options, (err, data) => {
                  if (err) {
                    if (!task.isFinish) {
                      if (!legacyCC.assetManager.force || firstTask) {
                        error(err.message, err.stack);
                        progress.canInvoke = false;
                        done(err);
                      } else {
                        task.output.push(item);

                        if (progress.canInvoke) {
                          task.dispatch('progress', ++progress.finish, progress.total, item);
                        }
                      }
                    }
                  } else if (!task.isFinish) {
                    item.file = data;
                    task.output.push(item);

                    if (!item.isNative) {
                      exclude[item.uuid] = true;
                      getDepends(item.uuid, data, exclude, depends, item.config);
                      progress.total = total + depends.length;
                    }

                    if (progress.canInvoke) {
                      task.dispatch('progress', ++progress.finish, progress.total, item);
                    }
                  }

                  cb();
                });
              }, () => {
                if (task.isFinish) {
                  clear$1(task, true);
                  task.dispatch('error');
                  return;
                }

                if (depends.length > 0) {
                  const subTask = Task.create({
                    input: depends,
                    progress,
                    options,
                    onProgress: task.onProgress,
                    onError: Task.prototype.recycle,
                    onComplete: err => {
                      if (!err) {
                        task.output.push(...subTask.output);
                        subTask.recycle();
                      }

                      if (firstTask) {
                        decreaseRef(task);
                      }

                      done(err);
                    }
                  });
                  fetchPipeline.async(subTask);
                  return;
                }

                if (firstTask) {
                  decreaseRef(task);
                }

                done();
              });
            }

            function decreaseRef(task) {
              const output = task.output;

              for (let i = 0, l = output.length; i < l; i++) {
                if (output[i].content) {
                  output[i].content.decRef(false);
                }
              }
            }

            class SAXParser {
              constructor() {
                this._parser = null;

                if (window.DOMParser) {
                  this._parser = new DOMParser();
                }
              }

              parse(xmlTxt) {
                return this._parseXML(xmlTxt);
              }

              _parseXML(textxml) {
                if (this._parser) {
                  return this._parser.parseFromString(textxml, 'text/xml');
                }

                throw new Error('Dom parser is not supported in this platform!');
              }

            } exports('eU', SAXParser);

            class PlistParser extends SAXParser {
              parse(xmlTxt) {
                const xmlDoc = this._parseXML(xmlTxt);

                const plist = xmlDoc.documentElement;

                if (plist.tagName !== 'plist') {
                  warnID(5100);
                  return {};
                }

                let node = null;

                for (let i = 0, len = plist.childNodes.length; i < len; i++) {
                  node = plist.childNodes[i];

                  if (node.nodeType === 1) {
                    break;
                  }
                }

                return this._parseNode(node);
              }

              _parseNode(node) {
                let data = null;
                const tagName = node.tagName;

                if (tagName === 'dict') {
                  data = this._parseDict(node);
                } else if (tagName === 'array') {
                  data = this._parseArray(node);
                } else if (tagName === 'string') {
                  if (node.childNodes.length === 1) {
                    data = node.firstChild.nodeValue;
                  } else {
                    data = '';

                    for (let i = 0; i < node.childNodes.length; i++) {
                      data += node.childNodes[i].nodeValue;
                    }
                  }
                } else if (tagName === 'false') {
                  data = false;
                } else if (tagName === 'true') {
                  data = true;
                } else if (tagName === 'real') {
                  data = parseFloat(node.firstChild.nodeValue);
                } else if (tagName === 'integer') {
                  data = parseInt(node.firstChild.nodeValue, 10);
                }

                return data;
              }

              _parseArray(node) {
                const data = [];

                for (let i = 0, len = node.childNodes.length; i < len; i++) {
                  const child = node.childNodes[i];

                  if (child.nodeType !== 1) {
                    continue;
                  }

                  data.push(this._parseNode(child));
                }

                return data;
              }

              _parseDict(node) {
                const data = {};
                let key = '';

                for (let i = 0, len = node.childNodes.length; i < len; i++) {
                  const child = node.childNodes[i];

                  if (child.nodeType !== 1) {
                    continue;
                  }

                  if (child.tagName === 'key') {
                    key = child.firstChild.nodeValue;
                  } else {
                    data[key] = this._parseNode(child);
                  }
                }

                return data;
              }

            }

            const plistParser = new PlistParser();

            const PVR_HEADER_LENGTH = 13;
            const PVR_MAGIC = 0x03525650;
            const PVR_HEADER_MAGIC = 0;
            const PVR_HEADER_HEIGHT = 6;
            const PVR_HEADER_WIDTH = 7;
            const PVR_HEADER_METADATA = 12;
            const ETC_PKM_HEADER_SIZE = 16;
            const ETC_PKM_FORMAT_OFFSET = 6;
            const ETC_PKM_ENCODED_WIDTH_OFFSET = 8;
            const ETC_PKM_ENCODED_HEIGHT_OFFSET = 10;
            const ETC_PKM_WIDTH_OFFSET = 12;
            const ETC_PKM_HEIGHT_OFFSET = 14;
            const ETC1_RGB_NO_MIPMAPS = 0;
            const ETC2_RGB_NO_MIPMAPS = 1;
            const ETC2_RGBA_NO_MIPMAPS = 3;
            const ASTC_MAGIC = 0x5CA1AB13;
            const ASTC_HEADER_LENGTH = 16;
            const ASTC_HEADER_MAGIC = 4;
            const ASTC_HEADER_SIZE_X_BEGIN = 7;
            const ASTC_HEADER_SIZE_Y_BEGIN = 10;
            const ASTC_HEADER_SIZE_Z_BEGIN = 13;

            function getASTCFormat(xdim, ydim) {
              if (xdim === 4) {
                return PixelFormat.RGBA_ASTC_4x4;
              }

              if (xdim === 5) {
                if (ydim === 4) {
                  return PixelFormat.RGBA_ASTC_5x4;
                }

                return PixelFormat.RGBA_ASTC_5x5;
              }

              if (xdim === 6) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_6x5;
                }

                return PixelFormat.RGBA_ASTC_6x6;
              }

              if (xdim === 8) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_8x5;
                }

                if (ydim === 6) {
                  return PixelFormat.RGBA_ASTC_8x6;
                }

                return PixelFormat.RGBA_ASTC_8x8;
              }

              if (xdim === 10) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_10x5;
                }

                if (ydim === 6) {
                  return PixelFormat.RGBA_ASTC_10x6;
                }

                if (ydim === 8) {
                  return PixelFormat.RGBA_ASTC_10x8;
                }

                return PixelFormat.RGBA_ASTC_10x10;
              }

              if (ydim === 10) {
                return PixelFormat.RGBA_ASTC_12x10;
              }

              return PixelFormat.RGBA_ASTC_12x12;
            }

            function readBEUint16(header, offset) {
              return header[offset] << 8 | header[offset + 1];
            }

            class Parser$1 {
              constructor() {
                this._parsing = new Cache();
                this._parsers = {
                  '.png': this.parseImage,
                  '.jpg': this.parseImage,
                  '.bmp': this.parseImage,
                  '.jpeg': this.parseImage,
                  '.gif': this.parseImage,
                  '.ico': this.parseImage,
                  '.tiff': this.parseImage,
                  '.webp': this.parseImage,
                  '.image': this.parseImage,
                  '.pvr': this.parsePVRTex,
                  '.pkm': this.parsePKMTex,
                  '.astc': this.parseASTCTex,
                  '.plist': this.parsePlist,
                  import: this.parseImport,
                  '.ccon': this.parseImport,
                  '.cconb': this.parseImport
                };
              }

              parseImage(file, options, onComplete) {
                if (file instanceof HTMLImageElement) {
                  onComplete(null, file);
                  return;
                }

                createImageBitmap(file, {
                  premultiplyAlpha: 'none'
                }).then(result => {
                  onComplete(null, result);
                }, err => {
                  onComplete(err, null);
                });
              }

              parsePVRTex(file, options, onComplete) {
                let err = null;
                let out = null;

                try {
                  const buffer = file instanceof ArrayBuffer ? file : file.buffer;
                  const header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH);

                  if (header[PVR_HEADER_MAGIC] === PVR_MAGIC) {
                    const width = header[PVR_HEADER_WIDTH];
                    const height = header[PVR_HEADER_HEIGHT];
                    const dataOffset = header[PVR_HEADER_METADATA] + 52;
                    const pvrtcData = new Uint8Array(buffer, dataOffset);
                    out = {
                      _data: pvrtcData,
                      _compressed: true,
                      width,
                      height,
                      format: 0
                    };
                  } else if (header[11] === 0x21525650) {
                    const headerLength = header[0];
                    const height = header[1];
                    const width = header[2];
                    const pvrtcData = new Uint8Array(buffer, headerLength);
                    out = {
                      _data: pvrtcData,
                      _compressed: true,
                      width,
                      height,
                      format: 0
                    };
                  } else {
                    throw new Error('Invalid magic number in PVR header');
                  }
                } catch (e) {
                  err = e;
                }

                onComplete(err, out);
              }

              parsePKMTex(file, options, onComplete) {
                let err = null;
                let out = null;

                try {
                  const buffer = file instanceof ArrayBuffer ? file : file.buffer;
                  const header = new Uint8Array(buffer);
                  const format = readBEUint16(header, ETC_PKM_FORMAT_OFFSET);

                  if (format !== ETC1_RGB_NO_MIPMAPS && format !== ETC2_RGB_NO_MIPMAPS && format !== ETC2_RGBA_NO_MIPMAPS) {
                    throw new Error('Invalid magic number in ETC header');
                  }

                  const width = readBEUint16(header, ETC_PKM_WIDTH_OFFSET);
                  const height = readBEUint16(header, ETC_PKM_HEIGHT_OFFSET);
                  const encodedWidth = readBEUint16(header, ETC_PKM_ENCODED_WIDTH_OFFSET);
                  const encodedHeight = readBEUint16(header, ETC_PKM_ENCODED_HEIGHT_OFFSET);
                  const etcData = new Uint8Array(buffer, ETC_PKM_HEADER_SIZE);
                  out = {
                    _data: etcData,
                    _compressed: true,
                    width,
                    height,
                    format: 0
                  };
                } catch (e) {
                  err = e;
                }

                onComplete(err, out);
              }

              parseASTCTex(file, options, onComplete) {
                let err = null;
                let out = null;

                try {
                  const buffer = file instanceof ArrayBuffer ? file : file.buffer;
                  const header = new Uint8Array(buffer);
                  const magicval = header[0] + (header[1] << 8) + (header[2] << 16) + (header[3] << 24);

                  if (magicval !== ASTC_MAGIC) {
                    throw new Error('Invalid magic number in ASTC header');
                  }

                  const xdim = header[ASTC_HEADER_MAGIC];
                  const ydim = header[ASTC_HEADER_MAGIC + 1];
                  const zdim = header[ASTC_HEADER_MAGIC + 2];

                  if ((xdim < 3 || xdim > 6 || ydim < 3 || ydim > 6 || zdim < 3 || zdim > 6) && (xdim < 4 || xdim === 7 || xdim === 9 || xdim === 11 || xdim > 12 || ydim < 4 || ydim === 7 || ydim === 9 || ydim === 11 || ydim > 12 || zdim !== 1)) {
                    throw new Error('Invalid block number in ASTC header');
                  }

                  const format = getASTCFormat(xdim, ydim);
                  const xsize = header[ASTC_HEADER_SIZE_X_BEGIN] + (header[ASTC_HEADER_SIZE_X_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_X_BEGIN + 2] << 16);
                  const ysize = header[ASTC_HEADER_SIZE_Y_BEGIN] + (header[ASTC_HEADER_SIZE_Y_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_Y_BEGIN + 2] << 16);
                  const zsize = header[ASTC_HEADER_SIZE_Z_BEGIN] + (header[ASTC_HEADER_SIZE_Z_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_Z_BEGIN + 2] << 16);
                  const astcData = new Uint8Array(buffer, ASTC_HEADER_LENGTH);
                  out = {
                    _data: astcData,
                    _compressed: true,
                    width: xsize,
                    height: ysize,
                    format
                  };
                } catch (e) {
                  err = e;
                }

                onComplete(err, out);
              }

              parsePlist(file, options, onComplete) {
                let err = null;
                const result = plistParser.parse(file);

                if (!result) {
                  err = new Error('parse failed');
                }

                onComplete(err, result);
              }

              parseImport(file, options, onComplete) {
                if (!file) {
                  onComplete(new Error(`The json file of asset ${options.__uuid__} is empty or missing`));
                  return;
                }

                let result = null;
                let err = null;

                try {
                  result = deserializeAsset(file, options);
                } catch (e) {
                  err = e;
                }

                onComplete(err, result);
              }

              init() {
                this._parsing.clear();
              }

              register(type, handler) {
                if (typeof type === 'object') {
                  mixin(this._parsers, type);
                } else {
                  this._parsers[type] = handler;
                }
              }

              parse(id, file, type, options, onComplete) {
                const parsedAsset = parsed.get(id);

                if (parsedAsset) {
                  onComplete(null, parsedAsset);
                  return;
                }

                const parsing = this._parsing.get(id);

                if (parsing) {
                  parsing.push(onComplete);
                  return;
                }

                const parseHandler = this._parsers[type];

                if (!parseHandler) {
                  onComplete(null, file);
                  return;
                }

                this._parsing.add(id, [onComplete]);

                parseHandler(file, options, (err, data) => {
                  if (err) {
                    files.remove(id);
                  } else if (!isScene(data)) {
                    parsed.add(id, data);
                  }

                  const callbacks = this._parsing.remove(id);

                  for (let i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, data);
                  }
                });
              }

            }
            var parser = new Parser$1();

            function load(task, done) {
              let firstTask = false;

              if (!task.progress) {
                task.progress = {
                  finish: 0,
                  total: task.input.length,
                  canInvoke: true
                };
                firstTask = true;
              }

              const {
                options,
                progress
              } = task;
              options.__exclude__ = options.__exclude__ || Object.create(null);
              task.output = [];
              forEach(task.input, (item, cb) => {
                const subTask = Task.create({
                  input: item,
                  onProgress: task.onProgress,
                  options,
                  progress,
                  onComplete: (err, result) => {
                    if (err && !task.isFinish) {
                      if (!legacyCC.assetManager.force || firstTask) {
                        {
                          error(err.message, err.stack);
                        }

                        progress.canInvoke = false;
                        done(err);
                      } else if (progress.canInvoke) {
                        task.dispatch('progress', ++progress.finish, progress.total, item);
                      }
                    }

                    task.output.push(result);
                    subTask.recycle();
                    cb(null);
                  }
                });
                loadOneAssetPipeline.async(subTask);
              }, () => {
                options.__exclude__ = null;

                if (task.isFinish) {
                  clear$1(task, true);
                  task.dispatch('error');
                  return;
                }

                gatherAsset(task);
                clear$1(task, true);
                done();
              });
            }
            const loadOneAssetPipeline = new Pipeline('loadOneAsset', [function fetch(task, done) {
              const item = task.output = task.input;
              const {
                options,
                isNative,
                uuid,
                file
              } = item;
              const {
                reloadAsset
              } = options;

              if (file || !reloadAsset && !isNative && assets.has(uuid)) {
                done();
                return;
              }

              packManager.load(item, task.options, (err, data) => {
                item.file = data;
                done(err);
              });
            }, function parse(task, done) {
              const item = task.output = task.input;
              const progress = task.progress;
              const exclude = task.options.__exclude__;
              const {
                id,
                file,
                options
              } = item;

              if (item.isNative) {
                parser.parse(id, file, item.ext, options, (err, asset) => {
                  if (err) {
                    done(err);
                    return;
                  }

                  item.content = asset;

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }

                  files.remove(id);
                  parsed.remove(id);
                  done();
                });
              } else {
                const {
                  uuid
                } = item;

                if (uuid in exclude) {
                  const {
                    finish,
                    content,
                    err,
                    callbacks
                  } = exclude[uuid];

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }

                  if (finish || checkCircleReference(uuid, uuid, exclude)) {
                    if (content) {
                      content.addRef();
                    }

                    item.content = content;
                    done(err);
                  } else {
                    callbacks.push({
                      done,
                      item
                    });
                  }
                } else if (!options.reloadAsset && assets.has(uuid)) {
                  const asset = assets.get(uuid);
                  item.content = asset.addRef();

                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }

                  done();
                } else {
                  options.__uuid__ = uuid;
                  parser.parse(id, file, 'import', options, (err, asset) => {
                    if (err) {
                      done(err);
                      return;
                    }

                    loadDepends(task, asset, done);
                  });
                }
              }
            }]);

            function loadDepends(task, asset, done) {
              const {
                input: item,
                progress
              } = task;
              const {
                uuid,
                id,
                options,
                config
              } = item;
              const {
                cacheAsset
              } = options;
              const depends = [];

              if (asset.addRef) {
                asset.addRef();
              }

              getDepends(uuid, asset, Object.create(null), depends, config);

              if (progress.canInvoke) {
                task.dispatch('progress', ++progress.finish, progress.total += depends.length, item);
              }

              const repeatItem = task.options.__exclude__[uuid] = {
                content: asset,
                finish: false,
                callbacks: [{
                  done,
                  item
                }]
              };
              const subTask = Task.create({
                input: depends,
                options: task.options,
                onProgress: task.onProgress,
                onError: Task.prototype.recycle,
                progress,
                onComplete: err => {
                  if (asset.decRef) {
                    asset.decRef(false);
                  }

                  repeatItem.finish = true;
                  repeatItem.err = err;

                  if (!err) {
                    const output = Array.isArray(subTask.output) ? subTask.output : [subTask.output];
                    const map = Object.create(null);

                    for (const dependAsset of output) {
                      if (!dependAsset) {
                        continue;
                      }

                      map[dependAsset instanceof Asset ? `${dependAsset._uuid}@import` : `${uuid}@native`] = dependAsset;
                    }

                    setProperties(uuid, asset, map);

                    try {
                      if (typeof asset.onLoaded === 'function' && !onLoadedInvokedMap.has(asset) && !nativeDependMap.has(asset)) {
                        asset.onLoaded();
                        onLoadedInvokedMap.add(asset);
                      }
                    } catch (e) {
                      error(`The asset ${uuid} is invalid for some reason, detail message: ${e.message}, stack: ${e.stack}`);
                    }

                    files.remove(id);
                    parsed.remove(id);

                    cache(uuid, asset, cacheAsset);
                    subTask.recycle();
                  }

                  const callbacks = repeatItem.callbacks;

                  for (let i = 0, l = callbacks.length; i < l; i++) {
                    const cb = callbacks[i];

                    if (asset.addRef) {
                      asset.addRef();
                    }

                    cb.item.content = asset;
                    cb.done(err);
                  }

                  callbacks.length = 0;
                }
              });
              pipeline.async(subTask);
            }

            function preprocess(task, done) {
              const options = task.options;
              const subOptions = Object.create(null);
              const leftOptions = Object.create(null);

              for (const op in options) {
                switch (op) {
                  case RequestType.PATH:
                  case RequestType.UUID:
                  case RequestType.DIR:
                  case RequestType.SCENE:
                  case RequestType.URL:
                    break;

                  case '__requestType__':
                  case '__isNative__':
                  case 'ext':
                  case 'type':
                  case '__nativeName__':
                  case 'audioLoadMode':
                  case 'bundle':
                    subOptions[op] = options[op];
                    break;

                  case '__exclude__':
                  case '__outputAsArray__':
                    leftOptions[op] = options[op];
                    break;

                  default:
                    subOptions[op] = options[op];
                    leftOptions[op] = options[op];
                    break;
                }
              }

              task.options = leftOptions;
              const subTask = Task.create({
                input: task.input,
                options: subOptions
              });
              let err = null;

              try {
                task.output = task.source = transformPipeline.sync(subTask);
              } catch (e) {
                err = e;

                for (let i = 0, l = subTask.output.length; i < l; i++) {
                  subTask.output[i].recycle();
                }
              }

              subTask.recycle();
              done(err);
            }

            class RequestItem {
              constructor() {
                this.uuid = '';
                this.url = '';
                this.ext = '.json';
                this.content = null;
                this.file = null;
                this.info = null;
                this.config = null;
                this.isNative = false;
                this.options = Object.create(null);
                this._id = '';
              }

              get id() {
                if (!this._id) {
                  this._id = `${this.uuid}@${this.isNative ? 'native' : 'import'}`;
                }

                return this._id;
              }

              static create() {
                let out;

                if (RequestItem._deadPool.length !== 0) {
                  out = RequestItem._deadPool.pop();
                } else {
                  out = new RequestItem();
                }

                return out;
              }

              recycle() {
                if (RequestItem._deadPool.length === RequestItem.MAX_DEAD_NUM) {
                  return;
                }

                this._id = '';
                this.uuid = '';
                this.url = '';
                this.ext = '.json';
                this.content = null;
                this.file = null;
                this.info = null;
                this.config = null;
                this.isNative = false;
                this.options = Object.create(null);

                RequestItem._deadPool.push(this);
              }

            }
            RequestItem.MAX_DEAD_NUM = 500;
            RequestItem._deadPool = [];

            const infos = [];
            function parse(task) {
              var _info2;

              const options = task.options;
              const input = Array.isArray(task.input) ? task.input : [task.input];
              task.output = [];

              for (let i = 0; i < input.length; i++) {
                let item = input[i];
                let out = RequestItem.create();
                let config = null;
                let info = null;

                if (typeof item === 'string') {
                  item = Object.create(null);
                  item[options.__requestType__ || RequestType.UUID] = input[i];
                }

                if (typeof item === 'object') {
                  addon(item, options);

                  if (item.preset) {
                    addon(item, presets[item.preset]);
                  }

                  for (const key in item) {
                    switch (key) {
                      case RequestType.UUID:
                        {
                          var _info;

                          const uuid = out.uuid = decodeUuid(item.uuid);

                          if (!item.bundle) {
                            const bundle = bundles.find(bundle => !!bundle.getAssetInfo(uuid));
                            item.bundle = bundle && bundle.name;
                          }

                          if (bundles.has(item.bundle)) {
                            config = bundles.get(item.bundle).config;
                            info = config.getAssetInfo(uuid);

                            if (info && info.redirect) {
                              if (!bundles.has(info.redirect)) {
                                throw new Error(`Please load bundle ${info.redirect} first`);
                              }

                              config = bundles.get(info.redirect).config;
                              info = config.getAssetInfo(uuid);
                            }

                            out.config = config;
                            out.info = info;
                          }

                          out.ext = item.ext || ((_info = info) === null || _info === void 0 ? void 0 : _info.extension) || '.json';
                          break;
                        }

                      case '__requestType__':
                      case 'ext':
                      case 'bundle':
                      case 'preset':
                      case 'type':
                        break;

                      case RequestType.DIR:
                        if (bundles.has(item.bundle)) {
                          bundles.get(item.bundle).config.getDirWithPath(item.dir, item.type, infos);

                          for (const assetInfo of infos) {
                            input.push({
                              uuid: assetInfo.uuid,
                              __isNative__: false,
                              ext: assetInfo.extension || '.json',
                              bundle: item.bundle
                            });
                          }

                          infos.length = 0;
                        }

                        out.recycle();
                        out = null;
                        break;

                      case RequestType.PATH:
                        if (bundles.has(item.bundle)) {
                          config = bundles.get(item.bundle).config;
                          info = config.getInfoWithPath(item.path, item.type);

                          if (info && info.redirect) {
                            if (!bundles.has(info.redirect)) {
                              throw new Error(`you need to load bundle ${info.redirect} first`);
                            }

                            config = bundles.get(info.redirect).config;
                            info = config.getAssetInfo(info.uuid);
                          }

                          if (!info) {
                            out.recycle();
                            throw new Error(`Bundle ${item.bundle} doesn't contain ${item.path}`);
                          }

                          out.config = config;
                          out.uuid = info.uuid;
                          out.info = info;
                        }

                        out.ext = item.ext || ((_info2 = info) === null || _info2 === void 0 ? void 0 : _info2.extension) || '.json';
                        break;

                      case RequestType.SCENE:
                        if (!item.bundle) {
                          const bundle = bundles.find(bundle => !!bundle.getSceneInfo(item.scene));
                          item.bundle = bundle && bundle.name;
                        }

                        if (bundles.has(item.bundle)) {
                          config = bundles.get(item.bundle).config;
                          info = config.getSceneInfo(item.scene);

                          if (info && info.redirect) {
                            if (!bundles.has(info.redirect)) {
                              throw new Error(`you need to load bundle ${info.redirect} first`);
                            }

                            config = bundles.get(info.redirect).config;
                            info = config.getAssetInfo(info.uuid);
                          }

                          if (!info) {
                            out.recycle();
                            throw new Error(`Bundle ${config.name} doesn't contain scene ${item.scene}`);
                          }

                          out.config = config;
                          out.uuid = info.uuid;
                          out.info = info;
                        }

                        break;

                      case '__isNative__':
                        out.isNative = item.__isNative__;
                        break;

                      case RequestType.URL:
                        out.url = item.url;
                        out.uuid = item.uuid || item.url;
                        out.ext = item.ext || extname(item.url);
                        out.isNative = item.__isNative__ !== undefined ? item.__isNative__ : true;
                        break;

                      default:
                        out.options[key] = item[key];
                    }

                    if (!out) {
                      break;
                    }
                  }
                }

                if (!out) {
                  continue;
                }

                task.output.push(out);

                if (!out.uuid && !out.url) {
                  throw new Error(`Can not parse this input:${JSON.stringify(item)}`);
                }
              }

              return null;
            }
            function combine(task) {
              const input = task.output = task.input;

              for (let i = 0; i < input.length; i++) {
                const item = input[i];

                if (item.url) {
                  continue;
                }

                let url = '';
                let base = '';
                const config = item.config;

                if (item.isNative) {
                  base = config && config.nativeBase ? config.base + config.nativeBase : legacyCC.assetManager.generalNativeBase;
                } else {
                  base = config && config.importBase ? config.base + config.importBase : legacyCC.assetManager.generalImportBase;
                }

                const uuid = item.uuid;
                let ver = '';

                if (item.info) {
                  if (item.isNative) {
                    ver = item.info.nativeVer ? `.${item.info.nativeVer}` : '';
                  } else {
                    ver = item.info.ver ? `.${item.info.ver}` : '';
                  }
                }

                if (item.ext === '.ttf') {
                  url = `${base}/${uuid.slice(0, 2)}/${uuid}${ver}/${item.options.__nativeName__}`;
                } else {
                  url = `${base}/${uuid.slice(0, 2)}/${uuid}${ver}${item.ext}`;
                }

                item.url = url;
              }

              return null;
            }

            class AssetManager {
              constructor() {
                this.pipeline = pipeline.append(preprocess).append(load);
                this.fetchPipeline = fetchPipeline.append(preprocess).append(fetch$1);
                this.transformPipeline = transformPipeline.append(parse).append(combine);
                this.bundles = bundles;
                this.assets = assets;
                this.generalImportBase = '';
                this.generalNativeBase = '';
                this.dependUtil = dependUtil;
                this.force =  PREVIEW;
                this.allowImageBitmap = !sys.isMobile;
                this.utils = helper;
                this.downloader = downloader;
                this.parser = parser;
                this.packManager = packManager;
                this.cacheAsset = true;
                this.cacheManager = null;
                this.presets = presets;
                this.factory = factory;
                this.preprocessPipe = preprocess;
                this.fetchPipe = fetch$1;
                this.loadPipe = load;
                this.references = references;
                this._releaseManager = releaseManager;
                this._files = files;
                this._parsed = parsed;
                this._parsePipeline =  null ;
              }

              get main() {
                return bundles.get(BuiltinBundleName.MAIN) || null;
              }

              get resources() {
                return bundles.get(BuiltinBundleName.RESOURCES) || null;
              }

              init(options = {}) {
                this._files.clear();

                this._parsed.clear();

                this._releaseManager.init();

                this.assets.clear();
                this.bundles.clear();
                this.packManager.init();
                this.downloader.init(options.server, options.bundleVers, options.remoteBundles);
                this.parser.init();
                this.dependUtil.init();
                let importBase = options.importBase || '';

                if (importBase && importBase.endsWith('/')) {
                  importBase = importBase.substr(0, importBase.length - 1);
                }

                let nativeBase = options.nativeBase || '';

                if (nativeBase && nativeBase.endsWith('/')) {
                  nativeBase = nativeBase.substr(0, nativeBase.length - 1);
                }

                this.generalImportBase = importBase;
                this.generalNativeBase = nativeBase;
              }

              getBundle(name) {
                return bundles.get(name) || null;
              }

              removeBundle(bundle) {
                bundle._destroy();

                bundles.remove(bundle.name);
              }

              loadAny(requests, options, onProgress, onComplete) {
                const {
                  options: opts,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseParameters(options, onProgress, onComplete);
                opts.preset = opts.preset || 'default';
                requests = Array.isArray(requests) ? requests.slice() : requests;
                const task = Task.create({
                  input: requests,
                  onProgress: onProg,
                  onComplete: asyncify(onComp),
                  options: opts
                });
                pipeline.async(task);
              }

              preloadAny(requests, options, onProgress, onComplete) {
                const {
                  options: opts,
                  onProgress: onProg,
                  onComplete: onComp
                } = parseParameters(options, onProgress, onComplete);
                opts.preset = opts.preset || 'preload';
                requests = Array.isArray(requests) ? requests.slice() : requests;
                const task = Task.create({
                  input: requests,
                  onProgress: onProg,
                  onComplete: asyncify(onComp),
                  options: opts
                });
                fetchPipeline.async(task);
              }

              loadRemote(url, options, onComplete) {
                const {
                  options: opts,
                  onComplete: onComp
                } = parseParameters(options, undefined, onComplete);

                if (!opts.reloadAsset && this.assets.has(url)) {
                  asyncify(onComp)(null, this.assets.get(url));
                  return;
                }

                opts.__isNative__ = true;
                opts.preset = opts.preset || 'remote';
                this.loadAny({
                  url
                }, opts, null, (err, data) => {
                  if (err) {
                    error(err.message, err.stack);

                    if (onComp) {
                      onComp(err, data);
                    }
                  } else {
                    factory.create(url, data, opts.ext || extname(url), opts, (p1, p2) => {
                      if (onComp) {
                        onComp(p1, p2);
                      }
                    });
                  }
                });
              }

              loadBundle(nameOrUrl, options, onComplete) {
                const {
                  options: opts,
                  onComplete: onComp
                } = parseParameters(options, undefined, onComplete);
                const bundleName = basename(nameOrUrl);

                if (this.bundles.has(bundleName)) {
                  asyncify(onComp)(null, this.getBundle(bundleName));
                  return;
                }

                opts.preset = opts.preset || 'bundle';
                opts.ext = 'bundle';
                opts.__isNative__ = true;
                this.loadAny({
                  url: nameOrUrl
                }, opts, null, (err, data) => {
                  if (err) {
                    error(err.message, err.stack);

                    if (onComp) {
                      onComp(err, data);
                    }
                  } else {
                    factory.create(nameOrUrl, data, 'bundle', opts, (p1, p2) => {
                      if (onComp) {
                        onComp(p1, p2);
                      }
                    });
                  }
                });
              }

              releaseAsset(asset) {
                releaseManager.tryRelease(asset, true);
              }

              releaseUnusedAssets() {
                assets.forEach(asset => {
                  releaseManager.tryRelease(asset);
                });
              }

              releaseAll() {
                assets.forEach(asset => {
                  releaseManager.tryRelease(asset, true);
                });
              }

              loadWithJson(json, options, onProgress, onComplete) {
                {
                  throw new Error('Only valid in Editor');
                }
              }

            } exports('g8', AssetManager);
            AssetManager.Pipeline = Pipeline;
            AssetManager.Task = Task;
            AssetManager.Cache = Cache;
            AssetManager.RequestItem = RequestItem;
            AssetManager.Bundle = Bundle;
            AssetManager.BuiltinBundleName = BuiltinBundleName;
            var assetManager = exports('eS', legacyCC.assetManager = new AssetManager());
            legacyCC.AssetManager = AssetManager;

            const ImageFmts = ['.png', '.jpg', '.bmp', '.jpeg', '.gif', '.ico', '.tiff', '.webp', '.image', '.pvr', '.pkm', '.astc'];
            const AudioFmts = ['.mp3', '.ogg', '.wav', '.m4a'];

            function GetTrue() {
              return true;
            }

            const md5Pipe = {
              transformURL(url) {
                const uuid = getUuidFromURL(url);

                if (!uuid) {
                  return url;
                }

                const bundle = bundles.find(b => !!b.getAssetInfo(uuid));

                if (!bundle) {
                  return url;
                }

                let hashValue = '';
                const info = bundle.getAssetInfo(uuid);

                if (url.startsWith(bundle.base + bundle.config.nativeBase)) {
                  hashValue = info.nativeVer || '';
                } else {
                  hashValue = info.ver || '';
                }

                if (!hashValue || url.indexOf(hashValue) !== -1) {
                  return url;
                }

                let hashPatchInFolder = false;

                if (extname(url) === '.ttf') {
                  hashPatchInFolder = true;
                }

                if (hashPatchInFolder) {
                  const dirname$1 = dirname(url);
                  const basename$1 = basename(url);
                  url = `${dirname$1}.${hashValue}/${basename$1}`;
                } else {
                  url = url.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,})/, (match, uuid) => `${match}.${hashValue}`);
                }

                return url;
              }

            };
            class CCLoader {
              constructor() {
                this._autoReleaseSetting = Object.create(null);
                this._parseLoadResArgs = parseLoadResArgs;
              }

              set onProgress(val) {
                setDefaultProgressCallback(val);
              }

              get _cache() {
                if (assets instanceof Cache) {
                  return assets._map;
                } else {
                  const map = {};
                  assets.forEach((val, key) => {
                    map[key] = val;
                  });
                  return map;
                }
              }

              load(res, progressCallback, completeCallback) {
                if (completeCallback === undefined) {
                  if (progressCallback !== undefined) {
                    completeCallback = progressCallback;
                    progressCallback = null;
                  }
                }

                const requests = Array.isArray(res) ? res : [res];

                for (let i = 0; i < requests.length; i++) {
                  const item = requests[i];

                  if (typeof item === 'string') {
                    requests[i] = {
                      url: item,
                      __isNative__: true
                    };
                  } else {
                    if (item.type) {
                      item.ext = `.${item.type}`;
                      item.type = undefined;
                    }

                    if (item.url) {
                      item.__isNative__ = true;
                    }
                  }
                }

                const images = [];
                const audios = [];
                assetManager.loadAny(requests, null, (finish, total, item) => {
                  if (item.content) {
                    if (ImageFmts.includes(item.ext)) {
                      images.push(item.content);
                    } else if (AudioFmts.includes(item.ext)) {
                      audios.push(item.content);
                    }
                  }

                  if (progressCallback) {
                    progressCallback(finish, total, item);
                  }
                }, (err, native) => {
                  let out = null;

                  if (!err) {
                    native = Array.isArray(native) ? native : [native];

                    for (let i = 0; i < native.length; i++) {
                      const item = native[i];

                      if (!(item instanceof Asset)) {
                        let asset = item;
                        const url = requests[i].url;

                        if (images.includes(asset)) {
                          factory.create(url, item, '.png', {}, (err, image) => {
                            asset = native[i] = image;
                          });
                        } else if (audios.includes(asset)) {
                          factory.create(url, item, '.mp3', {}, (err, audio) => {
                            asset = native[i] = audio;
                          });
                        }

                        assets.add(url, asset);
                      }
                    }

                    if (native.length > 1) {
                      const map = Object.create(null);
                      native.forEach(asset => {
                        map[asset._uuid] = asset;
                      });
                      out = {
                        isCompleted: GetTrue,
                        _map: map
                      };
                    } else {
                      out = native[0];
                    }
                  }

                  if (completeCallback) {
                    completeCallback(err, out);
                  }
                });
              }

              getXMLHttpRequest() {
                return new XMLHttpRequest();
              }

              getItem(id) {
                return assetManager.assets.has(id) ? {
                  content: assetManager.assets.get(id)
                } : null;
              }

              loadRes(url, type, progressCallback, completeCallback) {
                const {
                  type: _type,
                  onProgress,
                  onComplete
                } = this._parseLoadResArgs(type, progressCallback, completeCallback);

                const extname$1 = extname(url);

                if (extname$1 && !resources.getInfoWithPath(url, _type)) {
                  url = url.slice(0, -extname$1.length);
                }

                resources.load(url, _type, onProgress, onComplete);
              }

              loadResArray(urls, type, progressCallback, completeCallback) {
                const {
                  type: _type,
                  onProgress,
                  onComplete
                } = this._parseLoadResArgs(type, progressCallback, completeCallback);

                urls.forEach((url, i) => {
                  const extname$1 = extname(url);

                  if (extname$1 && !resources.getInfoWithPath(url, _type)) {
                    urls[i] = url.slice(0, -extname$1.length);
                  }
                });
                resources.load(urls, _type, onProgress, onComplete);
              }

              loadResDir(url, type, progressCallback, completeCallback) {
                const {
                  type: _type,
                  onProgress,
                  onComplete
                } = this._parseLoadResArgs(type, progressCallback, completeCallback);

                resources.loadDir(url, _type, onProgress, (err, out) => {
                  let urls = [];

                  if (!err) {
                    const infos = resources.getDirWithPath(url, _type);
                    urls = infos.map(info => info.path);
                  }

                  if (onComplete) {
                    onComplete(err, out, urls);
                  }
                });
              }

              getRes(url, type) {
                return assets.has(url) ? assets.get(url) : resources.get(url, type);
              }

              getResCount() {
                return assets.count;
              }

              getDependsRecursively(owner) {
                if (!owner) {
                  return [];
                }

                const uuid = typeof owner === 'string' ? owner : owner._uuid;
                return dependUtil.getDepsRecursively(uuid).concat([uuid]);
              }

              get md5Pipe() {
                return md5Pipe;
              }

              get downloader() {
                return downloader;
              }

              get loader() {
                return assetManager.parser;
              }

              addDownloadHandlers(extMap) {
                const handler = Object.create(null);

                for (const type in extMap) {
                  const func = extMap[type];

                  handler[`.${type}`] = (url, options, onComplete) => {
                    func({
                      url
                    }, onComplete);
                  };
                }

                downloader.register(handler);
              }

              addLoadHandlers(extMap) {
                const handler = Object.create(null);

                for (const type in extMap) {
                  const func = extMap[type];

                  handler[`.${type}`] = (file, options, onComplete) => {
                    func({
                      content: file
                    }, onComplete);
                  };
                }

                parser.register(handler);
              }

              release(asset) {
                if (Array.isArray(asset)) {
                  for (let i = 0; i < asset.length; i++) {
                    let key = asset[i];

                    if (typeof key === 'string') {
                      key = assets.get(key);
                    }

                    assetManager.releaseAsset(key);
                  }
                } else if (asset) {
                  if (typeof asset === 'string') {
                    asset = assets.get(asset);
                  }

                  assetManager.releaseAsset(asset);
                }
              }

              releaseAsset(asset) {
                assetManager.releaseAsset(asset);
              }

              releaseRes(res, type) {
                resources.release(res, type);
              }

              releaseAll() {
                assetManager.releaseAll();
                assets.clear();
              }

              removeItem(id) {
                return !!assets.remove(id);
              }

              setAutoRelease(asset, autoRelease) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }

                this._autoReleaseSetting[asset] = !!autoRelease;
              }

              setAutoReleaseRecursively(asset, autoRelease) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }

                autoRelease = !!autoRelease;
                this._autoReleaseSetting[asset] = autoRelease;
                const depends = dependUtil.getDepsRecursively(asset);

                for (let i = 0; i < depends.length; i++) {
                  this._autoReleaseSetting[depends[i]] = autoRelease;
                }
              }

              isAutoRelease(asset) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }

                return !!this._autoReleaseSetting[asset];
              }

            } exports('ga', CCLoader);
            const loader = exports('gb', new CCLoader());
            const AssetLibrary = exports('gc', {
              init(options) {
                options.importBase = options.libraryPath;
                options.nativeBase =  options.rawAssetsBase ;
                assetManager.init(options);

                if (options.rawAssets) {
                  resources.init({
                    base: '',
                    deps: [],
                    scenes: {},
                    redirect: [],
                    debug: true,
                    packs: {},
                    types: [],
                    versions: {
                      import: [],
                      native: []
                    },
                    name: BuiltinBundleName.RESOURCES,
                    importBase: options.importBase,
                    nativeBase: options.nativeBase,
                    paths: options.rawAssets.assets,
                    uuids: Object.keys(options.rawAssets.assets),
                    extensionMap: {}
                  });
                }
              },

              loadAsset(uuid, callback, options) {
                assetManager.loadAny(uuid, callback);
              }

            });
            const url = exports('gd', {});
            replaceProperty(url, 'url', [{
              name: 'normalize',
              target: assetManager.utils,
              targetName: 'assetManager.utils',
              newName: 'normalize'
            }, {
              name: 'raw',
              targetName: 'Asset.prototype',
              newName: 'nativeUrl',
              customFunction: url => {
                if (url.startsWith('resources/')) {
                  return transform({
                    path: changeExtname(url.substr(10)),
                    bundle: BuiltinBundleName.RESOURCES,
                    __isNative__: true,
                    ext: extname(url)
                  });
                }

                return '';
              }
            }]);
            removeProperty(AssetLibrary, 'AssetLibrary', [{
              name: 'getLibUrlNoExt',
              suggest: 'AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use cc.assetManager.utils.getUrlWithUuid instead'
            }, {
              name: 'queryAssetInfo',
              suggest: 'AssetLibrary.queryAssetInfo was removed'
            }]);
            removeProperty(loader, 'loader', [{
              name: 'releaseResDir',
              suggest: 'loader.releaseResDir was removed, please use assetManager.releaseAsset instead'
            }, {
              name: 'flowInDeps',
              suggest: 'loader.flowInDeps was removed'
            }, {
              name: 'assetLoader',
              suggest: 'cc.loader.assetLoader was removed, assetLoader and md5Pipe were merged into cc.assetManager.transformPipeline'
            }]);
            replaceProperty(legacyCC, 'cc', [{
              name: 'loader',
              newName: 'assetManager',
              logTimes: 1,
              customGetter: () => loader
            }, {
              name: 'AssetLibrary',
              newName: 'assetManager',
              logTimes: 1,
              customGetter: () => AssetLibrary
            }, {
              name: 'Pipeline',
              target: AssetManager,
              targetName: 'AssetManager',
              newName: 'Pipeline',
              logTimes: 1
            }, {
              name: 'url',
              targetName: 'assetManager',
              newName: 'utils',
              logTimes: 1,
              customGetter: () => url
            }]);
            removeProperty(legacyCC, 'cc', [{
              name: 'LoadingItems',
              suggest: getError(1400, 'cc.LoadingItems', 'cc.AssetManager.Task')
            }]);
            replaceProperty(macro, 'macro', [{
              name: 'DOWNLOAD_MAX_CONCURRENT',
              target: downloader,
              targetName: 'assetManager.downloader',
              newName: 'maxConcurrency'
            }]);
            replaceProperty(director, 'director', [{
              name: '_getSceneUuid',
              targetName: 'assetManager.main',
              newName: 'getSceneInfo',
              customFunction: sceneName => {
                if (assetManager.main) {
                  var _assetManager$main$ge;

                  return (_assetManager$main$ge = assetManager.main.getSceneInfo(sceneName)) === null || _assetManager$main$ge === void 0 ? void 0 : _assetManager$main$ge.uuid;
                }

                return '';
              }
            }]);
            replaceProperty(game, 'game', [{
              name: '_sceneInfos',
              targetName: 'assetManager.main',
              newName: 'getSceneInfo',
              customGetter: () => {
                const scenes = [];

                if (assetManager.main) {
                  assetManager.main.config.scenes.forEach(val => {
                    scenes.push(val);
                  });
                }

                return scenes;
              }
            }]);
            const _autoRelease = releaseManager._autoRelease;

            releaseManager._autoRelease = function (oldScene, newScene, persistNodes) {
              _autoRelease.call(releaseManager, oldScene, newScene, persistNodes);

              const releaseSettings = loader._autoReleaseSetting;
              const keys = Object.keys(releaseSettings);

              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];

                if (releaseSettings[key] === true) {
                  const asset = assets.get(key);

                  if (asset) {
                    releaseManager.tryRelease(asset);
                  }
                }
              }
            };

            var _dec$y, _dec2$d, _dec3$8, _dec4$6, _dec5$3, _dec6$3, _class$y, _class2$t, _descriptor$q, _descriptor2$i, _descriptor3$d, _descriptor4$a, _descriptor5$7, _temp$v;
            let EventHandler = exports('er', (_dec$y = ccclass('cc.ClickEvent'), _dec2$d = type(legacyCC.Node), _dec3$8 = tooltip(), _dec4$6 = tooltip(), _dec5$3 = tooltip(), _dec6$3 = tooltip(), _dec$y(_class$y = (_class2$t = (_temp$v = class EventHandler {
              constructor() {
                _initializerDefineProperty(this, "target", _descriptor$q, this);

                _initializerDefineProperty(this, "component", _descriptor2$i, this);

                _initializerDefineProperty(this, "_componentId", _descriptor3$d, this);

                _initializerDefineProperty(this, "handler", _descriptor4$a, this);

                _initializerDefineProperty(this, "customEventData", _descriptor5$7, this);
              }

              get _componentName() {
                this._genCompIdIfNeeded();

                return this._compId2Name(this._componentId);
              }

              set _componentName(value) {
                this._componentId = this._compName2Id(value);
              }

              static emitEvents(events, ...args) {
                for (let i = 0, l = events.length; i < l; i++) {
                  const event = events[i];

                  if (!(event instanceof EventHandler)) {
                    continue;
                  }

                  event.emit(args);
                }
              }

              emit(params) {
                const target = this.target;

                if (!legacyCC.isValid(target)) {
                  return;
                }

                this._genCompIdIfNeeded();

                const compType = legacyCC.js._getClassById(this._componentId);

                const comp = target.getComponent(compType);

                if (!legacyCC.isValid(comp)) {
                  return;
                }

                const handler = comp[this.handler];

                if (typeof handler !== 'function') {
                  return;
                }

                if (this.customEventData != null && this.customEventData !== '') {
                  params = params.slice();
                  params.push(this.customEventData);
                }

                handler.apply(comp, params);
              }

              _compName2Id(compName) {
                const comp = legacyCC.js.getClassByName(compName);
                return legacyCC.js._getClassId(comp);
              }

              _compId2Name(compId) {
                const comp = legacyCC.js._getClassById(compId);

                return legacyCC.js.getClassName(comp);
              }

              _genCompIdIfNeeded() {
                if (!this._componentId) {
                  this._componentName = this.component;
                  this.component = '';
                }
              }

            }, _temp$v), (_descriptor$q = _applyDecoratedDescriptor(_class2$t.prototype, "target", [serializable, _dec2$d, serializable, _dec3$8], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$i = _applyDecoratedDescriptor(_class2$t.prototype, "component", [serializable, editable, _dec4$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor3$d = _applyDecoratedDescriptor(_class2$t.prototype, "_componentId", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor4$a = _applyDecoratedDescriptor(_class2$t.prototype, "handler", [serializable, editable, _dec5$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor5$7 = _applyDecoratedDescriptor(_class2$t.prototype, "customEventData", [serializable, editable, _dec6$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$t)) || _class$y));
            legacyCC.Component.EventHandler = EventHandler;

            var _dec$z, _dec2$e, _dec3$9, _dec4$7, _dec5$4, _dec6$4, _dec7$2, _dec8$2, _dec9$2, _dec10$2, _dec11$2, _dec12$2, _dec13$2, _dec14$2, _dec15$2, _dec16$2, _dec17$2, _dec18$2, _dec19$2, _dec20$2, _dec21$2, _dec22$2, _dec23$2, _dec24$2, _dec25$2, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _dec30$1, _dec31$1, _dec32$1, _dec33$1, _dec34$1, _dec35$1, _dec36$1, _dec37$1, _dec38$1, _dec39$1, _dec40$1, _dec41$1, _dec42$1, _dec43$1, _dec44$1, _dec45$1, _class$z, _class2$u, _descriptor$r, _descriptor2$j, _descriptor3$e, _descriptor4$b, _descriptor5$8, _descriptor6$3, _descriptor7$3, _descriptor8$3, _descriptor9$2, _descriptor10$2, _descriptor11$2, _descriptor12$2, _descriptor13$2, _descriptor14$2, _descriptor15$2, _descriptor16$2, _descriptor17$2, _descriptor18$2, _class3$b, _temp$w;

            const _temp_vec3_1 = new Vec3();

            const ProjectionType = Enum(CameraProjection);
            const FOVAxis = Enum(CameraFOVAxis);
            const Aperture = Enum(CameraAperture);
            const Shutter = Enum(CameraShutter);
            const ISO = Enum(CameraISO);
            const ClearFlag = Enum({
              SKYBOX: SKYBOX_FLAG | ClearFlagBit.DEPTH_STENCIL,
              SOLID_COLOR: ClearFlagBit.ALL,
              DEPTH_ONLY: ClearFlagBit.DEPTH_STENCIL,
              DONT_CLEAR: ClearFlagBit.NONE
            });
            let Camera$1 = exports('ec', (_dec$z = ccclass('cc.Camera'), _dec2$e = help(), _dec3$9 = menu(), _dec4$7 = displayOrder(), _dec5$4 = tooltip(), _dec6$4 = type(Layers.BitMask), _dec7$2 = displayOrder(), _dec8$2 = tooltip(), _dec9$2 = type(ClearFlag), _dec10$2 = displayOrder(), _dec11$2 = tooltip(), _dec12$2 = displayOrder(), _dec13$2 = tooltip(), _dec14$2 = displayOrder(), _dec15$2 = tooltip(), _dec16$2 = displayOrder(), _dec17$2 = tooltip(), _dec18$2 = type(ProjectionType), _dec19$2 = displayOrder(), _dec20$2 = tooltip(), _dec21$2 = type(FOVAxis), _dec22$2 = displayOrder(), _dec23$2 = tooltip(), _dec24$2 = displayOrder(), _dec25$2 = tooltip(), _dec26$1 = displayOrder(), _dec27$1 = tooltip(), _dec28$1 = displayOrder(), _dec29$1 = tooltip(), _dec30$1 = displayOrder(), _dec31$1 = tooltip(), _dec32$1 = type(Aperture), _dec33$1 = displayOrder(), _dec34$1 = tooltip(), _dec35$1 = type(Shutter), _dec36$1 = displayOrder(), _dec37$1 = tooltip(), _dec38$1 = type(ISO), _dec39$1 = displayOrder(), _dec40$1 = tooltip(), _dec41$1 = displayOrder(), _dec42$1 = tooltip(), _dec43$1 = type(RenderTexture), _dec44$1 = displayOrder(), _dec45$1 = tooltip(), _dec$z(_class$z = _dec2$e(_class$z = _dec3$9(_class$z = executeInEditMode(_class$z = (_class2$u = (_temp$w = _class3$b = class Camera extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_projection", _descriptor$r, this);

                _initializerDefineProperty(this, "_priority", _descriptor2$j, this);

                _initializerDefineProperty(this, "_fov", _descriptor3$e, this);

                _initializerDefineProperty(this, "_fovAxis", _descriptor4$b, this);

                _initializerDefineProperty(this, "_orthoHeight", _descriptor5$8, this);

                _initializerDefineProperty(this, "_near", _descriptor6$3, this);

                _initializerDefineProperty(this, "_far", _descriptor7$3, this);

                _initializerDefineProperty(this, "_color", _descriptor8$3, this);

                _initializerDefineProperty(this, "_depth", _descriptor9$2, this);

                _initializerDefineProperty(this, "_stencil", _descriptor10$2, this);

                _initializerDefineProperty(this, "_clearFlags", _descriptor11$2, this);

                _initializerDefineProperty(this, "_rect", _descriptor12$2, this);

                _initializerDefineProperty(this, "_aperture", _descriptor13$2, this);

                _initializerDefineProperty(this, "_shutter", _descriptor14$2, this);

                _initializerDefineProperty(this, "_iso", _descriptor15$2, this);

                _initializerDefineProperty(this, "_screenScale", _descriptor16$2, this);

                _initializerDefineProperty(this, "_visibility", _descriptor17$2, this);

                _initializerDefineProperty(this, "_targetTexture", _descriptor18$2, this);

                this._camera = null;
                this._inEditorMode = false;
                this._flows = undefined;
              }

              get camera() {
                return this._camera;
              }

              get priority() {
                return this._priority;
              }

              set priority(val) {
                this._priority = val;

                if (this._camera) {
                  this._camera.priority = val;
                }
              }

              get visibility() {
                return this._visibility;
              }

              set visibility(val) {
                this._visibility = val;

                if (this._camera) {
                  this._camera.visibility = val;
                }
              }

              get clearFlags() {
                return this._clearFlags;
              }

              set clearFlags(val) {
                this._clearFlags = val;

                if (this._camera) {
                  this._camera.clearFlag = val;
                }
              }

              get clearColor() {
                return this._color;
              }

              set clearColor(val) {
                this._color.set(val);

                if (this._camera) {
                  this._camera.clearColor = this._color;
                }
              }

              get clearDepth() {
                return this._depth;
              }

              set clearDepth(val) {
                this._depth = val;

                if (this._camera) {
                  this._camera.clearDepth = val;
                }
              }

              get clearStencil() {
                return this._stencil;
              }

              set clearStencil(val) {
                this._stencil = val;

                if (this._camera) {
                  this._camera.clearStencil = val;
                }
              }

              get projection() {
                return this._projection;
              }

              set projection(val) {
                this._projection = val;

                if (this._camera) {
                  this._camera.projectionType = val;
                }
              }

              get fovAxis() {
                return this._fovAxis;
              }

              set fovAxis(val) {
                if (val === this._fovAxis) {
                  return;
                }

                this._fovAxis = val;

                if (this._camera) {
                  this._camera.fovAxis = val;

                  if (val === CameraFOVAxis.VERTICAL) {
                    this.fov = this._fov * this._camera.aspect;
                  } else {
                    this.fov = this._fov / this._camera.aspect;
                  }
                }
              }

              get fov() {
                return this._fov;
              }

              set fov(val) {
                this._fov = val;

                if (this._camera) {
                  this._camera.fov = toRadian(val);
                }
              }

              get orthoHeight() {
                return this._orthoHeight;
              }

              set orthoHeight(val) {
                this._orthoHeight = val;

                if (this._camera) {
                  this._camera.orthoHeight = val;
                }
              }

              get near() {
                return this._near;
              }

              set near(val) {
                this._near = val;

                if (this._camera) {
                  this._camera.nearClip = val;
                }
              }

              get far() {
                return this._far;
              }

              set far(val) {
                this._far = val;

                if (this._camera) {
                  this._camera.farClip = val;
                }
              }

              get aperture() {
                return this._aperture;
              }

              set aperture(val) {
                this._aperture = val;

                if (this._camera) {
                  this._camera.aperture = val;
                }
              }

              get shutter() {
                return this._shutter;
              }

              set shutter(val) {
                this._shutter = val;

                if (this._camera) {
                  this._camera.shutter = val;
                }
              }

              get iso() {
                return this._iso;
              }

              set iso(val) {
                this._iso = val;

                if (this._camera) {
                  this._camera.iso = val;
                }
              }

              get rect() {
                return this._rect;
              }

              set rect(val) {
                this._rect = val;

                if (this._camera) {
                  this._camera.setViewportInOrientedSpace(val);
                }
              }

              get targetTexture() {
                return this._targetTexture;
              }

              set targetTexture(value) {
                if (this._targetTexture === value) {
                  return;
                }

                const old = this._targetTexture;
                this._targetTexture = value;

                this._checkTargetTextureEvent(old);

                this._updateTargetTexture();

                if (!value && this._camera) {
                  this._camera.changeTargetWindow( null);

                  this._camera.isWindowSize = true;
                }

                this.node.emit(Camera.TARGET_TEXTURE_CHANGE, this);
              }

              get screenScale() {
                return this._screenScale;
              }

              set screenScale(val) {
                this._screenScale = val;

                if (this._camera) {
                  this._camera.screenScale = val;
                }
              }

              get inEditorMode() {
                return this._inEditorMode;
              }

              set inEditorMode(value) {
                this._inEditorMode = value;

                if (this._camera) {
                  this._camera.changeTargetWindow(value ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow);
                }
              }

              onLoad() {
                this._createCamera();
              }

              onEnable() {
                this.node.hasChangedFlags |= TransformBit.POSITION;

                if (this._camera) {
                  this._attachToScene();
                }
              }

              onDisable() {
                if (this._camera) {
                  this._detachFromScene();
                }
              }

              onDestroy() {
                if (this._camera) {
                  this._camera.destroy();

                  this._camera = null;
                }

                if (this._targetTexture) {
                  this._targetTexture.off('resize');
                }
              }

              screenPointToRay(x, y, out) {
                if (!out) {
                  out = Ray.create();
                }

                if (this._camera) {
                  this._camera.screenPointToRay(out, x, y);
                }

                return out;
              }

              worldToScreen(worldPos, out) {
                if (!out) {
                  out = new Vec3();
                }

                if (this._camera) {
                  this._camera.worldToScreen(out, worldPos);
                }

                return out;
              }

              screenToWorld(screenPos, out) {
                if (!out) {
                  out = this.node.getWorldPosition();
                }

                if (this._camera) {
                  this._camera.screenToWorld(out, screenPos);
                }

                return out;
              }

              convertToUINode(wpos, uiNode, out) {
                if (!out) {
                  out = new Vec3();
                }

                if (!this._camera) {
                  return out;
                }

                this.worldToScreen(wpos, _temp_vec3_1);
                const cmp = uiNode.getComponent('cc.UITransform');
                const designSize = view.getVisibleSize();
                const xoffset = _temp_vec3_1.x - this._camera.width * 0.5;
                const yoffset = _temp_vec3_1.y - this._camera.height * 0.5;
                _temp_vec3_1.x = xoffset / legacyCC.view.getScaleX() + designSize.width * 0.5;
                _temp_vec3_1.y = yoffset / legacyCC.view.getScaleY() + designSize.height * 0.5;

                if (cmp) {
                  cmp.convertToNodeSpaceAR(_temp_vec3_1, out);
                }

                return out;
              }

              _createCamera() {
                if (!this._camera) {
                  this._camera = legacyCC.director.root.createCamera();

                  this._camera.initialize({
                    name: this.node.name,
                    node: this.node,
                    projection: this._projection,
                    window: this._inEditorMode ? legacyCC.director.root && legacyCC.director.root.mainWindow : legacyCC.director.root && legacyCC.director.root.tempWindow,
                    priority: this._priority
                  });

                  this._camera.setViewportInOrientedSpace(this._rect);

                  this._camera.fovAxis = this._fovAxis;
                  this._camera.fov = toRadian(this._fov);
                  this._camera.orthoHeight = this._orthoHeight;
                  this._camera.nearClip = this._near;
                  this._camera.farClip = this._far;
                  this._camera.clearColor = this._color;
                  this._camera.clearDepth = this._depth;
                  this._camera.clearStencil = this._stencil;
                  this._camera.clearFlag = this._clearFlags;
                  this._camera.visibility = this._visibility;
                  this._camera.aperture = this._aperture;
                  this._camera.shutter = this._shutter;
                  this._camera.iso = this._iso;
                }

                this._updateTargetTexture();
              }

              _attachToScene() {
                if (!this.node.scene || !this._camera) {
                  return;
                }

                if (this._camera && this._camera.scene) {
                  this._camera.scene.removeCamera(this._camera);
                }

                const rs = this._getRenderScene();

                rs.addCamera(this._camera);
              }

              _detachFromScene() {
                if (this._camera && this._camera.scene) {
                  this._camera.scene.removeCamera(this._camera);
                }
              }

              _checkTargetTextureEvent(old) {
                if (old) {
                  old.off('resize');
                }

                if (this._targetTexture) {
                  this._targetTexture.on('resize', window => {
                    if (this._camera) {
                      this._camera.setFixedSize(window.width, window.height);
                    }
                  }, this);
                }
              }

              _updateTargetTexture() {
                if (!this._camera) {
                  return;
                }

                if (this._targetTexture) {
                  const window = this._targetTexture.window;

                  this._camera.changeTargetWindow(window);

                  this._camera.setFixedSize(window.width, window.height);
                }
              }

            }, _class3$b.ProjectionType = ProjectionType, _class3$b.FOVAxis = FOVAxis, _class3$b.ClearFlag = ClearFlag, _class3$b.Aperture = Aperture, _class3$b.Shutter = Shutter, _class3$b.ISO = ISO, _class3$b.TARGET_TEXTURE_CHANGE = 'tex-change', _temp$w), (_descriptor$r = _applyDecoratedDescriptor(_class2$u.prototype, "_projection", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ProjectionType.PERSPECTIVE;
              }
            }), _descriptor2$j = _applyDecoratedDescriptor(_class2$u.prototype, "_priority", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$e = _applyDecoratedDescriptor(_class2$u.prototype, "_fov", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 45;
              }
            }), _descriptor4$b = _applyDecoratedDescriptor(_class2$u.prototype, "_fovAxis", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return FOVAxis.VERTICAL;
              }
            }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$u.prototype, "_orthoHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 10;
              }
            }), _descriptor6$3 = _applyDecoratedDescriptor(_class2$u.prototype, "_near", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor7$3 = _applyDecoratedDescriptor(_class2$u.prototype, "_far", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1000;
              }
            }), _descriptor8$3 = _applyDecoratedDescriptor(_class2$u.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color('#333333');
              }
            }), _descriptor9$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_depth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor10$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_stencil", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor11$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_clearFlags", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ClearFlag.SOLID_COLOR;
              }
            }), _descriptor12$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_rect", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Rect(0, 0, 1, 1);
              }
            }), _descriptor13$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_aperture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Aperture.F16_0;
              }
            }), _descriptor14$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_shutter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Shutter.D125;
              }
            }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_iso", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ISO.ISO100;
              }
            }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_screenScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor17$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_visibility", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return CAMERA_DEFAULT_MASK;
              }
            }), _descriptor18$2 = _applyDecoratedDescriptor(_class2$u.prototype, "_targetTexture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$u.prototype, "priority", [_dec4$7, _dec5$4], Object.getOwnPropertyDescriptor(_class2$u.prototype, "priority"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "visibility", [_dec6$4, _dec7$2, _dec8$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "visibility"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "clearFlags", [_dec9$2, _dec10$2, _dec11$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "clearFlags"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "clearColor", [_dec12$2, _dec13$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "clearColor"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "clearDepth", [_dec14$2, _dec15$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "clearDepth"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "clearStencil", [_dec16$2, _dec17$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "clearStencil"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "projection", [_dec18$2, _dec19$2, _dec20$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "projection"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "fovAxis", [_dec21$2, _dec22$2, _dec23$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "fovAxis"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "fov", [_dec24$2, _dec25$2], Object.getOwnPropertyDescriptor(_class2$u.prototype, "fov"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "orthoHeight", [_dec26$1, _dec27$1], Object.getOwnPropertyDescriptor(_class2$u.prototype, "orthoHeight"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "near", [_dec28$1, _dec29$1], Object.getOwnPropertyDescriptor(_class2$u.prototype, "near"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "far", [_dec30$1, _dec31$1], Object.getOwnPropertyDescriptor(_class2$u.prototype, "far"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "aperture", [_dec32$1, _dec33$1, _dec34$1], Object.getOwnPropertyDescriptor(_class2$u.prototype, "aperture"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "shutter", [_dec35$1, _dec36$1, _dec37$1], Object.getOwnPropertyDescriptor(_class2$u.prototype, "shutter"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "iso", [_dec38$1, _dec39$1, _dec40$1], Object.getOwnPropertyDescriptor(_class2$u.prototype, "iso"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "rect", [_dec41$1, _dec42$1], Object.getOwnPropertyDescriptor(_class2$u.prototype, "rect"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "targetTexture", [_dec43$1, _dec44$1, _dec45$1], Object.getOwnPropertyDescriptor(_class2$u.prototype, "targetTexture"), _class2$u.prototype)), _class2$u)) || _class$z) || _class$z) || _class$z) || _class$z));
            legacyCC.Camera = Camera$1;

            var _dec$A, _dec2$f, _dec3$a, _dec4$8, _dec5$5, _class$A, _class2$v, _descriptor$s, _descriptor2$k, _temp$x;
            const _matInsInfo = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };
            let RenderableComponent = exports('bR', (_dec$A = ccclass('cc.RenderableComponent'), _dec2$f = type([Material]), _dec3$a = type(Material), _dec4$8 = displayOrder(), _dec5$5 = displayName(), _dec$A(_class$A = (_class2$v = (_temp$x = class RenderableComponent extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_materials", _descriptor$s, this);

                _initializerDefineProperty(this, "_visFlags", _descriptor2$k, this);

                this._materialInstances = [];
                this._models = [];
              }

              get visibility() {
                return this._visFlags;
              }

              set visibility(val) {
                this._visFlags = val;

                this._onVisibilityChange(val);
              }

              get sharedMaterials() {
                return  this._materials;
              }

              set sharedMaterials(val) {
                for (let i = 0; i < val.length; i++) {
                  if (val[i] !== this._materials[i]) {
                    this.setMaterial(val[i], i);
                  }
                }

                if (val.length < this._materials.length) {
                  for (let i = val.length; i < this._materials.length; i++) {
                    this.setMaterial(null, i);
                  }

                  this._materials.splice(val.length);
                }
              }

              get materials() {
                for (let i = 0; i < this._materials.length; i++) {
                  this._materialInstances[i] = this.getMaterialInstance(i);
                }

                return this._materialInstances;
              }

              set materials(val) {
                const dLen = val.length - this._materials.length;

                if (dLen > 0) {
                  this._materials.length = val.length;
                  this._materialInstances.length = val.length;
                } else if (dLen < 0) {
                  for (let i = this._materials.length - dLen; i < this._materials.length; ++i) {
                    this.setMaterialInstance(null, i);
                  }
                }

                for (let i = 0; i < this._materialInstances.length; i++) {
                  if (this._materialInstances[i] != val[i]) {
                    this.setMaterialInstance(val[i], i);
                  }
                }
              }

              get sharedMaterial() {
                return this.getMaterial(0);
              }

              getMaterial(idx) {
                if (idx < 0 || idx >= this._materials.length) {
                  return null;
                }

                return this._materials[idx];
              }

              setMaterial(material, index) {
                if (material && material instanceof MaterialInstance) {
                  console.error('Can\'t set a material instance to a sharedMaterial slot');
                }

                this._materials[index] = material;
                const inst = this._materialInstances[index];

                if (inst) {
                  inst.destroy();
                  this._materialInstances[index] = null;
                }

                this._onMaterialModified(index, this._materials[index]);
              }

              get material() {
                return this.getMaterialInstance(0);
              }

              set material(val) {
                if (this._materials.length === 1 && !this._materialInstances[0] && this._materials[0] === val) {
                  return;
                }

                this.setMaterialInstance(val, 0);
              }

              getMaterialInstance(idx) {
                const mat = this._materials[idx];

                if (!mat) {
                  return null;
                }

                if (!this._materialInstances[idx]) {
                  _matInsInfo.parent = this._materials[idx];
                  _matInsInfo.owner = this;
                  _matInsInfo.subModelIdx = idx;
                  const instantiated = new MaterialInstance(_matInsInfo);
                  _matInsInfo.parent = null;
                  _matInsInfo.owner = null;
                  _matInsInfo.subModelIdx = 0;
                  this.setMaterialInstance(instantiated, idx);
                }

                return this._materialInstances[idx];
              }

              setMaterialInstance(matInst, index) {
                if (typeof matInst === 'number') {
                  warnID(12007);
                  const temp = matInst;
                  matInst = index;
                  index = temp;
                }

                const curInst = this._materialInstances[index];

                if (matInst && matInst.parent) {
                  if (matInst !== curInst) {
                    this._materialInstances[index] = matInst;

                    this._onMaterialModified(index, matInst);
                  }

                  return;
                }

                if (matInst !== this._materials[index] || curInst) {
                  this.setMaterial(matInst, index);
                }
              }

              getRenderMaterial(index) {
                return this._materialInstances[index] || this._materials[index];
              }

              _collectModels() {
                return this._models;
              }

              _attachToScene() {}

              _detachFromScene() {}

              _onMaterialModified(index, material) {}

              _onRebuildPSO(index, material) {}

              _clearMaterials() {}

              _onVisibilityChange(val) {}

            }, _temp$x), (_descriptor$s = _applyDecoratedDescriptor(_class2$v.prototype, "_materials", [_dec2$f], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$k = _applyDecoratedDescriptor(_class2$v.prototype, "_visFlags", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Layers.Enum.NONE;
              }
            }), _applyDecoratedDescriptor(_class2$v.prototype, "sharedMaterials", [_dec3$a, _dec4$8, _dec5$5], Object.getOwnPropertyDescriptor(_class2$v.prototype, "sharedMaterials"), _class2$v.prototype)), _class2$v)) || _class$A));
            legacyCC.RenderableComponent = RenderableComponent;

            replaceProperty(Camera$1, 'Camera', [{
              name: 'CameraClearFlag',
              newName: 'ClearFlag'
            }]);
            replaceProperty(Camera$1.prototype, 'Camera.prototype', [{
              name: 'color',
              newName: 'clearColor'
            }, {
              name: 'depth',
              newName: 'clearDepth'
            }, {
              name: 'stencil',
              newName: 'clearStencil'
            }]);
            legacyCC.CameraComponent = Camera$1;
            js.setClassAlias(Camera$1, 'cc.CameraComponent');

            var _dec$B, _class$B, _class2$w, _descriptor$t, _temp$y, _dec2$g, _class4$3, _class5$3, _descriptor2$l, _temp2$3;
            function isPropertyPath(path) {
              return typeof path === 'string' || typeof path === 'number';
            }
            function isCustomPath(path, constructor) {
              return path instanceof constructor;
            }
            let HierarchyPath = exports('bh', (_dec$B = ccclass('cc.animation.HierarchyPath'), _dec$B(_class$B = (_class2$w = (_temp$y = class HierarchyPath {
              constructor(path) {
                _initializerDefineProperty(this, "path", _descriptor$t, this);

                this.path = path || '';
              }

              get(target) {
                if (!(target instanceof Node$1)) {
                  warnID(3925);
                  return null;
                }

                const result = target.getChildByPath(this.path);

                if (!result) {
                  warnID(3926, target.name, this.path);
                  return null;
                }

                return result;
              }

            }, _temp$y), (_descriptor$t = _applyDecoratedDescriptor(_class2$w.prototype, "path", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$w)) || _class$B));
            let ComponentPath = exports('bi', (_dec2$g = ccclass('cc.animation.ComponentPath'), _dec2$g(_class4$3 = (_class5$3 = (_temp2$3 = class ComponentPath {
              constructor(component) {
                _initializerDefineProperty(this, "component", _descriptor2$l, this);

                this.component = component || '';
              }

              get(target) {
                if (!(target instanceof Node$1)) {
                  warnID(3927);
                  return null;
                }

                const result = target.getComponent(this.component);

                if (!result) {
                  warnID(3928, target.name, this.component);
                  return null;
                }

                return result;
              }

            }, _temp2$3), (_descriptor2$l = _applyDecoratedDescriptor(_class5$3.prototype, "component", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class5$3)) || _class4$3));

            var _dec$C, _class$C, _class2$x, _descriptor$u, _descriptor2$m, _descriptor3$f, _temp$z;
            let UniformProxyFactory = exports('b3', (_dec$C = ccclass('cc.animation.UniformProxyFactory'), _dec$C(_class$C = (_class2$x = (_temp$z = class UniformProxyFactory {
              constructor(uniformName, passIndex) {
                _initializerDefineProperty(this, "passIndex", _descriptor$u, this);

                _initializerDefineProperty(this, "uniformName", _descriptor2$m, this);

                _initializerDefineProperty(this, "channelIndex", _descriptor3$f, this);

                this.passIndex = passIndex || 0;
                this.uniformName = uniformName || '';
              }

              forTarget(target) {
                const pass = target.passes[this.passIndex];
                const handle = pass.getHandle(this.uniformName);

                if (!handle) {
                  throw new Error(`Material "${target.name}" has no uniform "${this.uniformName}"`);
                }

                const type = Pass.getTypeFromHandle(handle);

                if (type < Type.SAMPLER1D) {
                  const realHandle = this.channelIndex === undefined ? handle : pass.getHandle(this.uniformName, this.channelIndex, Type.FLOAT);

                  if (!realHandle) {
                    throw new Error(`Uniform "${this.uniformName} (in material ${target.name}) has no channel ${this.channelIndex}"`);
                  }

                  if (isUniformArray(pass, this.uniformName)) {
                    return {
                      set: value => {
                        pass.setUniformArray(realHandle, value);
                      }
                    };
                  }

                  return {
                    set: value => {
                      pass.setUniform(realHandle, value);
                    }
                  };
                } else {
                  const binding = Pass.getBindingFromHandle(handle);
                  const prop = pass.properties[this.uniformName];
                  const texName = prop && prop.value ? `${prop.value}-texture` : getDefaultFromType(prop.type);
                  let dftTex = builtinResMgr.get(texName);

                  if (!dftTex) {
                    warn(`Illegal texture default value: ${texName}.`);
                    dftTex = builtinResMgr.get('default-texture');
                  }

                  return {
                    set: value => {
                      if (!value) {
                        value = dftTex;
                      }

                      const texture = value.getGFXTexture();

                      if (!texture || !texture.width || !texture.height) {
                        return;
                      }

                      pass.bindTexture(binding, texture);

                      if (value instanceof TextureBase) {
                        pass.bindSampler(binding, legacyCC.game._gfxDevice.getSampler(value.getSamplerInfo()));
                      }
                    }
                  };
                }
              }

            }, _temp$z), (_descriptor$u = _applyDecoratedDescriptor(_class2$x.prototype, "passIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$m = _applyDecoratedDescriptor(_class2$x.prototype, "uniformName", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor3$f = _applyDecoratedDescriptor(_class2$x.prototype, "channelIndex", [float], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return undefined;
              }
            })), _class2$x)) || _class$C));

            function isUniformArray(pass, name) {
              for (const block of pass.shaderInfo.blocks) {
                for (const uniform of block.members) {
                  if (uniform.name === name) {
                    return uniform.count > 1;
                  }
                }
              }

              return false;
            }

            var _dec$D, _class$D, _class2$y, _descriptor$v, _descriptor2$n, _temp$A, _dec2$h, _class4$4, _class5$4, _descriptor3$g, _temp2$4, _dec3$b, _class7$2;
            let MorphWeightValueProxy = exports('b4', (_dec$D = ccclass('cc.animation.MorphWeightValueProxy'), _dec$D(_class$D = (_class2$y = (_temp$A = class MorphWeightValueProxy {
              constructor() {
                _initializerDefineProperty(this, "subMeshIndex", _descriptor$v, this);

                _initializerDefineProperty(this, "shapeIndex", _descriptor2$n, this);
              }

              forTarget(target) {
                return {
                  set: value => {
                    target.setWeight(value, this.subMeshIndex, this.shapeIndex);
                  }
                };
              }

            }, _temp$A), (_descriptor$v = _applyDecoratedDescriptor(_class2$y.prototype, "subMeshIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$n = _applyDecoratedDescriptor(_class2$y.prototype, "shapeIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$y)) || _class$D));
            let MorphWeightsValueProxy = exports('b5', (_dec2$h = ccclass('cc.animation.MorphWeightsValueProxy'), _dec2$h(_class4$4 = (_class5$4 = (_temp2$4 = class MorphWeightsValueProxy {
              constructor() {
                _initializerDefineProperty(this, "subMeshIndex", _descriptor3$g, this);
              }

              forTarget(target) {
                return {
                  set: value => {
                    target.setWeights(value, this.subMeshIndex);
                  }
                };
              }

            }, _temp2$4), (_descriptor3$g = _applyDecoratedDescriptor(_class5$4.prototype, "subMeshIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class5$4)) || _class4$4));
            let MorphWeightsAllValueProxy = exports('b6', (_dec3$b = ccclass('cc.animation.MorphWeightsAllValueProxy'), _dec3$b(_class7$2 = class MorphWeightsAllValueProxy {
              forTarget(target) {
                return {
                  set: value => {
                    var _target$mesh$struct$p, _target$mesh;

                    const nSubMeshes = (_target$mesh$struct$p = (_target$mesh = target.mesh) === null || _target$mesh === void 0 ? void 0 : _target$mesh.struct.primitives.length) !== null && _target$mesh$struct$p !== void 0 ? _target$mesh$struct$p : 0;

                    for (let iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                      target.setWeights(value, iSubMesh);
                    }
                  }
                };
              }

            }) || _class7$2));

            var _dec2$i, _class4$5, _class5$5, _descriptor4$c, _descriptor5$9, _descriptor6$4, _temp2$5;

            function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
              var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;

              let tempValue = new constructorX();
              let m0 = new constructorX();
              let m1 = new constructorX();
              let CubicSplineValueClass = (_dec = ccclass(name), _dec(_class = (_class2 = (_temp = class CubicSplineValueClass {
                constructor(dataPoint, inTangent, outTangent) {
                  _initializerDefineProperty(this, "dataPoint", _descriptor, this);

                  _initializerDefineProperty(this, "inTangent", _descriptor2, this);

                  _initializerDefineProperty(this, "outTangent", _descriptor3, this);

                  this.dataPoint = dataPoint || new constructorX();
                  this.inTangent = inTangent || new constructorX();
                  this.outTangent = outTangent || new constructorX();
                }

                lerp(to, t, dt) {
                  const p0 = this.dataPoint;
                  const p1 = to.dataPoint;
                  m0 = scaleFx(m0, this.inTangent, dt);
                  m1 = scaleFx(m1, to.outTangent, dt);
                  const t_3 = t * t * t;
                  const t_2 = t * t;
                  const f_0 = 2 * t_3 - 3 * t_2 + 1;
                  const f_1 = t_3 - 2 * t_2 + t;
                  const f_2 = -2 * t_3 + 3 * t_2;
                  const f_3 = t_3 - t_2;
                  tempValue = scaleFx(tempValue, p0, f_0);
                  tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1);
                  tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2);
                  tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
                  return tempValue;
                }

                getNoLerp() {
                  return this.dataPoint;
                }

              }, _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "dataPoint", [serializable], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: function () {
                  return new constructorX();
                }
              }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "inTangent", [serializable], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: function () {
                  return new constructorX();
                }
              }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "outTangent", [serializable], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: function () {
                  return new constructorX();
                }
              })), _class2)) || _class);

              if (constructorX === Quat) {
                const lerp = CubicSplineValueClass.prototype.lerp;

                CubicSplineValueClass.prototype.lerp = function (to, t, dt) {
                  const result = lerp.call(this, to, t, dt);
                  Quat.normalize(result, result);
                  return result;
                };
              }

              return CubicSplineValueClass;
            }

            const CubicSplineVec2Value = exports('bj', makeCubicSplineValueConstructor('cc.CubicSplineVec2Value', Vec2, Vec2.multiplyScalar, Vec2.scaleAndAdd));
            legacyCC.CubicSplineVec2Value = CubicSplineVec2Value;
            const CubicSplineVec3Value = exports('bk', makeCubicSplineValueConstructor('cc.CubicSplineVec3Value', Vec3, Vec3.multiplyScalar, Vec3.scaleAndAdd));
            legacyCC.CubicSplineVec3Value = CubicSplineVec3Value;
            const CubicSplineVec4Value = exports('bl', makeCubicSplineValueConstructor('cc.CubicSplineVec4Value', Vec4, Vec4.multiplyScalar, Vec4.scaleAndAdd));
            legacyCC.CubicSplineVec4Value = CubicSplineVec4Value;
            const CubicSplineQuatValue = exports('bm', makeCubicSplineValueConstructor('cc.CubicSplineQuatValue', Quat, Quat.multiplyScalar, Quat.scaleAndAdd));
            legacyCC.CubicSplineQuatValue = CubicSplineQuatValue;
            let CubicSplineNumberValue = exports('bn', (_dec2$i = ccclass('cc.CubicSplineNumberValue'), _dec2$i(_class4$5 = (_class5$5 = (_temp2$5 = class CubicSplineNumberValue {
              constructor(dataPoint, inTangent, outTangent) {
                _initializerDefineProperty(this, "dataPoint", _descriptor4$c, this);

                _initializerDefineProperty(this, "inTangent", _descriptor5$9, this);

                _initializerDefineProperty(this, "outTangent", _descriptor6$4, this);

                this.dataPoint = dataPoint;
                this.inTangent = inTangent;
                this.outTangent = outTangent;
              }

              lerp(to, t, dt) {
                const p0 = this.dataPoint;
                const p1 = to.dataPoint;
                const m0 = this.outTangent * dt;
                const m1 = to.inTangent * dt;
                const t_3 = t * t * t;
                const t_2 = t * t;
                const f_0 = 2 * t_3 - 3 * t_2 + 1;
                const f_1 = t_3 - 2 * t_2 + t;
                const f_2 = -2 * t_3 + 3 * t_2;
                const f_3 = t_3 - t_2;
                return p0 * f_0 + m0 * f_1 + p1 * f_2 + m1 * f_3;
              }

              getNoLerp() {
                return this.dataPoint;
              }

            }, _temp2$5), (_descriptor4$c = _applyDecoratedDescriptor(_class5$5.prototype, "dataPoint", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor5$9 = _applyDecoratedDescriptor(_class5$5.prototype, "inTangent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$4 = _applyDecoratedDescriptor(_class5$5.prototype, "outTangent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class5$5)) || _class4$5));
            legacyCC.CubicSplineNumberValue = CubicSplineNumberValue;

            const CLASS_NAME_PREFIX_ANIM = 'cc.animation.';
            const createEvalSymbol = Symbol('CreateEval');

            var _dec$E, _class$E, _class2$z, _descriptor$w, _temp$B, _dec2$j, _class4$6, _class5$6, _descriptor2$o, _descriptor3$h, _temp2$6, _dec3$c, _class7$3, _class8$2, _descriptor4$d, _temp3$2, _dec4$9, _class10$2, _class11$2, _descriptor5$a, _temp4$2, _dec5$6, _class13$2, _class14$2, _descriptor6$5, _temp5$2;
            const normalizedFollowTag = Symbol('NormalizedFollow');
            const parseTrsPathTag = Symbol('ConvertAsTrsPath');
            const trackBindingTag = Symbol('TrackBinding');
            let TrackPath = exports('b8', (_dec$E = ccclass(`${CLASS_NAME_PREFIX_ANIM}TrackPath`), _dec$E(_class$E = (_class2$z = (_temp$B = class TrackPath {
              constructor() {
                _initializerDefineProperty(this, "_paths", _descriptor$w, this);
              }

              get length() {
                return this._paths.length;
              }

              toProperty(name) {
                this._paths.push(name);

                return this;
              }

              toElement(index) {
                this._paths.push(index);

                return this;
              }

              toHierarchy(nodePath) {
                this._paths.push(new HierarchyPath(nodePath));

                return this;
              }

              toComponent(constructor) {
                const path = new ComponentPath(typeof constructor === 'string' ? constructor : js.getClassName(constructor));

                this._paths.push(path);

                return this;
              }

              toCustomized(resolver) {
                this._paths.push(resolver);

                return this;
              }

              append(...trackPaths) {
                const paths = this._paths.concat(...trackPaths.map(trackPath => trackPath._paths));

                this._paths = paths;
                return this;
              }

              isPropertyAt(index) {
                return typeof this._paths[index] === 'string';
              }

              parsePropertyAt(index) {
                return this._paths[index];
              }

              isElementAt(index) {
                return typeof this._paths[index] === 'number';
              }

              parseElementAt(index) {
                return this._paths[index];
              }

              isHierarchyAt(index) {
                return this._paths[index] instanceof HierarchyPath;
              }

              parseHierarchyAt(index) {
                assertIsTrue(this.isHierarchyAt(index));
                return this._paths[index].path;
              }

              isComponentAt(index) {
                return this._paths[index] instanceof ComponentPath;
              }

              parseComponentAt(index) {
                assertIsTrue(this.isComponentAt(index));
                return this._paths[index].component;
              }

              slice(beginIndex, endIndex) {
                const trackPath = new TrackPath();
                trackPath._paths = this._paths.slice(beginIndex, endIndex);
                return trackPath;
              }

              trace(object, beginIndex, endIndex) {
                var _beginIndex, _endIndex;

                (_beginIndex = beginIndex) !== null && _beginIndex !== void 0 ? _beginIndex : beginIndex = 0;
                (_endIndex = endIndex) !== null && _endIndex !== void 0 ? _endIndex : endIndex = this._paths.length;
                return this[normalizedFollowTag](object, beginIndex, endIndex);
              }

              [parseTrsPathTag]() {
                const {
                  _paths: paths
                } = this;
                const nPaths = paths.length;
                let iPath = 0;
                let nodePath = '';

                for (; iPath < nPaths; ++iPath) {
                  const path = paths[iPath];

                  if (!(path instanceof HierarchyPath)) {
                    break;
                  } else if (!path.path) {
                    continue;
                  } else if (nodePath) {
                    nodePath += `/${path.path}`;
                  } else {
                    nodePath = path.path;
                  }
                }

                if (iPath === nPaths) {
                  return null;
                }

                let prs;

                if (iPath !== nPaths - 1) {
                  return null;
                }

                switch (paths[iPath]) {
                  case 'position':
                  case 'scale':
                  case 'rotation':
                  case 'eulerAngles':
                    prs = paths[iPath];
                    break;

                  default:
                    return null;
                }

                return {
                  node: nodePath,
                  property: prs
                };
              }

              [normalizedFollowTag](root, beginIndex, endIndex) {
                const {
                  _paths: paths
                } = this;
                let result = root;

                for (let iPath = beginIndex; iPath < endIndex; ++iPath) {
                  const path = paths[iPath];

                  if (isPropertyPath(path)) {
                    if (!(path in result)) {
                      warnID(3929, path);
                      return null;
                    } else {
                      result = result[path];
                    }
                  } else {
                    result = path.get(result);
                  }

                  if (result === null) {
                    break;
                  }
                }

                return result;
              }

            }, _temp$B), (_descriptor$w = _applyDecoratedDescriptor(_class2$z.prototype, "_paths", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$z)) || _class$E));
            let TrackBinding = (_dec2$j = ccclass(`${CLASS_NAME_PREFIX_ANIM}TrackBinding`), _dec2$j(_class4$6 = uniquelyReferenced(_class4$6 = (_class5$6 = (_temp2$6 = class TrackBinding {
              constructor() {
                _initializerDefineProperty(this, "path", _descriptor2$o, this);

                _initializerDefineProperty(this, "proxy", _descriptor3$h, this);
              }

              parseTrsPath() {
                if (this.proxy) {
                  return null;
                } else {
                  return this.path[parseTrsPathTag]();
                }
              }

              createRuntimeBinding(target, poseOutput, isConstant) {
                const {
                  path,
                  proxy
                } = this;
                const nPaths = path.length;
                const iLastPath = nPaths - 1;

                if (nPaths !== 0 && (path.isPropertyAt(iLastPath) || path.isElementAt(iLastPath)) && !proxy) {
                  const lastPropertyKey = path.isPropertyAt(iLastPath) ? path.parsePropertyAt(iLastPath) : path.parseElementAt(iLastPath);
                  const resultTarget = path[normalizedFollowTag](target, 0, nPaths - 1);

                  if (resultTarget === null) {
                    return null;
                  }

                  if (poseOutput && resultTarget instanceof Node$1 && isTrsPropertyName(lastPropertyKey)) {
                    const blendStateWriter = poseOutput.createPoseWriter(resultTarget, lastPropertyKey, isConstant);
                    return blendStateWriter;
                  }

                  return {
                    setValue: value => {
                      resultTarget[lastPropertyKey] = value;
                    },
                    getValue: () => {
                      return resultTarget[lastPropertyKey];
                    }
                  };
                } else if (!proxy) {
                  errorID(3921);
                  return null;
                } else {
                  const resultTarget = path[normalizedFollowTag](target, 0, nPaths);

                  if (resultTarget === null) {
                    return null;
                  }

                  const runtimeProxy = proxy.forTarget(resultTarget);
                  const binding = {
                    setValue: value => {
                      runtimeProxy.set(value);
                    }
                  };
                  const proxyGet = runtimeProxy.get;

                  if (proxyGet) {
                    binding.getValue = () => proxyGet.call(runtimeProxy);
                  }

                  return binding;
                }
              }

            }, _temp2$6), (_descriptor2$o = _applyDecoratedDescriptor(_class5$6.prototype, "path", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new TrackPath();
              }
            }), _descriptor3$h = _applyDecoratedDescriptor(_class5$6.prototype, "proxy", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class5$6)) || _class4$6) || _class4$6);

            function isTrsPropertyName(name) {
              return name === 'position' || name === 'rotation' || name === 'scale' || name === 'eulerAngles';
            }
            let Track = exports('b7', (_dec3$c = ccclass(`${CLASS_NAME_PREFIX_ANIM}Track`), _dec3$c(_class7$3 = (_class8$2 = (_temp3$2 = class Track {
              constructor() {
                _initializerDefineProperty(this, "_binding", _descriptor4$d, this);
              }

              get path() {
                return this._binding.path;
              }

              set path(value) {
                this._binding.path = value;
              }

              get proxy() {
                return this._binding.proxy;
              }

              set proxy(value) {
                this._binding.proxy = value;
              }

              get [trackBindingTag]() {
                return this._binding;
              }

              channels() {
                return [];
              }

              range() {
                const range = {
                  min: Infinity,
                  max: -Infinity
                };

                for (const channel of this.channels()) {
                  range.min = Math.min(range.min, channel.curve.rangeMin);
                  range.max = Math.max(range.max, channel.curve.rangeMax);
                }

                return range;
              }

            }, _temp3$2), (_descriptor4$d = _applyDecoratedDescriptor(_class8$2.prototype, "_binding", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new TrackBinding();
              }
            })), _class8$2)) || _class7$3));
            let Channel = (_dec4$9 = ccclass(`${CLASS_NAME_PREFIX_ANIM}Channel`), _dec4$9(_class10$2 = (_class11$2 = (_temp4$2 = class Channel {
              constructor(curve) {
                this.name = '';

                _initializerDefineProperty(this, "_curve", _descriptor5$a, this);

                this._curve = curve;
              }

              get curve() {
                return this._curve;
              }

            }, _temp4$2), (_descriptor5$a = _applyDecoratedDescriptor(_class11$2.prototype, "_curve", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class11$2)) || _class10$2);
            let SingleChannelTrack = (_dec5$6 = ccclass(`${CLASS_NAME_PREFIX_ANIM}SingleChannelTrack`), _dec5$6(_class13$2 = (_class14$2 = (_temp5$2 = class SingleChannelTrack extends Track {
              constructor() {
                super();

                _initializerDefineProperty(this, "_channel", _descriptor6$5, this);

                this._channel = new Channel(this.createCurve());
              }

              get channel() {
                return this._channel;
              }

              channels() {
                return [this._channel];
              }

              createCurve() {
                throw new Error(`Not impl`);
              }

              [createEvalSymbol](_runtimeBinding) {
                const {
                  curve
                } = this._channel;
                return new SingleChannelTrackEval(curve);
              }

            }, _temp5$2), (_descriptor6$5 = _applyDecoratedDescriptor(_class14$2.prototype, "_channel", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class14$2)) || _class13$2);

            class SingleChannelTrackEval {
              constructor(_curve) {
                this._curve = _curve;
              }

              evaluate(time) {
                return this._curve.evaluate(time);
              }

            }

            var _dec$F, _class$F;
            let RealTrack = exports('b9', (_dec$F = ccclass(`${CLASS_NAME_PREFIX_ANIM}RealTrack`), _dec$F(_class$F = class RealTrack extends SingleChannelTrack {
              createCurve() {
                return new RealCurve();
              }

            }) || _class$F));

            function maskIfEmpty(curve) {
              return curve.keyFramesCount === 0 ? undefined : curve;
            }

            var _dec$G, _class$G, _class2$A, _descriptor$x, _descriptor2$p, _temp$C;
            const CHANNEL_NAMES = ['X', 'Y', 'Z', 'W'];
            let VectorTrack = exports('ba', (_dec$G = ccclass(`${CLASS_NAME_PREFIX_ANIM}VectorTrack`), _dec$G(_class$G = (_class2$A = (_temp$C = class VectorTrack extends Track {
              constructor() {
                super();

                _initializerDefineProperty(this, "_channels", _descriptor$x, this);

                _initializerDefineProperty(this, "_nComponents", _descriptor2$p, this);

                this._channels = new Array(4);

                for (let i = 0; i < this._channels.length; ++i) {
                  const channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES[i];
                  this._channels[i] = channel;
                }
              }

              get componentsCount() {
                return this._nComponents;
              }

              set componentsCount(value) {
                this._nComponents = value;
              }

              channels() {
                return this._channels;
              }

              [createEvalSymbol]() {
                switch (this._nComponents) {
                  default:
                  case 2:
                    return new Vec2TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve));

                  case 3:
                    return new Vec3TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve));

                  case 4:
                    return new Vec4TrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve), maskIfEmpty(this._channels[3].curve));
                }
              }

            }, _temp$C), (_descriptor$x = _applyDecoratedDescriptor(_class2$A.prototype, "_channels", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor2$p = _applyDecoratedDescriptor(_class2$A.prototype, "_nComponents", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 4;
              }
            })), _class2$A)) || _class$G));
            class Vec2TrackEval {
              constructor(_x, _y) {
                this._result = new Vec2();
                this._x = _x;
                this._y = _y;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y) && runtimeBinding.getValue) {
                  Vec2.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                return this._result;
              }

            }
            class Vec3TrackEval {
              constructor(_x, _y, _z) {
                this._result = new Vec3();
                this._x = _x;
                this._y = _y;
                this._z = _z;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z) && runtimeBinding.getValue) {
                  Vec3.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.z = this._z.evaluate(time);
                }

                return this._result;
              }

            }
            class Vec4TrackEval {
              constructor(_x, _y, _z, _w) {
                this._result = new Vec4();
                this._x = _x;
                this._y = _y;
                this._z = _z;
                this._w = _w;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z || !this._w) && runtimeBinding.getValue) {
                  Vec4.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.x = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.y = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.z = this._z.evaluate(time);
                }

                if (this._w) {
                  this._result.w = this._w.evaluate(time);
                }

                return this._result;
              }

            }

            var _dec$H, _class$H;
            let QuatTrack = exports('bb', (_dec$H = ccclass(`${CLASS_NAME_PREFIX_ANIM}QuatTrack`), _dec$H(_class$H = class QuatTrack extends SingleChannelTrack {
              createCurve() {
                return new QuatCurve();
              }

              [createEvalSymbol]() {
                return new QuatTrackEval(this.channels()[0].curve);
              }

            }) || _class$H));
            class QuatTrackEval {
              constructor(_curve) {
                this._result = new Quat();
                this._curve = _curve;
              }

              evaluate(time) {
                this._curve.evaluate(time, this._result);

                return this._result;
              }

            }

            var _dec$I, _class$I, _class2$B, _descriptor$y, _temp$D;
            const CHANNEL_NAMES$1 = ['Red', 'Green', 'Blue', 'Alpha'];
            let ColorTrack = exports('bc', (_dec$I = ccclass(`${CLASS_NAME_PREFIX_ANIM}ColorTrack`), _dec$I(_class$I = (_class2$B = (_temp$D = class ColorTrack extends Track {
              constructor() {
                super();

                _initializerDefineProperty(this, "_channels", _descriptor$y, this);

                this._channels = new Array(4);

                for (let i = 0; i < this._channels.length; ++i) {
                  const channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES$1[i];
                  this._channels[i] = channel;
                }
              }

              channels() {
                return this._channels;
              }

              [createEvalSymbol]() {
                return new ColorTrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve), maskIfEmpty(this._channels[2].curve), maskIfEmpty(this._channels[3].curve));
              }

            }, _temp$D), (_descriptor$y = _applyDecoratedDescriptor(_class2$B.prototype, "_channels", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class2$B)) || _class$I));
            class ColorTrackEval {
              constructor(_x, _y, _z, _w) {
                this._result = new Color();
                this._x = _x;
                this._y = _y;
                this._z = _z;
                this._w = _w;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._x || !this._y || !this._z || !this._w) && runtimeBinding.getValue) {
                  Color.copy(this._result, runtimeBinding.getValue());
                }

                if (this._x) {
                  this._result.r = this._x.evaluate(time);
                }

                if (this._y) {
                  this._result.g = this._y.evaluate(time);
                }

                if (this._z) {
                  this._result.b = this._z.evaluate(time);
                }

                if (this._w) {
                  this._result.a = this._w.evaluate(time);
                }

                return this._result;
              }

            }

            var _dec$J, _class$J, _class2$C, _descriptor$z, _temp$E;
            const CHANNEL_NAMES$2 = ['Width', 'Height'];
            let SizeTrack = exports('bd', (_dec$J = ccclass(`${CLASS_NAME_PREFIX_ANIM}SizeTrack`), _dec$J(_class$J = (_class2$C = (_temp$E = class SizeTrack extends Track {
              constructor() {
                super();

                _initializerDefineProperty(this, "_channels", _descriptor$z, this);

                this._channels = new Array(2);

                for (let i = 0; i < this._channels.length; ++i) {
                  const channel = new Channel(new RealCurve());
                  channel.name = CHANNEL_NAMES$2[i];
                  this._channels[i] = channel;
                }
              }

              channels() {
                return this._channels;
              }

              [createEvalSymbol]() {
                return new SizeTrackEval(maskIfEmpty(this._channels[0].curve), maskIfEmpty(this._channels[1].curve));
              }

            }, _temp$E), (_descriptor$z = _applyDecoratedDescriptor(_class2$C.prototype, "_channels", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class2$C)) || _class$J));
            class SizeTrackEval {
              constructor(_width, _height) {
                this._result = new Size();
                this._width = _width;
                this._height = _height;
              }

              evaluate(time, runtimeBinding) {
                if ((!this._width || !this._height) && runtimeBinding.getValue) {
                  const size = runtimeBinding.getValue();
                  this._result.x = size.x;
                  this._result.y = size.y;
                }

                if (this._width) {
                  this._result.width = this._width.evaluate(time);
                }

                if (this._height) {
                  this._result.height = this._height.evaluate(time);
                }

                return this._result;
              }

            }

            var _dec$K, _class$K;
            let ObjectTrack = exports('be', (_dec$K = ccclass(`${CLASS_NAME_PREFIX_ANIM}ObjectTrack`), _dec$K(_class$K = class ObjectTrack extends SingleChannelTrack {
              createCurve() {
                return new ObjectCurve();
              }

            }) || _class$K));

            const BAKE_SKELETON_CURVE_SYMBOL = Symbol('BakeNodeCurves');

            class SkelAnimDataHub {
              static getOrExtract(clip) {
                let data = SkelAnimDataHub.pool.get(clip);

                if (!data || data.samples !== clip.sample) {
                  if (data) {
                    legacyCC.director.root.dataPoolManager.releaseAnimationClip(clip);
                  }

                  const frames = Math.ceil(clip.sample * clip.duration) + 1;
                  const step = clip.sample;
                  data = clip[BAKE_SKELETON_CURVE_SYMBOL](0, step, frames);
                  SkelAnimDataHub.pool.set(clip, data);
                }

                return data;
              }

              static destroy(clip) {
                SkelAnimDataHub.pool.delete(clip);
              }

            } exports('cH', SkelAnimDataHub);
            SkelAnimDataHub.pool = new Map();

            class RatioSampler {
              constructor(ratios) {
                this.ratios = void 0;
                this._findRatio = void 0;
                this.ratios = ratios;
                let currRatioDif;
                let lastRatioDif;
                let canOptimize = true;
                const EPSILON = 1e-6;

                for (let i = 1, l = ratios.length; i < l; i++) {
                  currRatioDif = ratios[i] - ratios[i - 1];

                  if (i === 1) {
                    lastRatioDif = currRatioDif;
                  } else if (Math.abs(currRatioDif - lastRatioDif) > EPSILON) {
                    canOptimize = false;
                    break;
                  }
                }

                this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon;
              }

              sample(ratio) {
                return this._findRatio(this.ratios, ratio);
              }

            } exports('gt', RatioSampler);
            legacyCC.RatioSampler = RatioSampler;
            class AnimCurve {
              static Bezier(controlPoints) {
                return controlPoints;
              }

              constructor(propertyCurveData, duration) {
                this.types = undefined;
                this.type = null;
                this._values = [];
                this._lerp = undefined;
                this._duration = void 0;
                this._array = void 0;
                this._duration = duration;
                this._values = propertyCurveData.values;

                const getCurveType = easingMethod => {
                  if (typeof easingMethod === 'string') {
                    return easingMethod;
                  } else if (Array.isArray(easingMethod)) {
                    if (easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3]) {
                      return AnimCurve.Linear;
                    } else {
                      return AnimCurve.Bezier(easingMethod);
                    }
                  } else {
                    return AnimCurve.Linear;
                  }
                };

                if (propertyCurveData.easingMethod !== undefined) {
                  this.type = getCurveType(propertyCurveData.easingMethod);
                } else if (Array.isArray(propertyCurveData.easingMethods)) {
                  this.types = propertyCurveData.easingMethods.map(getCurveType);
                } else if (propertyCurveData.easingMethods !== undefined) {
                  this.types = new Array(this._values.length).fill(null);

                  for (const index of Object.keys(propertyCurveData.easingMethods)) {
                    this.types[index] = getCurveType(propertyCurveData.easingMethods[index]);
                  }
                } else {
                  this.type = null;
                }

                const firstValue = propertyCurveData.values[0];
                const interpolate = propertyCurveData.interpolate === undefined ? true : propertyCurveData.interpolate;

                if (interpolate) {
                  this._lerp = selectLerpFx(firstValue);
                }

                if (propertyCurveData._arrayLength !== undefined) {
                  this._array = new Array(propertyCurveData._arrayLength);
                }
              }

              hasLerp() {
                return !!this._lerp;
              }

              valueAt(index) {
                if (this._array === undefined) {
                  const value = this._values[index];

                  if (value && value.getNoLerp) {
                    return value.getNoLerp();
                  } else {
                    return value;
                  }
                } else {
                  for (let i = 0; i < this._array.length; ++i) {
                    this._array[i] = this._values[this._array.length * index + i];
                  }

                  return this._array;
                }
              }

              valueBetween(ratio, from, fromRatio, to, toRatio) {
                if (this._lerp) {
                  const type = this.types ? this.types[from] : this.type;
                  const dRatio = toRatio - fromRatio;
                  let ratioBetweenFrames = (ratio - fromRatio) / dRatio;

                  if (type) {
                    ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type);
                  }

                  if (this._array === undefined) {
                    const fromVal = this._values[from];
                    const toVal = this._values[to];

                    const value = this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);

                    return value;
                  } else {
                    for (let i = 0; i < this._array.length; ++i) {
                      const fromVal = this._values[this._array.length * from + i];
                      const toVal = this._values[this._array.length * to + i];
                      this._array[i] = this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);
                    }

                    return this._array;
                  }
                } else if (this._array === undefined) {
                  return this.valueAt(from);
                } else {
                  for (let i = 0; i < this._array.length; ++i) {
                    this._array[i] = this._values[this._array.length * from + i];
                  }

                  return this._array;
                }
              }

              empty() {
                return this._values.length === 0;
              }

              constant() {
                return this._values.length === 1;
              }

            } exports('gu', AnimCurve);
            AnimCurve.Linear = null;
            legacyCC.AnimCurve = AnimCurve;
            class EventInfo {
              constructor() {
                this.events = [];
              }

              add(func, params) {
                this.events.push({
                  func: func || '',
                  params: params || []
                });
              }

            } exports('gv', EventInfo);
            function sampleAnimationCurve(curve, sampler, ratio) {
              let index = sampler.sample(ratio);

              if (index < 0) {
                index = ~index;

                if (index <= 0) {
                  index = 0;
                } else if (index >= sampler.ratios.length) {
                  index = sampler.ratios.length - 1;
                } else {
                  return curve.valueBetween(ratio, index - 1, sampler.ratios[index - 1], index, sampler.ratios[index]);
                }
              }

              return curve.valueAt(index);
            }
            legacyCC.sampleAnimationCurve = sampleAnimationCurve;
            function computeRatioByType(ratio, type) {
              if (typeof type === 'string') {
                const func = easing[type];

                if (func) {
                  ratio = func(ratio);
                } else {
                  errorID(3906, type);
                }
              } else if (Array.isArray(type)) {
                ratio = bezierByTime(type, ratio);
              }

              return ratio;
            }

            function quickFindIndex(ratios, ratio) {
              const length = ratios.length - 1;

              if (length === 0) {
                return 0;
              }

              const start = ratios[0];

              if (ratio < start) {
                return 0;
              }

              const end = ratios[length];

              if (ratio > end) {
                return length;
              }

              ratio = (ratio - start) / (end - start);
              const eachLength = 1 / length;
              const index = ratio / eachLength;
              const floorIndex = index | 0;
              const EPSILON = 1e-6;

              if (index - floorIndex < EPSILON) {
                return floorIndex;
              } else if (floorIndex + 1 - index < EPSILON) {
                return floorIndex + 1;
              }

              return ~(floorIndex + 1);
            }

            const selectLerpFx = (() => {
              function makeValueTypeLerpFx(constructor) {
                const tempValue = new constructor();
                return (from, to, ratio) => {
                  constructor.lerp(tempValue, from, to, ratio);
                  return tempValue;
                };
              }

              function callLerpable(from, to, t, dt) {
                return from.lerp(to, t, dt);
              }

              function makeQuatSlerpFx() {
                const tempValue = new Quat();
                return (from, to, t, dt) => Quat.slerp(tempValue, from, to, t);
              }

              return value => {
                if (value === null) {
                  return undefined;
                }

                if (typeof value === 'number') {
                  return lerp;
                } else if (typeof value === 'object' && value.constructor) {
                  if (value instanceof Quat) {
                    return makeQuatSlerpFx();
                  } else if (value instanceof ValueType) {
                    return makeValueTypeLerpFx(value.constructor);
                  } else if (value.constructor === Number) {
                    return lerp;
                  } else if (isLerpable(value)) {
                    return callLerpable;
                  }
                }

                return undefined;
              };
            })();

            var _dec$L, _class$L, _class2$D, _descriptor$A, _temp$F, _dec2$k, _class4$7, _class5$7, _descriptor2$q, _temp2$7;
            let UntypedTrackChannel = (_dec$L = ccclass(`${CLASS_NAME_PREFIX_ANIM}UntypedTrackChannel`), _dec$L(_class$L = (_class2$D = (_temp$F = class UntypedTrackChannel extends Channel {
              constructor() {
                super(new RealCurve());

                _initializerDefineProperty(this, "property", _descriptor$A, this);
              }

            }, _temp$F), (_descriptor$A = _applyDecoratedDescriptor(_class2$D.prototype, "property", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$D)) || _class$L);
            let UntypedTrack = (_dec2$k = ccclass(`${CLASS_NAME_PREFIX_ANIM}UntypedTrack`), _dec2$k(_class4$7 = (_class5$7 = (_temp2$7 = class UntypedTrack extends Track {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_channels", _descriptor2$q, this);
              }

              channels() {
                return this._channels;
              }

              [createEvalSymbol](runtimeBinding) {
                if (!runtimeBinding.getValue) {
                  throw new Error(getError(3930));
                }

                const trySearchCurve = property => {
                  var _this$_channels$find;

                  return (_this$_channels$find = this._channels.find(channel => channel.property === property)) === null || _this$_channels$find === void 0 ? void 0 : _this$_channels$find.curve;
                };

                const value = runtimeBinding.getValue();

                switch (true) {
                  default:
                    throw new Error(getError(3931));

                  case value instanceof Vec2:
                    return new Vec2TrackEval(trySearchCurve('x'), trySearchCurve('y'));

                  case value instanceof Vec3:
                    return new Vec3TrackEval(trySearchCurve('x'), trySearchCurve('y'), trySearchCurve('z'));

                  case value instanceof Vec4:
                    return new Vec4TrackEval(trySearchCurve('x'), trySearchCurve('y'), trySearchCurve('z'), trySearchCurve('w'));

                  case value instanceof Color:
                    return new ColorTrackEval(trySearchCurve('r'), trySearchCurve('g'), trySearchCurve('b'), trySearchCurve('a'));

                  case value instanceof Size:
                    return new SizeTrackEval(trySearchCurve('width'), trySearchCurve('height'));
                }
              }

              addChannel(property) {
                const channel = new UntypedTrackChannel();
                channel.property = property;

                this._channels.push(channel);

                return channel;
              }

              upgrade(refine) {
                const trySearchChannel = (property, outChannel) => {
                  const untypedChannel = this.channels().find(channel => channel.property === property);

                  if (untypedChannel) {
                    outChannel.name = untypedChannel.name;
                    outChannel.curve.assignSorted(Array.from(untypedChannel.curve.times()), Array.from(untypedChannel.curve.values()));
                  }
                };

                const kind = refine(this.path, this.proxy);

                switch (kind) {
                  default:
                    break;

                  case 'vec2':
                  case 'vec3':
                  case 'vec4':
                    {
                      const track = new VectorTrack();
                      track.path = this.path;
                      track.proxy = this.proxy;
                      track.componentsCount = kind === 'vec2' ? 2 : kind === 'vec3' ? 3 : 4;
                      const [x, y, z, w] = track.channels();

                      switch (kind) {
                        case 'vec4':
                          trySearchChannel('w', w);

                        case 'vec3':
                          trySearchChannel('z', z);

                        default:
                        case 'vec2':
                          trySearchChannel('x', x);
                          trySearchChannel('y', y);
                      }

                      return track;
                    }

                  case 'color':
                    {
                      const track = new ColorTrack();
                      const [r, g, b, a] = track.channels();
                      trySearchChannel('r', r);
                      trySearchChannel('g', g);
                      trySearchChannel('b', b);
                      trySearchChannel('a', a);
                      trySearchChannel('x', r);
                      trySearchChannel('y', g);
                      trySearchChannel('z', b);
                      trySearchChannel('w', a);
                      return track;
                    }

                  case 'size':
                    break;
                }

                return null;
              }

            }, _temp2$7), (_descriptor2$q = _applyDecoratedDescriptor(_class5$7.prototype, "_channels", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class5$7)) || _class4$7);

            class AnimationClipLegacyData {
              constructor(duration) {
                this._keys = [];
                this._curves = [];
                this._commonTargets = [];
                this._ratioSamplers = [];
                this._runtimeCurves = void 0;
                this._data = null;
                this._duration = void 0;
                this._duration = duration;
              }

              get keys() {
                return this._keys;
              }

              set keys(value) {
                this._keys = value;
              }

              get curves() {
                return this._curves;
              }

              set curves(value) {
                this._curves = value;
                delete this._runtimeCurves;
              }

              get commonTargets() {
                return this._commonTargets;
              }

              set commonTargets(value) {
                this._commonTargets = value;
              }

              get data() {
                return this._data;
              }

              getPropertyCurves() {
                if (!this._runtimeCurves) {
                  this._createPropertyCurves();
                }

                return this._runtimeCurves;
              }

              toTracks() {
                const newTracks = [];
                const {
                  keys: legacyKeys,
                  curves: legacyCurves,
                  commonTargets: legacyCommonTargets
                } = this;

                const convertTrackPath = (track, modifiers, valueAdapter) => {
                  const trackPath = new TrackPath();

                  for (const modifier of modifiers) {
                    if (typeof modifier === 'string') {
                      trackPath.toProperty(modifier);
                    } else if (typeof modifier === 'number') {
                      trackPath.toElement(modifier);
                    } else if (modifier instanceof HierarchyPath) {
                      trackPath.toHierarchy(modifier.path);
                    } else if (modifier instanceof ComponentPath) {
                      trackPath.toComponent(modifier.component);
                    } else {
                      trackPath.toCustomized(modifier);
                    }
                  }

                  track.path = trackPath;
                  track.proxy = valueAdapter;
                };

                const untypedTracks = legacyCommonTargets.map(legacyCommonTarget => {
                  const track = new UntypedTrack();
                  convertTrackPath(track, legacyCommonTarget.modifiers, legacyCommonTarget.valueAdapter);
                  newTracks.push(track);
                  return track;
                });

                for (const legacyCurve of legacyCurves) {
                  var _legacyCurveData$inte;

                  const legacyCurveData = legacyCurve.data;
                  const legacyValues = legacyCurveData.values;

                  if (legacyValues.length === 0) {
                    continue;
                  }

                  const legacyKeysIndex = legacyCurveData.keys;
                  const times = legacyKeysIndex < 0 ? [0.0] : legacyKeys[legacyCurveData.keys];
                  const firstValue = legacyValues[0];
                  const interpolate = (_legacyCurveData$inte = legacyCurveData.interpolate) !== null && _legacyCurveData$inte !== void 0 ? _legacyCurveData$inte : true;
                  assertIsTrue(typeof legacyCurveData._arrayLength !== 'number' || typeof firstValue === 'number');
                  const legacyEasingMethodConverter = new LegacyEasingMethodConverter(legacyCurveData, times.length);

                  const installPathAndSetter = track => {
                    convertTrackPath(track, legacyCurve.modifiers, legacyCurve.valueAdapter);
                  };

                  let legacyCommonTargetCurve;

                  if (typeof legacyCurve.commonTarget === 'number') {
                    if (!legacyValues.every(value => typeof value === 'number')) {
                      warnID(3932);
                      continue;
                    }

                    if (legacyCurve.valueAdapter || legacyCurve.modifiers.length !== 1 || typeof legacyCurve.modifiers[0] !== 'string') {
                      warnID(3933);
                      continue;
                    }

                    const propertyName = legacyCurve.modifiers[0];
                    const untypedTrack = untypedTracks[legacyCurve.commonTarget];
                    const {
                      curve
                    } = untypedTrack.addChannel(propertyName);
                    legacyCommonTargetCurve = curve;
                  }

                  const convertCurve = () => {
                    if (typeof firstValue === 'number') {
                      if (!legacyValues.every(value => typeof value === 'number')) {
                        warnID(3934);
                        return;
                      }

                      let realCurve;

                      if (legacyCommonTargetCurve) {
                        realCurve = legacyCommonTargetCurve;
                      } else {
                        const track = new RealTrack();
                        installPathAndSetter(track);
                        newTracks.push(track);
                        realCurve = track.channel.curve;
                      }

                      const interpolationMethod = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;
                      realCurve.assignSorted(times, legacyValues.map(value => ({
                        value,
                        interpolationMode: interpolationMethod
                      })));
                      legacyEasingMethodConverter.convert(realCurve);
                      return;
                    } else if (typeof firstValue === 'object') {
                      switch (true) {
                        default:
                          break;

                        case everyInstanceOf(legacyValues, Vec2):
                        case everyInstanceOf(legacyValues, Vec3):
                        case everyInstanceOf(legacyValues, Vec4):
                          {
                            const components = firstValue instanceof Vec2 ? 2 : firstValue instanceof Vec3 ? 3 : 4;
                            const track = new VectorTrack();
                            installPathAndSetter(track);
                            track.componentsCount = components;
                            const [{
                              curve: x
                            }, {
                              curve: y
                            }, {
                              curve: z
                            }, {
                              curve: w
                            }] = track.channels();
                            const interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            const valueToFrame = value => ({
                              value,
                              interpolationMode
                            });

                            switch (components) {
                              case 4:
                                w.assignSorted(times, legacyValues.map(value => valueToFrame(value.w)));
                                legacyEasingMethodConverter.convert(w);

                              case 3:
                                z.assignSorted(times, legacyValues.map(value => valueToFrame(value.z)));
                                legacyEasingMethodConverter.convert(z);

                              default:
                                x.assignSorted(times, legacyValues.map(value => valueToFrame(value.x)));
                                legacyEasingMethodConverter.convert(x);
                                y.assignSorted(times, legacyValues.map(value => valueToFrame(value.y)));
                                legacyEasingMethodConverter.convert(y);
                                break;
                            }

                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Quat):
                          {
                            const track = new QuatTrack();
                            installPathAndSetter(track);
                            const interpolationMode = interpolate ? QuatInterpolationMode.SLERP : QuatInterpolationMode.CONSTANT;
                            track.channel.curve.assignSorted(times, legacyValues.map(value => ({
                              value: Quat.clone(value),
                              interpolationMode
                            })));
                            legacyEasingMethodConverter.convertQuatCurve(track.channel.curve);
                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Color):
                          {
                            const track = new ColorTrack();
                            installPathAndSetter(track);
                            const [{
                              curve: r
                            }, {
                              curve: g
                            }, {
                              curve: b
                            }, {
                              curve: a
                            }] = track.channels();
                            const interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            const valueToFrame = value => ({
                              value,
                              interpolationMode
                            });

                            r.assignSorted(times, legacyValues.map(value => valueToFrame(value.r)));
                            legacyEasingMethodConverter.convert(r);
                            g.assignSorted(times, legacyValues.map(value => valueToFrame(value.g)));
                            legacyEasingMethodConverter.convert(g);
                            b.assignSorted(times, legacyValues.map(value => valueToFrame(value.b)));
                            legacyEasingMethodConverter.convert(b);
                            a.assignSorted(times, legacyValues.map(value => valueToFrame(value.a)));
                            legacyEasingMethodConverter.convert(a);
                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, Size):
                          {
                            const track = new SizeTrack();
                            installPathAndSetter(track);
                            const [{
                              curve: width
                            }, {
                              curve: height
                            }] = track.channels();
                            const interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            const valueToFrame = value => ({
                              value,
                              interpolationMode
                            });

                            width.assignSorted(times, legacyValues.map(value => valueToFrame(value.width)));
                            legacyEasingMethodConverter.convert(width);
                            height.assignSorted(times, legacyValues.map(value => valueToFrame(value.height)));
                            legacyEasingMethodConverter.convert(height);
                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, CubicSplineNumberValue):
                          {
                            assertIsTrue(legacyEasingMethodConverter.nil);
                            const track = new RealTrack();
                            installPathAndSetter(track);
                            const interpolationMode = interpolate ? RealInterpolationMode.CUBIC : RealInterpolationMode.CONSTANT;
                            track.channel.curve.assignSorted(times, legacyValues.map(value => ({
                              value: value.dataPoint,
                              leftTangent: value.inTangent,
                              rightTangent: value.outTangent,
                              interpolationMode
                            })));
                            newTracks.push(track);
                            return;
                          }

                        case everyInstanceOf(legacyValues, CubicSplineVec2Value):
                        case everyInstanceOf(legacyValues, CubicSplineVec3Value):
                        case everyInstanceOf(legacyValues, CubicSplineVec4Value):
                          {
                            assertIsTrue(legacyEasingMethodConverter.nil);
                            const components = firstValue instanceof CubicSplineVec2Value ? 2 : firstValue instanceof CubicSplineVec3Value ? 3 : 4;
                            const track = new VectorTrack();
                            installPathAndSetter(track);
                            track.componentsCount = components;
                            const [x, y, z, w] = track.channels();
                            const interpolationMode = interpolate ? RealInterpolationMode.LINEAR : RealInterpolationMode.CONSTANT;

                            const valueToFrame = (value, inTangent, outTangent) => ({
                              value,
                              leftTangent: inTangent,
                              rightTangent: outTangent,
                              interpolationMode
                            });

                            switch (components) {
                              case 4:
                                w.curve.assignSorted(times, legacyValues.map(value => valueToFrame(value.dataPoint.w, value.inTangent.w, value.outTangent.w)));

                              case 3:
                                z.curve.assignSorted(times, legacyValues.map(value => valueToFrame(value.dataPoint.z, value.inTangent.z, value.outTangent.z)));

                              default:
                                x.curve.assignSorted(times, legacyValues.map(value => valueToFrame(value.dataPoint.y, value.inTangent.y, value.outTangent.y)));
                                y.curve.assignSorted(times, legacyValues.map(value => valueToFrame(value.dataPoint.x, value.inTangent.x, value.outTangent.x)));
                                break;
                            }

                            newTracks.push(track);
                            return;
                          }

                        case legacyValues.every(value => value instanceof CubicSplineQuatValue):
                          {
                            warnID(3935);
                            break;
                          }
                      }
                    }

                    const objectTrack = new ObjectTrack();
                    installPathAndSetter(objectTrack);
                    objectTrack.channel.curve.assignSorted(times, legacyValues);
                    newTracks.push(objectTrack);
                  };

                  convertCurve();
                }

                return newTracks;
              }

              _createPropertyCurves() {
                this._ratioSamplers = this._keys.map(keys => new RatioSampler(keys.map(key => key / this._duration)));
                this._runtimeCurves = this._curves.map(targetCurve => ({
                  curve: new AnimCurve(targetCurve.data, this._duration),
                  modifiers: targetCurve.modifiers,
                  valueAdapter: targetCurve.valueAdapter,
                  sampler: this._ratioSamplers[targetCurve.data.keys],
                  commonTarget: targetCurve.commonTarget
                }));
              }

            }

            function everyInstanceOf(array, constructor) {
              return array.every(element => element instanceof constructor);
            }

            class LegacyEasingMethodConverter {
              constructor(legacyCurveData, keyframesCount) {
                this._easingMethods = void 0;
                const {
                  easingMethods
                } = legacyCurveData;

                if (Array.isArray(easingMethods)) {
                  if (easingMethods.length === 0 && keyframesCount !== 0) {
                    this._easingMethods = new Array(keyframesCount).fill(null);
                  } else {
                    this._easingMethods = easingMethods;
                  }
                } else if (easingMethods === undefined) {
                  this._easingMethods = new Array(keyframesCount).fill(legacyCurveData.easingMethod);
                } else {
                  this._easingMethods = Array.from({
                    length: keyframesCount
                  }, (_, index) => {
                    var _easingMethods$index;

                    return (_easingMethods$index = easingMethods[index]) !== null && _easingMethods$index !== void 0 ? _easingMethods$index : null;
                  });
                }
              }

              get nil() {
                return !this._easingMethods || this._easingMethods.every(easingMethod => easingMethod === null || easingMethod === undefined);
              }

              convert(curve) {
                const {
                  _easingMethods: easingMethods
                } = this;

                if (!easingMethods) {
                  return;
                }

                const nKeyframes = curve.keyFramesCount;

                if (curve.keyFramesCount < 2) {
                  return;
                }

                if (Array.isArray(easingMethods)) {
                  assertIsTrue(nKeyframes === easingMethods.length);
                }

                const iLastKeyframe = nKeyframes - 1;

                for (let iKeyframe = 0; iKeyframe < iLastKeyframe; ++iKeyframe) {
                  const easingMethod = easingMethods[iKeyframe];

                  if (!easingMethod) {
                    continue;
                  }

                  if (Array.isArray(easingMethod)) {
                    timeBezierToTangents(easingMethod, curve.getKeyframeTime(iKeyframe), curve.getKeyframeValue(iKeyframe), curve.getKeyframeTime(iKeyframe + 1), curve.getKeyframeValue(iKeyframe + 1));
                  } else {
                    applyLegacyEasingMethodName(easingMethod, curve, iKeyframe);
                  }
                }
              }

              convertQuatCurve(curve) {
                const {
                  _easingMethods: easingMethods
                } = this;

                if (!easingMethods) {
                  return;
                }

                const nKeyframes = curve.keyFramesCount;

                if (curve.keyFramesCount < 2) {
                  return;
                }

                if (Array.isArray(easingMethods)) {
                  assertIsTrue(nKeyframes === easingMethods.length);
                }

                const iLastKeyframe = nKeyframes - 1;

                for (let iKeyframe = 0; iKeyframe < iLastKeyframe; ++iKeyframe) {
                  const easingMethod = easingMethods[iKeyframe];

                  if (!easingMethod) {
                    continue;
                  }

                  if (Array.isArray(easingMethod)) {
                    curve.getKeyframeValue(iKeyframe).easingMethod = easingMethod.slice();
                  } else {
                    applyLegacyEasingMethodNameIntoQuatCurve(easingMethod, curve, iKeyframe);
                  }
                }
              }

            }

            function applyLegacyEasingMethodName(easingMethodName, curve, keyframeIndex) {
              assertIsTrue(keyframeIndex !== curve.keyFramesCount - 1);
              assertIsTrue(easingMethodName in easingMethodNameMap);
              const keyframeValue = curve.getKeyframeValue(keyframeIndex);
              const easingMethod = easingMethodNameMap[easingMethodName];

              if (easingMethod === EasingMethod.CONSTANT) {
                keyframeValue.interpolationMode = RealInterpolationMode.CONSTANT;
              } else {
                keyframeValue.interpolationMode = RealInterpolationMode.LINEAR;
                keyframeValue.easingMethod = easingMethod;
              }
            }

            function applyLegacyEasingMethodNameIntoQuatCurve(easingMethodName, curve, keyframeIndex) {
              assertIsTrue(keyframeIndex !== curve.keyFramesCount - 1);
              assertIsTrue(easingMethodName in easingMethodNameMap);
              const keyframeValue = curve.getKeyframeValue(keyframeIndex);
              const easingMethod = easingMethodNameMap[easingMethodName];
              keyframeValue.easingMethod = easingMethod;
            }

            const easingMethodNameMap = {
              constant: EasingMethod.CONSTANT,
              linear: EasingMethod.LINEAR,
              quadIn: EasingMethod.QUAD_IN,
              quadOut: EasingMethod.QUAD_OUT,
              quadInOut: EasingMethod.QUAD_IN_OUT,
              quadOutIn: EasingMethod.QUAD_OUT_IN,
              cubicIn: EasingMethod.CUBIC_IN,
              cubicOut: EasingMethod.CUBIC_OUT,
              cubicInOut: EasingMethod.CUBIC_IN_OUT,
              cubicOutIn: EasingMethod.CUBIC_OUT_IN,
              quartIn: EasingMethod.QUART_IN,
              quartOut: EasingMethod.QUART_OUT,
              quartInOut: EasingMethod.QUART_IN_OUT,
              quartOutIn: EasingMethod.QUART_OUT_IN,
              quintIn: EasingMethod.QUINT_IN,
              quintOut: EasingMethod.QUINT_OUT,
              quintInOut: EasingMethod.QUINT_IN_OUT,
              quintOutIn: EasingMethod.QUINT_OUT_IN,
              sineIn: EasingMethod.SINE_IN,
              sineOut: EasingMethod.SINE_OUT,
              sineInOut: EasingMethod.SINE_IN_OUT,
              sineOutIn: EasingMethod.SINE_OUT_IN,
              expoIn: EasingMethod.EXPO_IN,
              expoOut: EasingMethod.EXPO_OUT,
              expoInOut: EasingMethod.EXPO_IN_OUT,
              expoOutIn: EasingMethod.EXPO_OUT_IN,
              circIn: EasingMethod.CIRC_IN,
              circOut: EasingMethod.CIRC_OUT,
              circInOut: EasingMethod.CIRC_IN_OUT,
              circOutIn: EasingMethod.CIRC_OUT_IN,
              elasticIn: EasingMethod.ELASTIC_IN,
              elasticOut: EasingMethod.ELASTIC_OUT,
              elasticInOut: EasingMethod.ELASTIC_IN_OUT,
              elasticOutIn: EasingMethod.ELASTIC_OUT_IN,
              backIn: EasingMethod.BACK_IN,
              backOut: EasingMethod.BACK_OUT,
              backInOut: EasingMethod.BACK_IN_OUT,
              backOutIn: EasingMethod.BACK_OUT_IN,
              bounceIn: EasingMethod.BOUNCE_IN,
              bounceOut: EasingMethod.BOUNCE_OUT,
              bounceInOut: EasingMethod.BOUNCE_IN_OUT,
              bounceOutIn: EasingMethod.BOUNCE_OUT_IN,
              smooth: EasingMethod.SMOOTH,
              fade: EasingMethod.FADE
            };
            function timeBezierToTangents(timeBezierPoints, previousTime, previousKeyframe, nextTime, nextKeyframe) {
              const [p1X, p1Y, p2X, p2Y] = timeBezierPoints;
              const {
                value: previousValue
              } = previousKeyframe;
              const {
                value: nextValue
              } = nextKeyframe;
              const dValue = nextValue - previousValue;
              const dTime = nextTime - previousTime;
              const fx = 3 * dTime;
              const fy = 3 * dValue;
              const t1x = p1X * fx;
              const t1y = p1Y * fy;
              const t2x = (1.0 - p2X) * fx;
              const t2y = (1.0 - p2Y) * fy;
              const ONE_THIRD = 1.0 / 3.0;
              const previousTangent = t1y / t1x;
              const previousTangentWeight = Math.sqrt(t1x * t1x + t1y * t1y) * ONE_THIRD;
              const nextTangent = t2y / t2x;
              const nextTangentWeight = Math.sqrt(t2x * t2x + t2y * t2y) * ONE_THIRD;
              previousKeyframe.interpolationMode = RealInterpolationMode.CUBIC;
              previousKeyframe.tangentWeightMode = ensureRightTangentWeightMode(previousKeyframe.tangentWeightMode);
              previousKeyframe.rightTangent = previousTangent;
              previousKeyframe.rightTangentWeight = previousTangentWeight;
              nextKeyframe.tangentWeightMode = ensureLeftTangentWeightMode(nextKeyframe.tangentWeightMode);
              nextKeyframe.leftTangent = nextTangent;
              nextKeyframe.leftTangentWeight = nextTangentWeight;
            }

            function ensureLeftTangentWeightMode(tangentWeightMode) {
              if (tangentWeightMode === TangentWeightMode.NONE) {
                return TangentWeightMode.LEFT;
              } else if (tangentWeightMode === TangentWeightMode.RIGHT) {
                return TangentWeightMode.BOTH;
              } else {
                return tangentWeightMode;
              }
            }

            function ensureRightTangentWeightMode(tangentWeightMode) {
              if (tangentWeightMode === TangentWeightMode.NONE) {
                return TangentWeightMode.RIGHT;
              } else if (tangentWeightMode === TangentWeightMode.LEFT) {
                return TangentWeightMode.BOTH;
              } else {
                return tangentWeightMode;
              }
            }

            var _dec$M, _class$M, _class2$E, _descriptor$B, _temp$G, _dec2$l, _class4$8, _class5$8, _descriptor2$r, _descriptor3$i, _descriptor4$e, _descriptor5$b, _temp2$8, _dec3$d, _class7$4, _class8$3, _descriptor6$6, _descriptor7$4, _temp3$3, _dec4$a, _class10$3, _dec5$7, _class11$3, _dec6$5, _class12, _class13$3, _descriptor8$4, _descriptor9$3, _temp4$3, _dec7$3, _class15, _class16$2, _descriptor10$3, _descriptor11$3, _descriptor12$3, _descriptor13$3, _temp5$3;

            function throwIfSplitMethodIsNotValid() {
              throw new Error(`split() only valid in Editor.`);
            }

            let ExoticAnimation = (_dec$M = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticAnimation`), _dec$M(_class$M = (_class2$E = (_temp$G = class ExoticAnimation {
              constructor() {
                _initializerDefineProperty(this, "_nodeAnimations", _descriptor$B, this);
              }

              createEvaluator(binder) {
                return new ExoticTrsAnimationEvaluator(this._nodeAnimations, binder);
              }

              addNodeAnimation(path) {
                const nodeAnimation = new ExoticNodeAnimation(path);

                this._nodeAnimations.push(nodeAnimation);

                return nodeAnimation;
              }

              collectAnimatedJoints() {
                return Array.from(new Set(this._nodeAnimations.map(({
                  path
                }) => path)));
              }

              split(from, to) {
                {
                  return throwIfSplitMethodIsNotValid();
                }
              }

              toHashString() {
                return this._nodeAnimations.map(nodeAnimation => nodeAnimation.toHashString()).join('\n');
              }

            }, _temp$G), (_descriptor$B = _applyDecoratedDescriptor(_class2$E.prototype, "_nodeAnimations", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$E)) || _class$M);
            let ExoticNodeAnimation = (_dec2$l = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticNodeAnimation`), _dec2$l(_class4$8 = (_class5$8 = (_temp2$8 = class ExoticNodeAnimation {
              constructor(path) {
                _initializerDefineProperty(this, "_path", _descriptor2$r, this);

                _initializerDefineProperty(this, "_position", _descriptor3$i, this);

                _initializerDefineProperty(this, "_rotation", _descriptor4$e, this);

                _initializerDefineProperty(this, "_scale", _descriptor5$b, this);

                this._path = path;
              }

              createPosition(times, values) {
                this._position = new ExoticTrack(times, new ExoticVec3TrackValues(values));
              }

              createRotation(times, values) {
                this._rotation = new ExoticTrack(times, new ExoticQuatTrackValues(values));
              }

              createScale(times, values) {
                this._scale = new ExoticTrack(times, new ExoticVec3TrackValues(values));
              }

              createEvaluator(binder) {
                return new ExoticNodeAnimationEvaluator(this._path, this._position, this._rotation, this._scale, binder);
              }

              split(from, to, splitInfoCache) {
                {
                  return throwIfSplitMethodIsNotValid();
                }
              }

              get path() {
                return this._path;
              }

              toHashString() {
                var _this$_position$toHas, _this$_position, _this$_scale$toHashSt, _this$_scale, _this$_rotation$toHas, _this$_rotation;

                return `${this._path}\n${(_this$_position$toHas = (_this$_position = this._position) === null || _this$_position === void 0 ? void 0 : _this$_position.toHashString()) !== null && _this$_position$toHas !== void 0 ? _this$_position$toHas : ''}${(_this$_scale$toHashSt = (_this$_scale = this._scale) === null || _this$_scale === void 0 ? void 0 : _this$_scale.toHashString()) !== null && _this$_scale$toHashSt !== void 0 ? _this$_scale$toHashSt : ''}${(_this$_rotation$toHas = (_this$_rotation = this._rotation) === null || _this$_rotation === void 0 ? void 0 : _this$_rotation.toHashString()) !== null && _this$_rotation$toHas !== void 0 ? _this$_rotation$toHas : ''}`;
              }

            }, _temp2$8), (_descriptor2$r = _applyDecoratedDescriptor(_class5$8.prototype, "_path", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor3$i = _applyDecoratedDescriptor(_class5$8.prototype, "_position", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor4$e = _applyDecoratedDescriptor(_class5$8.prototype, "_rotation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor5$b = _applyDecoratedDescriptor(_class5$8.prototype, "_scale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class5$8)) || _class4$8);

            function floatToHashString(value) {
              return value.toPrecision(2);
            }

            function floatArrayToHashString(values) {
              return values.map(floatToHashString).join(' ');
            }

            let ExoticVectorLikeTrackValues = (_dec3$d = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticVectorLikeTrackValues`), _dec3$d(_class7$4 = (_class8$3 = (_temp3$3 = class ExoticVectorLikeTrackValues {
              constructor(values) {
                _initializerDefineProperty(this, "_values", _descriptor6$6, this);

                _initializerDefineProperty(this, "_isQuantized", _descriptor7$4, this);

                this._values = values;
                this._isQuantized = false;
              }

              get precision() {
                return this._isQuantized ? this._values.originalPrecision : getFloatArrayPrecision(this._values);
              }

              quantize(type) {
                assertIsTrue(!this._isQuantized);
                this._values = quantize(this._values, type);
                this._isQuantized = true;
              }

              toHashString() {
                const {
                  _isQuantized: isQuantized,
                  _values: values
                } = this;
                return `${isQuantized} ${isQuantized ? values.toHashString() : floatArrayToHashString(values)}`;
              }

            }, _temp3$3), (_descriptor6$6 = _applyDecoratedDescriptor(_class8$3.prototype, "_values", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor7$4 = _applyDecoratedDescriptor(_class8$3.prototype, "_isQuantized", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class8$3)) || _class7$4);
            let ExoticVec3TrackValues = (_dec4$a = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticVec3TrackValues`), _dec4$a(_class10$3 = class ExoticVec3TrackValues extends ExoticVectorLikeTrackValues {
              static imitate(values, model) {
                const trackValues = new ExoticVec3TrackValues(values);

                if (model._isQuantized) {
                  trackValues.quantize(model._values.quantizationType);
                }

                return trackValues;
              }

              get(index, resultValue) {
                const {
                  _values: values,
                  _isQuantized: isQuantized
                } = this;

                if (isQuantized) {
                  loadVec3FromQuantized(values, index, resultValue);
                } else {
                  Vec3.fromArray(resultValue, values, index * 3);
                }
              }

              lerp(prevIndex, nextIndex, ratio, prevValue, nextValue, resultValue) {
                const {
                  _values: values,
                  _isQuantized: isQuantized
                } = this;

                if (isQuantized) {
                  loadVec3FromQuantized(values, prevIndex, prevValue);
                  loadVec3FromQuantized(values, nextIndex, nextValue);
                } else {
                  Vec3.fromArray(prevValue, values, prevIndex * 3);
                  Vec3.fromArray(nextValue, values, nextIndex * 3);
                }

                Vec3.lerp(resultValue, prevValue, nextValue, ratio);
              }

            }) || _class10$3);
            let ExoticQuatTrackValues = (_dec5$7 = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticQuatTrackValues`), _dec5$7(_class11$3 = class ExoticQuatTrackValues extends ExoticVectorLikeTrackValues {
              static imitate(values, model) {
                const trackValues = new ExoticQuatTrackValues(values);

                if (model._isQuantized) {
                  trackValues.quantize(model._values.quantizationType);
                }

                return trackValues;
              }

              get(index, resultValue) {
                const {
                  _values: values,
                  _isQuantized: isQuantized
                } = this;

                if (isQuantized) {
                  loadQuatFromQuantized(values, index, resultValue);
                } else {
                  Quat.fromArray(resultValue, values, index * 4);
                }
              }

              lerp(prevIndex, nextIndex, ratio, prevValue, nextValue, resultValue) {
                const {
                  _values: values,
                  _isQuantized: isQuantized
                } = this;

                if (isQuantized) {
                  loadQuatFromQuantized(values, prevIndex, prevValue);
                  loadQuatFromQuantized(values, nextIndex, nextValue);
                } else {
                  Quat.fromArray(prevValue, values, prevIndex * 4);
                  Quat.fromArray(nextValue, values, nextIndex * 4);
                }

                Quat.slerp(resultValue, prevValue, nextValue, ratio);
              }

            }) || _class11$3);
            let ExoticTrack = (_dec6$5 = ccclass(`${CLASS_NAME_PREFIX_ANIM}ExoticTrack`), _dec6$5(_class12 = (_class13$3 = (_temp4$3 = class ExoticTrack {
              constructor(times, values) {
                _initializerDefineProperty(this, "times", _descriptor8$4, this);

                _initializerDefineProperty(this, "values", _descriptor9$3, this);

                this.times = times;
                this.values = values;
              }

              toHashString() {
                const {
                  times,
                  values
                } = this;
                return `times: ${floatArrayToHashString(times)}; values: ${values.toHashString()}`;
              }

            }, _temp4$3), (_descriptor8$4 = _applyDecoratedDescriptor(_class13$3.prototype, "times", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor9$3 = _applyDecoratedDescriptor(_class13$3.prototype, "values", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class13$3)) || _class12);

            class ExoticTrsAnimationEvaluator {
              constructor(nodeAnimations, binder) {
                this._nodeEvaluations = void 0;
                this._nodeEvaluations = nodeAnimations.map(nodeAnimation => nodeAnimation.createEvaluator(binder));
              }

              evaluate(time) {
                this._nodeEvaluations.forEach(nodeEvaluator => {
                  nodeEvaluator.evaluate(time);
                });
              }

            }

            class ExoticNodeAnimationEvaluator {
              constructor(path, position, rotation, scale, binder) {
                this._position = null;
                this._rotation = null;
                this._scale = null;

                if (position) {
                  this._position = createExoticTrackEvaluationRecord(position.times, position.values, Vec3, path, 'position', binder);
                }

                if (rotation) {
                  this._rotation = createExoticTrackEvaluationRecord(rotation.times, rotation.values, Quat, path, 'rotation', binder);
                }

                if (scale) {
                  this._scale = createExoticTrackEvaluationRecord(scale.times, scale.values, Vec3, path, 'scale', binder);
                }
              }

              evaluate(time) {
                if (this._position) {
                  const value = this._position.evaluator.evaluate(time);

                  this._position.runtimeBinding.setValue(value);
                }

                if (this._rotation) {
                  const value = this._rotation.evaluator.evaluate(time);

                  this._rotation.runtimeBinding.setValue(value);
                }

                if (this._scale) {
                  const value = this._scale.evaluator.evaluate(time);

                  this._scale.runtimeBinding.setValue(value);
                }
              }

            }

            class ExoticTrackEvaluator {
              constructor(times, values, ValueConstructor) {
                this._times = void 0;
                this._inputSampleResultCache = {
                  just: false,
                  index: -1,
                  nextIndex: -1,
                  ratio: 0.0
                };
                this._values = void 0;
                this._prevValue = void 0;
                this._nextValue = void 0;
                this._resultValue = void 0;
                this._times = times;
                this._values = values;
                this._prevValue = new ValueConstructor();
                this._nextValue = new ValueConstructor();
                this._resultValue = new ValueConstructor();
              }

              evaluate(time) {
                const {
                  _times: times,
                  _values: values,
                  _resultValue: resultValue
                } = this;
                const nFrames = times.length;

                if (nFrames === 0) {
                  return resultValue;
                }

                const inputSampleResult = sampleInput(times, time, this._inputSampleResultCache);

                if (inputSampleResult.just) {
                  values.get(inputSampleResult.index, resultValue);
                } else {
                  values.lerp(inputSampleResult.index, inputSampleResult.nextIndex, inputSampleResult.ratio, this._prevValue, this._nextValue, resultValue);
                }

                return resultValue;
              }

            }

            function sampleInput(values, time, result) {
              const nFrames = values.length;
              assertIsTrue(nFrames !== 0);
              const firstTime = values[0];
              const lastTime = values[nFrames - 1];

              if (time < firstTime) {
                result.just = true;
                result.index = 0;
              } else if (time > lastTime) {
                result.just = true;
                result.index = nFrames - 1;
              } else {
                const index = binarySearchEpsilon(values, time);

                if (index >= 0) {
                  result.just = true;
                  result.index = index;
                } else {
                  const nextIndex = ~index;
                  assertIsTrue(nextIndex !== 0 && nextIndex !== nFrames && nFrames > 1);
                  const prevIndex = nextIndex - 1;
                  const prevTime = values[prevIndex];
                  const nextTime = values[nextIndex];
                  const ratio = (time - values[prevIndex]) / (nextTime - prevTime);
                  result.just = false;
                  result.index = prevIndex;
                  result.nextIndex = nextIndex;
                  result.ratio = ratio;
                }
              }

              return result;
            }

            const QUANTIZATION_TYPE_TO_ARRAY_VIEW_CONSTRUCTOR_MAP = {
              uint8: Uint8Array,
              uint16: Uint16Array
            };
            var FloatPrecision;

            (function (FloatPrecision) {
              FloatPrecision[FloatPrecision["FLOAT_32"] = 0] = "FLOAT_32";
              FloatPrecision[FloatPrecision["FLOAT_64"] = 1] = "FLOAT_64";
            })(FloatPrecision || (FloatPrecision = {}));

            function getFloatArrayPrecision(array) {
              switch (array.BYTES_PER_ELEMENT) {
                default:
                  assertIsTrue(false);

                case 4:
                  return FloatPrecision.FLOAT_32;

                case 8:
                  return FloatPrecision.FLOAT_64;
              }
            }

            let QuantizedFloatArray = (_dec7$3 = ccclass(`${CLASS_NAME_PREFIX_ANIM}QuantizedFloatArray`), _dec7$3(_class15 = (_class16$2 = (_temp5$3 = class QuantizedFloatArray {
              get quantizationType() {
                switch (this.values.BYTES_PER_ELEMENT) {
                  default:
                  case 1:
                    return 'uint8';

                  case 2:
                    return 'uint16';
                }
              }

              constructor(originalPrecision, values, extent, min = 0.0) {
                _initializerDefineProperty(this, "originalPrecision", _descriptor10$3, this);

                _initializerDefineProperty(this, "min", _descriptor11$3, this);

                _initializerDefineProperty(this, "extent", _descriptor12$3, this);

                _initializerDefineProperty(this, "values", _descriptor13$3, this);

                this.originalPrecision = originalPrecision;
                this.values = values;
                this.extent = extent;
                this.min = min;
              }

              toHashString() {
                const {
                  originalPrecision,
                  min,
                  extent,
                  values
                } = this;
                return `${originalPrecision} ${floatToHashString(min)} ${floatToHashString(extent)} ${values.join(' ')}`;
              }

            }, _temp5$3), (_descriptor10$3 = _applyDecoratedDescriptor(_class16$2.prototype, "originalPrecision", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor11$3 = _applyDecoratedDescriptor(_class16$2.prototype, "min", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor12$3 = _applyDecoratedDescriptor(_class16$2.prototype, "extent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _descriptor13$3 = _applyDecoratedDescriptor(_class16$2.prototype, "values", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            })), _class16$2)) || _class15);

            function quantize(values, type) {
              const TypedArrayViewConstructor = QUANTIZATION_TYPE_TO_ARRAY_VIEW_CONSTRUCTOR_MAP[type];
              const MAX = 1 << TypedArrayViewConstructor.BYTES_PER_ELEMENT;
              let min = Number.POSITIVE_INFINITY;
              let max = Number.NEGATIVE_INFINITY;
              values.forEach(value => {
                min = Math.min(value, min);
                max = Math.max(value, max);
              });
              const extent = max - min;
              const normalized = TypedArrayViewConstructor.from(values, value => (value - min) / extent * MAX);
              return new QuantizedFloatArray(getFloatArrayPrecision(values), normalized, extent, min);
            }

            function indexQuantized(quantized, index) {
              const quantizedValue = quantized.values[index];
              const MAX_VALUE = 1 << quantized.values.BYTES_PER_ELEMENT;
              return quantizedValue / MAX_VALUE * quantized.extent + quantized.min;
            }

            function createExoticTrackEvaluationRecord(times, values, ValueConstructor, path, property, binder) {
              const trackBinding = new TrackBinding();
              trackBinding.path = new TrackPath().toHierarchy(path).toProperty(property);
              const runtimeBinding = binder(trackBinding);

              if (!runtimeBinding) {
                return null;
              }

              const evaluator = new ExoticTrackEvaluator(times, values, ValueConstructor);
              return {
                runtimeBinding,
                evaluator
              };
            }

            function loadVec3FromQuantized(values, index, out) {
              Vec3.set(out, indexQuantized(values, 3 * index + 0), indexQuantized(values, 3 * index + 1), indexQuantized(values, 3 * index + 2));
            }

            function loadQuatFromQuantized(values, index, out) {
              Quat.set(out, indexQuantized(values, 4 * index + 0), indexQuantized(values, 4 * index + 1), indexQuantized(values, 4 * index + 2), indexQuantized(values, 4 * index + 3));
            }

            var _dec$N, _class$N, _class2$F, _descriptor$C, _descriptor2$s, _descriptor3$j, _descriptor4$f, _descriptor5$c, _descriptor6$7, _descriptor7$5, _descriptor8$5, _descriptor9$4, _class3$c, _temp$H;
            const searchForRootBonePathSymbol = Symbol('SearchForRootBonePath');
            const exoticAnimationTag = Symbol('ExoticAnimation');
            let AnimationClip = exports('gq', (_dec$N = ccclass('cc.AnimationClip'), _dec$N(_class$N = (_class2$F = (_temp$H = _class3$c = class AnimationClip extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "sample", _descriptor$C, this);

                _initializerDefineProperty(this, "speed", _descriptor2$s, this);

                _initializerDefineProperty(this, "wrapMode", _descriptor3$j, this);

                _initializerDefineProperty(this, "enableTrsBlending", _descriptor4$f, this);

                _initializerDefineProperty(this, "_duration", _descriptor5$c, this);

                _initializerDefineProperty(this, "_hash", _descriptor6$7, this);

                this.frameRate = 0;

                _initializerDefineProperty(this, "_tracks", _descriptor7$5, this);

                _initializerDefineProperty(this, "_exoticAnimation", _descriptor8$5, this);

                this._legacyData = undefined;
                this._legacyDataDirty = false;

                _initializerDefineProperty(this, "_events", _descriptor9$4, this);

                this._runtimeEvents = {
                  ratios: [],
                  eventGroups: []
                };
              }

              static createWithSpriteFrames(spriteFrames, sample) {
                const clip = new AnimationClip();
                clip.sample = sample || clip.sample;
                clip.duration = spriteFrames.length / clip.sample;
                const step = 1 / clip.sample;
                const track = new ObjectTrack();
                track.path = new TrackPath().toComponent('cc.Sprite').toProperty('spriteFrame');
                const curve = track.channels()[0].curve;
                curve.assignSorted(spriteFrames.map((spriteFrame, index) => [step * index, spriteFrame]));
                clip.addTrack(track);
                return clip;
              }

              get duration() {
                return this._duration;
              }

              set duration(value) {
                this._duration = value;
              }

              get tracksCount() {
                return this._tracks.length;
              }

              get tracks() {
                return this._tracks;
              }

              get hash() {
                var _this$_exoticAnimatio, _this$_exoticAnimatio2;

                if (this._hash) {
                  return this._hash;
                }

                const hashString = `Exotic:${(_this$_exoticAnimatio = (_this$_exoticAnimatio2 = this._exoticAnimation) === null || _this$_exoticAnimatio2 === void 0 ? void 0 : _this$_exoticAnimatio2.toHashString()) !== null && _this$_exoticAnimatio !== void 0 ? _this$_exoticAnimatio : ''}`;
                return this._hash = murmurhash2_32_gc(hashString, 666);
              }

              get events() {
                return this._events;
              }

              set events(value) {
                this._events = value;
                const ratios = [];
                const eventGroups = [];
                const events = this.events.sort((a, b) => a.frame - b.frame);
                const nEvents = events.length;

                for (let iEvent = 0; iEvent < nEvents; ++iEvent) {
                  const eventData = events[iEvent];
                  const ratio = eventData.frame / this._duration;
                  let i = ratios.findIndex(r => r === ratio);

                  if (i < 0) {
                    i = ratios.length;
                    ratios.push(ratio);
                    eventGroups.push({
                      events: []
                    });
                  }

                  eventGroups[i].events.push({
                    functionName: eventData.func,
                    parameters: eventData.params
                  });
                }

                this._runtimeEvents = {
                  ratios,
                  eventGroups
                };
              }

              get [exoticAnimationTag]() {
                return this._exoticAnimation;
              }

              set [exoticAnimationTag](value) {
                this._exoticAnimation = value;
              }

              onLoaded() {
                this.frameRate = this.sample;
                this.events = this._events;
              }

              range() {
                const range = {
                  min: Infinity,
                  max: -Infinity
                };
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];
                  const trackRange = track.range();
                  range.min = Math.min(range.min, trackRange.min);
                  range.max = Math.max(range.max, trackRange.max);
                }

                return range;
              }

              getTrack(index) {
                return this._tracks[index];
              }

              addTrack(track) {
                const index = this._tracks.length;

                this._tracks.push(track);

                return index;
              }

              removeTrack(index) {
                this._tracks.splice(index, 1);
              }

              clearTracks() {
                this._tracks.length = 0;
              }

              createEventEvaluator(targetNode) {
                return new EventEvaluator(targetNode, this._runtimeEvents.ratios, this._runtimeEvents.eventGroups, this.wrapMode);
              }

              createEvaluator(context) {
                const {
                  target
                } = context;

                const binder = binding => {
                  const trackTarget = binding.createRuntimeBinding(target, this.enableTrsBlending ? context.pose : undefined, false);
                  return trackTarget !== null && trackTarget !== void 0 ? trackTarget : undefined;
                };

                return this._createEvalWithBinder(target, binder, context.rootMotion);
              }

              destroy() {
                var _legacyCC$director$ro;

                if ((_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.dataPoolManager) {
                  legacyCC.director.root.dataPoolManager.releaseAnimationClip(this);
                }

                SkelAnimDataHub.destroy(this);
                return super.destroy();
              }

              [BAKE_SKELETON_CURVE_SYMBOL](start, samples, frames) {
                const step = 1.0 / samples;

                const animatedJoints = this._collectAnimatedJoints();

                const nAnimatedJoints = animatedJoints.length;
                const jointsBakeInfo = {};

                for (let iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                  const joint = animatedJoints[iAnimatedJoint];
                  jointsBakeInfo[joint] = {
                    transforms: Array.from({
                      length: frames
                    }, () => new Mat4())
                  };
                }

                const skeletonFrames = animatedJoints.reduce((result, joint) => {
                  result[joint] = new BoneGlobalTransform();
                  return result;
                }, {});

                for (const joint in skeletonFrames) {
                  const skeletonFrame = skeletonFrames[joint];
                  const parentJoint = joint.lastIndexOf('/');

                  if (parentJoint >= 0) {
                    const parentJointName = joint.substring(0, parentJoint);
                    const parentJointFrame = skeletonFrames[parentJointName];

                    if (parentJointFrame) {
                      skeletonFrame.parent = parentJointFrame;
                    }
                  }
                }

                const binder = binding => {
                  const trsPath = binding.parseTrsPath();

                  if (!trsPath) {
                    return undefined;
                  }

                  const jointFrame = skeletonFrames[trsPath.node];

                  if (!jointFrame) {
                    return undefined;
                  }

                  return createBoneTransformBinding(jointFrame, trsPath.property);
                };

                const evaluator = this._createEvalWithBinder(undefined, binder, undefined);

                for (let iFrame = 0; iFrame < frames; ++iFrame) {
                  const time = start + step * iFrame;
                  evaluator.evaluate(time);

                  for (let iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                    const joint = animatedJoints[iAnimatedJoint];
                    Mat4.copy(jointsBakeInfo[joint].transforms[iFrame], skeletonFrames[joint].globalTransform);
                  }

                  for (let iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                    const joint = animatedJoints[iAnimatedJoint];
                    skeletonFrames[joint].invalidate();
                  }
                }

                return {
                  samples,
                  frames,
                  joints: jointsBakeInfo
                };
              }

              upgradeUntypedTracks(refine) {
                const newTracks = [];
                const removals = [];
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];

                  if (!(track instanceof UntypedTrack)) {
                    continue;
                  }

                  const newTrack = track.upgrade(refine);

                  if (newTrack) {
                    newTracks.push(newTrack);
                    removals.push(track);
                  }
                }

                const nRemovalTracks = removals.length;

                for (let iRemovalTrack = 0; iRemovalTrack < nRemovalTracks; ++iRemovalTrack) {
                  array.remove(tracks, removals[iRemovalTrack]);
                }

                tracks.push(...newTracks);
              }

              [searchForRootBonePathSymbol]() {
                return this._searchForRootBonePath();
              }

              get keys() {
                return this._getLegacyData().keys;
              }

              set keys(value) {
                this._legacyDataDirty = true;
                this._getLegacyData().keys = value;
              }

              get curves() {
                this._legacyDataDirty = true;
                return this._getLegacyData().curves;
              }

              set curves(value) {
                this._getLegacyData().curves = value;
              }

              get commonTargets() {
                return this._getLegacyData().commonTargets;
              }

              set commonTargets(value) {
                this._legacyDataDirty = true;
                this._getLegacyData().commonTargets = value;
              }

              get data() {
                return this._getLegacyData().data;
              }

              getPropertyCurves() {
                return this._getLegacyData().getPropertyCurves();
              }

              get eventGroups() {
                return this._runtimeEvents.eventGroups;
              }

              updateEventDatas() {
                this.events = this._events;
              }

              hasEvents() {
                return this.events.length !== 0;
              }

              syncLegacyData() {
                if (this._legacyData) {
                  this._fromLegacy(this._legacyData);

                  this._legacyData = undefined;
                }
              }

              _createEvalWithBinder(target, binder, rootMotionOptions) {
                if (this._legacyDataDirty) {
                  this._legacyDataDirty = false;
                  this.syncLegacyData();
                }

                const rootMotionTrackExcludes = [];
                let rootMotionEvaluation;

                if (rootMotionOptions) {
                  rootMotionEvaluation = this._createRootMotionEvaluation(target, rootMotionOptions, rootMotionTrackExcludes);
                }

                const trackEvalStatues = [];
                let exoticAnimationEvaluator;
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];

                  if (rootMotionTrackExcludes.includes(track)) {
                    continue;
                  }

                  if (Array.from(track.channels()).every(({
                    curve
                  }) => curve.keyFramesCount === 0)) {
                    continue;
                  }

                  const trackTarget = binder(track[trackBindingTag]);

                  if (!trackTarget) {
                    continue;
                  }

                  const trackEval = track[createEvalSymbol](trackTarget);
                  trackEvalStatues.push({
                    binding: trackTarget,
                    trackEval
                  });
                }

                if (this._exoticAnimation) {
                  exoticAnimationEvaluator = this._exoticAnimation.createEvaluator(binder);
                }

                const evaluation = new AnimationClipEvaluation(trackEvalStatues, exoticAnimationEvaluator, rootMotionEvaluation);
                return evaluation;
              }

              _createRootMotionEvaluation(target, rootMotionOptions, rootMotionTrackExcludes) {
                if (!(target instanceof Node$1)) {
                  errorID(3920);
                  return undefined;
                }

                const rootBonePath = this._searchForRootBonePath();

                if (!rootBonePath) {
                  warnID(3923);
                  return undefined;
                }

                const rootBone = target.getChildByPath(rootBonePath);

                if (!rootBone) {
                  warnID(3924);
                  return undefined;
                }

                const boneTransform = new BoneTransform();
                const rootMotionsTrackEvaluations = [];
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];
                  const {
                    [trackBindingTag]: trackBinding
                  } = track;
                  const trsPath = trackBinding.parseTrsPath();

                  if (!trsPath) {
                    continue;
                  }

                  const bonePath = trsPath.node;

                  if (bonePath !== rootBonePath) {
                    continue;
                  }

                  rootMotionTrackExcludes.push(track);
                  const property = trsPath.property;
                  const trackTarget = createBoneTransformBinding(boneTransform, property);

                  if (!trackTarget) {
                    continue;
                  }

                  const trackEval = track[createEvalSymbol](trackTarget);
                  rootMotionsTrackEvaluations.push({
                    binding: trackTarget,
                    trackEval
                  });
                }

                const rootMotionEvaluation = new RootMotionEvaluation(rootBone, this._duration, boneTransform, rootMotionsTrackEvaluations);
                return rootMotionEvaluation;
              }

              _searchForRootBonePath() {
                const paths = this._tracks.map(track => {
                  const trsPath = track[trackBindingTag].parseTrsPath();

                  if (trsPath) {
                    const nodePath = trsPath.node;
                    return {
                      path: nodePath,
                      rank: nodePath.split('/').length
                    };
                  } else {
                    return {
                      path: '',
                      rank: 0
                    };
                  }
                });

                paths.sort((a, b) => a.rank - b.rank);
                const iNonEmptyPath = paths.findIndex(p => p.rank !== 0);

                if (iNonEmptyPath < 0) {
                  return '';
                }

                const nPaths = paths.length;
                const firstPath = paths[iNonEmptyPath];
                let highestPathsAreSame = true;

                for (let iPath = iNonEmptyPath + 1; iPath < nPaths; ++iPath) {
                  const path = paths[iPath];

                  if (path.rank !== firstPath.rank) {
                    break;
                  }

                  if (path.path !== firstPath.path) {
                    highestPathsAreSame = false;
                    break;
                  }
                }

                return highestPathsAreSame ? firstPath.path : '';
              }

              _getLegacyData() {
                if (!this._legacyData) {
                  this._legacyData = this._toLegacy();
                }

                return this._legacyData;
              }

              _toLegacy() {
                const keys = [];
                const legacyCurves = [];
                const commonTargets = [];
                const legacyClipData = new AnimationClipLegacyData(this._duration);
                legacyClipData.keys = keys;
                legacyClipData.curves = legacyCurves;
                legacyClipData.commonTargets = commonTargets;
                return legacyClipData;
              }

              _fromLegacy(legacyData) {
                const newTracks = legacyData.toTracks();
                const nNewTracks = newTracks.length;

                for (let iNewTrack = 0; iNewTrack < nNewTracks; ++iNewTrack) {
                  this.addTrack(newTracks[iNewTrack]);
                }
              }

              _collectAnimatedJoints() {
                const joints = new Set();
                const {
                  _tracks: tracks
                } = this;
                const nTracks = tracks.length;

                for (let iTrack = 0; iTrack < nTracks; ++iTrack) {
                  const track = tracks[iTrack];
                  const trsPath = track[trackBindingTag].parseTrsPath();

                  if (trsPath) {
                    joints.add(trsPath.node);
                  }
                }

                if (this._exoticAnimation) {
                  const animatedJoints = this._exoticAnimation.collectAnimatedJoints();

                  const nAnimatedJoints = animatedJoints.length;

                  for (let iAnimatedJoint = 0; iAnimatedJoint < nAnimatedJoints; ++iAnimatedJoint) {
                    joints.add(animatedJoints[iAnimatedJoint]);
                  }
                }

                return Array.from(joints);
              }

            }, _class3$c.WrapMode = WrapMode, _temp$H), (_descriptor$C = _applyDecoratedDescriptor(_class2$F.prototype, "sample", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 60;
              }
            }), _descriptor2$s = _applyDecoratedDescriptor(_class2$F.prototype, "speed", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor3$j = _applyDecoratedDescriptor(_class2$F.prototype, "wrapMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return WrapMode.Normal;
              }
            }), _descriptor4$f = _applyDecoratedDescriptor(_class2$F.prototype, "enableTrsBlending", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor5$c = _applyDecoratedDescriptor(_class2$F.prototype, "_duration", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$7 = _applyDecoratedDescriptor(_class2$F.prototype, "_hash", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor7$5 = _applyDecoratedDescriptor(_class2$F.prototype, "_tracks", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor8$5 = _applyDecoratedDescriptor(_class2$F.prototype, "_exoticAnimation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor9$4 = _applyDecoratedDescriptor(_class2$F.prototype, "_events", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$F)) || _class$N));
            legacyCC.AnimationClip = AnimationClip;

            class AnimationClipEvaluation {
              constructor(trackEvalStatuses, exoticAnimationEvaluator, rootMotionEvaluation) {
                this._exoticAnimationEvaluator = void 0;
                this._trackEvalStatues = [];
                this._rootMotionEvaluation = undefined;
                this._trackEvalStatues = trackEvalStatuses;
                this._exoticAnimationEvaluator = exoticAnimationEvaluator;
                this._rootMotionEvaluation = rootMotionEvaluation;
              }

              evaluate(time) {
                const {
                  _trackEvalStatues: trackEvalStatuses,
                  _exoticAnimationEvaluator: exoticAnimationEvaluator
                } = this;
                const nTrackEvalStatuses = trackEvalStatuses.length;

                for (let iTrackEvalStatus = 0; iTrackEvalStatus < nTrackEvalStatuses; ++iTrackEvalStatus) {
                  const {
                    trackEval,
                    binding
                  } = trackEvalStatuses[iTrackEvalStatus];
                  const value = trackEval.evaluate(time, binding);
                  binding.setValue(value);
                }

                if (exoticAnimationEvaluator) {
                  exoticAnimationEvaluator.evaluate(time);
                }
              }

              evaluateRootMotion(time, motionLength) {
                const {
                  _rootMotionEvaluation: rootMotionEvaluation
                } = this;

                if (rootMotionEvaluation) {
                  rootMotionEvaluation.evaluate(time, motionLength);
                }
              }

            }

            class BoneTransform {
              constructor() {
                this.position = new Vec3();
                this.scale = new Vec3(1.0, 1.0, 1.0);
                this.rotation = new Quat();
                this.eulerAngles = new Vec3();
              }

              getTransform(out) {
                Mat4.fromRTS(out, this.rotation, this.position, this.scale);
              }

            }

            class BoneGlobalTransform extends BoneTransform {
              constructor(...args) {
                super(...args);
                this.parent = null;
                this._dirty = true;
                this._transform = new Mat4();
              }

              get globalTransform() {
                const transform = this._transform;

                if (this._dirty) {
                  this._dirty = false;
                  Mat4.fromRTS(transform, this.rotation, this.position, this.scale);

                  if (this.parent) {
                    Mat4.multiply(transform, this.parent.globalTransform, transform);
                  }
                }

                return this._transform;
              }

              invalidate() {
                this._dirty = true;
              }

            }

            const motionTransformCache = new Mat4();

            class RootMotionEvaluation {
              constructor(_rootBone, _duration, _boneTransform, _trackEvalStatuses) {
                this._initialTransformCache = new Mat4();
                this._clipEndTransformCache = new Mat4();
                this._startTransformCache = new Mat4();
                this._endTransformCache = new Mat4();
                this._motionTransformCache = new Mat4();
                this._translationMotionCache = new Vec3();
                this._rotationMotionCache = new Quat();
                this._scaleMotionCache = new Vec3();
                this._rootBone = _rootBone;
                this._duration = _duration;
                this._boneTransform = _boneTransform;
                this._trackEvalStatuses = _trackEvalStatuses;
              }

              evaluate(time, motionLength) {
                const motionTransform = this._calcMotionTransform(time, motionLength, this._motionTransformCache);

                const {
                  _translationMotionCache: translationMotion,
                  _rotationMotionCache: rotationMotion,
                  _scaleMotionCache: scaleMotion,
                  _rootBone: rootBone
                } = this;
                Mat4.toRTS(motionTransform, rotationMotion, translationMotion, scaleMotion);
                Vec3.add(translationMotion, translationMotion, rootBone.position);
                rootBone.setPosition(translationMotion);
                Quat.multiply(rotationMotion, rotationMotion, rootBone.rotation);
                rootBone.setRotation(rotationMotion);
                Vec3.multiply(scaleMotion, scaleMotion, rootBone.scale);
                rootBone.setScale(scaleMotion);
              }

              _calcMotionTransform(time, motionLength, outTransform) {
                const {
                  _duration: duration
                } = this;
                const remainLength = duration - time;
                assertIsTrue(remainLength >= 0);

                const startTransform = this._evaluateAt(time, this._startTransformCache);

                if (motionLength < remainLength) {
                  const endTransform = this._evaluateAt(time + motionLength, this._endTransformCache);

                  relativeTransform(outTransform, startTransform, endTransform);
                } else {
                  Mat4.identity(outTransform);

                  const accumulateMotionTransform = (from, to) => {
                    relativeTransform(motionTransformCache, from, to);
                    Mat4.multiply(outTransform, outTransform, motionTransformCache);
                  };

                  const diff = motionLength - remainLength;
                  const repeatCount = Math.floor(diff / duration);
                  const lastRemainTime = diff - repeatCount * duration;

                  const clipStartTransform = this._evaluateAt(0, this._initialTransformCache);

                  const clipEndTransform = this._evaluateAt(duration, this._clipEndTransformCache);

                  const endTransform = this._evaluateAt(lastRemainTime, this._endTransformCache);

                  accumulateMotionTransform(startTransform, clipEndTransform);
                  relativeTransform(motionTransformCache, clipStartTransform, clipEndTransform);

                  for (let i = 0; i < repeatCount; ++i) {
                    Mat4.multiply(outTransform, outTransform, motionTransformCache);
                  }

                  accumulateMotionTransform(clipStartTransform, endTransform);
                }

                return outTransform;
              }

              _evaluateAt(time, outTransform) {
                const {
                  _trackEvalStatuses: trackEvalStatuses
                } = this;
                const nTrackEvalStatuses = trackEvalStatuses.length;

                for (let iTrackEvalStatus = 0; iTrackEvalStatus < nTrackEvalStatuses; ++iTrackEvalStatus) {
                  const {
                    trackEval,
                    binding
                  } = trackEvalStatuses[iTrackEvalStatus];
                  const value = trackEval.evaluate(time, binding);
                  binding.setValue(value);
                }

                this._boneTransform.getTransform(outTransform);

                return outTransform;
              }

            }

            function relativeTransform(out, from, to) {
              Mat4.invert(out, from);
              Mat4.multiply(out, to, out);
            }

            function createBoneTransformBinding(boneTransform, property) {
              switch (property) {
                default:
                  return undefined;

                case 'position':
                  return {
                    setValue(value) {
                      Vec3.copy(boneTransform.position, value);
                    }

                  };

                case 'rotation':
                  return {
                    setValue(value) {
                      Quat.copy(boneTransform.rotation, value);
                    }

                  };

                case 'scale':
                  return {
                    setValue(value) {
                      Vec3.copy(boneTransform.scale, value);
                    }

                  };

                case 'eulerAngles':
                  return {
                    setValue(value) {
                      Vec3.copy(boneTransform.eulerAngles, value);
                    }

                  };
              }
            }

            const InvalidIndex = -1;

            class EventEvaluator {
              constructor(_targetNode, _ratios, _eventGroups, _wrapMode) {
                this._lastFrameIndex = -1;
                this._lastIterations = 0.0;
                this._lastDirection = 0;
                this._ignoreIndex = InvalidIndex;
                this._sampled = false;
                this._targetNode = _targetNode;
                this._ratios = _ratios;
                this._eventGroups = _eventGroups;
                this._wrapMode = _wrapMode;
              }

              setWrapMode(wrapMode) {
                this._wrapMode = wrapMode;
              }

              ignore(ratio, direction) {
                this._ignoreIndex = InvalidIndex;
                this._sampled = false;
                let frameIndex = getEventGroupIndexAtRatio(ratio, this._ratios);

                if (frameIndex < 0) {
                  frameIndex = ~frameIndex - 1;

                  if (direction < 0) {
                    frameIndex += 1;
                  }

                  this._ignoreIndex = frameIndex;
                }
              }

              sample(ratio, direction, iterations) {
                const length = this._eventGroups.length;
                let eventIndex = getEventGroupIndexAtRatio(ratio, this._ratios);

                if (eventIndex < 0) {
                  eventIndex = ~eventIndex - 1;

                  if (direction < 0) {
                    eventIndex += 1;
                  }
                }

                if (this._ignoreIndex !== eventIndex) {
                  this._ignoreIndex = InvalidIndex;
                }

                if (!this._sampled) {
                  this._sampled = true;

                  this._doFire(eventIndex, false);

                  this._lastFrameIndex = eventIndex;
                  this._lastIterations = iterations;
                  this._lastDirection = direction;
                  return;
                }

                const wrapMode = this._wrapMode;
                const currentIterations = wrapIterations(iterations);
                let lastIterations = wrapIterations(this._lastIterations);
                let lastIndex = this._lastFrameIndex;
                const lastDirection = this._lastDirection;
                const iterationsChanged = lastIterations !== -1 && currentIterations !== lastIterations;

                if (lastIndex === eventIndex && iterationsChanged && length === 1) {
                  this._doFire(0, false);
                } else if (lastIndex !== eventIndex || iterationsChanged) {
                  direction = lastDirection;

                  do {
                    if (lastIndex !== eventIndex) {
                      if (direction === -1 && lastIndex === 0 && eventIndex > 0) {
                        if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                          direction *= -1;
                        } else {
                          lastIndex = length;
                        }

                        lastIterations++;
                      } else if (direction === 1 && lastIndex === length - 1 && eventIndex < length - 1) {
                        if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                          direction *= -1;
                        } else {
                          lastIndex = -1;
                        }

                        lastIterations++;
                      }

                      if (lastIndex === eventIndex) {
                        break;
                      }

                      if (lastIterations > currentIterations) {
                        break;
                      }
                    }

                    lastIndex += direction;

                    this._doFire(lastIndex, true);
                  } while (lastIndex !== eventIndex && lastIndex > -1 && lastIndex < length);
                }

                this._lastFrameIndex = eventIndex;
                this._lastIterations = iterations;
                this._lastDirection = direction;
              }

              _doFire(eventIndex, delay) {
                if (delay) {
                  legacyCC.director.getAnimationManager().pushDelayEvent(this._checkAndFire, this, [eventIndex]);
                } else {
                  this._checkAndFire(eventIndex);
                }
              }

              _checkAndFire(eventIndex) {
                if (!this._targetNode || !this._targetNode.isValid) {
                  return;
                }

                const {
                  _eventGroups: eventGroups
                } = this;

                if (eventIndex < 0 || eventIndex >= eventGroups.length || this._ignoreIndex === eventIndex) {
                  return;
                }

                const eventGroup = eventGroups[eventIndex];
                const components = this._targetNode.components;
                const nEvents = eventGroup.events.length;

                for (let iEvent = 0; iEvent < nEvents; ++iEvent) {
                  const event = eventGroup.events[iEvent];
                  const {
                    functionName
                  } = event;
                  const nComponents = components.length;

                  for (let iComponent = 0; iComponent < nComponents; ++iComponent) {
                    const component = components[iComponent];
                    const fx = component[functionName];

                    if (typeof fx === 'function') {
                      fx.apply(component, event.parameters);
                    }
                  }
                }
              }

            }

            function wrapIterations(iterations) {
              if (iterations - (iterations | 0) === 0) {
                iterations -= 1;
              }

              return iterations | 0;
            }

            function getEventGroupIndexAtRatio(ratio, ratios) {
              const result = binarySearchEpsilon(ratios, ratio);
              return result;
            }

            class Playable {
              constructor() {
                this._isPlaying = false;
                this._isPaused = false;
                this._stepOnce = false;
              }

              get isPlaying() {
                return this._isPlaying;
              }

              get isPaused() {
                return this._isPaused;
              }

              get isMotionless() {
                return !this.isPlaying || this.isPaused;
              }

              play() {
                if (this._isPlaying) {
                  if (this._isPaused) {
                    this._isPaused = false;
                    this.onResume();
                  } else {
                    this.onError(getError(3912));
                  }
                } else {
                  this._isPlaying = true;
                  this.onPlay();
                }
              }

              stop() {
                if (this._isPlaying) {
                  this._isPlaying = false;
                  this.onStop();
                  this._isPaused = false;
                }
              }

              pause() {
                if (this._isPlaying && !this._isPaused) {
                  this._isPaused = true;
                  this.onPause();
                }
              }

              resume() {
                if (this._isPlaying && this._isPaused) {
                  this._isPaused = false;
                  this.onResume();
                }
              }

              step() {
                this.pause();
                this._stepOnce = true;

                if (!this._isPlaying) {
                  this.play();
                }
              }

              update(deltaTime) {}

              onPlay() {}

              onPause() {}

              onResume() {}

              onStop() {}

              onError(message) {}

            }

            class PoseOutput {
              constructor(pose) {
                this.weight = 0.0;
                this._pose = void 0;
                this._blendStateWriters = [];
                this._pose = pose;
              }

              destroy() {
                for (let iBlendStateWriter = 0; iBlendStateWriter < this._blendStateWriters.length; ++iBlendStateWriter) {
                  this._pose.destroyWriter(this._blendStateWriters[iBlendStateWriter]);
                }

                this._blendStateWriters.length = 0;
              }

              createPoseWriter(node, property, constants) {
                const writer = this._pose.createWriter(node, property, this, constants);

                this._blendStateWriters.push(writer);

                return writer;
              }

            }

            let EventType;

            (function (EventType) {
              EventType["PLAY"] = "play";
              EventType["STOP"] = "stop";
              EventType["PAUSE"] = "pause";
              EventType["RESUME"] = "resume";
              EventType["LASTFRAME"] = "lastframe";
              EventType["FINISHED"] = "finished";
            })(EventType || (EventType = {}));

            ccenum(EventType);
            class AnimationState extends Playable {
              get clip() {
                return this._clip;
              }

              get name() {
                return this._name;
              }

              get length() {
                return this.duration;
              }

              get wrapMode() {
                return this._wrapMode;
              }

              set wrapMode(value) {
                var _this$_clipEventEval;

                this._wrapMode = value;
                this.time = 0;

                if (value & WrapModeMask.Loop) {
                  this.repeatCount = Infinity;
                } else {
                  this.repeatCount = 1;
                }

                (_this$_clipEventEval = this._clipEventEval) === null || _this$_clipEventEval === void 0 ? void 0 : _this$_clipEventEval.setWrapMode(value);
              }

              get repeatCount() {
                return this._repeatCount;
              }

              set repeatCount(value) {
                this._repeatCount = value;
                const shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
                const reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;

                if (value === Infinity && !shouldWrap && !reverse) {
                  this._useSimpleProcess = true;
                } else {
                  this._useSimpleProcess = false;
                }
              }

              get delay() {
                return this._delay;
              }

              set delay(value) {
                this._delayTime = this._delay = value;
              }

              get playbackRange() {
                return this._playbackRange;
              }

              set playbackRange(value) {
                assertIsTrue(value.max > value.min);
                this._playbackRange.min = Math.max(value.min, 0);
                this._playbackRange.max = Math.min(value.max, this.duration);
                this._playbackDuration = this._playbackRange.max - this._playbackRange.min;
                this.setTime(0.0);
              }

              get current() {
                return this.getWrappedInfo(this.time).time;
              }

              get ratio() {
                return this.current / this.duration;
              }

              get weight() {
                return this._weight;
              }

              set weight(value) {
                this._weight = value;

                if (this._poseOutput) {
                  this._poseOutput.weight = value;
                }
              }

              constructor(clip, name = '') {
                super();
                this.duration = 1.0;
                this.speed = 1.0;
                this.time = 0.0;
                this.frameRate = 0;
                this._targetNode = null;
                this._curveLoaded = false;
                this._clip = void 0;
                this._useSimpleProcess = false;
                this._target = null;
                this._wrapMode = WrapMode.Normal;
                this._repeatCount = 1;
                this._delay = 0.0;
                this._delayTime = 0.0;
                this._currentFramePlayed = false;
                this._name = void 0;
                this._lastIterations = NaN;
                this._lastWrapInfo = null;
                this._wrappedInfo = new WrappedInfo();
                this._allowLastFrame = false;
                this._blendStateWriterHost = {
                  weight: 0.0
                };
                this._playbackDuration = 0.0;
                this._invDuration = 1.0;
                this._poseOutput = null;
                this._weight = 0.0;
                this._clipEval = void 0;
                this._clipEventEval = void 0;
                this._doNotCreateEval = false;
                this._clip = clip;
                this._name = name || clip && clip.name;
                this._playbackRange = {
                  min: 0.0,
                  max: clip.duration
                };
                this._playbackDuration = clip.duration;

                if (!clip.duration) {
                  debug(`Clip ${clip.name} has zero duration.`);
                }
              }

              get curveLoaded() {
                return this._curveLoaded;
              }

              initialize(root, blendStateBuffer, mask) {
                if (this._curveLoaded) {
                  return;
                }

                this._curveLoaded = true;

                if (this._poseOutput) {
                  this._poseOutput.destroy();

                  this._poseOutput = null;
                }

                if (this._clipEval) {
                  this._clipEval = undefined;
                }

                this._targetNode = root;
                const clip = this._clip;
                this.duration = clip.duration;
                this._invDuration = 1.0 / this.duration;
                this.speed = clip.speed;
                this.wrapMode = clip.wrapMode;
                this.frameRate = clip.sample;
                this._playbackRange.min = 0.0;
                this._playbackRange.max = clip.duration;
                this._playbackDuration = clip.duration;

                if ((this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop) {
                  this.repeatCount = Infinity;
                } else {
                  this.repeatCount = 1;
                }

                if (!this._doNotCreateEval) {
                  var _ref, _legacyCC$director$ge, _this$_poseOutput;

                  const pose = (_ref = blendStateBuffer !== null && blendStateBuffer !== void 0 ? blendStateBuffer : (_legacyCC$director$ge = legacyCC.director.getAnimationManager()) === null || _legacyCC$director$ge === void 0 ? void 0 : _legacyCC$director$ge.blendState) !== null && _ref !== void 0 ? _ref : null;

                  if (pose) {
                    this._poseOutput = new PoseOutput(pose);
                  }

                  this._clipEval = clip.createEvaluator({
                    target: root,
                    pose: (_this$_poseOutput = this._poseOutput) !== null && _this$_poseOutput !== void 0 ? _this$_poseOutput : undefined
                  });
                }

                {
                  this._clipEventEval = clip.createEventEvaluator(this._targetNode);
                }
              }

              destroy() {
                if (!this.isMotionless) {
                  legacyCC.director.getAnimationManager().removeAnimation(this);
                }

                if (this._poseOutput) {
                  this._poseOutput.destroy();

                  this._poseOutput = null;
                }

                this._clipEval = undefined;
              }

              emit(...args) {
                legacyCC.director.getAnimationManager().pushDelayEvent(this._emit, this, args);
              }

              on(type, callback, target) {
                if (this._target && this._target.isValid) {
                  return this._target.on(type, callback, target);
                } else {
                  return null;
                }
              }

              once(type, callback, target) {
                if (this._target && this._target.isValid) {
                  return this._target.once(type, callback, target);
                } else {
                  return null;
                }
              }

              off(type, callback, target) {
                if (this._target && this._target.isValid) {
                  this._target.off(type, callback, target);
                }
              }

              allowLastFrameEvent(allowed) {
                this._allowLastFrame = allowed;
              }

              _setEventTarget(target) {
                this._target = target;
              }

              setTime(time) {
                this._currentFramePlayed = false;
                this.time = time || 0.0;

                {
                  var _this$_clipEventEval2;

                  const info = this.getWrappedInfo(time, this._wrappedInfo);
                  (_this$_clipEventEval2 = this._clipEventEval) === null || _this$_clipEventEval2 === void 0 ? void 0 : _this$_clipEventEval2.ignore(info.ratio, info.direction);
                }
              }

              update(delta) {
                if (this._delayTime > 0.0) {
                  this._delayTime -= delta;

                  if (this._delayTime > 0.0) {
                    return;
                  }
                }

                if (this._currentFramePlayed) {
                  this.time += delta * this.speed;
                } else {
                  this._currentFramePlayed = true;
                }

                this._process();
              }

              sample() {
                const info = this.getWrappedInfo(this.time, this._wrappedInfo);

                this._sampleCurves(info.time);

                {
                  this._sampleEvents(info);
                }

                return info;
              }

              onPlay() {
                this.setTime(this._getPlaybackStart());
                this._delayTime = this._delay;

                this._onReplayOrResume();

                this.emit(EventType.PLAY, this);
              }

              onStop() {
                if (!this.isPaused) {
                  this._onPauseOrStop();
                }

                this.emit(EventType.STOP, this);
              }

              onResume() {
                this._onReplayOrResume();

                this.emit(EventType.RESUME, this);
              }

              onPause() {
                this._onPauseOrStop();

                this.emit(EventType.PAUSE, this);
              }

              _sampleCurves(time) {
                const {
                  _poseOutput: poseOutput,
                  _clipEval: clipEval
                } = this;

                if (poseOutput) {
                  poseOutput.weight = this.weight;
                }

                if (clipEval) {
                  clipEval.evaluate(time);
                }
              }

              _process() {
                if (this._useSimpleProcess) {
                  this.simpleProcess();
                } else {
                  this.process();
                }
              }

              process() {
                const info = this.sample();

                if (this._allowLastFrame) {
                  let lastInfo;

                  if (!this._lastWrapInfo) {
                    lastInfo = this._lastWrapInfo = new WrappedInfo(info);
                  } else {
                    lastInfo = this._lastWrapInfo;
                  }

                  if (this.repeatCount > 1 && (info.iterations | 0) > (lastInfo.iterations | 0)) {
                    this.emit(EventType.LASTFRAME, this);
                  }

                  lastInfo.set(info);
                }

                if (info.stopped) {
                  this.stop();
                  this.emit(EventType.FINISHED, this);
                }
              }

              simpleProcess() {
                const playbackStart = this._playbackRange.min;
                const playbackDuration = this._playbackDuration;
                let time = this.time % playbackDuration;

                if (time < 0.0) {
                  time += playbackDuration;
                }

                const realTime = playbackStart + time;
                const ratio = realTime * this._invDuration;

                this._sampleCurves(playbackStart + time);

                {
                  this._sampleEvents(this.getWrappedInfo(this.time, this._wrappedInfo));
                }

                if (this._allowLastFrame) {
                  if (Number.isNaN(this._lastIterations)) {
                    this._lastIterations = ratio;
                  }

                  if (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) {
                    this.emit(EventType.LASTFRAME, this);
                  }

                  this._lastIterations = ratio;
                }
              }

              _needReverse(currentIterations) {
                const wrapMode = this.wrapMode;
                let needReverse = false;

                if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                  const isEnd = currentIterations - (currentIterations | 0) === 0;

                  if (isEnd && currentIterations > 0) {
                    currentIterations -= 1;
                  }

                  const isOddIteration = currentIterations & 1;

                  if (isOddIteration) {
                    needReverse = !needReverse;
                  }
                }

                if ((wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse) {
                  needReverse = !needReverse;
                }

                return needReverse;
              }

              getWrappedInfo(time, info) {
                info = info || new WrappedInfo();

                const playbackStart = this._getPlaybackStart();

                const playbackEnd = this._getPlaybackEnd();

                const playbackDuration = playbackEnd - playbackStart;
                let stopped = false;
                const repeatCount = this.repeatCount;
                time -= playbackStart;
                let currentIterations = time > 0 ? time / playbackDuration : -(time / playbackDuration);

                if (currentIterations >= repeatCount) {
                  currentIterations = repeatCount;
                  stopped = true;
                  let tempRatio = repeatCount - (repeatCount | 0);

                  if (tempRatio === 0) {
                    tempRatio = 1;
                  }

                  time = tempRatio * playbackDuration * (time > 0 ? 1 : -1);
                }

                if (time > playbackDuration) {
                  const tempTime = time % playbackDuration;
                  time = tempTime === 0 ? playbackDuration : tempTime;
                } else if (time < 0) {
                  time %= playbackDuration;

                  if (time !== 0) {
                    time += playbackDuration;
                  }
                }

                let needReverse = false;
                const shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;

                if (shouldWrap) {
                  needReverse = this._needReverse(currentIterations);
                }

                let direction = needReverse ? -1 : 1;

                if (this.speed < 0) {
                  direction *= -1;
                }

                if (shouldWrap && needReverse) {
                  time = playbackDuration - time;
                }

                info.time = playbackStart + time;
                info.ratio = info.time / this.duration;
                info.direction = direction;
                info.stopped = stopped;
                info.iterations = currentIterations;
                return info;
              }

              _getPlaybackStart() {
                return this._playbackRange.min;
              }

              _getPlaybackEnd() {
                return this._playbackRange.max;
              }

              _sampleEvents(wrapInfo) {
                var _this$_clipEventEval3;

                (_this$_clipEventEval3 = this._clipEventEval) === null || _this$_clipEventEval3 === void 0 ? void 0 : _this$_clipEventEval3.sample(wrapInfo.ratio, wrapInfo.direction, wrapInfo.iterations);
              }

              _emit(type, state) {
                if (this._target && this._target.isValid) {
                  this._target.emit(type, type, state);
                }
              }

              _onReplayOrResume() {
                legacyCC.director.getAnimationManager().addAnimation(this);
              }

              _onPauseOrStop() {
                legacyCC.director.getAnimationManager().removeAnimation(this);
              }

            } exports('c_', AnimationState);
            legacyCC.AnimationState = AnimationState;

            class CrossFade extends Playable {
              constructor(scheduler) {
                super();
                this._managedStates = [];
                this._fadings = [];
                this._scheduled = false;
                this._scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : legacyCC.director.getAnimationManager();
              }

              update(deltaTime) {
                if (this.isMotionless) {
                  return;
                }

                const managedStates = this._managedStates;
                const fadings = this._fadings;

                if (managedStates.length === 1 && fadings.length === 1) {
                  const state = managedStates[0].state;

                  if (state) {
                    state.weight = 1.0;
                  }
                } else {
                  this._calculateWeights(deltaTime);
                }

                if (managedStates.length === 1 && fadings.length === 1) {
                  this._unscheduleThis();
                }
              }

              crossFade(state, duration) {
                var _target$state;

                if (this._managedStates.length === 0) {
                  duration = 0;
                }

                if (duration === 0) {
                  this.clear();
                }

                let target = this._managedStates.find(weightedState => weightedState.state === state);

                if (!target) {
                  target = {
                    state,
                    reference: 0
                  };

                  if (state) {
                    state.play();
                  }

                  this._managedStates.push(target);
                } else if ((_target$state = target.state) === null || _target$state === void 0 ? void 0 : _target$state.isMotionless) {
                  target.state.play();
                }

                ++target.reference;

                this._fadings.unshift({
                  easeDuration: duration,
                  easeTime: 0,
                  target
                });

                if (!this.isMotionless) {
                  this._scheduleThis();
                }
              }

              clear() {
                for (let iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  const state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.stop();
                  }
                }

                this._managedStates.length = 0;
                this._fadings.length = 0;
              }

              onPlay() {
                super.onPlay();

                this._scheduleThis();
              }

              onPause() {
                super.onPause();

                for (let iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  const state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.pause();
                  }
                }

                this._unscheduleThis();
              }

              onResume() {
                super.onResume();

                for (let iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                  const state = this._managedStates[iManagedState].state;

                  if (state) {
                    state.resume();
                  }
                }

                this._scheduleThis();
              }

              onStop() {
                super.onStop();
                this.clear();
              }

              _calculateWeights(deltaTime) {
                const managedStates = this._managedStates;
                const fadings = this._fadings;

                for (let iManagedState = 0; iManagedState < managedStates.length; ++iManagedState) {
                  const state = managedStates[iManagedState].state;

                  if (state) {
                    state.weight = 0;
                  }
                }

                let absoluteWeight = 1.0;
                let deadFadingBegin = fadings.length;

                for (let iFading = 0; iFading < fadings.length; ++iFading) {
                  const fading = fadings[iFading];
                  fading.easeTime += deltaTime;
                  const relativeWeight = fading.easeDuration === 0 ? 1 : clamp01(fading.easeTime / fading.easeDuration);
                  const weight = relativeWeight * absoluteWeight;
                  absoluteWeight *= 1.0 - relativeWeight;

                  if (fading.target.state) {
                    fading.target.state.weight += weight;
                  }

                  if (fading.easeTime >= fading.easeDuration) {
                    deadFadingBegin = iFading + 1;
                    fading.easeTime = fading.easeDuration;
                    break;
                  }
                }

                if (deadFadingBegin !== fadings.length) {
                  for (let iDeadFading = deadFadingBegin; iDeadFading < fadings.length; ++iDeadFading) {
                    const deadFading = fadings[iDeadFading];
                    --deadFading.target.reference;

                    if (deadFading.target.reference <= 0) {
                      if (deadFading.target.state) {
                        deadFading.target.state.stop();
                      }

                      remove(this._managedStates, deadFading.target);
                    }
                  }

                  fadings.splice(deadFadingBegin);
                }
              }

              _scheduleThis() {
                if (!this._scheduled) {
                  this._scheduler.addCrossFade(this);

                  this._scheduled = true;
                }
              }

              _unscheduleThis() {
                if (this._scheduled) {
                  this._scheduler.removeCrossFade(this);

                  this._scheduled = false;
                }
              }

            }

            var _dec$O, _dec2$m, _dec3$e, _dec4$b, _dec5$8, _dec6$6, _dec7$4, _dec8$3, _dec9$3, _dec10$3, _class$O, _class2$G, _descriptor$D, _descriptor2$t, _descriptor3$k, _class3$d, _temp$I;
            let Animation = exports('c$', (_dec$O = ccclass('cc.Animation'), _dec2$m = help(), _dec3$e = executionOrder(99), _dec4$b = menu(), _dec5$8 = type([AnimationClip]), _dec6$6 = tooltip(), _dec7$4 = type(AnimationClip), _dec8$3 = tooltip(), _dec9$3 = tooltip(), _dec10$3 = type([AnimationClip]), _dec$O(_class$O = _dec2$m(_class$O = _dec3$e(_class$O = executeInEditMode(_class$O = _dec4$b(_class$O = (_class2$G = (_temp$I = _class3$d = class Animation extends Eventify(Component) {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "playOnLoad", _descriptor$D, this);

                this._crossFade = new CrossFade();
                this._nameToState = createMap(true);

                _initializerDefineProperty(this, "_clips", _descriptor2$t, this);

                _initializerDefineProperty(this, "_defaultClip", _descriptor3$k, this);

                this._hasBeenPlayed = false;
              }

              get clips() {
                return this._clips;
              }

              set clips(value) {
                if (this._crossFade) {
                  this._crossFade.clear();
                }

                for (const clip of this._clips) {
                  if (clip) {
                    this._removeStateOfAutomaticClip(clip);
                  }
                }

                for (const clip of value) {
                  if (clip) {
                    this.createState(clip);
                  }
                }

                const newDefaultClip = value.find(clip => equalClips(clip, this._defaultClip));

                if (newDefaultClip) {
                  this._defaultClip = newDefaultClip;
                } else {
                  this._defaultClip = null;
                }

                this._clips = value;
              }

              get defaultClip() {
                return this._defaultClip;
              }

              set defaultClip(value) {
                this._defaultClip = value;

                if (!value) {
                  return;
                }

                const isBoundedDefaultClip = this._clips.findIndex(clip => equalClips(clip, value)) >= 0;

                if (!isBoundedDefaultClip) {
                  this._clips.push(value);

                  this.createState(value);
                }
              }

              onLoad() {
                this.clips = this._clips;

                for (const stateName in this._nameToState) {
                  const state = this._nameToState[stateName];
                  state.initialize(this.node);
                }
              }

              start() {
                if ( this.playOnLoad && !this._hasBeenPlayed && this._defaultClip) {
                  this.crossFade(this._defaultClip.name, 0);
                }
              }

              onEnable() {
                this._crossFade.resume();
              }

              onDisable() {
                this._crossFade.pause();
              }

              onDestroy() {
                this._crossFade.stop();

                for (const name in this._nameToState) {
                  const state = this._nameToState[name];
                  state.destroy();
                }

                this._nameToState = createMap(true);
              }

              play(name) {
                this._hasBeenPlayed = true;

                if (!name) {
                  if (!this._defaultClip) {
                    return;
                  }

                  name = this._defaultClip.name;
                }

                this.crossFade(name, 0);
              }

              crossFade(name, duration = 0.3) {
                this._hasBeenPlayed = true;
                const state = this._nameToState[name];

                if (state) {
                  this.doPlayOrCrossFade(state, duration);
                }
              }

              pause() {
                this._crossFade.pause();
              }

              resume() {
                this._crossFade.resume();
              }

              stop() {
                this._crossFade.stop();
              }

              getAnimationState(name) {
                return this.getState(name);
              }

              getState(name) {
                const state = this._nameToState[name];

                if (state && !state.curveLoaded) {
                  state.initialize(this.node);
                }

                return state || null;
              }

              createState(clip, name) {
                name = name || clip.name;
                this.removeState(name);
                return this._doCreateState(clip, name);
              }

              removeState(name) {
                const state = this._nameToState[name];

                if (state) {
                  state.allowLastFrameEvent(false);
                  state.stop();
                  delete this._nameToState[name];
                }
              }

              addClip(clip, name) {
                if (!contains(this._clips, clip)) {
                  this._clips.push(clip);
                }

                return this.createState(clip, name);
              }

              removeClip(clip, force) {
                let removalState;

                for (const name in this._nameToState) {
                  const state = this._nameToState[name];
                  const stateClip = state.clip;

                  if (stateClip === clip) {
                    removalState = state;
                    break;
                  }
                }

                if (clip === this._defaultClip) {
                  if (force) {
                    this._defaultClip = null;
                  } else {
                    {
                      warnID(3902);
                    }

                    return;
                  }
                }

                if (removalState && removalState.isPlaying) {
                  if (force) {
                    removalState.stop();
                  } else {
                    {
                      warnID(3903);
                    }

                    return;
                  }
                }

                this._clips = this._clips.filter(item => item !== clip);

                if (removalState) {
                  delete this._nameToState[removalState.name];
                }
              }

              on(type, callback, thisArg, once) {
                const ret = super.on(type, callback, thisArg, once);

                if (type === EventType.LASTFRAME) {
                  this._syncAllowLastFrameEvent();
                }

                return ret;
              }

              once(type, callback, thisArg) {
                const ret = super.once(type, callback, thisArg);

                if (type === EventType.LASTFRAME) {
                  this._syncAllowLastFrameEvent();
                }

                return ret;
              }

              off(type, callback, thisArg) {
                super.off(type, callback, thisArg);

                if (type === EventType.LASTFRAME) {
                  this._syncDisallowLastFrameEvent();
                }
              }

              _createState(clip, name) {
                return new AnimationState(clip, name);
              }

              _doCreateState(clip, name) {
                const state = this._createState(clip, name);

                state._setEventTarget(this);

                state.allowLastFrameEvent(this.hasEventListener(EventType.LASTFRAME));

                if (this.node) {
                  state.initialize(this.node);
                }

                this._nameToState[state.name] = state;
                return state;
              }

              doPlayOrCrossFade(state, duration) {
                this._crossFade.play();

                this._crossFade.crossFade(state, duration);
              }

              _removeStateOfAutomaticClip(clip) {
                for (const name in this._nameToState) {
                  const state = this._nameToState[name];

                  if (equalClips(clip, state.clip)) {
                    state.stop();
                    delete this._nameToState[name];
                  }
                }
              }

              _syncAllowLastFrameEvent() {
                if (this.hasEventListener(EventType.LASTFRAME)) {
                  for (const stateName in this._nameToState) {
                    this._nameToState[stateName].allowLastFrameEvent(true);
                  }
                }
              }

              _syncDisallowLastFrameEvent() {
                if (!this.hasEventListener(EventType.LASTFRAME)) {
                  for (const stateName in this._nameToState) {
                    this._nameToState[stateName].allowLastFrameEvent(false);
                  }
                }
              }

            }, _class3$d.EventType = EventType, _temp$I), (_applyDecoratedDescriptor(_class2$G.prototype, "clips", [_dec5$8, _dec6$6], Object.getOwnPropertyDescriptor(_class2$G.prototype, "clips"), _class2$G.prototype), _applyDecoratedDescriptor(_class2$G.prototype, "defaultClip", [_dec7$4, _dec8$3], Object.getOwnPropertyDescriptor(_class2$G.prototype, "defaultClip"), _class2$G.prototype), _descriptor$D = _applyDecoratedDescriptor(_class2$G.prototype, "playOnLoad", [serializable, _dec9$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$t = _applyDecoratedDescriptor(_class2$G.prototype, "_clips", [_dec10$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$k = _applyDecoratedDescriptor(_class2$G.prototype, "_defaultClip", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$G)) || _class$O) || _class$O) || _class$O) || _class$O) || _class$O));

            function equalClips(clip1, clip2) {
              if (clip1 === clip2) {
                return true;
              }

              return !!clip1 && !!clip2 && clip1._uuid === clip2._uuid && clip1._uuid;
            }

            replaceProperty(Animation.prototype, 'Animation', [{
              name: 'getAnimationState',
              newName: 'getState'
            }, {
              name: 'addClip',
              newName: 'createState'
            }, {
              name: 'removeClip',
              newName: 'removeState',

              customFunction(...args) {
                const arg0 = args[0];
                return Animation.prototype.removeState.call(this, arg0.name);
              }

            }]);
            legacyCC.AnimationComponent = Animation;
            js.setClassAlias(Animation, 'cc.AnimationComponent');

            class BlendStateBuffer {
              constructor() {
                this._nodeBlendStates = new Map();
              }

              createWriter(node, property, host, constants) {
                const propertyBlendState = this.ref(node, property);
                return new BlendStateWriterInternal(node, property, propertyBlendState, host, constants);
              }

              destroyWriter(writer) {
                const internal = writer;
                this.deRef(internal.node, internal.property);
              }

              ref(node, property) {
                let nodeBlendState = this._nodeBlendStates.get(node);

                if (!nodeBlendState) {
                  nodeBlendState = new NodeBlendState();

                  this._nodeBlendStates.set(node, nodeBlendState);
                }

                const propertyBlendState = nodeBlendState.refProperty(property);
                return propertyBlendState;
              }

              deRef(node, property) {
                const nodeBlendState = this._nodeBlendStates.get(node);

                if (!nodeBlendState) {
                  return;
                }

                nodeBlendState.deRefProperty(property);

                if (nodeBlendState.empty) {
                  this._nodeBlendStates.delete(node);
                }
              }

              apply() {
                this._nodeBlendStates.forEach((nodeBlendState, node) => {
                  nodeBlendState.apply(node);
                });
              }

            }

            class BlendStateWriterInternal {
              constructor(_node, _property, _propertyBlendState, _host, _constants) {
                this._node = _node;
                this._property = _property;
                this._propertyBlendState = _propertyBlendState;
                this._host = _host;
                this._constants = _constants;
              }

              get node() {
                return this._node;
              }

              get property() {
                return this._property;
              }

              getValue() {
                return this._node[this._property];
              }

              setValue(value) {
                const {
                  _propertyBlendState: propertyBlendState,
                  _host: host
                } = this;
                const weight = host.weight;
                propertyBlendState.blend(value, weight);
              }

            }

            class PropertyBlendState {
              constructor(value) {
                this.blendedWeight = 0.0;
                this.blendedValue = void 0;
                this.refCount = 0;
                this.blendedValue = value;
              }

            }

            class Vec3PropertyBlendState extends PropertyBlendState {
              constructor() {
                super(new Vec3());
              }

              blend(value, weight) {
                const {
                  blendedValue
                } = this;

                if (weight === 1.0) {
                  Vec3.copy(blendedValue, value);
                } else {
                  Vec3.scaleAndAdd(blendedValue, blendedValue, value, weight);
                }

                this.blendedWeight += weight;

                if ( this.blendedWeight > 1.0) ;
              }

              reset() {
                this.blendedWeight = 0.0;
                Vec3.zero(this.blendedValue);
              }

            }

            class QuatPropertyBlendState extends PropertyBlendState {
              constructor() {
                super(new Quat());
              }

              blend(value, weight) {
                if (weight === 0.0) {
                  return;
                }

                const {
                  blendedValue,
                  blendedWeight
                } = this;

                if (weight === 1.0) {
                  Quat.copy(blendedValue, value);
                } else {
                  const t = weight / (blendedWeight + weight);
                  Quat.slerp(blendedValue, blendedValue, value, t);
                }

                this.blendedWeight += weight;

                if ( this.blendedWeight > 1.0) ;
              }

              reset() {
                this.blendedWeight = 0.0;
                Quat.identity(this.blendedValue);
              }

            }

            class NodeBlendState {
              constructor() {
                this._properties = {};
              }

              get empty() {
                const {
                  _properties: properties
                } = this;
                return !properties.position && !properties.rotation && !properties.eulerAngles && !properties.scale;
              }

              refProperty(property) {
                var _properties$property, _properties$property2;

                const {
                  _properties: properties
                } = this;
                let propertyBlendState;

                switch (property) {
                  default:
                  case 'position':
                  case 'scale':
                  case 'eulerAngles':
                    propertyBlendState = (_properties$property = properties[property]) !== null && _properties$property !== void 0 ? _properties$property : properties[property] = new Vec3PropertyBlendState();
                    break;

                  case 'rotation':
                    propertyBlendState = (_properties$property2 = properties[property]) !== null && _properties$property2 !== void 0 ? _properties$property2 : properties[property] = new QuatPropertyBlendState();
                    break;
                }

                ++propertyBlendState.refCount;
                return propertyBlendState;
              }

              deRefProperty(property) {
                const {
                  _properties: properties
                } = this;
                const propertyBlendState = properties[property];

                if (!propertyBlendState) {
                  return;
                }

                --propertyBlendState.refCount;

                if (propertyBlendState.refCount > 0) {
                  return;
                }

                delete properties[property];
              }

              apply(node) {
                const {
                  _properties: {
                    position,
                    scale,
                    rotation,
                    eulerAngles
                  }
                } = this;
                let t;
                let s;
                let r;
                let tFlags = false;
                let sFlags = false;
                let rFlags = false;
                let eFlags = false;

                if (position && position.blendedWeight) {
                  tFlags = true;

                  if (position.blendedWeight < 1.0) {
                    position.blend(node.position, 1.0 - position.blendedWeight);
                  }

                  t = position.blendedValue;
                }

                if (scale && scale.blendedWeight) {
                  sFlags = true;

                  if (scale.blendedWeight < 1.0) {
                    scale.blend(node.scale, 1.0 - scale.blendedWeight);
                  }

                  s = scale.blendedValue;
                }

                if (eulerAngles && eulerAngles.blendedWeight) {
                  eFlags = true;

                  if (eulerAngles.blendedWeight < 1.0) {
                    eulerAngles.blend(node.eulerAngles, 1.0 - eulerAngles.blendedWeight);
                  }

                  r = eulerAngles.blendedValue;
                }

                if (rotation && rotation.blendedWeight) {
                  rFlags = true;

                  if (rotation.blendedWeight < 1.0) {
                    rotation.blend(node.rotation, 1.0 - rotation.blendedWeight);
                  }

                  r = rotation.blendedValue;
                }

                if (r || t || s) {
                  node.setRTS(r, t, s);
                }

                if (tFlags) {
                  position.reset();
                }

                if (sFlags) {
                  scale.reset();
                }

                if (rFlags) {
                  rotation.reset();
                }

                if (eFlags) {
                  eulerAngles.reset();
                }
              }

            }

            const stack = [];
            const pool = new Map();
            function getWorldMatrix(transform, stamp) {
              let i = 0;
              let res = Mat4.IDENTITY;

              while (transform) {
                if (transform.stamp === stamp || transform.stamp + 1 === stamp && !transform.node.hasChangedFlags) {
                  res = transform.world;
                  transform.stamp = stamp;
                  break;
                }

                transform.stamp = stamp;
                stack[i++] = transform;
                transform = transform.parent;
              }

              while (i > 0) {
                transform = stack[--i];
                stack[i] = null;
                const node = transform.node;
                Mat4.fromRTS(transform.local, node.rotation, node.position, node.scale);
                res = Mat4.multiply(transform.world, res, transform.local);
              }

              return res;
            }
            function getTransform(node, root) {
              let joint = null;
              let i = 0;

              while (node !== root) {
                const id = node.uuid;

                if (pool.has(id)) {
                  joint = pool.get(id);
                  break;
                } else {
                  joint = {
                    node,
                    local: new Mat4(),
                    world: new Mat4(),
                    stamp: -1,
                    parent: null
                  };
                  pool.set(id, joint);
                }

                stack[i++] = joint;
                node = node.parent;
                joint = null;
              }

              let child;

              while (i > 0) {
                child = stack[--i];
                stack[i] = null;
                child.parent = joint;
                joint = child;
              }

              return joint;
            }
            function deleteTransform(node) {
              let transform = pool.get(node.uuid) || null;

              while (transform) {
                pool.delete(transform.node.uuid);
                transform = transform.parent;
              }
            }

            var _class$P, _class2$H, _temp$J;
            let AnimationManager = exports('gy', ccclass(_class$P = (_temp$J = _class2$H = class AnimationManager extends System {
              constructor(...args) {
                super(...args);
                this._anims = new MutableForwardIterator([]);
                this._crossFades = new MutableForwardIterator([]);
                this._delayEvents = [];
                this._blendStateBuffer = new BlendStateBuffer();
                this._sockets = [];
              }

              get blendState() {
                return this._blendStateBuffer;
              }

              addCrossFade(crossFade) {
                const index = this._crossFades.array.indexOf(crossFade);

                if (index === -1) {
                  this._crossFades.push(crossFade);
                }
              }

              removeCrossFade(crossFade) {
                const index = this._crossFades.array.indexOf(crossFade);

                if (index >= 0) {
                  this._crossFades.fastRemoveAt(index);
                } else {
                  errorID(3907);
                }
              }

              update(dt) {
                const {
                  _delayEvents,
                  _crossFades: crossFadesIter,
                  _sockets
                } = this;
                {
                  const crossFades = crossFadesIter.array;

                  for (crossFadesIter.i = 0; crossFadesIter.i < crossFades.length; ++crossFadesIter.i) {
                    const crossFade = crossFades[crossFadesIter.i];
                    crossFade.update(dt);
                  }
                }
                const iterator = this._anims;
                const array = iterator.array;

                for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                  const anim = array[iterator.i];

                  if (!anim.isMotionless) {
                    anim.update(dt);
                  }
                }

                this._blendStateBuffer.apply();

                const stamp = legacyCC.director.getTotalFrames();

                for (let i = 0, l = _sockets.length; i < l; i++) {
                  const {
                    target,
                    transform
                  } = _sockets[i];
                  target.matrix = getWorldMatrix(transform, stamp);
                }

                for (let i = 0, l = _delayEvents.length; i < l; i++) {
                  const event = _delayEvents[i];
                  event.fn.apply(event.thisArg, event.args);
                }

                _delayEvents.length = 0;
              }

              destruct() {}

              addAnimation(anim) {
                const index = this._anims.array.indexOf(anim);

                if (index === -1) {
                  this._anims.push(anim);
                }
              }

              removeAnimation(anim) {
                const index = this._anims.array.indexOf(anim);

                if (index >= 0) {
                  this._anims.fastRemoveAt(index);
                } else {
                  errorID(3907);
                }
              }

              pushDelayEvent(fn, thisArg, args) {
                this._delayEvents.push({
                  fn,
                  thisArg,
                  args
                });
              }

              addSockets(root, sockets) {
                for (let i = 0; i < sockets.length; ++i) {
                  const socket = sockets[i];

                  if (this._sockets.find(s => s.target === socket.target)) {
                    continue;
                  }

                  const targetNode = root.getChildByPath(socket.path);
                  const transform = socket.target && targetNode && getTransform(targetNode, root);

                  if (transform) {
                    this._sockets.push({
                      target: socket.target,
                      transform
                    });
                  }
                }
              }

              removeSockets(root, sockets) {
                for (let i = 0; i < sockets.length; ++i) {
                  const socketToRemove = sockets[i];

                  for (let j = 0; j < this._sockets.length; ++j) {
                    const socket = this._sockets[j];

                    if (socket.target === socketToRemove.target) {
                      deleteTransform(socket.transform.node);
                      this._sockets[j] = this._sockets[this._sockets.length - 1];
                      this._sockets.length--;
                      break;
                    }
                  }
                }
              }

            }, _class2$H.ID = 'animation', _temp$J)) || _class$P);
            director.on(Director.EVENT_INIT, () => {
              const animationManager = new AnimationManager();
              director.registerSystem(AnimationManager.ID, animationManager, System.Priority.HIGH);
            });
            legacyCC.AnimationManager = AnimationManager;

            const m4_1$2 = new Mat4();
            function getPathFromRoot(target, root) {
              let node = target;
              let path = '';

              while (node !== null && node !== root) {
                path = `${node.name}/${path}`;
                node = node.parent;
              }

              return path.slice(0, -1);
            }
            function getWorldTransformUntilRoot(target, root, outMatrix) {
              Mat4.identity(outMatrix);

              while (target !== root) {
                Mat4.fromRTS(m4_1$2, target.rotation, target.position, target.scale);
                Mat4.multiply(outMatrix, m4_1$2, outMatrix);
                target = target.parent;
              }

              return outMatrix;
            }

            var _dec$P, _class$Q, _dec2$n, _class2$I, _dec3$f, _class3$e, _dec4$c, _class4$9;
            legacyCC.easing = easing;
            let HierachyModifier = exports('gj', (_dec$P = ccclass('cc.HierachyModifier'), _dec$P(_class$Q = class HierachyModifier extends HierarchyPath {}) || _class$Q));
            legacyCC.HierachyModifier = HierachyModifier;
            let ComponentModifier = exports('gk', (_dec2$n = ccclass('cc.ComponentModifier'), _dec2$n(_class2$I = class ComponentModifier extends ComponentPath {}) || _class2$I));
            legacyCC.ComponentModifier = ComponentModifier;
            let CurveValueAdapter = exports('gl', (_dec3$f = ccclass('cc.CurveValueAdapter'), _dec3$f(_class3$e = class CurveValueAdapter {
              forTarget(target) {
                return {
                  set: () => {}
                };
              }

            }) || _class3$e));
            legacyCC.CurveValueAdapter = CurveValueAdapter;
            let UniformCurveValueAdapter = exports('gm', (_dec4$c = ccclass('cc.UniformCurveValueAdapter'), _dec4$c(_class4$9 = class UniformCurveValueAdapter extends UniformProxyFactory {}) || _class4$9));
            legacyCC.UniformCurveValueAdapter = UniformCurveValueAdapter;
            function isPropertyModifier(path) {
              return typeof path === 'string';
            }
            legacyCC.isPropertyModifier = isPropertyModifier;
            function isElementModifier(path) {
              return typeof path === 'number';
            }
            legacyCC.isElementModifier = isElementModifier;
            function isCustomTargetModifier(path, constructor) {
              return path instanceof constructor;
            }
            legacyCC.isCustomTargetModifier = isCustomTargetModifier;

            legacyCC.math = math;
            legacyCC.geometry = geometry;

            class NodePool$1 {
              constructor(poolHandlerComp) {
                this.poolHandlerComp = void 0;
                this._pool = void 0;
                this.poolHandlerComp = poolHandlerComp;
                this._pool = [];
              }

              size() {
                return this._pool.length;
              }

              clear() {
                const count = this._pool.length;

                for (let i = 0; i < count; ++i) {
                  this._pool[i].destroy();
                }

                this._pool.length = 0;
              }

              put(obj) {
                if (obj && this._pool.indexOf(obj) === -1) {
                  obj.removeFromParent();
                  const handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

                  if (handler && handler.unuse) {
                    handler.unuse();
                  }

                  this._pool.push(obj);
                }
              }

              get(...args) {
                const last = this._pool.length - 1;

                if (last < 0) {
                  return null;
                } else {
                  const obj = this._pool[last];
                  this._pool.length = last;
                  const handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;

                  if (handler && handler.reuse) {
                    handler.reuse(arguments);
                  }

                  return obj;
                }
              }

            } exports('gG', NodePool$1);
            legacyCC.NodePool = NodePool$1;

            legacyCC.renderer = renderer;

            class BufferBlob {
              constructor() {
                this._arrayBufferOrPaddings = [];
                this._length = 0;
              }

              setNextAlignment(align) {
                if (align !== 0) {
                  const remainder = this._length % align;

                  if (remainder !== 0) {
                    const padding = align - remainder;

                    this._arrayBufferOrPaddings.push(padding);

                    this._length += padding;
                  }
                }
              }

              addBuffer(arrayBuffer) {
                const result = this._length;

                this._arrayBufferOrPaddings.push(arrayBuffer);

                this._length += arrayBuffer.byteLength;
                return result;
              }

              getLength() {
                return this._length;
              }

              getCombined() {
                const result = new Uint8Array(this._length);
                let counter = 0;

                this._arrayBufferOrPaddings.forEach(arrayBufferOrPadding => {
                  if (typeof arrayBufferOrPadding === 'number') {
                    counter += arrayBufferOrPadding;
                  } else {
                    result.set(new Uint8Array(arrayBufferOrPadding), counter);
                    counter += arrayBufferOrPadding.byteLength;
                  }
                });

                return result.buffer;
              }

            } exports('b_', BufferBlob);

            class StdMorphRendering {
              constructor(mesh, gfxDevice) {
                this._mesh = void 0;
                this._subMeshRenderings = [];
                this._mesh = mesh;

                if (!this._mesh.struct.morph) {
                  return;
                }

                const nSubMeshes = this._mesh.struct.primitives.length;
                this._subMeshRenderings = new Array(nSubMeshes).fill(null);

                for (let iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  const subMeshMorph = this._mesh.struct.morph.subMeshMorphs[iSubMesh];

                  if (!subMeshMorph) {
                    continue;
                  }

                  if ( subMeshMorph.targets.length > UBOMorph.MAX_MORPH_TARGET_COUNT) {
                    this._subMeshRenderings[iSubMesh] = new CpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
                  } else {
                    this._subMeshRenderings[iSubMesh] = new GpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
                  }
                }
              }

              createInstance() {
                const nSubMeshes = this._mesh.struct.primitives.length;
                const subMeshInstances = new Array(nSubMeshes);

                for (let iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  var _this$_subMeshRenderi, _this$_subMeshRenderi2;

                  subMeshInstances[iSubMesh] = (_this$_subMeshRenderi = (_this$_subMeshRenderi2 = this._subMeshRenderings[iSubMesh]) === null || _this$_subMeshRenderi2 === void 0 ? void 0 : _this$_subMeshRenderi2.createInstance()) !== null && _this$_subMeshRenderi !== void 0 ? _this$_subMeshRenderi : null;
                }

                return {
                  setWeights(subMeshIndex, weights) {
                    var _subMeshInstances$sub;

                    (_subMeshInstances$sub = subMeshInstances[subMeshIndex]) === null || _subMeshInstances$sub === void 0 ? void 0 : _subMeshInstances$sub.setWeights(weights);
                  },

                  requiredPatches: subMeshIndex => {
                    assertIsNonNullable(this._mesh.struct.morph);
                    const subMeshMorph = this._mesh.struct.morph.subMeshMorphs[subMeshIndex];
                    const subMeshRenderingInstance = subMeshInstances[subMeshIndex];

                    if (subMeshRenderingInstance === null) {
                      return null;
                    }

                    assertIsNonNullable(subMeshMorph);
                    const patches = [{
                      name: 'CC_USE_MORPH',
                      value: true
                    }, {
                      name: 'CC_MORPH_TARGET_COUNT',
                      value: subMeshMorph.targets.length
                    }];

                    if (subMeshMorph.attributes.includes(AttributeName.ATTR_POSITION)) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_POSITION',
                        value: true
                      });
                    }

                    if (subMeshMorph.attributes.includes(AttributeName.ATTR_NORMAL)) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_NORMAL',
                        value: true
                      });
                    }

                    if (subMeshMorph.attributes.includes(AttributeName.ATTR_TANGENT)) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_TANGENT',
                        value: true
                      });
                    }

                    patches.push(...subMeshRenderingInstance.requiredPatches());
                    return patches;
                  },
                  adaptPipelineState: (subMeshIndex, descriptorSet) => {
                    var _subMeshInstances$sub2;

                    (_subMeshInstances$sub2 = subMeshInstances[subMeshIndex]) === null || _subMeshInstances$sub2 === void 0 ? void 0 : _subMeshInstances$sub2.adaptPipelineState(descriptorSet);
                  },
                  destroy: () => {
                    for (const subMeshInstance of subMeshInstances) {
                      subMeshInstance === null || subMeshInstance === void 0 ? void 0 : subMeshInstance.destroy();
                    }
                  }
                };
              }

            }

            class GpuComputing {
              constructor(mesh, subMeshIndex, morph, gfxDevice) {
                this._gfxDevice = void 0;
                this._subMeshMorph = void 0;
                this._textureInfo = void 0;
                this._attributes = void 0;
                this._verticesCount = void 0;
                this._gfxDevice = gfxDevice;
                const subMeshMorph = morph.subMeshMorphs[subMeshIndex];
                assertIsNonNullable(subMeshMorph);
                this._subMeshMorph = subMeshMorph;
                enableVertexId(mesh, subMeshIndex, gfxDevice);
                const nVertices = mesh.struct.vertexBundles[mesh.struct.primitives[subMeshIndex].vertexBundelIndices[0]].view.count;
                this._verticesCount = nVertices;
                const nTargets = subMeshMorph.targets.length;
                const vec4Required = nVertices * nTargets;
                const vec4TextureFactory = createVec4TextureFactory(gfxDevice, vec4Required);
                this._textureInfo = {
                  width: vec4TextureFactory.width,
                  height: vec4TextureFactory.height
                };
                this._attributes = subMeshMorph.attributes.map((attributeName, attributeIndex) => {
                  const vec4Tex = vec4TextureFactory.create();
                  const valueView = vec4Tex.valueView;
                  subMeshMorph.targets.forEach((morphTarget, morphTargetIndex) => {
                    const displacementsView = morphTarget.displacements[attributeIndex];
                    const displacements = new Float32Array(mesh.data.buffer, mesh.data.byteOffset + displacementsView.offset, displacementsView.count);
                    const displacementsOffset = nVertices * morphTargetIndex * 4;

                    for (let iVertex = 0; iVertex < nVertices; ++iVertex) {
                      valueView[displacementsOffset + 4 * iVertex + 0] = displacements[3 * iVertex + 0];
                      valueView[displacementsOffset + 4 * iVertex + 1] = displacements[3 * iVertex + 1];
                      valueView[displacementsOffset + 4 * iVertex + 2] = displacements[3 * iVertex + 2];
                    }
                  });
                  vec4Tex.updatePixels();
                  return {
                    name: attributeName,
                    morphTexture: vec4Tex
                  };
                });
              }

              destroy() {
                for (const attribute of this._attributes) {
                  attribute.morphTexture.destroy();
                }
              }

              createInstance() {
                const morphUniforms = new MorphUniforms(this._gfxDevice, this._subMeshMorph.targets.length);
                morphUniforms.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height);
                morphUniforms.setVerticesCount(this._verticesCount);
                morphUniforms.commit();
                return {
                  setWeights: weights => {
                    morphUniforms.setWeights(weights);
                    morphUniforms.commit();
                  },
                  requiredPatches: () => [{
                    name: 'CC_MORPH_TARGET_USE_TEXTURE',
                    value: true
                  }],
                  adaptPipelineState: descriptorSet => {
                    for (const attribute of this._attributes) {
                      let binding;

                      switch (attribute.name) {
                        case AttributeName.ATTR_POSITION:
                          binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
                          break;

                        case AttributeName.ATTR_NORMAL:
                          binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
                          break;

                        case AttributeName.ATTR_TANGENT:
                          binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
                          break;

                        default:
                          warn('Unexpected attribute!');
                          break;
                      }

                      if (binding !== undefined) {
                        descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
                        descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
                      }
                    }

                    descriptorSet.bindBuffer(UBOMorph.BINDING, morphUniforms.buffer);
                    descriptorSet.update();
                  },
                  destroy: () => {}
                };
              }

            }

            class CpuComputing {
              constructor(mesh, subMeshIndex, morph, gfxDevice) {
                this._gfxDevice = void 0;
                this._attributes = [];
                this._gfxDevice = gfxDevice;
                const subMeshMorph = morph.subMeshMorphs[subMeshIndex];
                assertIsNonNullable(subMeshMorph);
                enableVertexId(mesh, subMeshIndex, gfxDevice);
                this._attributes = subMeshMorph.attributes.map((attributeName, attributeIndex) => ({
                  name: attributeName,
                  targets: subMeshMorph.targets.map(attributeDisplacement => ({
                    displacements: new Float32Array(mesh.data.buffer, mesh.data.byteOffset + attributeDisplacement.displacements[attributeIndex].offset, attributeDisplacement.displacements[attributeIndex].count)
                  }))
                }));
              }

              get data() {
                return this._attributes;
              }

              createInstance() {
                return new CpuComputingRenderingInstance(this, this._attributes[0].targets[0].displacements.length / 3, this._gfxDevice);
              }

            }

            class CpuComputingRenderingInstance {
              constructor(owner, nVertices, gfxDevice) {
                this._attributes = void 0;
                this._owner = void 0;
                this._morphUniforms = void 0;
                this._owner = owner;
                this._morphUniforms = new MorphUniforms(gfxDevice, 0);
                const vec4TextureFactory = createVec4TextureFactory(gfxDevice, nVertices);

                this._morphUniforms.setMorphTextureInfo(vec4TextureFactory.width, vec4TextureFactory.height);

                this._morphUniforms.commit();

                this._attributes = this._owner.data.map((attributeMorph, attributeIndex) => {
                  const morphTexture = vec4TextureFactory.create();
                  return {
                    attributeName: attributeMorph.name,
                    morphTexture
                  };
                });
              }

              setWeights(weights) {
                for (let iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {
                  const myAttribute = this._attributes[iAttribute];
                  const valueView = myAttribute.morphTexture.valueView;
                  const attributeMorph = this._owner.data[iAttribute];
                  assertIsTrue(weights.length === attributeMorph.targets.length);

                  for (let iTarget = 0; iTarget < attributeMorph.targets.length; ++iTarget) {
                    const targetDisplacements = attributeMorph.targets[iTarget].displacements;
                    const weight = weights[iTarget];
                    const nVertices = targetDisplacements.length / 3;

                    if (iTarget === 0) {
                      for (let iVertex = 0; iVertex < nVertices; ++iVertex) {
                        valueView[4 * iVertex + 0] = targetDisplacements[3 * iVertex + 0] * weight;
                        valueView[4 * iVertex + 1] = targetDisplacements[3 * iVertex + 1] * weight;
                        valueView[4 * iVertex + 2] = targetDisplacements[3 * iVertex + 2] * weight;
                      }
                    } else if (weight !== 0.0) {
                      for (let iVertex = 0; iVertex < nVertices; ++iVertex) {
                        valueView[4 * iVertex + 0] += targetDisplacements[3 * iVertex + 0] * weight;
                        valueView[4 * iVertex + 1] += targetDisplacements[3 * iVertex + 1] * weight;
                        valueView[4 * iVertex + 2] += targetDisplacements[3 * iVertex + 2] * weight;
                      }
                    }
                  }

                  myAttribute.morphTexture.updatePixels();
                }
              }

              requiredPatches() {
                return [{
                  name: 'CC_MORPH_TARGET_USE_TEXTURE',
                  value: true
                }, {
                  name: 'CC_MORPH_PRECOMPUTED',
                  value: true
                }];
              }

              adaptPipelineState(descriptorSet) {
                for (const attribute of this._attributes) {
                  const attributeName = attribute.attributeName;
                  let binding;

                  switch (attributeName) {
                    case AttributeName.ATTR_POSITION:
                      binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
                      break;

                    case AttributeName.ATTR_NORMAL:
                      binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
                      break;

                    case AttributeName.ATTR_TANGENT:
                      binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
                      break;

                    default:
                      warn('Unexpected attribute!');
                      break;
                  }

                  if (binding !== undefined) {
                    descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
                    descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
                  }
                }

                descriptorSet.bindBuffer(UBOMorph.BINDING, this._morphUniforms.buffer);
                descriptorSet.update();
              }

              destroy() {
                this._morphUniforms.destroy();

                for (let iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {
                  const myAttribute = this._attributes[iAttribute];
                  myAttribute.morphTexture.destroy();
                }
              }

            }

            class MorphUniforms {
              constructor(gfxDevice, targetCount) {
                this._targetCount = void 0;
                this._localBuffer = void 0;
                this._remoteBuffer = void 0;
                this._targetCount = targetCount;
                this._localBuffer = new DataView(new ArrayBuffer(UBOMorph.SIZE));
                this._remoteBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOMorph.SIZE, UBOMorph.SIZE));
              }

              destroy() {
                this._remoteBuffer.destroy();
              }

              get buffer() {
                return this._remoteBuffer;
              }

              setWeights(weights) {
                assertIsTrue(weights.length === this._targetCount);

                for (let iWeight = 0; iWeight < weights.length; ++iWeight) {
                  this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_WEIGHTS + 4 * iWeight, weights[iWeight], legacyCC.sys.isLittleEndian);
                }
              }

              setMorphTextureInfo(width, height) {
                this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH, width, legacyCC.sys.isLittleEndian);

                this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT, height, legacyCC.sys.isLittleEndian);
              }

              setVerticesCount(count) {
                this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_VERTICES_COUNT, count, legacyCC.sys.isLittleEndian);
              }

              commit() {
                this._remoteBuffer.update(this._localBuffer.buffer);
              }

            }

            function createVec4TextureFactory(gfxDevice, vec4Capacity) {
              const hasFeatureFloatTexture = gfxDevice.hasFeature(Feature$1.TEXTURE_FLOAT);
              let pixelRequired;
              let pixelFormat;
              let pixelBytes;
              let UpdateViewConstructor;

              if (hasFeatureFloatTexture) {
                pixelRequired = vec4Capacity;
                pixelBytes = 16;
                pixelFormat = Texture2D.PixelFormat.RGBA32F;
                UpdateViewConstructor = Float32Array;
              } else {
                pixelRequired = 4 * vec4Capacity;
                pixelBytes = 4;
                pixelFormat = Texture2D.PixelFormat.RGBA8888;
                UpdateViewConstructor = Uint8Array;
              }

              const {
                width,
                height
              } = bestSizeToHavePixels(pixelRequired);
              assertIsTrue(width * height >= pixelRequired);
              return {
                width,
                height,
                create: () => {
                  const arrayBuffer = new ArrayBuffer(width * height * pixelBytes);
                  const valueView = new Float32Array(arrayBuffer);
                  const updateView = UpdateViewConstructor === Float32Array ? valueView : new UpdateViewConstructor(arrayBuffer);
                  const image = new ImageAsset({
                    width,
                    height,
                    _data: updateView,
                    _compressed: false,
                    format: pixelFormat
                  });
                  const textureAsset = new Texture2D();
                  textureAsset.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST);
                  textureAsset.setMipFilter(Texture2D.Filter.NONE);
                  textureAsset.setWrapMode(Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE);
                  textureAsset.image = image;

                  if (!textureAsset.getGFXTexture()) {
                    warn('Unexpected: failed to create morph texture?');
                  }

                  const sampler = gfxDevice.getSampler(textureAsset.getSamplerInfo());
                  return {
                    get texture() {
                      return textureAsset.getGFXTexture();
                    },

                    get sampler() {
                      return sampler;
                    },

                    get valueView() {
                      return valueView;
                    },

                    destroy() {
                      textureAsset.destroy();
                    },

                    updatePixels() {
                      textureAsset.uploadData(updateView);
                    }

                  };
                }
              };
            }

            function enableVertexId(mesh, subMeshIndex, gfxDevice) {
              mesh.renderingSubMeshes[subMeshIndex].enableVertexIdChannel(gfxDevice);
            }

            function bestSizeToHavePixels(nPixels) {
              if (nPixels < 5) {
                nPixels = 5;
              }

              const aligned = nextPow2(nPixels);
              const epxSum = log2(aligned);
              const h = epxSum >> 1;
              const w = epxSum & 1 ? h + 1 : h;
              return {
                width: 1 << w,
                height: 1 << h
              };
            }

            function createMorphRendering(mesh, gfxDevice) {
              return new StdMorphRendering(mesh, gfxDevice);
            }

            var _dec$Q, _class$R, _class2$J, _descriptor$E, _descriptor2$u, _temp$K;

            function getIndexStrideCtor(stride) {
              switch (stride) {
                case 1:
                  return Uint8Array;

                case 2:
                  return Uint16Array;

                case 4:
                  return Uint32Array;

                default:
                  return Uint8Array;
              }
            }

            const v3_1$4 = new Vec3();
            const v3_2$2 = new Vec3();
            const globalEmptyMeshBuffer = new Uint8Array();
            let Mesh = exports('bH', (_dec$Q = ccclass('cc.Mesh'), _dec$Q(_class$R = (_class2$J = (_temp$K = class Mesh extends Asset {
              get _nativeAsset() {
                return this._data.buffer;
              }

              set _nativeAsset(value) {
                this._data = new Uint8Array(value);
              }

              get subMeshCount() {
                const renderingMesh = this.renderingSubMeshes;
                return renderingMesh ? renderingMesh.length : 0;
              }

              get minPosition() {
                return this.struct.minPosition;
              }

              get maxPosition() {
                return this.struct.maxPosition;
              }

              get struct() {
                return this._struct;
              }

              get data() {
                return this._data;
              }

              get hash() {
                if (!this._hash) {
                  this._hash = murmurhash2_32_gc(this._data, 666);
                }

                return this._hash;
              }

              get jointBufferIndices() {
                if (this._jointBufferIndices) {
                  return this._jointBufferIndices;
                }

                return this._jointBufferIndices = this._struct.primitives.map(p => p.jointMapIndex || 0);
              }

              get renderingSubMeshes() {
                this.initialize();
                return this._renderingSubMeshes;
              }

              constructor() {
                super();
                this.morphRendering = null;

                _initializerDefineProperty(this, "_struct", _descriptor$E, this);

                _initializerDefineProperty(this, "_hash", _descriptor2$u, this);

                this._data = globalEmptyMeshBuffer;
                this._initialized = false;
                this._renderingSubMeshes = null;
                this._boneSpaceBounds = new Map();
                this._jointBufferIndices = null;
              }

              onLoaded() {
                this.initialize();
              }

              initialize() {
                if (this._initialized) {
                  return;
                }

                this._initialized = true;
                const {
                  buffer
                } = this._data;
                const gfxDevice = legacyCC.director.root.device;

                const vertexBuffers = this._createVertexBuffers(gfxDevice, buffer);
                const subMeshes = [];

                for (let i = 0; i < this._struct.primitives.length; i++) {
                  const prim = this._struct.primitives[i];

                  if (prim.vertexBundelIndices.length === 0) {
                    continue;
                  }

                  let indexBuffer = null;
                  let ib = null;

                  if (prim.indexView) {
                    const idxView = prim.indexView;
                    let dstStride = idxView.stride;
                    let dstSize = idxView.length;

                    if (dstStride === 4 && !gfxDevice.hasFeature(Feature$1.ELEMENT_INDEX_UINT)) {
                      const vertexCount = this._struct.vertexBundles[prim.vertexBundelIndices[0]].view.count;

                      if (vertexCount >= 65536) {
                        warnID(10001, vertexCount, 65536);
                        continue;
                      } else {
                        dstStride >>= 1;
                        dstSize >>= 1;
                      }
                    }

                    indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX, MemoryUsageBit.DEVICE, dstSize, dstStride));
                    ib = new (getIndexStrideCtor(idxView.stride))(buffer, idxView.offset, idxView.count);

                    if (idxView.stride !== dstStride) {
                      ib = getIndexStrideCtor(dstStride).from(ib);
                    }

                    indexBuffer.update(ib);
                  }

                  const vbReference = prim.vertexBundelIndices.map(idx => vertexBuffers[idx]);
                  const gfxAttributes = [];

                  if (prim.vertexBundelIndices.length > 0) {
                    const idx = prim.vertexBundelIndices[0];
                    const vertexBundle = this._struct.vertexBundles[idx];
                    const attrs = vertexBundle.attributes;

                    for (let j = 0; j < attrs.length; ++j) {
                      const attr = attrs[j];
                      gfxAttributes[j] = new Attribute(attr.name, attr.format, attr.isNormalized, attr.stream, attr.isInstanced, attr.location);
                    }
                  }

                  const subMesh = new RenderingSubMesh(vbReference, gfxAttributes, prim.primitiveMode, indexBuffer);
                  subMesh.mesh = this;
                  subMesh.subMeshIdx = i;
                  subMeshes.push(subMesh);
                }

                this._renderingSubMeshes = subMeshes;

                if (this._struct.morph) {
                  this.morphRendering = createMorphRendering(this, gfxDevice);
                }
              }

              destroy() {
                this.destroyRenderingMesh();
                return super.destroy();
              }

              destroyRenderingMesh() {
                if (this._renderingSubMeshes) {
                  for (let i = 0; i < this._renderingSubMeshes.length; i++) {
                    this._renderingSubMeshes[i].destroy();
                  }

                  this._renderingSubMeshes = null;
                  this._initialized = false;
                }
              }

              assign(struct, data) {
                this.reset({
                  struct,
                  data
                });
              }

              reset(info) {
                this.destroyRenderingMesh();
                this._struct = info.struct;
                this._data = info.data;
                this._hash = 0;
              }

              getBoneSpaceBounds(skeleton) {
                if (this._boneSpaceBounds.has(skeleton.hash)) {
                  return this._boneSpaceBounds.get(skeleton.hash);
                }

                const bounds = [];

                this._boneSpaceBounds.set(skeleton.hash, bounds);

                const valid = [];
                const {
                  bindposes
                } = skeleton;

                for (let i = 0; i < bindposes.length; i++) {
                  bounds.push(new AABB(Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity));
                  valid.push(false);
                }

                const {
                  primitives
                } = this._struct;

                for (let p = 0; p < primitives.length; p++) {
                  const joints = this.readAttribute(p, AttributeName.ATTR_JOINTS);
                  const weights = this.readAttribute(p, AttributeName.ATTR_WEIGHTS);
                  const positions = this.readAttribute(p, AttributeName.ATTR_POSITION);

                  if (!joints || !weights || !positions) {
                    continue;
                  }

                  const vertCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3);

                  for (let i = 0; i < vertCount; i++) {
                    Vec3.set(v3_1$4, positions[3 * i + 0], positions[3 * i + 1], positions[3 * i + 2]);

                    for (let j = 0; j < 4; ++j) {
                      const idx = 4 * i + j;
                      const joint = joints[idx];

                      if (weights[idx] === 0 || joint >= bindposes.length) {
                        continue;
                      }

                      Vec3.transformMat4(v3_2$2, v3_1$4, bindposes[joint]);
                      valid[joint] = true;
                      const b = bounds[joint];
                      Vec3.min(b.center, b.center, v3_2$2);
                      Vec3.max(b.halfExtents, b.halfExtents, v3_2$2);
                    }
                  }
                }

                for (let i = 0; i < bindposes.length; i++) {
                  const b = bounds[i];

                  if (!valid[i]) {
                    bounds[i] = null;
                  } else {
                    AABB.fromPoints(b, b.center, b.halfExtents);
                  }
                }

                return bounds;
              }

              merge(mesh, worldMatrix, validate) {
                if (validate) {
                  if (!this.validateMergingMesh(mesh)) {
                    return false;
                  }
                }

                const vec3_temp = new Vec3();
                const rotate = worldMatrix && new Quat();
                const boundingBox = worldMatrix && new AABB();

                if (rotate) {
                  worldMatrix.getRotation(rotate);
                }

                if (!this._initialized) {
                  const struct = JSON.parse(JSON.stringify(mesh._struct));

                  const data = mesh._data.slice();

                  if (worldMatrix) {
                    if (struct.maxPosition && struct.minPosition) {
                      Vec3.add(boundingBox.center, struct.maxPosition, struct.minPosition);
                      Vec3.multiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                      Vec3.subtract(boundingBox.halfExtents, struct.maxPosition, struct.minPosition);
                      Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                      AABB.transform(boundingBox, boundingBox, worldMatrix);
                      Vec3.add(struct.maxPosition, boundingBox.center, boundingBox.halfExtents);
                      Vec3.subtract(struct.minPosition, boundingBox.center, boundingBox.halfExtents);
                    }

                    for (let i = 0; i < struct.vertexBundles.length; i++) {
                      const vtxBdl = struct.vertexBundles[i];

                      for (let j = 0; j < vtxBdl.attributes.length; j++) {
                        if (vtxBdl.attributes[j].name === AttributeName.ATTR_POSITION || vtxBdl.attributes[j].name === AttributeName.ATTR_NORMAL) {
                          const {
                            format
                          } = vtxBdl.attributes[j];
                          const inputView = new DataView(data.buffer, vtxBdl.view.offset + getOffset(vtxBdl.attributes, j));
                          const reader = getReader(inputView, format);
                          const writer = getWriter(inputView, format);

                          if (!reader || !writer) {
                            continue;
                          }

                          const vertexCount = vtxBdl.view.count;
                          const vertexStride = vtxBdl.view.stride;
                          const attrComponentByteLength = getComponentByteLength(format);

                          for (let vtxIdx = 0; vtxIdx < vertexCount; vtxIdx++) {
                            const xOffset = vtxIdx * vertexStride;
                            const yOffset = xOffset + attrComponentByteLength;
                            const zOffset = yOffset + attrComponentByteLength;
                            vec3_temp.set(reader(xOffset), reader(yOffset), reader(zOffset));

                            switch (vtxBdl.attributes[j].name) {
                              case AttributeName.ATTR_POSITION:
                                vec3_temp.transformMat4(worldMatrix);
                                break;

                              case AttributeName.ATTR_NORMAL:
                                Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                                break;
                            }

                            writer(xOffset, vec3_temp.x);
                            writer(yOffset, vec3_temp.y);
                            writer(zOffset, vec3_temp.z);
                          }
                        }
                      }
                    }
                  }

                  this.reset({
                    struct,
                    data
                  });
                  this.initialize();
                  return true;
                }

                const bufferBlob = new BufferBlob();
                let vertCount = 0;
                let vertStride = 0;
                let srcOffset = 0;
                let dstOffset = 0;
                let vb;
                let vbView;
                let srcVBView;
                let dstVBView;
                let srcAttrOffset = 0;
                let srcVBOffset = 0;
                let dstVBOffset = 0;
                let attrSize = 0;
                let dstAttrView;
                let hasAttr = false;
                const vertexBundles = new Array(this._struct.vertexBundles.length);

                for (let i = 0; i < this._struct.vertexBundles.length; ++i) {
                  const bundle = this._struct.vertexBundles[i];
                  const dstBundle = mesh._struct.vertexBundles[i];
                  srcOffset = bundle.view.offset;
                  dstOffset = dstBundle.view.offset;
                  vertStride = bundle.view.stride;
                  vertCount = bundle.view.count + dstBundle.view.count;
                  vb = new ArrayBuffer(vertCount * vertStride);
                  vbView = new Uint8Array(vb);
                  srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length);
                  srcOffset += srcVBView.length;
                  dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length);
                  dstOffset += dstVBView.length;
                  vbView.set(srcVBView);
                  srcAttrOffset = 0;

                  for (const attr of bundle.attributes) {
                    dstVBOffset = 0;
                    hasAttr = false;

                    for (const dstAttr of dstBundle.attributes) {
                      if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                        hasAttr = true;
                        break;
                      }

                      dstVBOffset += FormatInfos[dstAttr.format].size;
                    }

                    if (hasAttr) {
                      attrSize = FormatInfos[attr.format].size;
                      srcVBOffset = bundle.view.length + srcAttrOffset;

                      for (let v = 0; v < dstBundle.view.count; ++v) {
                        dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize);
                        vbView.set(dstAttrView, srcVBOffset);

                        if ((attr.name === AttributeName.ATTR_POSITION || attr.name === AttributeName.ATTR_NORMAL) && worldMatrix) {
                          const f32_temp = new Float32Array(vbView.buffer, srcVBOffset, 3);
                          vec3_temp.set(f32_temp[0], f32_temp[1], f32_temp[2]);

                          switch (attr.name) {
                            case AttributeName.ATTR_POSITION:
                              vec3_temp.transformMat4(worldMatrix);
                              break;

                            case AttributeName.ATTR_NORMAL:
                              Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                              break;
                          }

                          f32_temp[0] = vec3_temp.x;
                          f32_temp[1] = vec3_temp.y;
                          f32_temp[2] = vec3_temp.z;
                        }

                        srcVBOffset += bundle.view.stride;
                        dstVBOffset += dstBundle.view.stride;
                      }
                    }

                    srcAttrOffset += FormatInfos[attr.format].size;
                  }

                  vertexBundles[i] = {
                    attributes: bundle.attributes,
                    view: {
                      offset: bufferBlob.getLength(),
                      length: vb.byteLength,
                      count: vertCount,
                      stride: vertStride
                    }
                  };
                  bufferBlob.addBuffer(vb);
                }

                let idxCount = 0;
                let idxStride = 2;
                let vertBatchCount = 0;
                let ibView;
                let srcIBView;
                let dstIBView;
                const primitives = new Array(this._struct.primitives.length);

                for (let i = 0; i < this._struct.primitives.length; ++i) {
                  const prim = this._struct.primitives[i];
                  const dstPrim = mesh._struct.primitives[i];
                  primitives[i] = {
                    primitiveMode: prim.primitiveMode,
                    vertexBundelIndices: prim.vertexBundelIndices
                  };

                  for (const bundleIdx of prim.vertexBundelIndices) {
                    vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                  }

                  if (prim.indexView && dstPrim.indexView) {
                    idxCount = prim.indexView.count;
                    idxCount += dstPrim.indexView.count;
                    srcOffset = prim.indexView.offset;
                    dstOffset = dstPrim.indexView.offset;

                    if (idxCount < 256) {
                      idxStride = 1;
                    } else if (idxCount < 65536) {
                      idxStride = 2;
                    } else {
                      idxStride = 4;
                    }

                    const ib = new ArrayBuffer(idxCount * idxStride);

                    if (idxStride === 2) {
                      ibView = new Uint16Array(ib);
                    } else if (idxStride === 1) {
                      ibView = new Uint8Array(ib);
                    } else {
                      ibView = new Uint32Array(ib);
                    }

                    if (prim.indexView.stride === 2) {
                      srcIBView = new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count);
                    } else if (prim.indexView.stride === 1) {
                      srcIBView = new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count);
                    } else {
                      srcIBView = new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count);
                    }

                    if (idxStride === prim.indexView.stride) {
                      ibView.set(srcIBView);
                    } else {
                      for (let n = 0; n < prim.indexView.count; ++n) {
                        ibView[n] = srcIBView[n];
                      }
                    }

                    srcOffset += prim.indexView.length;

                    if (dstPrim.indexView.stride === 2) {
                      dstIBView = new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    } else if (dstPrim.indexView.stride === 1) {
                      dstIBView = new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    } else {
                      dstIBView = new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    }

                    for (let n = 0; n < dstPrim.indexView.count; ++n) {
                      ibView[prim.indexView.count + n] = vertBatchCount + dstIBView[n];
                    }

                    dstOffset += dstPrim.indexView.length;
                    primitives[i].indexView = {
                      offset: bufferBlob.getLength(),
                      length: ib.byteLength,
                      count: idxCount,
                      stride: idxStride
                    };
                    bufferBlob.setNextAlignment(idxStride);
                    bufferBlob.addBuffer(ib);
                  }
                }

                const meshStruct = {
                  vertexBundles,
                  primitives,
                  minPosition: this._struct.minPosition,
                  maxPosition: this._struct.maxPosition
                };

                if (meshStruct.minPosition && mesh._struct.minPosition && meshStruct.maxPosition && mesh._struct.maxPosition) {
                  if (worldMatrix) {
                    Vec3.add(boundingBox.center, mesh._struct.maxPosition, mesh._struct.minPosition);
                    Vec3.multiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                    Vec3.subtract(boundingBox.halfExtents, mesh._struct.maxPosition, mesh._struct.minPosition);
                    Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                    AABB.transform(boundingBox, boundingBox, worldMatrix);
                    Vec3.add(vec3_temp, boundingBox.center, boundingBox.halfExtents);
                    Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, vec3_temp);
                    Vec3.subtract(vec3_temp, boundingBox.center, boundingBox.halfExtents);
                    Vec3.min(meshStruct.minPosition, meshStruct.minPosition, vec3_temp);
                  } else {
                    Vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition);
                    Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition);
                  }
                }

                this.reset({
                  struct: meshStruct,
                  data: new Uint8Array(bufferBlob.getCombined())
                });
                this.initialize();
                return true;
              }

              validateMergingMesh(mesh) {
                if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) {
                  return false;
                }

                for (let i = 0; i < this._struct.vertexBundles.length; ++i) {
                  const bundle = this._struct.vertexBundles[i];
                  const dstBundle = mesh._struct.vertexBundles[i];

                  if (bundle.attributes.length !== dstBundle.attributes.length) {
                    return false;
                  }

                  for (let j = 0; j < bundle.attributes.length; ++j) {
                    if (bundle.attributes[j].format !== dstBundle.attributes[j].format) {
                      return false;
                    }
                  }
                }

                if (this._struct.primitives.length !== mesh._struct.primitives.length) {
                  return false;
                }

                for (let i = 0; i < this._struct.primitives.length; ++i) {
                  const prim = this._struct.primitives[i];
                  const dstPrim = mesh._struct.primitives[i];

                  if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) {
                    return false;
                  }

                  for (let j = 0; j < prim.vertexBundelIndices.length; ++j) {
                    if (prim.vertexBundelIndices[j] !== dstPrim.vertexBundelIndices[j]) {
                      return false;
                    }
                  }

                  if (prim.primitiveMode !== dstPrim.primitiveMode) {
                    return false;
                  }

                  if (prim.indexView) {
                    if (dstPrim.indexView === undefined) {
                      return false;
                    }
                  } else if (dstPrim.indexView) {
                    return false;
                  }
                }

                return true;
              }

              readAttribute(primitiveIndex, attributeName) {
                let result = null;

                this._accessAttribute(primitiveIndex, attributeName, (vertexBundle, iAttribute) => {
                  const vertexCount = vertexBundle.view.count;
                  const {
                    format
                  } = vertexBundle.attributes[iAttribute];
                  const StorageConstructor = getTypedArrayConstructor(FormatInfos[format]);

                  if (vertexCount === 0) {
                    return;
                  }

                  const inputView = new DataView(this._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
                  const formatInfo = FormatInfos[format];
                  const reader = getReader(inputView, format);

                  if (!StorageConstructor || !reader) {
                    return;
                  }

                  const componentCount = formatInfo.count;
                  const storage = new StorageConstructor(vertexCount * componentCount);
                  const inputStride = vertexBundle.view.stride;

                  for (let iVertex = 0; iVertex < vertexCount; ++iVertex) {
                    for (let iComponent = 0; iComponent < componentCount; ++iComponent) {
                      storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                    }
                  }

                  result = storage;
                });

                return result;
              }

              copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
                let written = false;

                this._accessAttribute(primitiveIndex, attributeName, (vertexBundle, iAttribute) => {
                  const vertexCount = vertexBundle.view.count;

                  if (vertexCount === 0) {
                    written = true;
                    return;
                  }

                  const {
                    format
                  } = vertexBundle.attributes[iAttribute];
                  const inputView = new DataView(this._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
                  const outputView = new DataView(buffer, offset);
                  const formatInfo = FormatInfos[format];
                  const reader = getReader(inputView, format);
                  const writer = getWriter(outputView, format);

                  if (!reader || !writer) {
                    return;
                  }

                  const componentCount = formatInfo.count;
                  const inputStride = vertexBundle.view.stride;
                  const inputComponentByteLength = getComponentByteLength(format);
                  const outputStride = stride;
                  const outputComponentByteLength = inputComponentByteLength;

                  for (let iVertex = 0; iVertex < vertexCount; ++iVertex) {
                    for (let iComponent = 0; iComponent < componentCount; ++iComponent) {
                      const inputOffset = inputStride * iVertex + inputComponentByteLength * iComponent;
                      const outputOffset = outputStride * iVertex + outputComponentByteLength * iComponent;
                      writer(outputOffset, reader(inputOffset));
                    }
                  }

                  written = true;
                });

                return written;
              }

              readIndices(primitiveIndex) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return null;
                }

                const primitive = this._struct.primitives[primitiveIndex];

                if (!primitive.indexView) {
                  return null;
                }

                const {
                  stride
                } = primitive.indexView;
                const Ctor = stride === 1 ? Uint8Array : stride === 2 ? Uint16Array : Uint32Array;
                return new Ctor(this._data.buffer, primitive.indexView.offset, primitive.indexView.count);
              }

              copyIndices(primitiveIndex, outputArray) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return false;
                }

                const primitive = this._struct.primitives[primitiveIndex];

                if (!primitive.indexView) {
                  return false;
                }

                const indexCount = primitive.indexView.count;
                const indexFormat = primitive.indexView.stride === 1 ? Format.R8UI : primitive.indexView.stride === 2 ? Format.R16UI : Format.R32UI;
                const reader = getReader(new DataView(this._data.buffer), indexFormat);

                for (let i = 0; i < indexCount; ++i) {
                  outputArray[i] = reader(primitive.indexView.offset + FormatInfos[indexFormat].size * i);
                }

                return true;
              }

              _accessAttribute(primitiveIndex, attributeName, accessor) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return;
                }

                const primitive = this._struct.primitives[primitiveIndex];

                for (const vertexBundleIndex of primitive.vertexBundelIndices) {
                  const vertexBundle = this._struct.vertexBundles[vertexBundleIndex];
                  const iAttribute = vertexBundle.attributes.findIndex(a => a.name === attributeName);

                  if (iAttribute < 0) {
                    continue;
                  }

                  accessor(vertexBundle, iAttribute);
                  break;
                }
              }

              _createVertexBuffers(gfxDevice, data) {
                return this._struct.vertexBundles.map(vertexBundle => {
                  const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX, MemoryUsageBit.DEVICE, vertexBundle.view.length, vertexBundle.view.stride));
                  const view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);
                  vertexBuffer.update(view);
                  return vertexBuffer;
                });
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                this.reset({
                  struct: {
                    vertexBundles: [],
                    primitives: []
                  },
                  data: globalEmptyMeshBuffer
                });
              }

            }, _temp$K), (_descriptor$E = _applyDecoratedDescriptor(_class2$J.prototype, "_struct", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return {
                  vertexBundles: [],
                  primitives: []
                };
              }
            }), _descriptor2$u = _applyDecoratedDescriptor(_class2$J.prototype, "_hash", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$J)) || _class$R));
            legacyCC.Mesh = Mesh;

            function getOffset(attributes, attributeIndex) {
              let result = 0;

              for (let i = 0; i < attributeIndex; ++i) {
                const attribute = attributes[i];
                result += FormatInfos[attribute.format].size;
              }

              return result;
            }

            const {
              isLittleEndian
            } = sys;

            function getComponentByteLength(format) {
              const info = FormatInfos[format];
              return info.size / info.count;
            }

            function getReader(dataView, format) {
              const info = FormatInfos[format];
              const stride = info.size / info.count;

              switch (info.type) {
                case FormatType.UNORM:
                  {
                    switch (stride) {
                      case 1:
                        return offset => dataView.getUint8(offset);

                      case 2:
                        return offset => dataView.getUint16(offset, isLittleEndian);

                      case 4:
                        return offset => dataView.getUint32(offset, isLittleEndian);
                    }

                    break;
                  }

                case FormatType.SNORM:
                  {
                    switch (stride) {
                      case 1:
                        return offset => dataView.getInt8(offset);

                      case 2:
                        return offset => dataView.getInt16(offset, isLittleEndian);

                      case 4:
                        return offset => dataView.getInt32(offset, isLittleEndian);
                    }

                    break;
                  }

                case FormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return offset => dataView.getInt8(offset);

                      case 2:
                        return offset => dataView.getInt16(offset, isLittleEndian);

                      case 4:
                        return offset => dataView.getInt32(offset, isLittleEndian);
                    }

                    break;
                  }

                case FormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return offset => dataView.getUint8(offset);

                      case 2:
                        return offset => dataView.getUint16(offset, isLittleEndian);

                      case 4:
                        return offset => dataView.getUint32(offset, isLittleEndian);
                    }

                    break;
                  }

                case FormatType.FLOAT:
                  {
                    return offset => dataView.getFloat32(offset, isLittleEndian);
                  }
              }

              return null;
            }

            function getWriter(dataView, format) {
              const info = FormatInfos[format];
              const stride = info.size / info.count;

              switch (info.type) {
                case FormatType.UNORM:
                  {
                    switch (stride) {
                      case 1:
                        return (offset, value) => dataView.setUint8(offset, value);

                      case 2:
                        return (offset, value) => dataView.setUint16(offset, value, isLittleEndian);

                      case 4:
                        return (offset, value) => dataView.setUint32(offset, value, isLittleEndian);
                    }

                    break;
                  }

                case FormatType.SNORM:
                  {
                    switch (stride) {
                      case 1:
                        return (offset, value) => dataView.setInt8(offset, value);

                      case 2:
                        return (offset, value) => dataView.setInt16(offset, value, isLittleEndian);

                      case 4:
                        return (offset, value) => dataView.setInt32(offset, value, isLittleEndian);
                    }

                    break;
                  }

                case FormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return (offset, value) => dataView.setInt8(offset, value);

                      case 2:
                        return (offset, value) => dataView.setInt16(offset, value, isLittleEndian);

                      case 4:
                        return (offset, value) => dataView.setInt32(offset, value, isLittleEndian);
                    }

                    break;
                  }

                case FormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return (offset, value) => dataView.setUint8(offset, value);

                      case 2:
                        return (offset, value) => dataView.setUint16(offset, value, isLittleEndian);

                      case 4:
                        return (offset, value) => dataView.setUint32(offset, value, isLittleEndian);
                    }

                    break;
                  }

                case FormatType.FLOAT:
                  {
                    return (offset, value) => dataView.setFloat32(offset, value, isLittleEndian);
                  }
              }

              return null;
            }

            replaceProperty(Mesh.prototype, 'Mesh.prototype', [{
              name: 'renderingMesh',
              newName: 'renderingSubMeshes'
            }]);
            removeProperty(Mesh.prototype, 'Mesh.prototype', [{
              name: 'hasFlatBuffers'
            }, {
              name: 'destroyFlatBuffers'
            }]);

            var _dec$R, _dec2$o, _dec3$g, _class$S, _class2$K, _descriptor$F, _descriptor2$v, _descriptor3$l, _temp$L;
            let Skeleton = exports('cU', (_dec$R = ccclass('cc.Skeleton'), _dec2$o = type([CCString]), _dec3$g = type([Mat4]), _dec$R(_class$S = (_class2$K = (_temp$L = class Skeleton extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_joints", _descriptor$F, this);

                _initializerDefineProperty(this, "_bindposes", _descriptor2$v, this);

                _initializerDefineProperty(this, "_hash", _descriptor3$l, this);

                this._invBindposes = null;
              }

              get joints() {
                return this._joints;
              }

              set joints(value) {
                this._joints = value;
              }

              get bindposes() {
                return this._bindposes;
              }

              set bindposes(value) {
                this._bindposes = value;
              }

              get inverseBindposes() {
                if (!this._invBindposes) {
                  this._invBindposes = [];

                  for (let i = 0; i < this._bindposes.length; i++) {
                    const inv = new Mat4();
                    Mat4.invert(inv, this._bindposes[i]);

                    this._invBindposes.push(inv);
                  }
                }

                return this._invBindposes;
              }

              get hash() {
                if (!this._hash) {
                  let str = '';

                  for (let i = 0; i < this._bindposes.length; i++) {
                    const ibm = this._bindposes[i];
                    str += `${ibm.m00.toPrecision(2)} ${ibm.m01.toPrecision(2)} ${ibm.m02.toPrecision(2)} ${ibm.m03.toPrecision(2)} ${ibm.m04.toPrecision(2)} ${ibm.m05.toPrecision(2)} ${ibm.m06.toPrecision(2)} ${ibm.m07.toPrecision(2)} ${ibm.m08.toPrecision(2)} ${ibm.m09.toPrecision(2)} ${ibm.m10.toPrecision(2)} ${ibm.m11.toPrecision(2)} ${ibm.m12.toPrecision(2)} ${ibm.m13.toPrecision(2)} ${ibm.m14.toPrecision(2)} ${ibm.m15.toPrecision(2)}\n`;
                  }

                  this._hash = murmurhash2_32_gc(str, 666);
                }

                return this._hash;
              }

              destroy() {
                var _ref, _legacyCC$director$ro;

                (_ref = (_legacyCC$director$ro = legacyCC.director.root) === null || _legacyCC$director$ro === void 0 ? void 0 : _legacyCC$director$ro.dataPoolManager) === null || _ref === void 0 ? void 0 : _ref.releaseSkeleton(this);
                return super.destroy();
              }

              validate() {
                return this.joints.length > 0 && this.bindposes.length > 0;
              }

            }, _temp$L), (_descriptor$F = _applyDecoratedDescriptor(_class2$K.prototype, "_joints", [_dec2$o], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$v = _applyDecoratedDescriptor(_class2$K.prototype, "_bindposes", [_dec3$g], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$l = _applyDecoratedDescriptor(_class2$K.prototype, "_hash", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$K)) || _class$S));
            legacyCC.Skeleton = Skeleton;

            let ERigidBodyType;

            (function (ERigidBodyType) {
              ERigidBodyType[ERigidBodyType["DYNAMIC"] = 1] = "DYNAMIC";
              ERigidBodyType[ERigidBodyType["STATIC"] = 2] = "STATIC";
              ERigidBodyType[ERigidBodyType["KINEMATIC"] = 4] = "KINEMATIC";
            })(ERigidBodyType || (ERigidBodyType = exports('dw', {})));

            Enum(ERigidBodyType);
            let EAxisDirection;

            (function (EAxisDirection) {
              EAxisDirection[EAxisDirection["X_AXIS"] = 0] = "X_AXIS";
              EAxisDirection[EAxisDirection["Y_AXIS"] = 1] = "Y_AXIS";
              EAxisDirection[EAxisDirection["Z_AXIS"] = 2] = "Z_AXIS";
            })(EAxisDirection || (EAxisDirection = exports('h4', {})));

            Enum(EAxisDirection);
            let ESimplexType;

            (function (ESimplexType) {
              ESimplexType[ESimplexType["VERTEX"] = 1] = "VERTEX";
              ESimplexType[ESimplexType["LINE"] = 2] = "LINE";
              ESimplexType[ESimplexType["TRIANGLE"] = 3] = "TRIANGLE";
              ESimplexType[ESimplexType["TETRAHEDRON"] = 4] = "TETRAHEDRON";
            })(ESimplexType || (ESimplexType = {}));

            Enum(ESimplexType);
            let EColliderType;

            (function (EColliderType) {
              EColliderType[EColliderType["BOX"] = 0] = "BOX";
              EColliderType[EColliderType["SPHERE"] = 1] = "SPHERE";
              EColliderType[EColliderType["CAPSULE"] = 2] = "CAPSULE";
              EColliderType[EColliderType["CYLINDER"] = 3] = "CYLINDER";
              EColliderType[EColliderType["CONE"] = 4] = "CONE";
              EColliderType[EColliderType["MESH"] = 5] = "MESH";
              EColliderType[EColliderType["PLANE"] = 6] = "PLANE";
              EColliderType[EColliderType["SIMPLEX"] = 7] = "SIMPLEX";
              EColliderType[EColliderType["TERRAIN"] = 8] = "TERRAIN";
            })(EColliderType || (EColliderType = exports('dx', {})));

            Enum(EColliderType);
            let EConstraintType;

            (function (EConstraintType) {
              EConstraintType[EConstraintType["POINT_TO_POINT"] = 0] = "POINT_TO_POINT";
              EConstraintType[EConstraintType["HINGE"] = 1] = "HINGE";
              EConstraintType[EConstraintType["CONE_TWIST"] = 2] = "CONE_TWIST";
            })(EConstraintType || (EConstraintType = {}));

            Enum(EConstraintType);
            let PhysicsGroup;

            (function (PhysicsGroup) {
              PhysicsGroup[PhysicsGroup["DEFAULT"] = 1] = "DEFAULT";
            })(PhysicsGroup || (PhysicsGroup = exports('dv', {})));

            Enum(PhysicsGroup);

            function updateLegacyMacro(id) {
              legacyCC._global.CC_PHYSICS_BUILTIN = id === 'builtin';
              legacyCC._global.CC_PHYSICS_CANNON = id === 'cannon.js';
              legacyCC._global.CC_PHYSICS_AMMO = id === 'ammo.js';
            }

            function register(id, wrapper) {
              console.info(`[PHYSICS]: register ${id}.`);
              selector.backend[id] = wrapper;

              if (!selector.physicsWorld || selector.id === id) {
                updateLegacyMacro(id);
                const mutableSelector = selector;
                mutableSelector.id = id;
                mutableSelector.wrapper = wrapper;
              }
            }

            let worldInitData;

            function switchTo(id) {
              if (!selector.runInEditor) return;
              const mutableSelector = selector;

              if (selector.physicsWorld && id !== selector.id && selector.backend[id] != null) {
                selector.physicsWorld.destroy();
                console.info(`[PHYSICS]: switch from ${selector.id} to ${id}.`);
                updateLegacyMacro(id);
                mutableSelector.id = id;
                mutableSelector.wrapper = selector.backend[id];
                mutableSelector.physicsWorld = createPhysicsWorld();
              } else {
                console.info(`[PHYSICS]: using ${id}.`);
                mutableSelector.physicsWorld = createPhysicsWorld();
              }

              if (worldInitData) {
                const world = mutableSelector.physicsWorld;
                world.setGravity(worldInitData.gravity);
                world.setAllowSleep(worldInitData.allowSleep);
                world.setDefaultMaterial(worldInitData.defaultMaterial);
              }
            }

            const selector = exports('dE', {
              id: '',
              switchTo,
              register,
              wrapper: {},
              backend: {},
              physicsWorld: null,
              runInEditor: !EDITOR
            });
            function constructDefaultWorld(data) {
              if (!worldInitData) worldInitData = data;
              if (!selector.runInEditor) return;

              if (!selector.physicsWorld) {
                console.info(`[PHYSICS]: using ${selector.id}.`);
                const mutableSelector = selector;
                const world = mutableSelector.physicsWorld = createPhysicsWorld();
                world.setGravity(worldInitData.gravity);
                world.setAllowSleep(worldInitData.allowSleep);
                world.setDefaultMaterial(worldInitData.defaultMaterial);
              }
            }

            const FUNC = (...v) => 0;

            const ENTIRE_WORLD = {
              impl: null,
              setGravity: FUNC,
              setAllowSleep: FUNC,
              setDefaultMaterial: FUNC,
              step: FUNC,
              syncAfterEvents: FUNC,
              syncSceneToPhysics: FUNC,
              raycast: FUNC,
              raycastClosest: FUNC,
              emitEvents: FUNC,
              destroy: FUNC
            };
            var ECheckType;

            (function (ECheckType) {
              ECheckType[ECheckType["World"] = 0] = "World";
              ECheckType[ECheckType["RigidBody"] = 1] = "RigidBody";
              ECheckType[ECheckType["BoxCollider"] = 2] = "BoxCollider";
              ECheckType[ECheckType["SphereCollider"] = 3] = "SphereCollider";
              ECheckType[ECheckType["CapsuleCollider"] = 4] = "CapsuleCollider";
              ECheckType[ECheckType["MeshCollider"] = 5] = "MeshCollider";
              ECheckType[ECheckType["CylinderCollider"] = 6] = "CylinderCollider";
              ECheckType[ECheckType["ConeCollider"] = 7] = "ConeCollider";
              ECheckType[ECheckType["TerrainCollider"] = 8] = "TerrainCollider";
              ECheckType[ECheckType["SimplexCollider"] = 9] = "SimplexCollider";
              ECheckType[ECheckType["PlaneCollider"] = 10] = "PlaneCollider";
              ECheckType[ECheckType["PointToPointConstraint"] = 11] = "PointToPointConstraint";
              ECheckType[ECheckType["HingeConstraint"] = 12] = "HingeConstraint";
              ECheckType[ECheckType["ConeTwistConstraint"] = 13] = "ConeTwistConstraint";
            })(ECheckType || (ECheckType = {}));

            function check(obj, type) {
              if (obj == null) {
                if (selector.id) {
                  warn(`${selector.id} physics does not support ${ECheckType[type]}`);
                } else {
                  errorID(9600);
                }

                return true;
              }

              return false;
            }

            function createPhysicsWorld() {
              if (check(selector.wrapper.PhysicsWorld, ECheckType.World)) {
                return ENTIRE_WORLD;
              }

              return new selector.wrapper.PhysicsWorld();
            }
            const ENTIRE_RIGID_BODY = {
              impl: null,
              rigidBody: null,
              isAwake: false,
              isSleepy: false,
              isSleeping: false,
              initialize: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setType: FUNC,
              setMass: FUNC,
              setLinearDamping: FUNC,
              setAngularDamping: FUNC,
              useGravity: FUNC,
              setLinearFactor: FUNC,
              setAngularFactor: FUNC,
              setAllowSleep: FUNC,
              wakeUp: FUNC,
              sleep: FUNC,
              clearState: FUNC,
              clearForces: FUNC,
              clearVelocity: FUNC,
              setSleepThreshold: FUNC,
              getSleepThreshold: FUNC,
              getLinearVelocity: FUNC,
              setLinearVelocity: FUNC,
              getAngularVelocity: FUNC,
              setAngularVelocity: FUNC,
              applyForce: FUNC,
              applyLocalForce: FUNC,
              applyImpulse: FUNC,
              applyLocalImpulse: FUNC,
              applyTorque: FUNC,
              applyLocalTorque: FUNC,
              setGroup: FUNC,
              getGroup: FUNC,
              addGroup: FUNC,
              removeGroup: FUNC,
              setMask: FUNC,
              getMask: FUNC,
              addMask: FUNC,
              removeMask: FUNC,
              isUsingCCD: FUNC,
              useCCD: FUNC
            };
            function createRigidBody() {
              if (check(selector.wrapper.RigidBody, ECheckType.RigidBody)) {
                return ENTIRE_RIGID_BODY;
              }

              return new selector.wrapper.RigidBody();
            }
            const CREATE_COLLIDER_PROXY = {
              INITED: false
            };
            const ENTIRE_SHAPE = {
              impl: null,
              collider: null,
              attachedRigidBody: null,
              initialize: FUNC,
              onLoad: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setGroup: FUNC,
              getGroup: FUNC,
              addGroup: FUNC,
              removeGroup: FUNC,
              setMask: FUNC,
              getMask: FUNC,
              addMask: FUNC,
              removeMask: FUNC,
              setMaterial: FUNC,
              setAsTrigger: FUNC,
              setCenter: FUNC,
              getAABB: FUNC,
              getBoundingSphere: FUNC,
              updateSize: FUNC,
              updateRadius: FUNC,
              setRadius: FUNC,
              setCylinderHeight: FUNC,
              setDirection: FUNC,
              setHeight: FUNC,
              setShapeType: FUNC,
              setVertices: FUNC,
              setMesh: FUNC,
              setTerrain: FUNC,
              setNormal: FUNC,
              setConstant: FUNC,
              updateEventListener: FUNC
            };
            function createShape(type) {
              initColliderProxy();
              return CREATE_COLLIDER_PROXY[type]();
            }

            function initColliderProxy() {
              if (CREATE_COLLIDER_PROXY.INITED) return;
              CREATE_COLLIDER_PROXY.INITED = true;

              CREATE_COLLIDER_PROXY[EColliderType.BOX] = function createBoxShape() {
                if (check(selector.wrapper.BoxShape, ECheckType.BoxCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.BoxShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.SPHERE] = function createSphereShape() {
                if (check(selector.wrapper.SphereShape, ECheckType.SphereCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.SphereShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CAPSULE] = function createCapsuleShape() {
                if (check(selector.wrapper.CapsuleShape, ECheckType.CapsuleCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.CapsuleShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CYLINDER] = function createCylinderShape() {
                if (check(selector.wrapper.CylinderShape, ECheckType.CylinderCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.CylinderShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CONE] = function createConeShape() {
                if (check(selector.wrapper.ConeShape, ECheckType.ConeCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.ConeShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.MESH] = function createTrimeshShape() {
                if (check(selector.wrapper.TrimeshShape, ECheckType.MeshCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.TrimeshShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.TERRAIN] = function createTerrainShape() {
                if (check(selector.wrapper.TerrainShape, ECheckType.TerrainCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.TerrainShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.SIMPLEX] = function createSimplexShape() {
                if (check(selector.wrapper.SimplexShape, ECheckType.SimplexCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.SimplexShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.PLANE] = function createPlaneShape() {
                if (check(selector.wrapper.PlaneShape, ECheckType.PlaneCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.PlaneShape();
              };
            }

            const CREATE_CONSTRAINT_PROXY = {
              INITED: false
            };
            const ENTIRE_CONSTRAINT = {
              impl: null,
              initialize: FUNC,
              onLoad: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setEnableCollision: FUNC,
              setConnectedBody: FUNC,
              setPivotA: FUNC,
              setPivotB: FUNC,
              setAxis: FUNC
            };
            function createConstraint(type) {
              initConstraintProxy();
              return CREATE_CONSTRAINT_PROXY[type]();
            }

            function initConstraintProxy() {
              if (CREATE_CONSTRAINT_PROXY.INITED) return;
              CREATE_CONSTRAINT_PROXY.INITED = true;

              CREATE_CONSTRAINT_PROXY[EConstraintType.POINT_TO_POINT] = function createPointToPointConstraint() {
                if (check(selector.wrapper.PointToPointConstraint, ECheckType.PointToPointConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.PointToPointConstraint();
              };

              CREATE_CONSTRAINT_PROXY[EConstraintType.HINGE] = function createHingeConstraint() {
                if (check(selector.wrapper.HingeConstraint, ECheckType.HingeConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.HingeConstraint();
              };

              CREATE_CONSTRAINT_PROXY[EConstraintType.CONE_TWIST] = function createConeTwistConstraint() {
                if (check(selector.wrapper.ConeTwistConstraint, ECheckType.ConeTwistConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.ConeTwistConstraint();
              };
            }

            var commonjsGlobal = exports('eI', typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {});

            function unwrapExports (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var bullet_cocos=createCommonjsModule(function(module,exports$1){(function(global,factory){{factory(exports$1);}})(typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:commonjsGlobal,function(_exports){Object.defineProperty(_exports,"__esModule",{value:true});_exports.default=void 0;function instantiate(A){for(var t1,t=new Uint8Array(123),f=25;0<=f;--f)t[48+f]=52+f,t[65+f]=f,t[97+f]=26+f;function c1(A,f,r){for(var e,i,a=0,n=f,o=r.length,b=f+(3*o>>2)-("="==r[o-2])-("="==r[o-1]);a<o;a+=4)e=t[r.charCodeAt(a+1)],i=t[r.charCodeAt(a+2)],A[n++]=t[r.charCodeAt(a)]<<2|e>>4,n<b&&(A[n++]=e<<4|i>>2),n<b&&(A[n++]=i<<6|t[r.charCodeAt(a+3)]);}t[43]=62,t[47]=63;var r=new ArrayBuffer(16),u1=new Int32Array(r),e=new Float32Array(r),i=new Float64Array(r);function k1(A,f){u1[A]=f;}function l1(){return i[0];}function s1(A){i[0]=A;}function v1(A){e[2]=A;}function d1(){return e[2];}return function(A){var r=A.memory,e=r.buffer;r.grow=b1;var p2=new Int8Array(e),$=new Int16Array(e),T2=new Int32Array(e),S2=new Uint8Array(e),A2=new Uint16Array(e),T=new Uint32Array(e),j2=new Float32Array(e),X=new Float64Array(e),P2=Math.imul,z2=Math.fround,O2=Math.abs,k=Math.clz32,F2=Math.min,H2=Math.max,R=Math.floor,_2=(Math.sqrt),j=A.abort,p=1/0,a=A.syncPhysicsToGraphics,i=A.fd_close,n=A.fd_write,o=A.fd_seek,L2=89792,z=0;function K2(A){var f=0,r=0,e=0,i=0,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0;L2=u=L2-16|0;A:{f:{r:{e:{i:{a:{n:{o:{b:{t:{c:{if(A>>>0<=236){if(3&(f=(a=T2[5296])>>>(r=(n=A>>>0<11?16:A+19&-16)>>>3|0)|0)){A=(i=T2[(f=(e=1^(r|1&f))<<3)+21232>>2])+8|0,(0|(r=T2[i+8>>2]))!=(0|(f=f+21224|0))?(T2[f+8>>2]=r,T2[r+12>>2]=f):(k=a1(e)&a,T2[21184>>2]=k),T2[i+4>>2]=3|(f=e<<3),T2[(f=f+i|0)+4>>2]=1|T2[f+4>>2];break A;}if(n>>>0<=(t=T2[5298])>>>0)break c;if(f){r=A=(f=(0-(A=(0-(A=2<<r)|A)&f<<r)&A)-1|0)>>>12&16,r|=A=(f=f>>>A|0)>>>5&8,r|=A=(f=f>>>A|0)>>>2&4,e=T2[(A=(r=((r|=A=(f=f>>>A|0)>>>1&2)|(A=(f=f>>>A|0)>>>1&1))+(f>>>A|0)|0)<<3)+21232>>2],(0|(f=T2[e+8>>2]))!=(0|(A=A+21224|0))?(T2[A+8>>2]=f,T2[f+12>>2]=A):(a=a1(r)&a,T2[5296]=a),A=e+8|0,T2[e+4>>2]=3|n,T2[(f=r<<3)+e>>2]=i=f-n|0,T2[(e=e+n|0)+4>>2]=1|i,t&&(r=21224+((f=t>>>3|0)<<3)|0,n=T2[5301],f=(f=1<<f)&a?T2[r+8>>2]:(T2[5296]=f|a,r),T2[f+12>>2]=n,T2[r+8>>2]=n,T2[n+12>>2]=r,T2[n+8>>2]=f),T2[5301]=e,T2[5298]=i;break A;}if(!(o=T2[5297]))break c;for(r=A=(f=(0-o&o)-1|0)>>>12&16,r|=A=(f=f>>>A|0)>>>5&8,r|=A=(f=f>>>A|0)>>>2&4,f=T2[21488+(((r|=A=(f=f>>>A|0)>>>1&2)|(A=(f=f>>>A|0)>>>1&1))+(f>>>A|0)<<2)>>2],e=(-8&T2[f+4>>2])-n|0,r=f;A=(A=T2[r+16>>2])||T2[r+20>>2];)e=(i=(r=(-8&T2[A+4>>2])-n|0)>>>0<e>>>0)?r:e,f=i?A:f,r=A;if(c=T2[f+24>>2],(0|(i=T2[f+12>>2]))!=(0|f)){A=T2[f+8>>2],T2[i+8>>2]=A,T2[A+12>>2]=i;break f;}if(!(A=T2[(r=f+20|0)>>2])){if(!(A=T2[f+16>>2]))break t;r=f+16|0;}for(;b=r,(A=T2[(r=(i=A)+20|0)>>2])||(r=i+16|0,A=T2[i+16>>2]););T2[b>>2]=0;break f;}if(n=-1,!(4294967231<A>>>0)&&(n=-16&(A=A+19|0),o=T2[5297])){r=0-n|0,(A=A>>>8|(b=0))&&(b=31,16777215<n>>>0||(A<<=f=A+1048320>>>16&8,b=28+((A=((A<<=a=A+520192>>>16&4)<<(e=A+245760>>>16&2)>>>15|0)-(e|f|a)|0)<<1|n>>>A+21&1)|0));u:{k:{if(e=T2[21488+(b<<2)>>2])for(f=n<<(31==(0|b)?0:25-(b>>>1|0)|0),A=0;;){if(!(r>>>0<=(a=(-8&T2[e+4>>2])-n|0)>>>0||(i=e,r=a))){r=0,A=e;break k;}if(a=T2[e+20>>2],e=T2[16+((f>>>29&4)+e|0)>>2],A=!a||(0|a)==(0|e)?A:a,f<<=0!=(0|e),!e)break;}else A=0;if(!(A|i)){if(!(A=(0-(A=2<<b)|A)&o))break c;e=A=(f=(A&0-A)-1|0)>>>12&16,e|=A=(f=f>>>A|0)>>>5&8,e|=A=(f=f>>>A|0)>>>2&4,A=T2[21488+(((e|=A=(f=f>>>A|0)>>>1&2)|(A=(f=f>>>A|0)>>>1&1))+(f>>>A|0)<<2)>>2];}if(!A)break u;}for(;r=(e=(f=(-8&T2[A+4>>2])-n|0)>>>0<r>>>0)?f:r,i=e?A:i,A=(f=T2[A+16>>2])||T2[A+20>>2];);}if(i&&!(T2[5298]-n>>>0<=r>>>0)){if(b=T2[i+24>>2],(0|i)!=(0|(f=T2[i+12>>2]))){A=T2[i+8>>2],T2[f+8>>2]=A,T2[A+12>>2]=f;break r;}if(!(A=T2[(e=i+20|0)>>2])){if(!(A=T2[i+16>>2]))break b;e=i+16|0;}for(;a=e,(A=T2[(e=(f=A)+20|0)>>2])||(e=f+16|0,A=T2[f+16>>2]););T2[a>>2]=0;break r;}}}if(n>>>0<=(r=T2[5298])>>>0){e=T2[5301],16<=(f=r-n|0)>>>0?(T2[(A=e+n|0)+4>>2]=1|f,T2[5298]=f,T2[5301]=A,T2[r+e>>2]=f,T2[e+4>>2]=3|n):(T2[e+4>>2]=3|r,T2[(A=r+e|0)+4>>2]=1|T2[A+4>>2],T2[5301]=0,T2[5298]=0),A=e+8|0;break A;}if(n>>>0<(o=T2[5299])>>>0){r=T2[5302],T2[(f=r+n|0)+4>>2]=1|(A=o-n|0),T2[5299]=A,T2[5302]=f,T2[r+4>>2]=3|n,A=r+8|0;break A;}if((r=(i=(f=b=n+71|(A=0))+(r=T2[5414]?T2[5416]:(T2[5417]=-1,T2[5418]=-1,T2[5415]=65536,T2[5416]=65536,T2[5414]=12+u&-16^1431655768,T2[5419]=0,T2[5407]=0,65536))|0)&(e=0-r|0))>>>0<=n>>>0){T2[5420]=48;break A;}if((f=T2[5406])&&!((a=(A=T2[5404])+r|0)>>>0<=f>>>0&&A>>>0<a>>>0)){A=0,T2[5420]=48;break A;}if(4&S2[21628])break a;c:{u:{if(a=T2[5302])for(A=21632;;){if(a>>>0<(f=T2[A>>2])+T2[A+4>>2]>>>0&&f>>>0<=a>>>0)break u;if(!(A=T2[A+8>>2]))break;}if(-1==(0|(f=l(0))))break n;if(a=r,(a=(A=(e=T2[5415])-1|0)&f?(r-f|0)+(A+f&0-e)|0:a)>>>0<=n>>>0)break n;if(2147483646<a>>>0)break n;if(e=T2[5406]){if((i=(A=T2[5404])+a|0)>>>0<=A>>>0)break n;if(e>>>0<i>>>0)break n;}if((0|f)!=(0|(A=l(a))))break c;break i;}if(2147483646<(a=e&i-o)>>>0)break n;if((0|(f=l(a)))==(T2[A>>2]+T2[A+4>>2]|0))break o;A=f;}if(f=A,!(n+72>>>0<=a>>>0||2147483646<a>>>0||-1==(0|f))){if(2147483646<(A=(A=T2[5416])+(b-a|0)&0-A)>>>0)break i;if(-1!=(0|l(A))){a=A+a|0;break i;}l(0-a|0);break n;}if(-1!=(0|f))break i;break n;}i=0;break f;}f=0;break r;}if(-1!=(0|f))break i;}T2[5407]=4|T2[5407];}if(2147483646<r>>>0)break e;if(f=l(r),(A=l(0))>>>0<=f>>>0)break e;if(-1==(0|f))break e;if(-1==(0|A))break e;if((a=A-f|0)>>>0<=n+56>>>0)break e;}A=T2[5404]+a|0,(T2[5404]=A)>>>0>T[5405]&&(T2[5405]=A);i:{a:{n:{if(o=T2[5302]){for(A=21632;;){if(((r=T2[A>>2])+(i=T2[A+4>>2])|0)==(0|f))break n;if(!(A=T2[A+8>>2]))break;}break a;}for((A=T2[5300])>>>0<=f>>>0&&A||(T2[5300]=f),A=0,T2[5409]=a,T2[5408]=f,T2[5304]=-1,T2[5305]=T2[5414],T2[5411]=0;T2[A+21232>>2]=r=A+21224|0,T2[A+21236>>2]=r,256!=(0|(A=A+8|0)););T2[(e=(A=f+8&15?-8-f&15:0)+f|0)+4>>2]=1|(A=(r=a-56|0)-A|0),T2[5303]=T2[5418],T2[5299]=A,T2[5302]=e,T2[4+(f+r|0)>>2]=56;break i;}if(!(8&S2[A+12|0])&&!(f>>>0<=o>>>0||o>>>0<r>>>0)){r=T2[5299]+a|0,T2[(e=(f=o+8&15?-8-o&15:0)+o|0)+4>>2]=1|(f=r-f|0),T2[A+4>>2]=i+a,T2[5303]=T2[5418],T2[5299]=f,T2[5302]=e,T2[4+(r+o|0)>>2]=56;break i;}}f>>>0<(i=T2[5300])>>>0&&(T2[5300]=f,i=0),r=f+a|0,A=21632;a:{n:{o:{b:{t:{c:{for(;(0|r)!=T2[A>>2];)if(!(A=T2[A+8>>2]))break c;if(!(8&S2[A+12|0]))break t;}for(A=21632;;){if((r=T2[A>>2])>>>0<=o>>>0&&o>>>0<(i=r+T2[A+4>>2]|0)>>>0)break b;A=T2[A+8>>2];}}if(T2[A>>2]=f,T2[A+4>>2]=T2[A+4>>2]+a,T2[(c=(f+8&15?-8-f&15:0)+f|0)+4>>2]=3|n,A=((f=r+(r+8&15?-8-r&15:0)|0)-c|0)-n|0,b=n+c|0,(0|f)==(0|o)){T2[5302]=b,A=T2[5299]+A|0,T2[5299]=A,T2[b+4>>2]=1|A;break n;}if(T2[5301]==(0|f)){T2[5301]=b,A=T2[5298]+A|0,T2[5298]=A,T2[b+4>>2]=1|A,T2[A+b>>2]=A;break n;}if(1==(3&(r=T2[f+4>>2]))){o=-8&r;t:if(r>>>0<=255)i=T2[f+8>>2],r=r>>>3|0,(0|(e=T2[f+12>>2]))!=(0|i)?(T2[e+8>>2]=i,T2[i+12>>2]=e):(k=T2[5296]&a1(r),T2[21184>>2]=k);else {if(t=T2[f+24>>2],(0|(a=T2[f+12>>2]))==(0|f)){if((n=T2[(e=f+20|0)>>2])||(n=T2[(e=f+16|0)>>2])){for(;r=e,(n=T2[(e=(a=n)+20|0)>>2])||(e=a+16|0,n=T2[a+16>>2]););T2[r>>2]=0;}else a=0;}else r=T2[f+8>>2],T2[a+8>>2]=r,T2[r+12>>2]=a;if(t){e=T2[f+28>>2];c:{if(T2[(r=21488+(e<<2)|0)>>2]==(0|f)){if(T2[r>>2]=a)break c;k=T2[5297]&a1(e),T2[21188>>2]=k;break t;}if(!(T2[t+(T2[t+16>>2]==(0|f)?16:20)>>2]=a))break t;}T2[a+24>>2]=t,(r=T2[f+16>>2])&&(T2[a+16>>2]=r,T2[r+24>>2]=a),(r=T2[f+20>>2])&&(T2[a+20>>2]=r,T2[r+24>>2]=a);}}f=f+o|0,A=A+o|0;}if(T2[f+4>>2]=-2&T2[f+4>>2],T2[A+b>>2]=A,T2[b+4>>2]=1|A,A>>>0<=255){f=21224+((A=A>>>3|0)<<3)|0,A=(r=T2[5296])&(A=1<<A)?T2[f+8>>2]:(T2[5296]=A|r,f),T2[A+12>>2]=b,T2[f+8>>2]=b,T2[b+12>>2]=f,T2[b+8>>2]=A;break n;}if((e=A>>>8|(f=0))&&(f=31,16777215<A>>>0||(f=e,f<<=e=e+1048320>>>16&8,f=28+((f=((f<<=n=f+520192>>>16&4)<<(i=f+245760>>>16&2)>>>15|0)-(i|e|n)|0)<<1|A>>>f+21&1)|0)),T2[(a=r=b)+28>>2]=f,T2[r+16>>2]=0,n=21488+(f<<2)|(T2[r+20>>2]=0),!((i=T2[5297])&(e=1<<f))){T2[n>>2]=r,T2[5297]=e|i,T2[r+24>>2]=n,T2[r+8>>2]=r,T2[r+12>>2]=r;break n;}for(e=A<<(31==(0|f)?0:25-(f>>>1|0)|0),f=T2[n>>2];;){if((-8&T2[(i=f)+4>>2])==(0|A))break o;if(f=e>>>29|0,e<<=1,!(f=T2[(n=16+(i+(4&f)|0)|0)>>2]))break;}T2[n>>2]=r,T2[r+24>>2]=i,T2[r+12>>2]=r,T2[r+8>>2]=r;break n;}for(T2[(e=(r=f+8&15?-8-f&15:0)+f|0)+4>>2]=1|(r=(A=a-56|0)-r|0),T2[4+(A+f|0)>>2]=56,T2[(b=(A=(i+(i-55&15?55-i&15:0)|0)-63|0)>>>0<o+16>>>0?o:A)+4>>2]=35,T2[5303]=T2[5418],T2[5299]=r,T2[5302]=e,A=T2[5411],T2[(r=b+16|0)>>2]=T2[5410],T2[r+4>>2]=A,A=T2[5409],T2[b+8>>2]=T2[5408],T2[b+12>>2]=A,T2[5410]=b+8,T2[5409]=a,T2[5408]=f,A=b+36|(T2[5411]=0);T2[A>>2]=7,(A=A+4|0)>>>0<i>>>0;);if((0|o)==(0|b))break i;if(T2[b+4>>2]=-2&T2[b+4>>2],T2[b>>2]=a=b-o|0,T2[o+4>>2]=1|a,a>>>0<=255){f=21224+((A=a>>>3|0)<<3)|0,A=(r=T2[5296])&(A=1<<A)?T2[f+8>>2]:(T2[5296]=A|r,f),T2[A+12>>2]=o,T2[f+8>>2]=o,T2[o+12>>2]=f,T2[o+8>>2]=A;break i;}if(T2[o+16>>2]=0,(f=a>>>8|(A=T2[o+20>>2]=0))&&(A=31,16777215<a>>>0||(A=f,A<<=f=f+1048320>>>16&8,A=28+((A=((A<<=i=A+520192>>>16&4)<<(e=A+245760>>>16&2)>>>15|0)-(e|f|i)|0)<<1|a>>>A+21&1)|0)),e=21488+((T2[(r=o+28|0)>>2]=A)<<2)|0,!((r=T2[5297])&(f=1<<A))){T2[e>>2]=o,T2[5297]=f|r,T2[o+24>>2]=e,T2[o+8>>2]=o,T2[o+12>>2]=o;break i;}for(A=a<<(31==(0|A)?0:25-(A>>>1|0)|0),f=T2[e>>2];;){if((0|a)==(-8&T2[(r=f)+4>>2]))break a;if(f=A>>>29|0,A<<=1,!(f=T2[(e=16+(r+(4&f)|0)|0)>>2]))break;}T2[e>>2]=o,T2[o+24>>2]=r,T2[o+12>>2]=o,T2[o+8>>2]=o;break i;}A=T2[i+8>>2],T2[i+8>>2]=r,T2[A+12>>2]=r,T2[r+24>>2]=0,T2[r+8>>2]=A,T2[r+12>>2]=i;}A=c+8|0;break A;}A=T2[r+8>>2],T2[r+8>>2]=o,T2[A+12>>2]=o,T2[o+24>>2]=0,T2[o+8>>2]=A,T2[o+12>>2]=r;}if(!((A=T2[5299])>>>0<=n>>>0)){r=T2[5302],T2[(f=r+n|0)+4>>2]=1|(A=A-n|0),T2[5299]=A,T2[5302]=f,T2[r+4>>2]=3|n,A=r+8|0;break A;}}A=0,T2[5420]=48;break A;}r:if(b){e=T2[i+28>>2];e:{if(T2[(A=21488+(e<<2)|0)>>2]==(0|i)){if(T2[A>>2]=f)break e;o=a1(e)&o,T2[5297]=o;break r;}if(!(T2[b+(T2[b+16>>2]==(0|i)?16:20)>>2]=f))break r;}T2[f+24>>2]=b,(A=T2[i+16>>2])&&(T2[f+16>>2]=A,T2[A+24>>2]=f),(A=T2[i+20>>2])&&(T2[f+20>>2]=A,T2[A+24>>2]=f);}r:if(r>>>0<=15)T2[i+4>>2]=3|(A=r+n|0),T2[(A=A+i|0)+4>>2]=1|T2[A+4>>2];else if(T2[(e=i+n|0)+4>>2]=1|r,T2[i+4>>2]=3|n,(T2[r+e>>2]=r)>>>0<=255)f=21224+((A=r>>>3|0)<<3)|0,A=(r=T2[5296])&(A=1<<A)?T2[f+8>>2]:(T2[5296]=A|r,f),T2[A+12>>2]=e,T2[f+8>>2]=e,T2[e+12>>2]=f,T2[e+8>>2]=A;else if(f=e,(e=r>>>8|(A=0))&&(A=31,16777215<r>>>0||(A=e,A<<=e=e+1048320>>>16&8,A=28+((A=((A<<=a=A+520192>>>16&4)<<(n=A+245760>>>16&2)>>>15|0)-(n|e|a)|0)<<1|r>>>A+21&1)|0)),T2[(b=f)+28>>2]=A,T2[f+16>>2]=0,n=21488+(A<<2)|(T2[f+20>>2]=0),(e=1<<A)&o){A=r<<(31==(0|A)?0:25-(A>>>1|0)|0),n=T2[n>>2];e:{for(;;){if((-8&T2[(e=n)+4>>2])==(0|r))break e;if(n=A>>>29|0,A<<=1,!(n=T2[(a=16+(e+(4&n)|0)|0)>>2]))break;}T2[a>>2]=f,T2[f+24>>2]=e,T2[f+12>>2]=f,T2[f+8>>2]=f;break r;}A=T2[e+8>>2],T2[e+8>>2]=f,T2[A+12>>2]=f,T2[f+24>>2]=0,T2[f+8>>2]=A,T2[f+12>>2]=e;}else T2[n>>2]=f,T2[5297]=e|o,T2[f+24>>2]=n,T2[f+8>>2]=f,T2[f+12>>2]=f;A=i+8|0;break A;}f:if(c){r=T2[f+28>>2];r:{if(T2[(A=21488+(r<<2)|0)>>2]==(0|f)){if(T2[A>>2]=i)break r;k=a1(r)&o,T2[21188>>2]=k;break f;}if(!(T2[c+(T2[c+16>>2]==(0|f)?16:20)>>2]=i))break f;}T2[i+24>>2]=c,(A=T2[f+16>>2])&&(T2[i+16>>2]=A,T2[A+24>>2]=i),(A=T2[f+20>>2])&&(T2[i+20>>2]=A,T2[A+24>>2]=i);}e>>>0<=15?(T2[f+4>>2]=3|(A=e+n|0),T2[(A=A+f|0)+4>>2]=1|T2[A+4>>2]):(T2[(i=f+n|0)+4>>2]=1|e,T2[f+4>>2]=3|n,T2[e+i>>2]=e,t&&(r=21224+((A=t>>>3|0)<<3)|0,n=T2[5301],A=(A=1<<A)&a?T2[r+8>>2]:(T2[5296]=A|a,r),T2[A+12>>2]=n,T2[r+8>>2]=n,T2[n+12>>2]=r,T2[n+8>>2]=A),T2[5301]=i,T2[5298]=e),A=f+8|0;}return L2=16+u|0,A;}function q2(A){var f=0,r=0,e=0,i=0,a=0,n=0,o=0,b=0;A:if(A){a=(r=A-8|0)+(i=-8&(A=T2[A-4>>2]))|0;f:if(!(1&A)){if(!(3&A))break A;if((r=r-(A=T2[r>>2])|0)>>>0<T[5300])break A;if(i=A+i|0,T2[5301]==(0|r)){if(3==(3&(A=T2[a+4>>2]))){T2[a+4>>2]=-2&A,T2[5298]=i,T2[r+i>>2]=i,T2[r+4>>2]=1|i;break A;}}else if(A>>>0<=255)e=A>>>3|0,A=T2[r+8>>2],(0|(f=T2[r+12>>2]))!=(0|A)?(T2[f+8>>2]=A,T2[A+12>>2]=f):(b=T2[5296]&a1(e),T2[21184>>2]=b);else {if(o=T2[r+24>>2],(0|r)==(0|(A=T2[r+12>>2]))){if((e=T2[(f=r+20|0)>>2])||(e=T2[(f=r+16|0)>>2])){for(;n=f,(e=T2[(f=(A=e)+20|0)>>2])||(f=A+16|0,e=T2[A+16>>2]););T2[n>>2]=0;}else A=0;}else f=T2[r+8>>2],T2[A+8>>2]=f,T2[f+12>>2]=A;if(o){f=T2[r+28>>2];r:{if(T2[(e=21488+(f<<2)|0)>>2]==(0|r)){if(T2[e>>2]=A)break r;b=T2[5297]&a1(f),T2[21188>>2]=b;break f;}if(!(T2[o+(T2[o+16>>2]==(0|r)?16:20)>>2]=A))break f;}T2[A+24>>2]=o,(f=T2[r+16>>2])&&(T2[A+16>>2]=f,T2[f+24>>2]=A),(f=T2[r+20>>2])&&(T2[A+20>>2]=f,T2[f+24>>2]=A);}}}if(!(a>>>0<=r>>>0)&&1&(A=T2[a+4>>2])){f:{if(!(2&A)){if(T2[5302]==(0|a)){if(T2[5302]=r,A=T2[5299]+i|0,T2[5299]=A,T2[r+4>>2]=1|A,T2[5301]!=(0|r))break A;T2[5298]=0,T2[5301]=0;break A;}if(T2[5301]==(0|a)){T2[5301]=r,A=T2[5298]+i|0,T2[5298]=A,T2[r+4>>2]=1|A,T2[A+r>>2]=A;break A;}i=(-8&A)+i|0;r:if(A>>>0<=255)A=A>>>3|0,(0|(e=T2[a+8>>2]))!=(0|(f=T2[a+12>>2]))?(T2[f+8>>2]=e,T2[e+12>>2]=f):(b=T2[5296]&a1(A),T2[21184>>2]=b);else {if(o=T2[a+24>>2],(0|a)==(0|(A=T2[a+12>>2]))){if((e=T2[(f=a+20|0)>>2])||(e=T2[(f=a+16|0)>>2])){for(;n=f,(e=T2[(f=(A=e)+20|0)>>2])||(f=A+16|0,e=T2[A+16>>2]););T2[n>>2]=0;}else A=0;}else f=T2[a+8>>2],T2[A+8>>2]=f,T2[f+12>>2]=A;if(o){f=T2[a+28>>2];e:{if(T2[(e=21488+(f<<2)|0)>>2]==(0|a)){if(T2[e>>2]=A)break e;b=T2[5297]&a1(f),T2[21188>>2]=b;break r;}if(!(T2[o+(T2[o+16>>2]==(0|a)?16:20)>>2]=A))break r;}T2[A+24>>2]=o,(f=T2[a+16>>2])&&(T2[A+16>>2]=f,T2[f+24>>2]=A),(f=T2[a+20>>2])&&(T2[A+20>>2]=f,T2[f+24>>2]=A);}}if(T2[r+i>>2]=i,T2[r+4>>2]=1|i,T2[5301]!=(0|r))break f;T2[5298]=i;break A;}T2[a+4>>2]=-2&A,T2[r+i>>2]=i,T2[r+4>>2]=1|i;}if(i>>>0<=255)A=21224+((f=i>>>3|0)<<3)|0,f=(e=T2[5296])&(f=1<<f)?T2[A+8>>2]:(T2[5296]=f|e,A),T2[f+12>>2]=r,T2[A+8>>2]=r,T2[r+12>>2]=A,T2[r+8>>2]=f;else {T2[r+16>>2]=0,(f=i>>>8|(A=T2[r+20>>2]=0))&&(A=31,16777215<i>>>0||(A=28+((A=((a=(f<<=n=f+1048320>>>16&8)<<(A=f+520192>>>16&4))<<(f=a+245760>>>16&2)>>>15|0)-(f|A|n)|0)<<1|i>>>A+21&1)|0)),e=21488+((T2[(e=r+28|0)>>2]=A)<<2)|0;f:if((f=T2[5297])&(n=1<<A)){f=i<<(31==(0|A)?0:25-(A>>>1|0)|0),A=T2[e>>2];r:{for(;;){if((-8&T2[(e=A)+4>>2])==(0|i))break r;if(A=f>>>29|0,f<<=1,!(A=T2[(n=16+(e+(4&A)|0)|0)>>2]))break;}T2[n>>2]=r,T2[r+24>>2]=e,T2[r+12>>2]=r,T2[r+8>>2]=r;break f;}A=T2[e+8>>2],T2[e+8>>2]=r,T2[A+12>>2]=r,T2[r+24>>2]=0,T2[r+8>>2]=A,T2[r+12>>2]=e;}else T2[e>>2]=r,T2[5297]=f|n,T2[r+24>>2]=e,T2[r+8>>2]=r,T2[r+12>>2]=r;if(A=T2[5304]-1|0,!(T2[5304]=A)){for(r=21640;r=(A=T2[r>>2])+8|0,A;);T2[5304]=-1;}}}}}function l(A){return A?65535&A||(0|A)<=-1?void j():-1==(0|(A=b1(A>>>16|0)))?(T2[5420]=48,-1):A<<16:o1()<<16;}function t(A){var f,r=0,e=0;if(r=(r=T2[5421])||(T2[5421]=21692),32==(0|(e=T2[5422]))){if((f=K2(260))&&3&S2[f-4|0]&&d2(f,0,260),!f)return;e=0,T2[5421]=f,T2[f>>2]=r,T2[5422]=0,r=f;}T2[5422]=e+1,T2[(r=(e<<2)+r|0)+132>>2]=0,T2[r+4>>2]=A;}function d2(A,f,r){var e,i,a,n;if(r&&(p2[0|A]=f,p2[(e=A+r|0)-1|0]=f,!(r>>>0<3||(p2[A+2|0]=f,p2[A+1|0]=f,p2[e-3|0]=f,p2[e-2|0]=f,r>>>0<7||(p2[A+3|0]=f,p2[e-4|0]=f,r>>>0<9||(a=(e=0-A&3)+A|0,f=P2(255&f,16843009),T2[a>>2]=f,T2[(e=(r=r-e&-4)+a|0)-4>>2]=f,r>>>0<9||(T2[8+a>>2]=f,T2[4+a>>2]=f,T2[e-8>>2]=f,T2[e-12>>2]=f,r>>>0<25||(T2[24+a>>2]=f,T2[20+a>>2]=f,T2[16+a>>2]=f,T2[12+a>>2]=f,T2[e-16>>2]=f,T2[e-20>>2]=f,T2[e-24>>2]=f,T2[e-28>>2]=f,(r=r-(i=4&a|24)|0)>>>0<32))))))))for(n=e=f,f=a+i|0;T2[f>>2]=n,T2[f+4>>2]=e,T2[(i=f+24|0)>>2]=n,T2[4+i>>2]=e,T2[(i=f+16|0)>>2]=n,T2[4+i>>2]=e,T2[(i=f+8|0)>>2]=n,T2[4+i>>2]=e,f=f+32|0,31<(r=r-32|0)>>>0;);return A;}function $2(A,f,r){var e=0,i=0,a=0,n=0,o=0,b=0,t=0;A:if(r&&3&f)for(;;){if(p2[0|A]=S2[0|f],e=r-1|0,A=A+1|0,f=f+1|0,1==(0|r))break A;if(r=e,!(3&f))break;}else e=r;A:{if(!(r=3&A)){if(e>>>0<16)r=e;else for(r=e-16|0;T2[A>>2]=T2[f>>2],T2[A+4>>2]=T2[f+4>>2],T2[A+8>>2]=T2[f+8>>2],T2[A+12>>2]=T2[f+12>>2],A=A+16|0,f=f+16|0,15<(e=e-16|0)>>>0;);if(8&r&&(e=T2[f+4>>2],T2[A>>2]=T2[f>>2],T2[A+4>>2]=e,f=f+8|0,A=A+8|0),4&r&&(T2[A>>2]=T2[f>>2],f=f+4|0,A=A+4|0),2&r&&(p2[0|A]=S2[0|f],p2[A+1|0]=S2[f+1|0],f=f+2|0,A=A+2|0),!(1&r))break A;return void(p2[0|A]=S2[0|f]);}f:if(!(e>>>0<32||2<(r=r-1|0)>>>0)){r:switch(r-1|0){default:for(p2[A+1|0]=S2[f+1|0],i=T2[f>>2],p2[0|A]=i,p2[A+2|0]=S2[f+2|0],o=e-3|0,b=A+3|0,t=e-20&-16,r=0;a=T2[(n=f+r|0)+4>>2],T2[(A=r+b|0)>>2]=a<<8|i>>>24,i=T2[n+8>>2],T2[A+4>>2]=i<<8|a>>>24,a=T2[n+12>>2],T2[A+8>>2]=a<<8|i>>>24,i=T2[n+16>>2],T2[A+12>>2]=i<<8|a>>>24,r=r+16|0,16<(o=o-16|0)>>>0;);A=r+b|0,f=3+(f+r|0)|0,e=(e-t|0)-19|0;break f;case 0:for(i=T2[f>>2],p2[0|A]=i,p2[A+1|0]=S2[f+1|0],o=e-2|0,b=A+2|0,t=e-20&-16,r=0;a=T2[(n=f+r|0)+4>>2],T2[(A=r+b|0)>>2]=a<<16|i>>>16,i=T2[n+8>>2],T2[A+4>>2]=i<<16|a>>>16,a=T2[n+12>>2],T2[A+8>>2]=a<<16|i>>>16,i=T2[n+16>>2],T2[A+12>>2]=i<<16|a>>>16,r=r+16|0,17<(o=o-16|0)>>>0;);A=r+b|0,f=2+(f+r|0)|0,e=(e-t|0)-18|0;break f;case 1:break r;}for(i=T2[f>>2],p2[0|A]=i,o=e-1|0,b=A+1|0,t=e-20&-16,r=0;a=T2[(n=f+r|0)+4>>2],T2[(A=r+b|0)>>2]=a<<24|i>>>8,i=T2[n+8>>2],T2[A+4>>2]=i<<24|a>>>8,a=T2[n+12>>2],T2[A+8>>2]=a<<24|i>>>8,i=T2[n+16>>2],T2[A+12>>2]=i<<24|a>>>8,r=r+16|0,18<(o=o-16|0)>>>0;);A=r+b|0,f=1+(f+r|0)|0,e=(e-t|0)-17|0;}16&e&&(r=S2[0|f]|S2[f+1|0]<<8,p2[0|A]=r,p2[A+1|0]=r>>>8,p2[A+2|0]=S2[f+2|0],p2[A+3|0]=S2[f+3|0],p2[A+4|0]=S2[f+4|0],p2[A+5|0]=S2[f+5|0],p2[A+6|0]=S2[f+6|0],p2[A+7|0]=S2[f+7|0],p2[A+8|0]=S2[f+8|0],p2[A+9|0]=S2[f+9|0],p2[A+10|0]=S2[f+10|0],p2[A+11|0]=S2[f+11|0],p2[A+12|0]=S2[f+12|0],p2[A+13|0]=S2[f+13|0],p2[A+14|0]=S2[f+14|0],p2[A+15|0]=S2[f+15|0],f=f+16|0,A=A+16|0),8&e&&(p2[0|A]=S2[0|f],p2[A+1|0]=S2[f+1|0],p2[A+2|0]=S2[f+2|0],p2[A+3|0]=S2[f+3|0],p2[A+4|0]=S2[f+4|0],p2[A+5|0]=S2[f+5|0],p2[A+6|0]=S2[f+6|0],p2[A+7|0]=S2[f+7|0],f=f+8|0,A=A+8|0),4&e&&(p2[0|A]=S2[0|f],p2[A+1|0]=S2[f+1|0],p2[A+2|0]=S2[f+2|0],p2[A+3|0]=S2[f+3|0],f=f+4|0,A=A+4|0),2&e&&(p2[0|A]=S2[0|f],p2[A+1|0]=S2[f+1|0],f=f+2|0,A=A+2|0),1&e&&(p2[0|A]=S2[0|f]);}}function b(A){var f,r,e,i=0,a=(0),n=0;v1(A);A:{if(1283457024<=(i=2147483647&(n=u1[2]))>>>0){if(A!=A)break A;return z2((0|n)<0?-1.570796251296997:1.570796251296997);}f:{if(i>>>0<=1054867455){if(a=-1,964689920<=i>>>0)break f;break A;}A=z2(O2(A)),i>>>0<=1066926079?a=i>>>0<=1060110335?(A=z2(z2(z2(A+A)+z2(-1))/z2(A+z2(2))),0):(A=z2(z2(A+z2(-1))/z2(A+z2(1))),1):a=i>>>0<=1075576831?(A=z2(z2(A+z2(-1.5))/z2(z2(A*z2(1.5))+z2(1))),2):(A=z2(z2(-1)/A),3);}if(i=a,r=z2(A*A),f=z2(r*r),e=z2(f*z2(z2(f*z2(-.106480173766613))+z2(-.19999158382415771))),f=z2(r*z2(z2(f*z2(z2(f*z2(.06168760731816292))+z2(.14253635704517365)))+z2(.333333283662796))),(0|i)<=-1)return z2(A-z2(A*z2(e+f)));A=z2(j2[(i<<=2)+1024>>2]-z2(z2(z2(A*z2(e+f))-j2[i+1040>>2])-A)),A=(0|n)<0?z2(-A):A;}return A;}function B2(A,f){var r,e,i,a=0,n=0,o=z2(0);if(!(f==f&A==A))return z2(A+f);if(v1(f),1065353216==(0|(a=u1[2])))return b(A);i=a>>>30&2,v1(A),r=i|(n=u1[2])>>>31;A:{f:{r:{e:{if(!(e=2147483647&n)){i:switch(r-2|0){case 0:break e;case 1:break i;default:break r;}return z2(-3.1415927410125732);}if(2139095040!=(0|(a&=2147483647))){if(!a)break A;if(!(e>>>0<=218103808+a>>>0&&2139095040!=(0|e)))break A;if(A=o=!(218103808+e>>>0<a>>>0&&(o=z2(0),i))?b(z2(O2(z2(A/f)))):o,r>>>0<=2){i:switch(r-1|0){case 0:return z2(-A);case 1:break i;default:break r;}return z2(z2(3.1415927410125732)-z2(A+z2(8.742277657347586e-8)));}return z2(z2(A+z2(8.742277657347586e-8))+z2(-3.1415927410125732));}if(2139095040==(0|e))break f;return j2[1072+(r<<2)>>2];}A=z2(3.1415927410125732);}return A;}return j2[1056+(r<<2)>>2];}return z2((0|n)<0?-1.5707963705062866:1.5707963705062866);}function c(A){var f=0;for(T2[12+(L2=f=L2-16|0)>>2]=A,T2[12+f>>2]||(T2[12+f>>2]=1);A=K2(T2[12+f>>2]),!(T2[8+f>>2]=A)&&(T2[(A=L2-16|0)+12>>2]=21952,T2[A+8>>2]=2,T2[4+f>>2]=T2[T2[A+12>>2]>>2],T2[4+f>>2]);)n1[T2[4+f>>2]]();return L2=16+f|0,T2[8+f>>2];}function u(A){var f=0;T2[12+(L2=f=L2-16|0)>>2]=A,q2(T2[12+f>>2]),L2=16+f|0;}function s(A,f,r){var e=0,i=0;return L2=e=L2-16|0,(0|r)<=(i=-1)?T2[5420]=28:(A=0|n(0|A,0|f,0|r,12+e|0))?T2[5420]=A:i=T2[12+e>>2],L2=16+e|0,i;}function v(A){var f=0,f=T2[A+60>>2];if(T2[A+60>>2]=f-1|f,8&(f=T2[A>>2]))return T2[A>>2]=32|f,1;T2[A+4>>2]=0,T2[A+8>>2]=0,f=T2[A+40>>2],T2[A+24>>2]=f,T2[A+20>>2]=f,T2[A+16>>2]=f+T2[A+44>>2];}function S(A,f,r){var e,i=0,a=0,n=0,o=0;A:{if(!(i=T2[r+16>>2])){if(v(r))break A;i=T2[r+16>>2];}if(i-(n=T2[r+20>>2])>>>0<f>>>0)return void n1[T2[r+32>>2]](r,A,f);f:if(!(T2[r+64>>2]<0)){for(i=A;;){if((0|f)==(0|a))break f;if(a=a+1|0,e=f+i|0,i=o=i-1|0,10==S2[e-1|0])break;}if(n1[T2[r+32>>2]](r,i=A,A=1+(f-a|0)|0)>>>0<A>>>0)break A;A=1+(f+o|0)|0,n=T2[r+20>>2],f=a-1|0;}$2(n,A,f),T2[r+20>>2]=T2[r+20>>2]+f;}}function P(A,f){if(!A)return 0;if(A){A:if(f>>>0<=127)p2[0|A]=f,A=1;else {f:{if(!T2[5491]){if(57216!=(-128&f))break f;p2[0|A]=f,A=1;break A;}if(f>>>0<=2047){p2[A+1|0]=63&f|128,p2[0|A]=f>>>6|192,A=2;break A;}if(!(57344!=(-8192&f)&&55296<=f>>>0)){p2[A+2|0]=63&f|128,p2[0|A]=f>>>12|224,p2[A+1|0]=f>>>6&63|128,A=3;break A;}if(f-65536>>>0<=1048575){p2[A+3|0]=63&f|128,p2[0|A]=f>>>18|240,p2[A+2|0]=f>>>6&63|128,p2[A+1|0]=f>>>12&63|128,A=4;break A;}}T2[5420]=25,A=-1;}}else A=1;return A;}function f(A,f,r){var e,i=0,a=0;if(T2[204+(L2=i=L2-208|0)>>2]=r,T2[(e=192+i|0)>>2]=0,T2[4+e>>2]=0,T2[(e=184+i|0)>>2]=0,T2[4+e>>2]=0,T2[(e=176+i|0)>>2]=0,T2[4+e>>2]=0,T2[168+i>>2]=0,T2[172+i>>2]=0,T2[160+i>>2]=0,T2[164+i>>2]=0,T2[200+i>>2]=r,0<=(0|d(0,f,200+i|0,80+i|0,160+i|0))){e=T2[A>>2],T2[A+60>>2]<=0&&(T2[A>>2]=-33&e);A:{f:{if(T2[A+44>>2]){if(T2[A+16>>2])break f;}else T2[A+44>>2]=80,T2[A+24>>2]=0,T2[A+16>>2]=0,T2[A+20>>2]=0,a=T2[A+40>>2],T2[A+40>>2]=i;if(v(A))break A;}d(A,f,200+i|0,80+i|0,160+i|0);}a&&(n1[T2[A+32>>2]](A,0,0),T2[A+44>>2]=0,T2[A+40>>2]=a,T2[A+24>>2]=0,T2[A+16>>2]=0,T2[A+20>>2]=0),T2[A>>2]=T2[A>>2]|32&e;}L2=208+i|0;}function d(A,f,r,e,i){var a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0,l=0,s=0,v=0,d=0,B=0,Q=0,g=0,w=0,G=0,C=0,E=0,D=0,h=0,Z=0,Y=0,R=0,F=0,W=0,m=0,N=336+(L2=u=L2-880|0)|8,V=55+u|0,J=-338-u|0,M=336+u|9,I=656+u|0,x=336+u|0,y=-336-u|0,U=56+u|0;A:{f:{r:for(;;){e:if(b=f,!((2147483647-G|0)<(0|a))){G=a+G|0;i:{a:{n:{if(a=S2[0|b])for(;;){o:{b:if(a&=255){if(37!=(0|a))break o;for(a=n=f;;){if(37!=S2[a+1|0]){f=a;break b;}if(n=n+1|0,o=S2[a+2|0],a=f=a+2|0,37!=(0|o))break;}}else n=f;if((0|(C=2147483647-G|0))<(0|(a=n-b|0)))break e;if(A&&(32&S2[0|A]||S(b,a,A)),a)continue r;o=-1,9<(c=(t=p2[a=f+1|0])-48|0)>>>0||(a=(n=36==S2[f+2|0])?f+3|0:a,Z=n?1:Z,t=p2[(n?3:1)+f|0],o=n?c:-1);b:if(31<(f=t-32|(n=0))>>>0)f=a;else if(75913&(k=1<<f))for(;;){if(n|=k,31<(c=(t=p2[f=a+1|0])-32|0)>>>0)break b;if(a=f,!(75913&(k=1<<c)))break;}else f=a;b:if(42!=(0|t)){if(9<(k=t-48|(v=0))>>>0)c=f;else {for(a=0;v=-1,t=p2[f+1|0],f=c=f+1|0,a=v=a>>>0<=214748364?(2147483647-(a=P2(a,10))|0)<(0|k)?-1:a+k|0:v,(k=t-48|0)>>>0<10;);if((0|v)<0)break e;}}else {if(9<(a=p2[f+1|0]-48|0)>>>0||36!=S2[f+2|0]){if(Z)break n;if(c=f+1|0,!A){v=Z=0;break b;}f=T2[r>>2],T2[r>>2]=f+4,Z=0,v=T2[f>>2];}else T2[(a<<2)+i>>2]=10,c=f+3|0,v=T2[((p2[f+(Z=1)|0]<<3)+e|0)-384>>2];-1<(0|v)||(v=0-v|0,n|=8192);}if(t=-1,46==S2[(a=0)|c]){if(42!=(0|(t=p2[c+1|0]))){if(f=c+1|0,9<(s=t-48|0)>>>0)g=1,t=0;else for(c=0,k=f;t=-1,c>>>0<=214748364&&(t=(2147483647-(f=P2(c,10))|0)<(0|s)?-1:f+s|0),l=p2[k+(g=1)|0],k=f=k+1|0,c=t,(s=l-48|0)>>>0<10;);}else {if(9<(f=p2[c+2|0]-48|0)>>>0||36!=S2[c+3|0]){if(Z)break n;f=c+2|0,t=0,A&&(c=T2[r>>2],T2[r>>2]=c+4,t=T2[c>>2]);}else T2[(f<<2)+i>>2]=10,f=c+4|0,t=T2[((p2[c+2|0]<<3)+e|0)-384>>2];g=(-1^t)>>>31|0;}}else f=c,g=0;for(;;){if(k=a,57<(a=p2[0|f]-65|0)>>>0)break n;if(f=f+1|0,!((a=S2[2816+(a+P2(k,58)|0)|0])-1>>>0<8))break;}if(!a)break n;b:{t:{c:{if(27==(0|a)){if((0|o)<=-1)break c;break n;}if((0|o)<0)break t;T2[(o<<2)+i>>2]=a,o=T2[(a=(o<<3)+e|0)+4>>2],T2[56+u>>2]=T2[a>>2],T2[60+u>>2]=o;}if(a=0,!A)continue r;break b;}if(!A){G=0;break A;}O(56+u|0,a,r);}o=-65537&n,d=8192&n?o:n;b:{t:{c:if(a=p2[f-1|0],!(55<(a=(c=k&&3==(15&a)?-33&a:a)-65|0)>>>0)){u:{k:{l:{s:{v:{d:{B:{Q:{g:{w:{G:{C:switch(a-1|0){case 51:l=0,k=T2[56+u>>2],a=T2[60+u>>2],s=2790;break G;case 44:if(7<(n=255&k)>>>(a=0))continue r;E:switch(n-1|0){default:case 0:T2[T2[56+u>>2]>>2]=G;continue r;case 1:n=T2[56+u>>2],T2[n>>2]=G,T2[n+4>>2]=G>>31;continue r;case 2:$[T2[56+u>>2]>>1]=G;continue r;case 3:p2[T2[56+u>>2]]=G;continue r;case 5:T2[T2[56+u>>2]>>2]=G;continue r;case 4:continue r;case 6:break E;}n=T2[56+u>>2],T2[n>>2]=G,T2[n+4>>2]=G>>31;continue r;case 46:t=8<t>>>0?t:8,d|=8,c=120;case 22:case 54:if(l=0,s=2790,!((a=n=T2[60+u>>2])|(k=T2[56+u>>2]))){b=U;break w;}for(o=32&c,b=U;p2[0|(b=b-1|0)]=o|S2[3424+(15&k)|0],(k=(15&(n=a))<<28|k>>>4)|(a=a>>>4|0););if(!(8&d))break w;if(!(T2[56+u>>2]|T2[60+u>>2]))break w;s=2790+(c>>4)|0,l=2;break w;case 45:if(b=U,(a=n=T2[60+u>>2])|(k=T2[56+u>>2]))for(;p2[0|(b=b-1|0)]=7&k|48,(k=(7&(n=a))<<29|k>>>3)|(a=a>>>3|0););if(l=0,s=2790,!(8&d))break w;t=(0|(a=U-b|0))<(0|t)?t:a+1|0;break w;case 0:case 2:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:case 16:case 18:case 19:case 20:case 21:case 23:case 24:case 25:case 26:case 27:case 28:case 29:case 30:case 32:case 38:case 40:case 41:case 42:case 47:case 48:case 50:case 52:case 53:break c;case 1:break s;case 17:break v;case 49:break B;case 43:break Q;case 33:break g;case 34:case 39:break C;default:break u;}n=T2[60+u>>2],k=T2[56+u>>2],(0|(a=n))<-1||(0|a)<=-1?(a=0-((0!=(0|k))+a|0)|0,T2[56+u>>2]=k=0-k|0,T2[60+u>>2]=a,l=1,s=2790):s=2048&d?(l=1,2791):(l=1&d)?2792:2790;}if(a>>>0<1)n=k,b=U;else for(b=U;W=b=b-1|0,m=k-e1(n=i1(k,a,10),o=c=z,10,0)|48,p2[0|W]=m,c=9<a>>>0,k=n,a=o,c;);if(a=n)for(;p2[0|(b=b-1|0)]=a-P2(n=(a>>>0)/10|0,10)|48,o=9<a>>>0,a=n,o;);}if((0|t)<0&&g)break e;if(d=g?-65537&d:d,a=T2[56+u>>2],n=T2[60+u>>2],!(t||a|n)){a=b=U,t=0;break i;}t=(0|(a=!(a|n)+(U-b|0)|0))<(0|t)?t:a;break t;}p2[55+u|0]=T2[56+u>>2],l=0,s=2790,t=1,b=V,a=U,d=o;break i;}b=T2[5420],a=0,T2[5497]||(T2[5497]=21964);Q:{g:{for(;(0|b)!=S2[a+1136|0];)if((n=77)==(0|(a=a+1|0)))break g;if(!(n=a)){b=1216;break Q;}}for(a=1216;c=S2[0|a],a=b=a+1|0,c||(a=b,n=n-1|0););}break d;}b=(a=T2[56+u>>2])||2800;}c=s=b,d=(l=0)!=(0|(n=g=(0|t)<0?2147483647:t));d:{B:{Q:{g:if(n){if(3&c)for(;;){if(!S2[0|c]){a=n;break Q;}if(d=1!=(0|n),a=n-1|0,c=c+1|0,1==(0|n))break g;if(n=a,!(3&c))break;}else a=n;}else a=n;if(!d)break B;}Q:if(S2[0|c]&&!(a>>>0<4)){for(n=3&(k=a-4|0),k=4+((-4&k)+c|0)|0;;){if((-1^(d=T2[c>>2]))&d-16843009&-2139062144)break Q;if(c=c+4|0,!(3<(a=a-4|0)>>>0))break;}a=n,c=k;}if(a)for(;;){if(!S2[0|c])break d;if(c=c+1|0,!(a=a-1|0))break;}}c=0;}if(a=(n=c?c-b|0:g)+s|0,s=2790,(0|t)<=-1)break b;d=o,t=n;break i;}if(n=b=T2[56+u>>2],t)break l;a=0;break k;}T2[12+u>>2]=0,T2[8+u>>2]=T2[56+u>>2],T2[56+u>>2]=8+u,t=-1,n=8+u|0;}a=0,b=n;l:{for(;;){if(!(o=T2[n>>2]))break l;if((c=(0|(o=P(4+u|0,o)))<0)||t-a>>>0<o>>>0)break;if(n=n+4|0,!((a=a+o|0)>>>0<t>>>0))break l;}if(c)break f;}if((0|a)<0)break e;}c=73728&d;k:if(!(c||(0|v)<=(0|a))){if(d2(u+64|0,32,(n=(s=v-a|0)>>>0<256)?s:256),o=32&(k=T2[A>>2]),n){if(o)break k;}else {for(n=!o,o=s;1&n&&(S(u+64|0,256,A),k=T2[A>>2]),n=!(t=32&k),255<(o=o-256|0)>>>0;);if(t)break k;s&=255;}S(u+64|0,s,A);}k:if(a)for(n=0;;){if(!(o=T2[b>>2]))break k;if(a>>>0<(n=(o=P(4+u|0,o))+n|0)>>>0)break k;if(32&S2[0|A]||S(4+u|0,o,A),b=b+4|0,!(n>>>0<a>>>0))break;}k:if(8192==(0|c)&&!((0|v)<=(0|a))){if(d2(u+64|0,32,(n=(t=v-a|0)>>>0<256)?t:256),o=32&(b=T2[A>>2]),n){if(o)break k;}else {for(n=!o,o=t;1&n&&(S(u+64|0,256,A),b=T2[A>>2]),n=!(c=32&b),255<(o=o-256|0)>>>0;);if(c)break k;t&=255;}S(u+64|0,t,A);}a=(0|a)<(0|v)?v:a;continue r;}if(g&&(0|t)<=-1)break e;Q=X[56+u>>3],T2[364+u>>2]=0,s1(+Q),a=0|u1[1],w=(0|a)<-1||(0|a)<=-1?(Q=-Q,C=1,3440):2048&d?(C=1,3443):(C=1&d)?3446:3441;u:if((D=O2(Q))!=p&D==D){if(Q=function A(f,r){var e,i,a;if(s1(+f),i=0|u1[1],a=0|u1[0],2047!=(0|(e=i>>>20&2047))){if(!e)return 0==f?T2[r>>2]=0:(f=A(0x10000000000000000*f,r),T2[r>>2]=T2[r>>2]+-64),f;T2[r>>2]=e-1022,k1(0,0|a),k1(1,-2146435073&i|1071644672),f=+l1();}return f;}(Q,364+u|0),0!=(Q+=Q)&&(T2[364+u>>2]=T2[364+u>>2]-1),97!=(0|(h=32|c))){for(a=(0|t)<0,0!=Q?(b=T2[364+u>>2]-28|0,T2[364+u>>2]=b,Q*=268435456):b=T2[364+u>>2],l=a?6:t,o=g=(0|b)<0?368+u|0:I;o=(n=o)+4|0,0!=(Q=1e9*(Q-((T2[n>>2]=a=Q<4294967296&0<=Q?~~Q>>>0:0)>>>0))););if((0|b)<1)a=o,n=g;else for(n=g;;){if(t=(0|b)<29?b:29,!((a=o-4|0)>>>0<n>>>0)){for(b=t,k=0;F=k,k=T2[(s=a)>>2],a=31&b,E=32<=(63&b)>>>0?(B=k<<a,0):(B=(1<<a)-1&k>>>32-a,k<<a),a=B,W=s,m=(B=k=F+E|0)-e1(k=i1(k,k>>>0<E>>>0?a+1|0:a,1e9),z,1e9,0)|0,T2[W>>2]=m,n>>>0<=(a=s-4|0)>>>0;);k&&(T2[(n=n-4|0)>>2]=k);}for(;n>>>0<(a=o)>>>0&&!T2[(o=a-4|0)>>2];);if(b=T2[364+u>>2]-t|0,o=a,!(0<(0|(T2[364+u>>2]=b))))break;}if((0|b)<=-1)for(k=1+((l+25>>>0)/9|0)|0;;){if(t=(0|b)<-9?9:0-b|0,a>>>0<=n>>>0)n=T2[n>>2]?n:n+4|0;else {for(s=1e9>>>t|0,B=-1<<t^-1,b=0,o=n;E=b,b=T2[o>>2],T2[o>>2]=E+(b>>>t|0),b=P2(s,b&B),(o=o+4|0)>>>0<a>>>0;);n=T2[n>>2]?n:n+4|0,b&&(T2[a>>2]=b,a=a+4|0);}if(b=t+T2[364+u>>2]|0,a=(0|k)<a-(o=102==(0|h)?g:n)>>2?o+(k<<2)|0:a,!((0|(T2[364+u>>2]=b))<0))break;}if(!(a>>>(o=0)<=n>>>0||(o=P2(g-n>>2,9),(t=T2[n>>2])>>>0<10)))for(b=10;o=o+1|0,(b=P2(b,10))>>>0<=t>>>0;);if((0|(b=(l-(k=102==(0|h)?0:o)|0)-(s=(h=103==(0|h))&0!=(0|l))|0))<(P2(a-g>>2,9)-9|0)){if(t=(R=g+((E=(0|(B=b+9216|0))/9|0)<<2)|0)-4092|0,b=10,((F=B)-(B=P2(E,9))|0)<=7)for(k=9215+(((l-s|0)-k|0)-B|0)|0;b=P2(b,10),(0|(k=k+1|0))<7;);if(E=t+4|0,(k=(s=T2[t>>2])-P2(b,B=(s>>>0)/(b>>>0)|0)|0)||(0|E)!=(0|a)){k:{if(!(1&B)){if(Q=9007199254740992,t>>>0<=n>>>0)break k;if(1e9!=(0|b))break k;if(!(1&p2[t-4|0]))break k;}Q=9007199254740994;}if(D=k>>>0<(B=b>>>1|0)>>>0?.5:(0|a)==(0|E)&&(0|B)==(0|k)?1:1.5,C&&45==S2[0|w]&&(D=-D,Q=-Q),T2[t>>2]=k=s-k|0,Q+D!=Q){if(1e9<=(T2[t>>2]=b=b+k|0)>>>0){for(o=R-4096|0;o>>>(T2[o+4>>2]=0)<n>>>0&&(T2[(n=n-4|0)>>2]=0),b=T2[o>>2]+1|0,T2[o>>2]=b,o=o-4|0,999999999<b>>>0;);t=o+4|0;}if(o=P2(g-n>>2,9),!((k=T2[n>>2])>>>0<10))for(b=10;o=o+1|0,(b=P2(b,10))>>>0<=k>>>0;);}}a=(b=t+4|0)>>>0<a>>>0?b:a;}k:{for(;;){if((k=a)>>>(t=0)<=n>>>0)break k;if(T2[(a=k-4|0)>>2])break;}t=1;}if(h){if(l=((b=(0|o)<(0|(a=l||1))&-5<(0|o))?-1^o:-1)+a|0,c=(b?-1:-2)+c|0,!(s=8&d)){if(a=9,t&&(s=T2[k-4>>2])&&!((s>>>(a=0))%10|0))for(b=10;a=a+1|0,!((s>>>0)%((b=P2(b,10))>>>0)|0););b=P2(k-g>>2,9)-9|0,l=102!=(32|c)?((s=0)|l)<(0|(a=0<(0|(a=(o+b|0)-a|0))?a:0))?l:a:((s=0)|l)<(0|(a=0<(0|(a=b-a|0))?a:0))?l:a;}}else s=8&d;if(a=-1,!((0|((E=l|s)?2147483645:2147483646))<(0|l))){if(h=1+((0!=(0|E))+l|0)|0,R=102!=(32|c)){if(b=x,a=o>>31,a^=a+o)for(;p2[0|(b=b-1|0)]=a-P2(B=(a>>>0)/10|0,10)|48,Y=9<a>>>0,a=B,Y;);if((x-b|0)<=1){for(a=b-1|0;p2[0|a]=48,b=x-a|0,a=B=a-1|0,(0|b)<2;);b=B+1|0;}if(p2[0|(Y=b-2|0)]=c,a=-1,p2[b-1|0]=(0|o)<0?45:43,(2147483647-h|0)<(0|(o=x-Y|0)))break u;}else {if((2147483647-h|0)<(0|o))break u;o=0<(0|o)?o:0;}if(!((2147483647^C)<(0|(b=o+h|0)))){B=b+C|0,d&=73728;k:if(!(d||(0|v)<=(0|B))){if(d2(u+64|0,32,(a=(c=v-B|0)>>>0<256)?c:256),o=32&(b=T2[A>>2]),a){if(o)break k;}else {for(a=!o,o=c;1&a&&(S(u+64|0,256,A),b=T2[A>>2]),a=!(h=32&b),255<(o=o-256|0)>>>0;);if(h)break k;c&=255;}S(u+64|0,c,A);}32&S2[0|A]||S(w,C,A);k:if(65536==(0|d)&&!((0|v)<=(0|B))){if(d2(u+64|0,48,(a=(c=v-B|0)>>>0<256)?c:256),o=32&(b=T2[A>>2]),a){if(o)break k;}else {for(a=!o,o=c;1&a&&(S(u+64|0,256,A),b=T2[A>>2]),a=!(w=32&b),255<(o=o-256|0)>>>0;);if(w)break k;c&=255;}S(u+64|0,c,A);}k:if(R){l:if(!((0|l)<0)){for(c=t?k:n+4|0,t=n;;){b=M;s:{if(a=T2[t>>2]){for(o=0;p2[344+(o+u|0)|0]=a-P2(b=(a>>>0)/10|0,10)|48,o=o-1|0,k=9<a>>>0,a=b,k;);if(b=345+(o+u|0)|0,o)break s;}p2[0|(b=b-1|0)]=48;}if((0|n)==(0|t))32&S2[0|A]||S(b,1,A),b=b+1|0,(0|l)<1&&!s||32&S2[0|A]||S(3475,1,A);else if(!(b>>>0<=336+u>>>0))for(d2(336+u|0,48,b+y|0);336+u>>>0<(b=b-1|0)>>>0;);if(a=M-b|0,32&S2[0|A]||S(b,(0|a)<(0|l)?a:l,A),t=t+4|0,!(-1<(0|(l=l-a|0))&&t>>>0<c>>>0))break;}if(!((0|l)<1)){if(d2(u+64|0,48,(n=l>>>0<256)?l:256),a=32&(o=T2[A>>2]),n){if(a)break l;}else {for(a=!a,n=l;1&a&&(S(u+64|0,256,A),o=T2[A>>2]),a=!(b=32&o),255<(n=n-256|0)>>>0;);if(b)break l;l&=255;}S(u+64|0,l,A);}}32&S2[0|A]||S(Y,x-Y|0,A);}else {for(t=o=g>>>0<n>>>0?g:n;;){if(a=T2[t>>2])for(n=0;p2[n+N|0]=a-P2(b=(a>>>0)/10|0,10)|48,n=n-1|0,c=9<a>>>0,a=b,c;);else n=0;if(a=n+M|0,(0|o)==(0|t)?n||(p2[0|(a=a-1|0)]=48):a>>>0<=336+u>>>0||(d2(336+u|0,48,n+9|0),a=336+u|0),32&S2[0|A]||S(a,M-a|0,A),!((t=t+4|0)>>>0<=g>>>0))break;}E&&(32&S2[0|A]||S(3475,1,A));l:if((0|l)<1)a=l;else if(k>>>0<=t>>>0)a=l;else for(;;){a=M;s:{if(n=T2[t>>2]){for(;p2[0|(a=a-1|0)]=n-P2(b=(n>>>0)/10|0,10)|48,o=9<n>>>0,n=b,o;);if(a>>>0<=336+u>>>0)break s;}for(d2(336+u|0,48,a+y|0);336+u>>>0<(a=a-1|0)>>>0;);}if(32&S2[0|A]||S(a,(0|l)<9?l:9,A),a=l-9|0,(0|l)<10)break l;if(l=a,!((t=t+4|0)>>>0<k>>>0))break;}if(!((0|a)<1)){if(d2(u+64|0,48,(o=a>>>0<256)?a:256),n=32&(b=T2[A>>2]),o){if(n)break k;}else {for(n=!n,o=a;1&n&&(S(u+64|0,256,A),b=T2[A>>2]),n=!(c=32&b),255<(o=o-256|0)>>>0;);if(c)break k;a&=255;}S(u+64|0,a,A);}}k:if(8192==(0|d)&&!((0|v)<=(0|B))){if(d2(u+64|0,32,(a=(k=v-B|0)>>>0<256)?k:256),n=32&(o=T2[A>>2]),a){if(n)break k;}else {for(a=!n,n=k;1&a&&(S(u+64|0,256,A),o=T2[A>>2]),a=!(b=32&o),255<(n=n-256|0)>>>0;);if(b)break k;k&=255;}S(u+64|0,k,A);}a=(0|B)<(0|v)?v:B;}}}else {if(n=w+9|0,a=w,l=(w=32&c)?n:a,!(11<t>>>0)&&12!=(0|t)){for(a=t-12|0,D=16;D*=16,(n=a)>>>0<=(a=a+1|0)>>>0;);Q=45!=S2[0|l]?Q+D-D:-(D+(-Q-D));}o=x,a=(k=T2[364+u>>2])>>31;k:{if(a^=a+k){for(n=0;p2[335+(n+u|0)|0]=a-P2(b=(a>>>0)/10|0,10)|48,n=n-1|0,o=9<a>>>0,a=b,o;);if(o=336+(n+u|0)|0,n)break k;}p2[0|(o=o-1|0)]=48;}for(s=2|C,p2[0|(g=o-2|0)]=c+15,p2[o-1|0]=(0|k)<0?45:43,b=8&d,n=336+u|0;o=a=n,c=w,n=O2(Q)<2147483648?~~Q:-2147483648,p2[0|o]=c|S2[n+3424|0],Q=16*(Q-(0|n)),1==((n=a+1|0)-(336+u|0)|0)&&(b||0<(0|t)||0!=Q)&&(p2[a+1|0]=46,n=a+2|0),0!=Q;);if(a=-1,!((2147483645-(b=(w=x-g|0)+s|0)|0)<(0|t))){k=n-(336+u|0)|0,b=(t=t&&(n+J|0)<(0|t)?t+2|0:k)+b|0,d&=73728;k:if(!(d||(0|v)<=(0|b))){if(d2(u+64|0,32,(a=(c=v-b|0)>>>0<256)?c:256),n=32&(o=T2[A>>2]),a){if(n)break k;}else {for(a=!n,n=c;1&a&&(S(u+64|0,256,A),o=T2[A>>2]),a=!(B=32&o),255<(n=n-256|0)>>>0;);if(B)break k;c&=255;}S(u+64|0,c,A);}32&S2[0|A]||S(l,s,A);k:if(65536==(0|d)&&!((0|v)<=(0|b))){if(d2(u+64|0,48,(a=(s=v-b|0)>>>0<256)?s:256),n=32&(o=T2[A>>2]),a){if(n)break k;}else {for(a=!n,n=s;1&a&&(S(u+64|0,256,A),o=T2[A>>2]),a=!(c=32&o),255<(n=n-256|0)>>>0;);if(c)break k;s&=255;}S(u+64|0,s,A);}32&S2[0|A]||S(336+u|0,k,A);k:if(!((0|(t=t-k|0))<1)){if(d2(u+64|0,48,(n=t>>>0<256)?t:256),a=32&(o=T2[A>>2]),n){if(a)break k;}else {for(a=!a,n=t;1&a&&(S(u+64|0,256,A),o=T2[A>>2]),a=!(c=32&o),255<(n=n-256|0)>>>0;);if(c)break k;t&=255;}S(u+64|0,t,A);}32&S2[0|A]||S(g,w,A);k:if(8192==(0|d)&&!((0|v)<=(0|b))){if(d2(u+64|0,32,(a=(t=v-b|0)>>>0<256)?t:256),n=32&(o=T2[A>>2]),a){if(n)break k;}else {for(a=!n,n=t;1&a&&(S(u+64|0,256,A),o=T2[A>>2]),a=!(c=32&o),255<(n=n-256|0)>>>0;);if(c)break k;t&=255;}S(u+64|0,t,A);}a=(0|b)<(0|v)?v:b;}}}else {b=C+3|0;k:if(!(8192&d||(0|v)<=(0|b))){if(d2(u+64|0,32,(a=(t=v-b|0)>>>0<256)?t:256),n=32&(o=T2[A>>2]),a){if(n)break k;}else {for(a=!n,n=t;1&a&&(S(u+64|0,256,A),o=T2[A>>2]),a=!(k=32&o),255<(n=n-256|0)>>>0;);if(k)break k;t&=255;}S(u+64|0,t,A);}32&(a=T2[A>>2])||(S(w,C,A),a=T2[A>>2]),32&a||(a=(32&c)>>>5|0,S(Q!=Q?a?3467:3471:a?3459:3463,3,A));k:if(8192==(73728&d)&&!((0|v)<=(0|b))){if(d2(u+64|0,32,(a=(t=v-b|0)>>>0<256)?t:256),n=32&(o=T2[A>>2]),a){if(n)break k;}else {for(a=!n,n=t;1&a&&(S(u+64|0,256,A),o=T2[A>>2]),a=!(c=32&o),255<(n=n-256|0)>>>0;);if(c)break k;t&=255;}S(u+64|0,t,A);}a=(0|b)<(0|v)?v:b;}if(0<=(0|a))continue r;break e;}l=0,s=2790;}a=U;break i;}if(d=o,t=n,!S2[0|a])break i;break e;}a=S2[f+1|0],f=f+1|0;}if(A)break A;if(!Z){G=0;break A;}if(A=1,(f=T2[i+4>>2])&&(O(e+8|0,f,r),(f=T2[i+8>>(A=2)])&&(O(e+16|0,f,r),A=3,(f=T2[i+12>>2])&&(O(e+24|0,f,r),A=4,(f=T2[i+16>>2])&&(O(e+32|0,f,r),A=5,(f=T2[i+20>>2])&&(O(e+40|0,f,r),A=6,(f=T2[i+24>>2])&&(O(e+48|0,f,r),A=7,(f=T2[i+28>>2])&&(O(e+56|0,f,r),A=8,f=T2[i+32>>2])))))))){if(O(e- -64|0,f,r),A=T2[i+36>>2])break a;A=9;}for(a=A-1|0,f=(A<<2)+i|0;;){if(T2[f>>2])break n;if(f=f+4|0,!((a=a+(G=1)|0)>>>0<=8))break;}break A;}T2[5420]=28;break f;}O(e+72|0,A,r),G=1;break A;}if(!((2147483647-l|0)<(0|(B=(0|t)<(0|(w=a-b|0))?w:t))||(0|C)<(0|(a=(0|v)<(0|(g=l+B|0))?g:v)))){d&=73728;i:if(!(d||(0|v)<=(0|g))){if(d2(u+64|0,32,(n=(c=a-g|0)>>>0<256)?c:256),o=32&(k=T2[A>>2]),n){if(o)break i;}else {for(n=!o,o=c;1&n&&(S(u+64|0,256,A),k=T2[A>>2]),n=!(C=32&k),255<(o=o-256|0)>>>0;);if(C)break i;c&=255;}S(u+64|0,c,A);}32&S2[0|A]||S(s,l,A);i:if(65536==(0|d)&&!((0|v)<=(0|g))){if(d2(u+64|0,48,(n=(l=a-g|0)>>>0<256)?l:256),o=32&(k=T2[A>>2]),n){if(o)break i;}else {for(n=!o,o=l;1&n&&(S(u+64|0,256,A),k=T2[A>>2]),n=!(c=32&k),255<(o=o-256|0)>>>0;);if(c)break i;l&=255;}S(u+64|0,l,A);}i:if(!((0|t)<=(0|w))){if(d2(u+64|0,48,(n=(c=B-w|0)>>>0<256)?c:256),o=32&(k=T2[A>>2]),n){if(o)break i;}else {for(n=!o,o=c;1&n&&(S(u+64|0,256,A),k=T2[A>>2]),n=!(t=32&k),255<(o=o-256|0)>>>0;);if(t)break i;c&=255;}S(u+64|0,c,A);}if(32&S2[0|A]||S(b,w,A),8192!=(0|d))continue;if((0|v)<=(0|g))continue;if(d2(u+64|0,32,(n=(v=a-g|0)>>>0<256)?v:256),o=32&(b=T2[A>>2]),n){if(o)continue;}else {for(n=!o,o=v;1&n&&(S(u+64|0,256,A),b=T2[A>>2]),n=!(c=32&b),255<(o=o-256|0)>>>0;);if(c)continue;v&=255;}S(u+64|0,v,A);continue;}}break;}T2[5420]=61;}G=-1;}return L2=880+u|0,G;}function O(A,f,r){var e,i,a=0,n=0,o=0;A:{f:{r:{if((f=f-9|0)>>>0<=17){e:switch(f-1|0){case 5:return f=T2[r>>2],T2[r>>2]=f+4,f=$[f>>1],T2[A>>2]=f,void(T2[A+4>>2]=f>>31);case 6:return f=T2[r>>2],T2[r>>2]=f+4,T2[A>>2]=A2[f>>1],void(T2[A+4>>2]=0);case 7:return f=T2[r>>2],T2[r>>2]=f+4,f=p2[0|f],T2[A>>2]=f,void(T2[A+4>>2]=f>>31);case 8:return f=T2[r>>2],T2[r>>2]=f+4,T2[A>>2]=S2[0|f],void(T2[A+4>>2]=0);case 16:for(A=3276;!((-1^(r=T2[(A=A+4|0)>>2]))&r-16843009&-2139062144););if(f=A-3280|0,255&r){for(;r=S2[A+1|0],A=f=A+1|0,r;);f=f-3280|0;}A=f,r=0,o=3280;i:{if(!(f=T2[5272])){if(f=0,v(21072))break i;f=T2[5272];}if(f-(n=T2[5273])>>>0<A>>>0)f=0|n1[T2[5276]](21072,3280,A);else {a=A;a:if(!(T2[5284]<0)){for(e=A+3280|0,f=0;;){if(!((a=A)+f|0))break a;if(i=f+e|0,f=a=f-1|0,10==S2[i-1|0])break;}if((f=0|n1[T2[5276]](21072,3280,r=1+(A+a|0)|0))>>>0<r>>>0)break i;o=1+(a+e|0)|0,n=T2[5273],a^=-1;}$2(n,o,a),T2[5273]=a+T2[5273],f=r+a|0;}}j();case 2:case 9:case 11:case 12:case 15:break A;case 1:case 4:case 10:case 14:break f;case 0:case 3:case 13:break r;default:break e;}f=T2[r>>2],T2[r>>2]=f+4,T2[A>>2]=T2[f>>2];}return;}return f=T2[r>>2],T2[r>>2]=f+4,f=T2[f>>2],T2[A>>2]=f,void(T2[A+4>>2]=f>>31);}return f=T2[r>>2],T2[r>>2]=f+4,T2[A>>2]=T2[f>>2],void(T2[A+4>>2]=0);}f=T2[r>>2]+7&-8,T2[r>>2]=f+8,r=T2[f+4>>2],T2[A>>2]=T2[f>>2],T2[A+4>>2]=r;}function B(A,f){var r=0,e=0,e=S2[0|f],r=S2[0|A];A:if(r&&(0|e)==(0|r))for(A=A+1|0,f=f+1|0;;){if(e=S2[0|f],!(r=S2[0|A]))break A;if(A=A+1|0,f=f+1|0,(0|e)!=(0|r))break;}return r-e|0;}function Q(A){T2[12+(L2-16|0)>>2]=A|=0;}function g(A){var f,r=0;return T2[12+(L2=r=L2-16|0)>>2]=A|=0,L2=A=L2-16|0,f=T2[12+r>>2],T2[A+12>>2]=f,T2[12+(L2-16|0)>>2]=T2[A+12>>2],L2=A+16|0,L2=16+r|0,0|f;}function w(A){var f=0;return T2[12+(L2=f=L2-16|0)>>2]=A|=0,g(A=T2[12+f>>2]),L2=16+f|0,0|A;}function G(A){var f=0;T2[12+(L2=f=L2-16|0)>>2]=A|=0,w(A=T2[12+f>>2]),u(A),L2=16+f|0;}function C(A,f,r){var e=0;return T2[8+(L2=e=L2-16|0)>>2]=A,T2[4+e>>2]=f,p2[3+e|0]=r,1&p2[3+e|0]?(A=T2[8+(r=e)>>2]!=T2[4+e>>2]?(T2[(A=L2-16|0)+8>>2]=T2[8+e>>2],T2[A+12>>2]=T2[T2[A+8>>2]+4>>2],f=T2[A+12>>2],T2[(A=L2-16|0)+8>>2]=T2[4+e>>2],T2[A+12>>2]=T2[T2[A+8>>2]+4>>2],!B(f,T2[A+12>>2])):1,p2[r+15|0]=A):(f=T2[4+e>>2],T2[(L2=A=L2-16|0)+4>>2]=T2[8+e>>2],T2[A>>2]=f,f=T2[T2[A>>2]+4>>2],T2[A+12>>2]=T2[T2[A+4>>2]+4>>2],T2[A+8>>2]=f,f=1,T2[A+12>>2]!=T2[A+8>>2]&&(f=!B(T2[A+12>>2],T2[A+8>>2])),L2=A+16|0,p2[15+e|0]=1&f),L2=16+e|0,1&p2[15+e|0];}function E(A,f,r,e){var i=0;T2[12+(i=L2-16|0)>>2]=A,T2[8+i>>2]=f,T2[4+i>>2]=r,T2[i>>2]=e,T2[T2[8+i>>2]+16>>2]?T2[T2[8+i>>2]+16>>2]!=T2[4+i>>2]?(A=T2[8+i>>2],T2[A+36>>2]=T2[A+36>>2]+1,T2[T2[8+i>>2]+24>>2]=2,p2[T2[8+i>>2]+54|0]=1):2==T2[T2[8+i>>2]+24>>2]&&(T2[T2[8+i>>2]+24>>2]=T2[i>>2]):(T2[T2[8+i>>2]+16>>2]=T2[4+i>>2],T2[T2[8+i>>2]+24>>2]=T2[i>>2],T2[T2[8+i>>2]+36>>2]=1);}function D(A,f,r,e){var i,a=0;T2[28+(L2=a=L2-32|0)>>2]=A,T2[24+a>>2]=f,T2[20+a>>2]=r,T2[16+a>>2]=e,A=T2[28+a>>2],T2[12+a>>2]=0,T2[20+a>>2]&&(T2[12+a>>2]=T2[A+4>>2]>>8,1&T2[A+4>>2]&&(T2[8+a>>2]=T2[T2[20+a>>2]>>2],T2[12+a>>2]=T2[T2[8+a>>2]+T2[12+a>>2]>>2])),f=T2[A>>2],e=T2[24+a>>2],i=T2[20+a>>2]+T2[12+a>>2]|0,A=2&T2[A+4>>2]?T2[16+a>>2]:2,n1[T2[T2[(r=f)>>2]+28>>2]](r,e,i,A),L2=32+a|0;}function h(A,f,r,e,i){var a=0;T2[28+(a=L2-32|0)>>2]=A,T2[24+a>>2]=f,T2[20+a>>2]=r,T2[16+a>>2]=e,T2[12+a>>2]=i,p2[T2[24+a>>2]+53|0]=1,T2[16+a>>2]==T2[T2[24+a>>2]+4>>2]&&(p2[T2[24+a>>2]+52|0]=1,T2[T2[24+a>>2]+16>>2]?T2[T2[24+a>>2]+16>>2]!=T2[20+a>>2]?(A=T2[24+a>>2],T2[A+36>>2]=T2[A+36>>2]+1,p2[T2[24+a>>2]+54|0]=1):(2==T2[T2[24+a>>2]+24>>2]&&(T2[T2[24+a>>2]+24>>2]=T2[12+a>>2]),1==T2[T2[24+a>>2]+48>>2]&&1==T2[T2[24+a>>2]+24>>2]&&(p2[T2[24+a>>2]+54|0]=1)):(T2[T2[24+a>>2]+16>>2]=T2[20+a>>2],T2[T2[24+a>>2]+24>>2]=T2[12+a>>2],(T2[T2[24+a>>2]+36>>2]=1)==T2[T2[24+a>>2]+48>>2]&&1==T2[T2[24+a>>2]+24>>2]&&(p2[T2[24+a>>2]+54|0]=1)));}function Z(A,f,r,e){var i=0;T2[12+(i=L2-16|0)>>2]=A,T2[8+i>>2]=f,T2[4+i>>2]=r,T2[i>>2]=e,T2[4+i>>2]==T2[T2[8+i>>2]+4>>2]&&1!=T2[T2[8+i>>2]+28>>2]&&(T2[T2[8+i>>2]+28>>2]=T2[i>>2]);}function Y(A,f,r,e,i,a){var n=0;T2[28+(L2=n=L2-32|0)>>2]=A,T2[24+n>>2]=f,T2[20+n>>2]=r,T2[16+n>>2]=e,T2[12+n>>2]=i,p2[11+n|0]=a,A=T2[28+n>>2],T2[4+n>>2]=T2[A+4>>2]>>8,1&T2[A+4>>2]&&(T2[n>>2]=T2[T2[16+n>>2]>>2],T2[4+n>>2]=T2[T2[n>>2]+T2[4+n>>2]>>2]),f=T2[A>>2],e=T2[24+n>>2],i=T2[20+n>>2],a=T2[16+n>>2]+T2[4+n>>2]|0,A=2&T2[A+4>>2]?T2[12+n>>2]:2,n1[T2[T2[(r=f)>>2]+20>>2]](r,e,i,a,A,1&p2[11+n|0]),L2=32+n|0;}function F(A,f,r,e,i){var a=0;T2[28+(L2=a=L2-32|0)>>2]=A,T2[24+a>>2]=f,T2[20+a>>2]=r,T2[16+a>>2]=e,p2[15+a|0]=i,A=T2[28+a>>2],T2[8+a>>2]=T2[A+4>>2]>>8,1&T2[A+4>>2]&&(T2[4+a>>2]=T2[T2[20+a>>2]>>2],T2[8+a>>2]=T2[T2[4+a>>2]+T2[8+a>>2]>>2]),f=T2[A>>2],e=T2[24+a>>2],i=T2[20+a>>2]+T2[8+a>>2]|0,A=2&T2[A+4>>2]?T2[16+a>>2]:2,n1[T2[T2[(r=f)>>2]+24>>2]](r,e,i,A,1&p2[15+a|0]),L2=32+a|0;}function W(A){var f=0,r=0;return z2((f=A*A)*f*(r=f*A)*(2718311493989822e-21*f-.00019839334836096632)+(r*(.008333329385889463*f-.16666666641626524)+A));}function m(A){var f;return z2(-.499999997251031*(A*=A)+1+.04166662332373906*(f=A*A)+A*f*(2439044879627741e-20*A-.001388676377460993));}function N(A,f){return 1024<=(0|f)?(A*=898846567431158e293,f=(0|f)<2047?f-1023|0:(A*=898846567431158e293,((0|f)<3069?f:3069)-2046|0)):-1023<(0|f)||(A*=2004168360008973e-307,f=-1992<(0|f)?f+969|0:(A*=2004168360008973e-307,(-2960<(0|f)?f:-2960)+1938|0)),k1(0,0),k1(1,f+1023<<20),A*+l1();}function V(A,f){var r,e,i,a,n,o,b,t,c,u=0,k=0,l=0,s=0,v=0,d=0,B=0,Q=0,g=0,w=0,G=0,C=0,E=0,D=0,h=0,Z=0,Y=0;if(L2=E=L2-16|0,v1(A),(u=2147483647&(Z=u1[2]))>>>0<=1305022426)X[f>>3]=(w=+A)+-1.5707963109016418*(k=.6366197723675814*w+6755399441055744-6755399441055744)+-1.5893254773528196e-8*k,l=O2(k)<2147483648?~~k:-2147483648;else if(2139095040<=u>>>0)X[f>>3]=z2(A-A);else {if(X[8+E>>3]=(k1(2,(v=u)-((u=(u>>>23|0)-150|0)<<23)|0),d1()),D=8+E|0,L2=r=L2-560|0,G=u+P2(i=0<(0|(v=(u-3|0)/24|0))?v:0,-24)|0,0<=(0|(e=T2[956])))for(v=e+1|0,d=3840+((u=i)<<2)|0,s=320+r|0;X[s>>3]=(0|u)<0?0:+T2[d>>2],s=s+8|0,d=d+4|0,u=u+1|0,v=v-1|0;);for(B=G-24|0,v=320+r|0;;){for(k=0,u=D,d=1,s=v;k+=X[u>>3]*X[s>>3],u=u+8|0,s=s-8|0,d=d-1|0;);if(X[(l<<3)+r>>3]=k,v=v+8|0,u=(0|l)<(0|e),l=l+1|0,!u)break;}n=23-B|0,a=24-B|0,o=476+((e<<2)+r|0)|0,b=476+r|0,t=r-8|0,l=e;A:{for(;;){if(k=X[(u=l<<3)+r>>3],!(g=(0|l)<1))for(d=l+1|0,u=u+t|0,s=480+r|0;v=s,Q=O2(w=5.960464477539063e-8*(h=k))<2147483648?~~w:-2147483648,Q=O2(w=h+-16777216*(k=+(0|Q)))<2147483648?~~w:-2147483648,T2[v>>2]=Q,s=s+4|0,k=X[u>>3]+k,u=u-8|0,1<(0|(d=d-1|0)););k=N(k,B),k+=-8*R(.125*k),k-=0|(Q=O2(k)<2147483648?~~k:-2147483648);f:{r:{e:{if(d=(0|B)<1){if(B)break e;C=T2[476+((l<<2)+r|0)>>2]>>23;}else Q=(u=(s=T2[(v=476+((l<<2)+r|0)|0)>>2])>>a)+Q|0,C=(T2[(C=v)>>2]=v=s-(u<<a)|0)>>n;if((0|C)<1)break f;break r;}if(C=2,!(.5<=k)){C=0;break f;}}if(g)g=0;else for(u=480+r|(g=0),v=l;;){s=T2[u>>2];r:{e:{if(c=u,g)Y=16777215;else {if(!s)break e;g=1,Y=16777216;}T2[c>>2]=Y-s;break r;}g=0;}if(u=u+4|0,!(v=v-1|0))break;}d||1<(u=B-1|0)>>>0||(T2[(u=476+((l<<2)+r|0)|0)>>2]=1==(0|u)?4194303&T2[u>>2]:8388607&T2[u>>2]),Q=Q+1|0,2==(0|C)&&(k=1-k,C=2,g&&(k-=N(1,B)));}if(0!=k)break;if(!((0|l)<=(0|e))){for(u=(l<<2)+b|0,s=0,d=l;s=T2[u>>2]|s,u=u-4|0,(0|e)<(0|(d=d-1|0)););if(s){for(u=476+((l<<2)+r|0)|0,G=B;l=l-1|0,G=G-24|0,v=T2[u>>2],u=u-4|0,!v;);break A;}}for(u=o,v=l;v=v+1|0,s=T2[u>>2],u=u-4|0,!s;);for(g=328+((l<<3)+r|0)|0;;){for(X[(u=328+((l<<3)+r|0)|0)>>3]=T2[3840+(i+(l=l+1|0)<<2)>>2],k=0,u=D,s=g,d=1;k+=X[u>>3]*X[s>>3],u=u+8|0,s=s-8|0,d=d-1|0;);if(X[(l<<3)+r>>3]=k,g=g+8|0,!((0|l)<(0|v)))break;}l=v;}16777216<=(k=N(k,0-B|0))?(s=(480+r|0)+(l<<2)|0,u=O2(w=5.960464477539063e-8*(h=k))<2147483648?~~w:-2147483648,v=O2(k=h+-16777216*(0|u))<2147483648?~~k:-2147483648,T2[s>>2]=v,l=l+1|0):(u=O2(k)<2147483648?~~k:-2147483648,G=B),T2[(480+r|0)+(l<<2)>>2]=u;}if(!((0|l)<0)){for(d=l+1|0,k=N(1,G),u=(480+r|0)+(l<<2)|0,s=(l<<3)+r|0;X[s>>3]=k*+T2[u>>2],u=u-4|0,s=s-8|0,k*=5.960464477539063e-8,0<(0|(d=d-1|0)););if(!((0|l)<0))for(v=(l<<3)+r|0,u=l;;){for(G=l-(B=u)|0,s=u=k=0;k+=X[u+6608>>3]*X[u+v>>3],!((0|e)<=(0|s))&&(u=u+8|0,D=s>>>0<G>>>0,s=s+1|0,D););if(X[(160+r|0)+(G<<3)>>3]=k,v=v-8|0,u=B-1|0,!(0<(0|B)))break;}}if((0|l)<0)k=0;else for(s=l+1|0,u=(160+r|0)+(l<<3)|0,k=0;k+=X[u>>3],u=u-8|0,0<(0|(s=s-1|0)););X[E>>3]=C?-k:k,L2=560+r|0,l=7&Q,k=X[E>>3],(0|Z)<=-1?(X[f>>3]=-k,l=0-l|0):X[f>>3]=k;}return L2=16+E|0,l;}function W2(A){var f=0,r=0,e=0,i=0;L2=r=L2-16|0,v1(A);A:if((f=2147483647&(i=u1[2]))>>>0<=1061752794)f>>>0<964689920||(A=W(+A));else if(f>>>0<=1081824209)e=+A,A=f>>>0<=1075235811?(0|i)<=-1?z2(-m(e+1.5707963267948966)):m(e+-1.5707963267948966):W(-(((0|i)<0?3.141592653589793:-3.141592653589793)+e));else if(f>>>0<=1088565717)e=+A,A=f>>>0<=1085271519?(0|i)<=-1?m(e+4.71238898038469):z2(-m(e+-4.71238898038469)):W(((0|i)<0?6.283185307179586:-6.283185307179586)+e);else if(2139095040<=f>>>0)A=z2(A-A);else if((f=3&V(A,8+r|0))>>>0<=2){f:switch(f-1|0){default:A=W(X[8+r>>3]);break A;case 0:A=m(X[8+r>>3]);break A;case 1:break f;}A=W(-X[8+r>>3]);}else A=z2(-m(X[8+r>>3]));return L2=16+r|0,A;}function m2(A){var f,r=z2(0),e=0,i=0,a=0;L2=i=L2-16|0,v1(A);A:if((e=2147483647&(a=u1[2]))>>>0<=1061752794)r=z2(1),e>>>0<964689920||(r=m(+A));else if(e>>>0<=1081824209)f=+A,r=1075235812<=e>>>0?z2(-m(((0|a)<0?3.141592653589793:-3.141592653589793)+f)):W((0|a)<=-1?1.5707963267948966+f:1.5707963267948966-f);else if(e>>>0<=1088565717)r=1085271520<=e>>>0?m(+A+((0|a)<0?6.283185307179586:-6.283185307179586)):W((0|a)<=-1?-4.71238898038469-+A:+A-4.71238898038469);else if(r=z2(A-A),!(2139095040<=e>>>0))if((e=3&V(A,8+i|0))>>>0<=2){f:switch(e-1|0){default:r=m(X[8+i>>3]);break A;case 0:r=W(-X[8+i>>3]);break A;case 1:break f;}r=z2(-m(X[8+i>>3]));}else r=W(X[8+i>>3]);return L2=16+i|0,A=r;}function J(A,f){var r,e,i=0,a=0,n=0,o=0,b=0,t=0,c=z2(0);v1(f),a=(t=(n=u1[2])<<1)-1|0;A:{f:{r:{e:{v1(A);i:{if((o=u1[2])-8388608>>>0<=2130706431){if(4278190078<a>>>0)break i;break r;}if(a>>>0<4278190079)break e;}if(c=z2(1),1065353216==(0|o))break f;if(!t)break f;if(i=o<<1,!(t>>>0<4278190081&&i>>>0<=4278190080))return z2(A+f);if(2130706432==(0|i))break f;return z2(((-1^n)>>>31|0)==(i>>>0<2130706432|0)?0:f*f);}if(4278190079<=(o<<1)-1>>>0){if(c=z2(A*A),-1<(0|o)||23<(i=n>>>23&255)-127>>>0||(c=!((i=1<<150-i)&n)||n&i-1?c:z2(-c)),-1<(0|n))break f;return z2(z2(1)/c);}if((0|o)<=-1){if((i=n>>>23&255)>>>0<127)break A;e:{if(i>>>0<=150){if(n&(a=1<<150-i)-1)break A;if(i=65536,a&n)break e;}i=0;}o&=2147483647;}8388607<o>>>0||(o=(2147483647&(v1(z2(A*z2(8388608))),u1[2]))-192937984|0);}if(r=X[(a=(t=o-1060306944|0)>>>15&240)+6672>>3]*(k1(2,o-(-8388608&t)|0),+d1())-1,s1(+(b=((X[867]+X[866]*r)*((b=r*r)*b)+(b*(X[869]+X[868]*r)+(X[a+6680>>3]+ +(t>>23)+r*X[870])))*+f)),a=0|u1[1],!(1079967744==(0|(a&=2147450880))|a>>>0<1079967744)){if(127.99999995700433<b)return z2(z2(i?-15845632502852868e13:15845632502852868e13)*z2(15845632502852868e13));if(b<=-150)return z2(z2(i?-2524354896707238e-44:2524354896707238e-44)*z2(2524354896707238e-44));}e=(r=b-((b+=r=X[903])-r))*r*(X[905]+X[904]*r)+(r*X[906]+1),s1(+b),t=i+(n=0|u1[0])|0,i=T2[(a=6968+((31&n)<<3)|0)>>2],a=T2[a+4>>2]+(t<<=15)|0,k1(0,0|i),k1(1,0|(i>>>0<i>>>0?a+1|0:a)),c=z2(e*+l1());}return c;}return A=z2(A-A),z2(A/A);}function o2(A){var f=0,r=0,e=0,i=0,a=0;if(v1(A),255==(0|(r=(a=u1[2])>>>23&255)))return A=z2(A*z2(6.2831854820251465)),z2(A/A);if(2173837238<(f=a<<1)>>>0){if(r)f=8388607&a|8388608;else {if((r=0)<=(0|(f=a<<9)))for(;r=r-1|0,-1<(0|(f<<=1)););f=a<<1-r;}if(i=-1<(0|(e=f-13176795|0)),129<(0|r)){for(;;){if(1&i&&!(f=e))return z2(A*z2(0));if(i=-1<(0|(e=(f<<=1)-13176795|0)),!(129<(0|(r=r-1|0))))break;}r=129;}if(i&&!(f=e))return z2(A*z2(0));if(8388607<f>>>0)i=f;else for(;r=r-1|0,e=f>>>0<4194304,f=i=f<<1,e;);return k1(2,(f=1<=(0|r)?i-8388608|r<<23:i>>>1-r|0)|(e=-2147483648&a)),d1();}return -2121130058==(0|f)?z2(A*z2(0)):A;}function M(A){j();}function I(A){u(A|=0);}function x(A){var f=0;return T2[(A|=0)>>2]=7508,(f=T2[A+144>>2])&&S2[A+148|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+144>>2]=0,T2[A>>2]=7532,p2[A+148|0]=1,T2[(f=A+136|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+124>>2])&&S2[A+128|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+124>>2]=0,p2[A+128|0]=1,T2[(f=A+116|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+104>>2])&&S2[A+108|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+104>>2]=0,p2[A+108|0]=1,T2[(f=A+96|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+84>>2])&&S2[A+88|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+84>>2]=0,p2[A+88|0]=1,T2[(f=A+76|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,T2[A>>2]=7328,p2[A+36|0]=1,T2[(f=A+24|0)>>2]=0,(T2[f+4>>2]=0)|A;}function y(A,f,r){A|=0,f|=0,r|=0;var e=0,i=0,a=0,n=0,o=0,b=0,t=z2(0),c=z2(0),u=z2(0),k=z2(0),l=z2(0);if(T2[A+8>>2]=T2[f>>2],(0|(e=T2[A+24>>2]))==T2[A+28>>2]&&!((0|(a=e?e<<1:1))<=(0|e))){if(a&&(T2[5498]=T2[5498]+1,(i=K2(19+(a<<2)|0))&&(T2[(n=i+19&-16)-4>>2]=i)),1<=(0|e))for(i=e;T2[o+n>>2]=T2[T2[A+32>>2]+o>>2],o=o+4|0,i=i-1|0;);(i=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2]),e=T2[A+24>>2]),T2[A+32>>2]=n,T2[A+28>>2]=a,p2[A+36|0]=1;}if(T2[A+24>>2]=e+1,T2[T2[A+32>>2]+(e<<2)>>2]=T2[f>>2],t=r?(l=j2[f+16>>2],u=j2[f+12>>2],c=j2[f+8>>2],j2[f+20>>2]):(k=j2[f+8>>2],r=T2[A+8>>2],c=j2[f+12>>2],t=j2[f+16>>2],l=z2(z2(z2(k*j2[r+36>>2])+z2(c*j2[r+40>>2]))+z2(t*j2[r+44>>2])),u=z2(z2(z2(k*j2[r+20>>2])+z2(c*j2[r+24>>2]))+z2(t*j2[r+28>>2])),c=z2(z2(z2(j2[r+4>>2]*k)+z2(j2[r+8>>2]*c))+z2(j2[r+12>>2]*t)),z2(0)),(0|(i=T2[A+76>>2]))==T2[A+80>>2]&&!((0|(b=i?i<<1:1))<=(0|i))){if(r=0,b&&(T2[5498]=T2[5498]+1,(e=K2(19+(b<<4)|0))&&(T2[(r=e+19&-16)-4>>2]=e)),1<=(0|i))for(o=0;a=T2[A+84>>2]+o|0,e=T2[a+4>>2],T2[(n=r+o|0)>>2]=T2[a>>2],T2[n+4>>2]=e,e=T2[(a=a+8|0)+4>>2],T2[(n=n+8|0)>>2]=T2[a>>2],T2[n+4>>2]=e,o=o+16|0,i=i-1|0;);(e=T2[A+84>>2])&&S2[A+88|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+84>>2]=r,T2[A+80>>2]=b,p2[A+88|0]=1,i=T2[A+76>>2];}if(r=T2[A+84>>2]+(i<<4)|0,j2[r+12>>2]=t,j2[r+8>>2]=l,j2[r+4>>2]=u,j2[r>>2]=c,T2[A+76>>2]=T2[A+76>>2]+1,u=j2[f+24>>2],t=z2(z2(1)-u),k=z2(z2(t*j2[A+48>>2])+z2(u*j2[A- -64>>2])),c=z2(z2(t*j2[A+44>>2])+z2(u*j2[A+60>>2])),t=z2(z2(t*j2[A+40>>2])+z2(u*j2[A+56>>2])),(0|(i=T2[A+96>>2]))==T2[A+100>>2]&&!((0|(b=i?i<<1:1))<=(0|i))){if(r=0,b&&(T2[5498]=T2[5498]+1,(e=K2(19+(b<<4)|0))&&(T2[(r=e+19&-16)-4>>2]=e)),1<=(0|i))for(o=0;a=T2[A+104>>2]+o|0,e=T2[a+4>>2],T2[(n=r+o|0)>>2]=T2[a>>2],T2[n+4>>2]=e,e=T2[(a=a+8|0)+4>>2],T2[(n=n+8|0)>>2]=T2[a>>2],T2[n+4>>2]=e,o=o+16|0,i=i-1|0;);(e=T2[A+104>>2])&&S2[A+108|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+104>>2]=r,T2[A+100>>2]=b,p2[A+108|0]=1,i=T2[A+96>>2];}if(r=T2[A+104>>2]+(i<<4)|0,j2[r+8>>2]=k,j2[r+4>>2]=c,j2[r>>2]=t,T2[A+96>>2]=T2[A+96>>2]+1,(0|(e=T2[A+116>>2]))==T2[A+120>>2]&&!((0|(b=e?e<<1:1))<=(0|e))){a=0,b&&(T2[5498]=T2[5498]+1,(r=K2(19+(b<<2)|0))&&(T2[(a=r+19&-16)-4>>2]=r)),r=T2[A+124>>2];A:{if(1<=(0|e))for(o=a,i=r,n=e;j2[o>>2]=j2[i>>2],o=o+4|0,i=i+4|0,n=n-1|0;);else if(!r)break A;S2[A+128|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),e=T2[A+116>>2]);}T2[A+124>>2]=a,T2[A+120>>2]=b,p2[A+128|0]=1;}return j2[T2[A+124>>2]+(e<<2)>>2]=j2[f+24>>2],T2[A+116>>2]=e+1,z2(j2[A+4>>2]);}function U(A){return (A|=0)+92|0;}function H(A){return (A|=0)+48|0;}function _(A){return 0|(A|=0);}function L(A){return T2[(A|=0)+204>>2];}function K(A,f,r){r|=0;var e,i=0;return j2[(f|=0)+16>>2]=j2[(A|=0)+4>>2],j2[f+20>>2]=j2[A+8>>2],j2[f+24>>2]=j2[A+12>>2],j2[f+28>>2]=j2[A+16>>2],j2[f+32>>2]=j2[A+20>>2],j2[f+36>>2]=j2[A+24>>2],j2[f+40>>2]=j2[A+28>>2],j2[f+44>>2]=j2[A+32>>2],j2[f+48>>2]=j2[A+36>>2],j2[f+52>>2]=j2[A+40>>2],j2[f+56>>2]=j2[A+44>>2],j2[f+60>>2]=j2[A+48>>2],j2[f+64>>2]=j2[A+52>>2],j2[f+68>>2]=j2[A+56>>2],j2[f+72>>2]=j2[A+60>>2],j2[f+76>>2]=j2[A- -64>>2],j2[f+80>>2]=j2[A+68>>2],j2[f+84>>2]=j2[A+72>>2],j2[f+88>>2]=j2[A+76>>2],j2[f+92>>2]=j2[A+80>>2],j2[f+96>>2]=j2[A+84>>2],j2[f+100>>2]=j2[A+88>>2],j2[f+104>>2]=j2[A+92>>2],j2[f+108>>2]=j2[A+96>>2],j2[f+112>>2]=j2[A+100>>2],j2[f+116>>2]=j2[A+104>>2],j2[f+120>>2]=j2[A+108>>2],j2[f+124>>2]=j2[A+112>>2],j2[f+128>>2]=j2[A+116>>2],j2[f+132>>2]=j2[A+120>>2],j2[f+136>>2]=j2[A+124>>2],j2[f+140>>2]=j2[A+128>>2],j2[f+144>>2]=j2[A+132>>2],j2[f+148>>2]=j2[A+136>>2],j2[f+152>>2]=j2[A+140>>2],j2[f+156>>2]=j2[A+144>>2],j2[f+160>>2]=j2[A+148>>2],j2[f+164>>2]=j2[A+152>>2],j2[f+168>>2]=j2[A+156>>2],j2[f+172>>2]=j2[A+160>>2],j2[f+176>>2]=j2[A+164>>2],j2[f+180>>2]=j2[A+168>>2],j2[f+184>>2]=j2[A+172>>2],j2[f+188>>2]=j2[A+176>>2],T2[f+232>>2]=T2[A+180>>2],j2[f+192>>2]=j2[A+184>>2],i=(T2[f>>2]=0)|n1[T2[T2[r>>2]+28>>2]](r,T2[A+192>>2]),e=T2[A+228>>2],T2[f+196>>2]=T2[A+224>>2],T2[f+200>>2]=e,e=T2[A+212>>2],T2[f+240>>2]=T2[A+208>>2],T2[f+244>>2]=e,T2[f+8>>2]=0,T2[f+4>>2]=i,T2[f+236>>2]=T2[A+204>>2],T2[f+248>>2]=T2[A+220>>2],j2[f+204>>2]=j2[A+236>>2],j2[f+208>>2]=j2[A+244>>2],j2[f+212>>2]=j2[A+248>>2],j2[f+216>>2]=j2[A+232>>2],T2[f+252>>2]=T2[A+252>>2],i=0|n1[T2[T2[r>>2]+40>>2]](r,A),e=0|n1[T2[T2[r>>2]+28>>2]](r,i),(T2[f+12>>2]=e)&&n1[T2[T2[r>>2]+48>>2]](r,i),j2[f+220>>2]=j2[A+268>>2],r=T2[A+280>>2],i=T2[A+276>>2],A=T2[A+272>>2],T2[f+260>>2]=0,T2[f+224>>2]=A,T2[f+228>>2]=i,T2[f+256>>2]=r,7700;}function q(A){(A|=0)&&n1[T2[T2[A>>2]+4>>2]](A);}function f2(A){return (A|=0)+4|0;}function r2(A,f){n1[T2[T2[(A|=0)>>2]+8>>2]](A,f|=0);}function e2(A){return 12;}function t2(A,f,r){A|=0,f|=0,r|=0;var e,i=z2(0),a=0,n=z2(0),o=z2(0),b=z2(0),t=z2(0),c=0,u=0,k=z2(0),l=0,s=z2(0),v=z2(0),d=0,B=(z2(0)),Q=z2(0),g=z2(0);L2=a=L2-48|0;A:{f:switch(T2[f+4>>2]){case 8:T2[A>>2]=0,T2[A+4>>2]=0,T2[(A=A+8|0)>>2]=0,T2[A+4>>2]=0;break A;case 0:T2[A+12>>2]=0,i=j2[f+44>>2],j2[A+8>>2]=j2[r+8>>2]>=z2(0)?i:z2(-i),i=j2[f+40>>2],j2[A+4>>2]=j2[r+4>>2]>=z2(0)?i:z2(-i),i=j2[f+36>>2],j2[A>>2]=j2[r>>2]>=z2(0)?i:z2(-i);break A;case 1:T2[A+12>>2]=0,i=j2[r>>2],o=j2[r+4>>2],n=j2[r+8>>2],t=z2(z2(z2(i*j2[f+80>>2])+z2(o*j2[f+84>>2]))+z2(n*j2[f+88>>2])),b=z2(z2(z2(i*j2[f+96>>2])+z2(o*j2[f+100>>2]))+z2(n*j2[f+104>>2])),i=z2(z2(z2(i*j2[(r=f- -64|0)>>2])+z2(o*j2[f+68>>2]))+z2(n*j2[f+72>>2])),j2[A+8>>2]=j2[(f=((i<t?t<b?2:1:(i<b)<<1)<<4)+r|0)+8>>2],r=T2[f+4>>2],T2[A>>2]=T2[f>>2],T2[A+4>>2]=r;break A;case 13:d=T2[(l=f+44|0)+4>>2],T2[(c=40+a|0)>>2]=T2[l>>2],T2[c+4>>2]=d,l=T2[(c=f+36|0)+4>>2],T2[32+a>>2]=T2[c>>2],T2[36+a>>2]=l,T2[28+a>>2]=0,j2[16+a>>2]=j2[r>>2],n=j2[r+4>>2],j2[20+a>>2]=n,i=j2[r+8>>2],j2[24+a>>2]=i;r:{e:{i:switch((f=T2[f+60>>(c=2)])-(r=1)|0){case 1:break e;case 0:break i;default:break r;}r=0,u=1;break r;}r=0,u=2,c=1,i=n;}n=j2[(32+a|0)+(f<<2)>>2],t=j2[((f=r<<2)|32+a)>>2],b=j2[(f|16+a)>>2],(k=z2(_2(z2(z2(b*b)+z2(i*i)))))==z2(0)?(j2[(r<<2|a)>>2]=t,j2[(f=u<<2)+a>>2]=j2[f+(16+a|0)>>2]<z2(0)?z2(-n):n):(o=z2(t/k),j2[(r<<2|a)>>2]=b*o,j2[(f=u<<2)+a>>2]=j2[f+(16+a|0)>>2]<z2(0)?z2(-n):n,o=z2(i*o)),i=j2[a>>2],j2[(c<<2)+a>>2]=o,T2[A+12>>2]=0,j2[A>>2]=i,f=T2[8+a>>2],T2[A+4>>2]=T2[4+a>>2],T2[A+8>>2]=f;break A;case 10:c=T2[f+60>>2],e=j2[36+((u=c<<2)+f|0)>>2],i=z2(1),o=j2[r>>2],n=j2[r+4>>2],t=j2[r+8>>2],(b=z2(z2(z2(o*o)+z2(n*n))+z2(t*t)))<z2(14210854715202004e-30)||(i=z2(z2(1)/z2(_2(b))),B=z2(t*i),Q=z2(n*i),i=z2(o*i)),T2[(f=40+a|0)>>2]=0,T2[f+4>>2]=0,T2[32+a>>2]=0,T2[36+a>>2]=0,j2[u+(32+a|0)>>2]=e,o=z2(-0xde0b6b000000000),n=z2(0),t=z2(0),b=j2[32+a>>2],k=j2[36+a>>2],s=j2[f>>2],(v=z2(z2(z2(i*b)+z2(Q*k))+z2(B*s)))>z2(-0xde0b6b000000000)&&(n=k,t=s,g=b,o=v),T2[f>>2]=0,T2[f+4>>2]=0,T2[32+a>>2]=0,T2[36+a>>2]=0,j2[(32+a|0)+(c<<2)>>2]=-e,b=j2[f>>2],k=j2[32+a>>2],s=j2[36+a>>2],T2[A+12>>2]=0,f=z2(z2(z2(i*k)+z2(Q*s))+z2(B*b))>o,j2[A+8>>2]=f?b:t,j2[A+4>>2]=f?s:n,j2[A>>2]=f?k:g;break A;case 5:if(o=j2[f+28>>2],n=j2[f+24>>2],t=j2[f+20>>2],c=T2[f+100>>2],(0|(d=T2[f+104>>2]))<1)u=-1;else for(b=z2(j2[r+8>>2]*o),k=z2(j2[r+4>>2]*n),s=z2(j2[r>>2]*t),r=0,u=-1,i=z2(-34028234663852886e22),f=c;i=(l=i<(v=z2(z2(z2(s*j2[f>>2])+z2(k*j2[f+4>>2]))+z2(b*j2[f+8>>2]))))?v:i,u=l?r:u,f=f+16|0,(0|d)!=(0|(r=r+1|0)););T2[A+12>>2]=0,j2[A+8>>2]=o*j2[(f=c+(u<<4)|0)+8>>2],j2[A+4>>2]=n*j2[f+4>>2],j2[A>>2]=t*j2[f>>2];break A;case 4:if(o=j2[f+28>>2],n=j2[f+24>>2],t=j2[f+20>>2],c=T2[f+112>>2],(0|(d=T2[f+104>>2]))<1)u=-1;else for(b=z2(j2[r+8>>2]*o),k=z2(j2[r+4>>2]*n),s=z2(j2[r>>2]*t),r=0,u=-1,i=z2(-34028234663852886e22),f=c;i=(l=i<(v=z2(z2(z2(s*j2[f>>2])+z2(k*j2[f+4>>2]))+z2(b*j2[f+8>>2]))))?v:i,u=l?r:u,f=f+16|0,(0|d)!=(0|(r=r+1|0)););T2[A+12>>2]=0,j2[A+8>>2]=o*j2[(f=c+(u<<4)|0)+8>>2],j2[A+4>>2]=n*j2[f+4>>2],j2[A>>2]=t*j2[f>>2];break A;default:break f;}n1[T2[T2[f>>2]+68>>2]](A,f,r);}L2=48+a|0;}function i2(A,f,r){A|=0,f|=0,r|=0;var e,i,a=z2(0),n=z2(0),o=z2(0);n1[T2[T2[f>>2]+68>>2]](A,f,r),z2(n1[T2[T2[f>>2]+48>>2]](f))!=z2(0)&&(n=j2[r+4>>2],a=j2[r>>2],o=j2[r+8>>2],e=z2(n1[T2[T2[f>>2]+48>>2]](f)),i=a=(f=z2(z2(z2(a*a)+z2(n*n))+z2(o*o))<z2(14210854715202004e-30))?z2(-1):a,o=f?z2(-1):o,n=f?z2(-1):n,a=z2(z2(1)/z2(_2(z2(z2(o*o)+z2(z2(a*a)+z2(n*n)))))),j2[A>>2]=j2[A>>2]+z2(e*z2(i*a)),j2[A+4>>2]=j2[A+4>>2]+z2(e*z2(n*a)),j2[A+8>>2]=j2[A+8>>2]+z2(e*z2(o*a)));}function a2(A){var f,r,e=0,i=0,a=0;if(T2[(A|=0)>>2]=7868,(e=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+56>>2]=0,p2[A+60|0]=1,T2[(e=A+48|0)>>2]=0,1<=((T2[e+4>>2]=0)|(a=T2[A+28>>2])))for(e=8;i=T2[A+36>>2]+e|0,(r=T2[(f=i+4|0)>>2])&&S2[i+8|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[f>>2]=0,p2[i+8|0]=1,T2[(i=i-4|0)>>2]=0,e=e+36|(T2[i+4>>2]=0),a=a-1|0;);return (e=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+36>>2]=0,T2[A+28>>2]=0,T2[A+32>>2]=0,p2[A+40|0]=1,(e=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+16>>2]=0,p2[A+20|0]=1,T2[(e=A+8|0)>>2]=0,(T2[e+4>>2]=0)|A;}function n2(A){for(var f=z2(0),r=z2(0),e=z2(0),i=0,a=0,n=0,o=0,b=T2[A+28>>2],o=1;;){A:{f:switch(0|a){case 0:f=z2(j2[A+88>>2]+j2[A+72>>2]),r=z2(j2[A+84>>2]+j2[A+68>>2]),e=z2(j2[A+80>>2]+j2[A+64>>2]);break A;case 1:f=z2(j2[A+72>>2]-j2[A+88>>2]),r=z2(j2[A+84>>2]+j2[A+68>>2]),e=z2(j2[A+80>>2]+j2[A+64>>2]);break A;case 2:f=z2(j2[A+88>>2]+j2[A+72>>2]),r=z2(j2[A+68>>2]-j2[A+84>>2]),e=z2(j2[A+80>>2]+j2[A+64>>2]);break A;case 3:f=z2(j2[A+72>>2]-j2[A+88>>2]),r=z2(j2[A+68>>2]-j2[A+84>>2]),e=z2(j2[A+80>>2]+j2[A+64>>2]);break A;case 4:f=z2(j2[A+88>>2]+j2[A+72>>2]),r=z2(j2[A+84>>2]+j2[A+68>>2]),e=z2(j2[A+64>>2]-j2[A+80>>2]);break A;case 5:f=z2(j2[A+72>>2]-j2[A+88>>2]),r=z2(j2[A+84>>2]+j2[A+68>>2]),e=z2(j2[A+64>>2]-j2[A+80>>2]);break A;case 6:f=z2(j2[A+88>>2]+j2[A+72>>2]),r=z2(j2[A+68>>2]-j2[A+84>>2]),e=z2(j2[A+64>>2]-j2[A+80>>2]);break A;case 7:break f;default:break A;}f=z2(j2[A+72>>2]-j2[A+88>>2]),r=z2(j2[A+68>>2]-j2[A+84>>2]),e=z2(j2[A+64>>2]-j2[A+80>>2]);}A:{if(1<=(0|b))for(i=T2[A+36>>2]+32|0,n=b;;){if(z2(j2[i>>2]+z2(z2(z2(e*j2[i-12>>2])+z2(r*j2[i-8>>2]))+z2(f*j2[i-4>>2])))>z2(0))break A;if(i=i+36|0,!(n=n-1|0))break;}if(o=a>>>0<7,8!=(0|(a=a+1|0)))continue;}break;}return 1&(-1^o);}function b2(A){var f,r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G=0,C=0,E=0,D=0,h=0,Z=z2(0),Y=0,R=0,F=z2(0),W=z2(0),m=0,N=z2(0),V=z2(0),J=0,M=z2(0),I=0,x=0,y=0,U=z2(0),X=0,p=0,T=z2(0),S=0,j=0,P=0,z=z2(0),O=0,H=z2(0),_=0,L=0,K=(0),q=(0);T2[A+64>>2]=0,T2[A+68>>2]=0,T2[(C=A+72|0)>>2]=0;A:{if(!(((T2[C+4>>2]=0)|(I=T2[A+28>>2]))<1)){for(;;){if(G=T2[A+36>>2],n=P2(_,36),1<=(0|(o=T2[4+(G+n|0)>>2]))){for(i=-65536|_,L=0;;){C=T2[12+(G+n|0)>>2],u=x>>>0<=(I=(c=(r=(h=(0|(E=$[C+(L<<2)>>1]))<(0|(R=$[C+(((b=(0|o)==(0|(L=L+1|0)))?0:L)<<2)>>1])))?R:E)+(t=(p=h?E:R)<<16)|0)&Y-1)>>>0,E=0;f:if(!u&&-1!=((E=0)|(G=T2[(I<<2)+y>>2]))){r:{for(;;){if(A2[(E=(C=G<<2)+m|0)+2>>1]==(65535&p)&&A2[E>>1]==(65535&r))break r;if(-1==(0|(G=T2[C+J>>2])))break;}E=0;break f;}E=C+D|0;}R=T2[A+16>>2],Z=z2(j2[(C=R+(p<<4)|0)+8>>2]-j2[(R=R+(r<<4)|0)+8>>2]),W=z2(j2[C>>2]-j2[R>>2]),F=z2(j2[C+4>>2]-j2[R+4>>2]),N=z2(z2(1)/z2(_2(z2(z2(z2(W*W)+z2(F*F))+z2(Z*Z))))),Z=z2(Z*N),F=z2(F*N),W=z2(W*N);f:{if(!(S=(0|(C=T2[A+48>>2]))<1))for(G=T2[A+56>>2],h=C;;){if(N=j2[G+8>>2],M=j2[G+4>>2],U=j2[G>>2],!(1e-6<+z2(O2(z2(U-W)))||1e-6<+z2(O2(z2(M-F)))||1e-6<+z2(O2(z2(N-Z)))))break f;if(!(1e-6<+z2(O2(z2(W+U)))||1e-6<+z2(O2(z2(F+M)))||1e-6<+z2(O2(z2(Z+N)))))break f;if(G=G+16|0,!(h=h-1|0))break;}if(T2[A+52>>2]==(0|C)&&!((0|(h=C?C<<1:1))<=(0|C))){if(R=0,h&&(T2[5498]=T2[5498]+1,(G=K2(19+(h<<4)|0))&&(T2[(R=G+19&-16)-4>>2]=G)),!S)for(G=0;S=T2[A+56>>2]+G|0,a=T2[S+4>>2],T2[(f=G+R|0)>>2]=T2[S>>2],T2[4+f>>2]=a,a=T2[(S=S+8|0)+4>>2],T2[(f=8+f|0)>>2]=T2[S>>2],T2[4+f>>2]=a,G=G+16|0,C=C-1|0;);(C=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[C-4>>2])),T2[A+56>>2]=R,p2[A+60|0]=1,T2[A+52>>2]=h,C=T2[A+48>>2];}C=T2[A+56>>2]+(C<<4)|0,T2[C+12>>2]=0,j2[C+8>>2]=Z,j2[C+4>>2]=F,j2[C>>2]=W,T2[A+48>>2]=T2[A+48>>2]+1;}f:{if(E)$[E+2>>1]=_;else {r:{if(!u&&-1!=(0|(G=T2[(I<<2)+y>>2])))for(;;){if(A2[(E=(C=G<<2)+m|0)+2>>1]==(65535&p)&&A2[E>>1]==(65535&r))break r;if(-1==(0|(G=T2[C+J>>2])))break;}if((0|Y)==(0|j)){e:if((0|(E=Y?Y<<1:1))<=(0|Y))R=D,E=Y;else {if(R=0,E&&(T2[5498]=T2[5498]+1,(C=K2(19+(E<<2)|0))&&(T2[(R=C+19&-16)-4>>2]=C)),1<=(0|Y))for(G=R,h=D,C=Y;p=A2[h>>1]|A2[h+2>>1]<<16,$[G>>1]=p,$[G+2>>1]=p>>>16,G=G+4|0,h=h+4|0,C=C-1|0;);else if(!D)break e;T2[5499]=T2[5499]+1,q2(T2[D-4>>2]);}D=Y;}else R=D,E=Y,D=j;$[(D=(D<<2)+R|0)>>1]=i,$[D+2>>1]=i>>>16;e:if((0|X)==(0|O)){if((0|(O=X?X<<1:1))<=(0|X))O=X,C=m;else {if(C=0,O&&(T2[5498]=T2[5498]+1,(D=K2(19+(O<<2)|0))&&(T2[(C=D+19&-16)-4>>2]=D)),1<=(0|X))for(G=C,h=m,D=X;p=A2[h>>1]|A2[h+2>>1]<<16,$[G>>1]=p,$[G+2>>1]=p>>>16,G=G+4|0,h=h+4|0,D=D-1|0;);else if(!m)break e;T2[5499]=T2[5499]+1,q2(T2[m-4>>2]);}}else C=m;if($[(D=(X<<2)+C|0)>>1]=m=65535&r|t,$[D+2>>1]=m>>>16,X=X+1|0,(0|Y)<(0|E)&&(I=E-1&c,(0|x)<(0|E))){if((0|E)<=(0|K))m=y;else {m=0,E&&(T2[5498]=T2[5498]+1,(D=K2(19+(E<<2)|0))&&(T2[(m=D+19&-16)-4>>2]=D));e:{if(1<=(0|x))for(G=m,h=y,Y=x;T2[G>>2]=T2[h>>2],G=G+4|0,h=h+4|0,Y=Y-1|0;);else if(!y)break e;T2[5499]=T2[5499]+1,q2(T2[y-4>>2]);}K=E;}if(d2((x<<2)+m|0,0,E-x<<2),y=E<<2,(0|E)<=(0|P))D=J;else {if((0|E)<=(0|q))D=J;else {D=0,E&&(T2[5498]=T2[5498]+1,(Y=K2(16+(3|y)|0))&&(T2[(D=Y+19&-16)-4>>2]=Y));e:{if(1<=(0|P))for(G=D,h=J,Y=P;T2[G>>2]=T2[h>>2],G=G+4|0,h=h+4|0,Y=Y-1|0;);else if(!J)break e;T2[5499]=T2[5499]+1,q2(T2[J-4>>2]);}q=E;}d2((P<<2)+D|0,0,E-P<<2);}if(1<=(0|E)&&(d2(m,255,y),d2(D,255,y)),1<=(0|x))for(Y=E-1|0,h=G=0;J=((Y&(A2[(J=G+C|0)+2>>1]<<16)+$[J>>1])<<2)+m|0,T2[G+D>>2]=T2[J>>2],G=G+4|0,(0|x)!=(0|(h=(T2[J>>2]=h)+1|0)););y=m,x=P=E,J=D;}T2[(j<<2)+J>>2]=T2[(D=(I<<2)+y|0)>>2],j=(T2[D>>2]=j)+1|0;break f;}$[(C=C+D|0)>>1]=i,$[C+2>>1]=i>>>16;}R=D,E=Y,C=m;}if(b)break;G=T2[A+36>>2],D=R,Y=E,m=C;}I=T2[A+28>>2],Y=E,m=C,D=R;}if(!((0|(_=_+1|0))<(0|I)))break;}if(!((0|I)<1)){for(Y=T2[A+16>>2],X=T2[A+36>>2],x=0;;){if(E=X+P2(x,36)|0,3<=(0|(C=T2[E+4>>2])))for(G=(E=T2[E+12>>2])+4|0,O=(R=Y+(T2[E>>2]<<4)|0)+8|0,K=R+4|0,W=j2[A+72>>2],N=j2[A+68>>2],M=j2[A+64>>2],h=2;j=Y+(T2[G>>2]<<4)|0,Z=j2[j+8>>2],P=Y+(T2[E+((0|h)%(0|C)<<2)>>2]<<4)|0,F=j2[P+8>>2],U=j2[R>>2],k=j2[j>>2],l=z2(U-k),V=j2[K>>2],s=j2[P+4>>2],e=z2(V-s),v=j2[j+4>>2],T=z2(V-v),d=j2[P>>2],B=z2(U-d),H=z2(z2(l*e)-z2(T*B)),w=T,T=j2[O>>2],Q=z2(T-F),g=z2(T-Z),e=z2(z2(w*Q)-z2(g*e)),F=z2(z2(z2(T+Z)+F)*z2(.3333333432674408)),Z=z2(z2(g*B)-z2(l*Q)),Z=z2(z2(_2(z2(z2(H*H)+z2(z2(e*e)+z2(Z*Z)))))*z2(.5)),W=z2(W+z2(F*Z)),j2[A+72>>2]=W,N=z2(N+z2(z2(z2(s+z2(V+v))*z2(.3333333432674408))*Z)),j2[A+68>>2]=N,M=z2(M+z2(z2(z2(d+z2(U+k))*z2(.3333333432674408))*Z)),j2[A+64>>2]=M,z=z2(z+Z),G=G+4|0,(0|C)!=(0|(h=h+1|0)););if((0|I)==(0|(x=x+(G=1)|0)))break;}break A;}}G=0;}if(T2[A+96>>2]=2139095039,Z=z2(z2(1)/z),W=z2(Z*j2[A+64>>2]),j2[A+64>>2]=W,N=z2(Z*j2[A+68>>2]),j2[A+68>>2]=N,M=z2(Z*j2[A+72>>2]),j2[A+72>>2]=M,U=z2(34028234663852886e22),F=z2(34028234663852886e22),G)for(G=T2[A+36>>2]+32|0;(Z=z2(O2(z2(j2[G>>2]+z2(z2(z2(W*j2[G-12>>2])+z2(j2[G-8>>2]*N))+z2(j2[G-4>>2]*M))))))<F&&(F=j2[A+96>>2]=Z),G=G+36|0,I=I-1|0;);if((0|(h=T2[A+8>>2]))<1)Z=z2(-34028234663852886e22),W=z2(34028234663852886e22),N=z2(-34028234663852886e22),M=z2(-34028234663852886e22),z=z2(34028234663852886e22);else for(G=T2[A+16>>2],M=z2(-34028234663852886e22),z=z2(34028234663852886e22),N=z2(-34028234663852886e22),Z=z2(-34028234663852886e22),W=z2(34028234663852886e22);M=M<(V=j2[G+8>>2])?V:M,W=V<W?V:W,N=N<(V=j2[G+4>>2])?V:N,U=V<U?V:U,Z=Z<(V=j2[G>>2])?V:Z,z=V<z?V:z,G=G+16|0,h=h-1|0;);T2[A+128>>2]=0,V=z2(M-W),j2[A+124>>2]=V,H=z2(N-U),j2[A+120>>2]=H,T=z2(Z-z),j2[A+116>>2]=T,F=z2(F/z2(1.7320507764816284)),j2[A+88>>2]=F,T2[A+112>>2]=0,j2[A+108>>2]=W+M,j2[A+104>>2]=U+N,j2[A+100>>2]=Z+z,j2[A+84>>2]=F,j2[A+80>>2]=F,E=(C=(Y=T<H?H<V?2:1:(T<V)<<1)<<2)+(A+80|0)|0,Z=z2(j2[C+(A+116|0)>>2]*z2(.5)),j2[E>>2]=Z,W=z2(z2(Z-F)*z2(.0009765625)),G=1024;A:{f:{for(;;){if(n2(A))break f;if(Z=z2(Z-W),j2[E>>2]=Z,!(G=G-1|0))break;}j2[A+84>>2]=F,j2[A+88>>2]=F,j2[A+80>>2]=F;break A;}for(Y=(E=A+80|0)+((C=1<<Y&3)<<2)|0,Z=j2[(E=E+((1<<C&3)<<2)|0)>>2],W=z2(z2(j2[A+96>>2]-F)*z2(.0009765625)),C=1024;;){if(N=j2[Y>>2],j2[Y>>2]=W+N,F=z2(W+j2[E>>2]),j2[E>>2]=F,n2(A)){if(Z=F,C=C-1|0)continue;break A;}break;}j2[Y>>2]=N,j2[E>>2]=Z;}m&&(T2[5499]=T2[5499]+1,q2(T2[m-4>>2])),D&&(T2[5499]=T2[5499]+1,q2(T2[D-4>>2])),J&&(T2[5499]=T2[5499]+1,q2(T2[J-4>>2])),y&&(T2[5499]=T2[5499]+1,q2(T2[y-4>>2]));}function N2(A,f,r,e,i,a,n){var o,b,t,c,u=z2(0),k=z2(0),l=0,s=0;if(T2[e>>2]=2139095039,T2[i>>2]=-8388609,s=T2[A+(l=8)>>2],u=z2(-34028234663852886e22),!((0|s)<1)){for(;o=T2[A+16>>2]+l|0,u=j2[o-8>>2],k=j2[o-4>>2],b=j2[o>>2],t=z2(z2(z2(z2(u*j2[f>>2])+z2(k*j2[f+4>>2]))+z2(b*j2[f+8>>2]))+j2[f+48>>2]),c=z2(z2(z2(z2(u*j2[f+16>>2])+z2(k*j2[f+20>>2]))+z2(b*j2[f+24>>2]))+j2[f+52>>2]),k=z2(z2(z2(z2(u*j2[f+32>>2])+z2(k*j2[f+36>>2]))+z2(b*j2[f+40>>2]))+j2[f+56>>2]),(u=z2(z2(z2(t*j2[r>>2])+z2(c*j2[r+4>>2]))+z2(k*j2[r+8>>2])))<j2[e>>2]&&(j2[e>>2]=u,T2[a+12>>2]=0,j2[a+8>>2]=k,j2[a+4>>2]=c,j2[a>>2]=t),u>j2[i>>2]&&(j2[i>>2]=u,T2[n+12>>2]=0,j2[n+8>>2]=k,j2[n+4>>2]=c,j2[n>>2]=t),l=l+16|0,s=s-1|0;);u=j2[i>>2];}u<(k=j2[e>>2])&&(j2[e>>2]=u,j2[i>>2]=k,r=T2[(A=a+8|0)>>2],e=T2[A+4>>2],l=T2[(f=n+8|0)+4>>2],T2[A>>2]=T2[f>>2],T2[A+4>>2]=l,A=T2[a>>2],i=T2[a+4>>2],l=T2[n+4>>2],T2[a>>2]=T2[n>>2],T2[a+4>>2]=l,T2[n>>2]=A,T2[n+4>>2]=i,T2[f>>2]=r,T2[f+4>>2]=e);}function c2(A,f,r,e,i,a){var n,o,b,t,c,u,k=0,l=0;return (0|(k=T2[a+16>>2]))!=(0|i)?i-k|0:i?(t=T2[a+8>>2],o=e1(n=T2[a+12>>2],k=0,c=A,0),A=z,l=f,b=e1(n,f=0,l,f),k=z,k=(n=A+b|0)>>>0<b>>>0?k+1|0:k,f=e1(l,0,t,0),A=k,k=A=(n=z+n|0)>>>0<z>>>0?A+1|0:A,k=(n=n+(A=(o=f+o|0)>>>0<f>>>0)|0)>>>0<A>>>0?k+1|0:k,l=n,A=o,o=e1(t,0,c,0),A=(f=A)+z|0,u=t=0+o|0,o=(c=f=l+(A=(0|f)==(0|(n=A=t>>>0<o>>>0?A+1|0:A))&0|A>>>0<f>>>0)|0)>>>0<A>>>0?k+1|0:k,A=T2[a+4>>2],a=T2[a>>2],r=e1(A,k=0,t=r,0),l=z,f=e1(A,0,e,0),A=z,A=(l=l+f|0)>>>0<f>>>0?A+1|0:A,f=e1(e,0,a,0),e=(k=l=(e=z)+l|0)>>>0<e>>>0?A+1|0:A,l=l+(k=A=(r=f+r|0)>>>0<f>>>0)|0,A=e,k=(e=l)>>>0<k>>>0?A+1|0:A,l=-1,b=e,A=r,r=e1(a,e=0,t,0),A=(f=A)+z|0,P2(i,l=!((0|(k=(r=b+(f=(A=(a=e+r|0)>>>0<r>>>0?A+1|0:A)>>>0<f>>>0)|0)>>>0<f>>>0?k+1|0:k))==(0|o)&c>>>0<(f=r)>>>0|o>>>0<k>>>0)?(0|k)==(0|o)&r>>>0<c>>>0|k>>>0<o>>>0?1:(0|A)==(0|n)&u>>>0<a>>>0|n>>>0<A>>>0?-1:(0|A)==(0|n)&a>>>0<u>>>0|A>>>0<n>>>0:l)):0;}function u2(A,f,r){var e=0,i=0,a=0,n=0,o=0,b=0,n=T2[A+56>>2];if(!(n||((e=T2[A+52>>2])?T2[A+52>>2]=T2[e+8>>2]:(a=T2[5498],e=n=0,(i=K2(31))&&(T2[(e=i+19&-16)-4>>2]=i),T2[e+8>>2]=0,T2[5498]=a+2,i=T2[A+60>>2],T2[e+4>>2]=i,(i=K2(P2(i,24)+19|0))&&(T2[(n=i+19&-16)-4>>2]=i),T2[e>>2]=n,n=T2[A+48>>2],T2[A+48>>2]=e,T2[e+8>>2]=n),n=T2[e>>2],(0|(i=T2[e+4>>2]))<1||(e=n+24|0,T2[n>>2]=(a=1==(0|i))?0:e,a))))for(a=1;e=(b=e)+24|0,T2[b>>2]=(0|(a=a+1|0))<(0|i)?e:0,(0|i)!=(0|a););if(T2[A+56>>2]=T2[n>>2],T2[(e=n+8|0)>>2]=0,T2[e+4>>2]=0,T2[(e=n+16|0)>>2]=0,T2[e+4>>2]=0,T2[n>>2]=0,T2[n+4>>2]=0,!((i=T2[A+56>>2])||((e=T2[A+52>>2])?T2[A+52>>2]=T2[e+8>>2]:(o=T2[5498],e=a=0,(i=K2(31))&&(T2[(e=i+19&-16)-4>>2]=i),T2[e+8>>2]=0,T2[5498]=o+2,i=T2[A+60>>2],T2[e+4>>2]=i,(i=K2(P2(i,24)+19|0))&&(T2[(a=i+19&-16)-4>>2]=i),T2[e>>2]=a,i=T2[A+48>>2],T2[A+48>>2]=e,T2[e+8>>2]=i),i=T2[e>>2],(0|(o=T2[e+4>>2]))<1||(e=i+24|0,T2[i>>2]=(a=1==(0|o))?0:e,a))))for(a=1;e=(b=e)+24|0,T2[b>>2]=(0|(a=a+1|0))<(0|o)?e:0,(0|a)!=(0|o););return T2[A+56>>2]=T2[i>>2],T2[(e=i+8|0)>>2]=0,T2[e+4>>2]=0,T2[(a=i+16|0)>>2]=0,T2[a+4>>2]=0,T2[i>>2]=0,T2[i+4>>2]=0,T2[n+8>>2]=i,T2[n+12>>2]=r,T2[n+16>>2]=0,r=T2[A+100>>2],T2[n+20>>2]=r,T2[e>>2]=n,T2[i+12>>2]=f,T2[a>>2]=0,T2[i+20>>2]=r,f=T2[A+116>>2],T2[A+116>>2]=r=f+1|0,(0|f)>=T2[A+120>>2]&&(T2[A+120>>2]=r),n;}function k2(A,f,r,e,i,a,n,o){var b,t,c,u,k,l,s,v=0,v=T2[A+4>>2];return T2[A>>2]==(0|f)?A=(0|f)==(0|v)?(v=T2[f+12>>2],f=T2[T2[f+8>>2]+12>>2],c=T2[f+96>>2],l=T2[v+96>>2]-c|0,A=T2[A+12>>2],b=T2[f+92>>2],s=T2[A+92>>2]-b|0,b=T2[v+92>>2]-b|0,c=T2[A+96>>2]-c|0,t=e1(t=P2(l,s)-P2(b,c)|0,t>>31,t=P2(i,n)-P2(e,o)|0,t>>31),k=z,u=b,b=T2[A+88>>2],A=T2[f+88>>2],v=T2[v+88>>2]-A|0,e=e1(f=A=P2(u,b=b-A|0)-P2(v,s)|0,A>>31,A=P2(e,a)-P2(r,n)|0,A>>31),A=z+k|0,A=(f=e+t|0)>>>0<e>>>0?A+1|0:A,e=f,r=e1(n=f=P2(v,c)-P2(b,l)|0,f>>31,f=P2(r,o)-P2(i,a)|0,f>>31),A=z+A|0,(A=0<(0|(A=(f=e+r|0)>>>0<r>>>0?A+1|0:A))?1:0<=(0|A)?f:0)?2:1):2:(0|f)==(0|v);}function l2(A,f,r,e,i){var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w=0,G=0,C=0,E=0,D=0,h=0,Z=0,Y=0,R=0,F=0,W=0,m=0,N=0,V=0,J=0,M=0,I=0,x=0,y=0,U=0,X=0,p=0,T=0,S=0,j=L2-32|0;if(L2=j,N=T2[i>>2],x=f,(T=T2[e>>2])&&(x=T2[T+12>>2]),X=T2[x+96>>2],J=T2[f+96>>2],u=T2[(E=r)+96>>2]-J|0,Z=T2[(T||N)+12>>2],M=T2[f+92>>2],F=T2[Z+92>>2]-M|0,k=T2[r+92>>2]-M|0,Y=T2[Z+96>>2]-J|0,r=e1(B=r=P2(u,F)-P2(k,Y)|0,s=r>>31,u,C=u>>31),D=z,G=T2[f+88>>2],w=T2[Z+88>>2]-G|0,l=T2[E+88>>2]-G|0,f=e1(Q=f=P2(w,k)-P2(F,l)|0,v=f>>31,l,R=l>>31),r=e1(a=r-f|0,n=D-(z+(r>>>0<f>>>0)|0)|0,f=p=T2[x+92>>2],f>>31),Z=z,f=e1(Q,v,k,F=k>>31),D=z,V=r,r=e1(g=r=P2(Y,l)-P2(w,u)|0,d=r>>31,u,C),f=e1(o=f-r|0,b=D-(z+(f>>>0<r>>>0)|0)|0,f=x=T2[x+88>>2],f>>31),w=z+Z|0,w=(r=V+f|0)>>>0<f>>>0?w+1|0:w,f=e1(l,R,g,d),D=z,C=r,r=e1(k,F,B,s),f=e1(t=f-r|0,c=D-(z+(f>>>0<r>>>0)|0)|0,X,X>>31),w=z+w|0,D=(F=r=C+f|0)>>>0<f>>>0?w+1|0:w,f=e1(B,s,G,G>>31),r=z,C=f,f=e1(Q,v,J,J>>31),w=z+r|0,w=(Z=C+f|0)>>>0<f>>>0?w+1|0:w,r=e1(g,d,M,M>>31),f=z+w|0,Z=(R=Z=r+Z|0)>>>0<r>>>0?f+1|0:f,E=N?T2[N+12>>2]:E,S=T2[E+96>>2],J=T2[E+92>>2],M=T2[E+88>>2],r=N,T&&T2[T+12>>2]&&(f=T2[T2[T+8>>2]+4>>2],U=T2[f+12>>2],w=e1(Y=r=T2[U+92>>2],C=r>>31,g,d),E=z,r=N,h=w,G=e1(V=w=T2[U+88>>2],m=w>>31,B,s),w=z+E|0,w=(h=h+G|0)>>>0<G>>>0?w+1|0:w,G=e1(y=G=T2[U+96>>2],W=G>>31,Q,v),w=z+w|0,!(w=(0|(w=(E=G+h|0)>>>0<G>>>0?w+1|0:w))<(0|(G=Z))?1:(0|w)<=(0|G)?E>>>0<R>>>0:0))){for(E=f+12|0;T2[f+20>>2]!=(0|A)&&(r=e1(Y,C,a,n),w=z,C=r,r=e1(V,m,o,b),w=z+w|0,w=(C=C+r|0)>>>0<r>>>0?w+1|0:w,r=e1(y,W,t,c),w=z+w|0,!((0|(r=w=(C=r+C|0)>>>0<r>>>0?w+1|0:w))<(0|D)||(0|w)<=(0|D)&&C>>>0<=F>>>0)&&(T2[e>>2]=f,D=T2[E>>2],X=T2[D+96>>2],p=T2[D+92>>2],x=T2[D+88>>2],E=(f=T2[T2[f+8>>2]+4>>2])+12|0,F=C,D=r,h=T2[f+12>>2],r=e1(Y=r=T2[h+92>>2],C=r>>31,g,d),w=z,G=r,r=e1(V=r=T2[h+88>>2],m=r>>31,B,s),w=z+w|0,w=(G=G+r|0)>>>0<r>>>0?w+1|0:w,r=e1(y=r=T2[h+96>>2],W=r>>31,Q,v),w=z+w|0,w=(G=r+G|0)>>>0<r>>>0?w+1|0:w,r=G,(0|Z)<(0|w)||(0|Z)<=(0|w)&&R>>>0<=r>>>0)););r=T2[i>>2];}f=e1(a,n,J,J>>31),w=z,C=f,f=e1(o,b,M,M>>31),w=z+w|0,w=(C=C+f|0)>>>0<f>>>0?w+1|0:w,f=e1(t,c,S,S>>31),w=z+w|0,C=(Y=C=f+C|0)>>>0<f>>>0?w+1|0:w;A:if(r){if(T2[r+12>>2]&&(E=T2[T2[r+8>>2]>>2],h=T2[E+12>>2],f=e1(V=f=T2[h+92>>2],m=f>>31,g,d),w=z,G=f,f=e1(y=f=T2[h+88>>2],W=f>>31,B,s),w=z+w|0,w=(G=G+f|0)>>>0<f>>>0?w+1|0:w,f=e1(I=f=T2[h+96>>2],h=f>>31,Q,v),w=z+w|0,w=(G=f+G|0)>>>0<f>>>0?w+1|0:w,f=G,!((0|w)<(0|Z)||(0|w)<=(0|Z)&&f>>>0<R>>>0)))for(U=E+12|0;;){if(T2[(G=E)+20>>2]==(0|A))break A;if(w=e1(V,m,a,n),f=z,E=w,w=e1(y,W,o,b),f=z+f|0,f=(E=E+w|0)>>>0<w>>>0?f+1|0:f,h=(w=E)+(E=e1(t,c,I,h))|0,w=z+f|0,w=h>>>0<E>>>0?w+1|0:w,h=f=h,E=(0|(E=w))<(0|C)?1:(0|E)<=(0|C)?h>>>0<=Y>>>0:0)break A;if(T2[i>>2]=G,r=T2[U>>2],S=T2[r+96>>2],J=T2[r+92>>2],M=T2[r+88>>2],U=(E=T2[T2[G+8>>2]>>2])+12|0,Y=f,C=w,r=G,h=T2[E+12>>2],f=e1(V=f=T2[h+92>>2],m=f>>31,g,d),w=z,G=f,f=e1(y=f=T2[h+88>>2],W=f>>31,B,s),w=z+w|0,w=(G=G+f|0)>>>0<f>>>0?w+1|0:w,f=e1(I=f=T2[h+96>>2],h=f>>31,Q,v),w=z+w|0,w=(G=f+G|0)>>>0<f>>>0?w+1|0:w,f=G,!((0|Z)<(0|w)||(0|Z)<=(0|w)&&R>>>0<=f>>>0))break;}}else r=0;A:{if(D=C-((Y>>>0<F>>>0)+D|0)|0,f=F=Y-F|0,f=0<(0|D)?1:0<=(0|D)?1<=f>>>0:0)for(;;){for(f=T2[e>>2];;){f:if(m=(Z=r=V=(P2(J-p|0,k)+P2(M-x|0,l)|0)+P2(S-X|0,u)|0)>>31,f&&T2[f+12>>2]&&(W=T2[T2[f>>2]+8>>2],!(T2[W+20>>2]<=(0|A)))){r=T2[W+12>>2],Y=T2[r+92>>2],G=(C=T2[r+88>>2])-x|0,E=(R=T2[r+96>>2])-X|0,r=(P2(w=Y-p|0,k)+P2(G,l)|0)+P2(E,u)|0,N=e1(a,n,w,w>>31),w=z,h=N,N=e1(o,b,G,G>>31),w=z+w|0,w=(G=h+N|0)>>>0<N>>>0?w+1|0:w,N=e1(t,c,E,E>>31),w=z+w|0;r:{if(!((G=N+G|0)|(N=w=G>>>0<N>>>0?w+1|0:w))){if((0|r)<0)break r;break f;}if(-1<(0|N))break f;if(y=0<(0|r),U=r>>>31|0,h=(w=(0|r)<0)?0-r|0:0,I=r>>31,E=w?0-(I+(0!=(0|r))|0)|0:0,w=1<=(0|V)?(T2[8+j>>2]=Z,T2[12+j>>2]=m,-(T2[24+j>>2]=1)):(0|V)<=-1?(T2[24+j>>2]=-1,T2[8+j>>2]=0-Z,T2[12+j>>2]=0-((0!=(0|Z))+m|0),1):(T2[8+j>>2]=0,T2[12+j>>2]=0,T2[24+j>>2]=0),U=y?-1:U,h=y?r:h,E=y?I:E,G=0-(r=G)|0,N=0-((0!=(0|r))+N|0)|0,r=F,(y=0<(0|(I=D))?1:0<=(0|D)?F:0)||-1<((I=r=0)|D)||(T2[24+j>>2]=w,r=0-F|0,I=0-((0!=(0|F))+D|0)|0),T2[16+j>>2]=r,T2[20+j>>2]=I,(0|c2(h,E,G,N,U,8+j|0))<=-1)break f;}T2[e>>2]=f=(0|f)==(0|T)?0:W,r=e1(a,n,r=J-Y|0,r>>31),D=z,F=(w=r)+(r=e1(o,b,r=M-C|0,r>>31))|0,w=z+D|0,w=F>>>0<r>>>0?w+1|0:w,r=e1(t,c,r=S-R|0,r>>31),w=z+w|0,D=(F=D=r+F|0)>>>0<r>>>0?w+1|0:w,x=C,p=Y,X=R;continue;}break;}if(!(f=T2[i>>2]))break A;if(!T2[f+12>>2])break A;if(W=T2[T2[f+8>>2]>>2],T2[W+20>>2]<=(0|A))break A;if(Y=T2[W+12>>2],f=e1(h=f=U=(I=T2[Y+92>>2])-J|0,J=f>>31,g,d),R=z,C=f,r=e1(E=f=M=(w=T2[Y+88>>2])-M|0,G=f>>31,B,s),f=z+R|0,f=(C=C+r|0)>>>0<r>>>0?f+1|0:f,f=(0|(y=C))!=(0-(r=e1(Q,v,N=r=R=(C=T2[Y+96>>2])-S|0,Y=r>>31))|0)?1:(0-(z+(0!=(0|r))|0)|0)!=(0|f))break A;if(f=e1(a,n,f=I-p|0,f>>31),r=z,I=f,f=e1(o,b,f=w-x|0,f>>31),w=z+r|0,w=(S=I+f|0)>>>0<f>>>0?w+1|0:w,f=e1(t,c,f=C-X|0,f>>31),w=z+w|0,w=(r=f+S|0)>>>0<f>>>0?w+1|0:w,f=r,C=(0|(r=w))<0?1:(0|r)<=0?f>>>0<1:0)break A;R=(P2(U,k)+P2(M,l)|0)+P2(R,u)|0,C=e1(h,J,a,n),w=z,h=C,C=e1(E,G,o,b),w=z+w|0,w=(G=h+C|0)>>>0<C>>>0?w+1|0:w,C=e1(t,c,N,Y),w=z+w|0;f:{if(!((Y=C+G|0)|(C=w=Y>>>0<C>>>0?w+1|0:w))){if((0|R)<0)break f;break A;}if(-1<(0|C))break A;if(J=0<(0|R),E=R>>>31|0,G=(R=(0|(w=R))<0)?0-w|0:0,M=w>>31,N=R?0-(M+(0!=(0|w))|0)|0:0,R=1<=(0|V)?(T2[8+j>>2]=Z,T2[12+j>>2]=m,-(T2[24+j>>2]=1)):(0|V)<=-1?(T2[24+j>>2]=-1,T2[8+j>>2]=0-Z,T2[12+j>>2]=0-((0!=(0|Z))+m|0),1):(T2[8+j>>2]=0,T2[12+j>>2]=0,T2[24+j>>2]=0),E=J?-1:E,G=J?w:G,N=J?M:N,Y=0-(Z=Y)|0,w=0-((0!=(0|Z))+C|0)|0,C=Z=D,D=F,(V=0<(0|C)?1:0<=(0|Z)?D:0)||-1<((C=F=0)|Z)||(T2[24+j>>2]=R,F=0-D|0,C=0-((0!=(0|D))+Z|0)|0),T2[16+j>>2]=F,T2[20+j>>2]=C,(0|c2(G,N,Y,w,E,8+j|0))<=0)break A;}T2[i>>2]=W,D=T2[W+12>>2],S=T2[D+96>>2],J=T2[D+92>>2],M=T2[D+88>>2],F=f,D=r;}if(!(-1<(0|D)))for(;;){V=(Z=f=T=(P2(J-p|0,k)+P2(M-x|0,l)|0)+P2(S-X|0,u)|0)>>31;f:if(r&&T2[r+12>>2]&&(y=T2[T2[r+4>>2]+8>>2],!(T2[y+20>>2]<=(0|A)))){R=T2[y+12>>2],Y=T2[R+92>>2],G=(C=T2[R+88>>2])-M|0,E=(R=T2[R+96>>2])-S|0,h=(P2(f=Y-J|0,k)+P2(G,l)|0)+P2(E,u)|0,w=e1(a,n,f,f>>31),f=z,I=w,w=e1(o,b,G,G>>31),f=z+f|0,f=(G=I+w|0)>>>0<w>>>0?f+1|0:f,E=(w=G)+(G=e1(t,c,E,E>>31))|0,w=z+f|0;r:{if(!(E|(G=w=E>>>0<G>>>0?w+1|0:w))){if(0<(0|h))break r;break f;}if(-1<(0|G))break f;if(m=0<(0|h),I=h>>>31|0,U=(w=(0|(f=h))<0)?0-f|0:0,W=f>>31,h=w?0-(W+(0!=(0|f))|0)|0:0,w=1<=(0|T)?(T2[8+j>>2]=Z,T2[12+j>>2]=V,-(T2[24+j>>2]=1)):(0|T)<=-1?(T2[24+j>>2]=-1,T2[8+j>>2]=0-Z,T2[12+j>>2]=0-((0!=(0|Z))+V|0),1):(T2[8+j>>2]=0,T2[12+j>>2]=0,T2[24+j>>2]=0),I=m?-1:I,U=m?f:U,h=m?W:h,E=0-(f=E)|0,G=0-((0!=(0|f))+G|0)|0,f=F,(m=0<(0|(W=D))?1:0<=(0|D)?F:0)||-1<((W=f=0)|D)||(T2[24+j>>2]=w,f=0-F|0,W=0-((0!=(0|F))+D|0)|0),T2[16+j>>2]=f,T2[20+j>>2]=W,1<=(0|c2(U,h,E,G,I,8+j|0)))break f;}T2[i>>2]=r=(0|r)==(0|N)?0:y,f=e1(a,n,f=Y-p|0,f>>31),D=z,F=(w=f)+(f=e1(o,b,f=C-x|0,f>>31))|0,w=z+D|0,w=F>>>0<f>>>0?w+1|0:w,D=e1(t,c,f=R-X|0,f>>31),f=z+w|0,D=f=(F=D+F|0)>>>0<D>>>0?f+1|0:f,M=C,J=Y,S=R;continue;}if(!(f=T2[e>>2]))break A;if(!T2[f+12>>2])break A;if(m=T2[T2[f+8>>2]+4>>2],T2[m+20>>2]<=(0|A))break A;if(C=T2[m+12>>2],f=e1(I=f=W=(y=T2[C+92>>2])-p|0,U=f>>31,g,d),r=z,R=(w=f)+(f=e1(E=f=p=(h=T2[C+88>>2])-x|0,G=f>>31,B,s))|0,w=z+r|0,w=R>>>0<f>>>0?w+1|0:w,f=(0|(r=R))!=(0-(f=e1(Q,v,x=f=C=(R=T2[C+96>>2])-X|0,Y=f>>31))|0)?1:(0-(z+(0!=(0|f))|0)|0)!=(0|w))break A;if(f=e1(a,n,f=J-y|0,f>>31),r=z,X=(w=f)+(f=e1(o,b,f=M-h|0,f>>31))|0,w=z+r|0,w=X>>>0<f>>>0?w+1|0:w,f=e1(t,c,f=S-R|0,f>>31),w=z+w|0,-1<(0|(f=(R=r=f+X|0)>>>0<f>>>0?w+1|0:w)))break A;if(r=(P2(W,k)+P2(p,l)|0)+P2(C,u)|0,C=e1(I,U,a,n),w=z,h=C,C=e1(E,G,o,b),w=z+w|0,w=(G=h+C|0)>>>0<C>>>0?w+1|0:w,C=e1(t,c,x,Y),w=z+w|0,(w=(Y=C+G|0)>>>0<C>>>0?w+1|0:w)|(C=Y)){if(-1<(0|w))break A;if(X=0<(0|r),p=r>>>31|0,x=(Y=(0|r)<0)?0-r|0:0,E=r>>31,Y=Y?0-(E+(0!=(0|r))|0)|0:0,Z=1<=(0|T)?(T2[8+j>>2]=Z,T2[12+j>>2]=V,-(T2[24+j>>2]=1)):(0|T)<=-1?(T2[24+j>>2]=-1,T2[8+j>>2]=0-Z,T2[12+j>>2]=0-((0!=(0|Z))+V|0),1):(T2[8+j>>2]=0,T2[12+j>>2]=0,T2[24+j>>2]=0),G=X?-1:p,x=X?r:x,Y=X?E:Y,C=0-(r=C)|0,w=0-((0!=(0|r))+w|0)|0,r=F,(V=0<(0|(E=D))?1:0<=(0|D)?r:0)||-1<((E=F=0)|D)||(T2[24+j>>2]=Z,F=0-r|0,E=0-((0!=(0|r))+D|0)|0),T2[16+j>>2]=F,T2[20+j>>2]=E,0<=(0|c2(x,Y,C,w,G,8+j|0)))break A;}else if((0|r)<=0)break A;T2[e>>2]=m,D=T2[m+12>>2],X=T2[D+96>>2],p=T2[D+92>>2],r=T2[i>>2],x=T2[D+88>>2],F=R,D=f;}}L2=32+j|0;}function s2(A,f,r,e,i,a,n){var o,b,t,c,u,k,l,s=0,v=0,d=0,B=0,Q=0,g=0,w=0,G=0,C=0,E=0;if(!(s=T2[r+8>>2]))return 0;for(k=e+8|0,l=e+4|0,w=s;;){if(T2[w+20>>2]>T2[A+100>>2]){v=T2[w+12>>2],s=e1(d=s=b=T2[v+92>>2]-T2[r+92>>2]|0,B=s>>31,T2[i+8>>2],T2[i+12>>2]),Q=z,g=s,o=e1(G=s=t=T2[v+88>>2]-T2[r+88>>2]|0,C=s>>31,T2[i>>2],T2[i+4>>2]),s=z+Q|0,s=(g=g+o|0)>>>0<o>>>0?s+1|0:s,u=e1(Q=v=o=T2[v+96>>2]-T2[r+96>>2]|0,c=v>>31,T2[i+16>>2],T2[i+20>>2]),v=z+s|0,v=(g=u+g|0)>>>0<u>>>0?v+1|0:v,s=e1(T2[a+8>>2],T2[a+12>>2],d,B),B=z,d=(G=e1(T2[a>>2],T2[a+4>>2],G,C))+s|0,s=z+B|0,s=d>>>0<G>>>0?s+1|0:s,B=e1(T2[a+16>>2],T2[a+20>>2],Q,c),s=z+s|0,s=(d=B+d|0)>>>0<B>>>0?s+1|0:s,Q=B=d,s=(s=0<(0|(d=s))?1:0<=(0|d)?Q:0)?(Q=-1,G=0,1):-1<(0|d)?(G=1,Q=d=B=0):(B=0-(s=B)|0,d=0-((0!=(0|s))+d|0)|0,G=0,-(Q=1));A:{if(!(C=0<(0|v)?1:0<=(0|v)?g:0))if((0|v)<-1||(0|v)<=-1)g=0-(s=g)|0,v=0-((0!=(0|s))+v|0)|0,s=Q;else if(v=g=0,G)break A;!E||(0|(Q=c2(B,d,g,v,s,n)))<=-1?(T2[n+16>>2]=s,T2[n+8>>2]=g,T2[n+12>>2]=v,T2[n>>2]=B,T2[n+4>>2]=d,E=w):Q||(E=2!=(0|k2(E,w,T2[e>>2],T2[l>>2],T2[k>>2],t,b,o))^f?w:E);}s=T2[r+8>>2];}if((0|(w=T2[w>>2]))==(0|s))break;}return E;}function v2(A){var f,r,e=0,i=0,a=z2(0);return L2=i=L2-16|0,f=T2[A+8>>2],e=T2[A+12>>2],a=z2(z2(z2(+(f>>>0)+4294967296*((r=e)>>>0))*z2(0x10000000000000000))+z2(+T[A>>2]+4294967296*+T[A+4>>2])),0<(0|e)||0<=(0|e)||(e=T2[A+4>>2],A=T2[A>>2],T2[i>>2]=0-A,T2[4+i>>2]=0-(e+(0!=(0|A))|0),f=(A=!(A|e))+(e=-1^f)|0,A=-1^r,T2[8+i>>2]=f,T2[12+i>>2]=f>>>0<e>>>0?A+1|0:A,a=z2(-v2(i))),L2=16+i|0,a;}function Q2(A,f,r){var e,i,a=0,n=0,o=0,b=0,t=0,c=z2(0),u=z2(0),k=0,l=0,s=0,v=z2(0),d=0,B=z2(0),Q=0,g=0,w=0,G=z2(0),C=z2(0),E=z2(0),D=0,h=z2(0),Z=z2(0),Y=(0),R=0;if(L2=n=L2-176|0,(0|r)<=0)(f=T2[A+12>>2])&&S2[A+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+12>>2]=0,p2[A+16|0]=1,T2[A+4>>2]=0,T2[A+8>>2]=0,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,p2[A+36|0]=1,T2[(f=A+24|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+52>>2])&&S2[A+56|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+52>>2]=0,p2[A+56|0]=1,T2[(A=A+44|0)>>2]=0,T2[A+4>>2]=0;else {for(p2[104+n|0]=1,T2[(a=80+n|0)>>2]=0,T2[a+4>>2]=256,T2[(a=n+64|0)>>2]=0,T2[a+4>>2]=256,T2[(a=48+n|0)>>2]=0,T2[a+4>>2]=256,T2[100+n>>2]=0,T2[(a=92+n|0)>>2]=0,T2[a+4>>2]=0,T2[72+n>>2]=0,T2[76+n>>2]=0,T2[56+n>>2]=0,T2[60+n>>2]=0,T2[40+n>>2]=0,T2[44+n>>2]=0,G=z2(-1.0000000150474662e30),C=z2(1.0000000150474662e30),o=r,a=f,E=z2(1.0000000150474662e30),B=z2(1.0000000150474662e30),h=z2(-1.0000000150474662e30),Z=z2(-1.0000000150474662e30);G=G<(c=j2[a+8>>2])?c:G,h=h<(u=j2[a+4>>2])?u:h,C=c<C?c:C,E=u<E?u:E,Z=Z<(c=j2[a>>2])?c:Z,B=c<B?c:B,a=a+16|0,o=o-1|0;);if(a=1,i=z2(G-C),u=z2(h-E),(0|(t=(c=(v=z2(Z-B))<u?(T2[120+n>>2]=o=u<i?2:1,a=0,v):(T2[120+n>>2]=o=(v<i)<<1,u))<i?a:2))==(0|o)&&(t=(o+1>>>0)%3|0),T2[36+n>>2]=a=0,j2[32+n>>2]=z2(G+C)*z2(.5),j2[28+n>>2]=z2(h+E)*z2(.5),T2[5498]=T2[5498]+1,T2[20+n>>2]=0,j2[24+n>>2]=z2(Z+B)*z2(.5),T2[112+n>>2]=t,T2[116+n>>2]=b=(3^o)-t|0,c=z2(i*z2(9788566967472434e-20)),c=(o=((b+1|0)%3|0)==(0|o))?c:z2(-c),j2[16+n>>2]=c,u=z2(u*z2(9788566967472434e-20)),u=o?u:z2(-u),j2[12+n>>2]=u,v=z2(v*z2(9788566967472434e-20)),v=o?v:z2(-v),j2[8+n>>2]=v,(o=K2(19+(r<<4)|0))&&(T2[(a=o+19&-16)-4>>2]=o),T2[164+n>>2]=a,p2[168+n|0]=1,T2[160+n>>2]=r,o=T2[140+n>>2],T2[a>>2]=T2[136+n>>2],T2[a+4>>2]=o,o=T2[(b=144+n|0)+4>>2],T2[(a=a+8|0)>>2]=T2[b>>2],T2[a+4>>2]=o,1!=(0|r))for(o=r-1|0,a=16;t=T2[140+n>>2],l=T2[164+n>>2]+a|0,T2[l>>2]=T2[136+n>>2],T2[l+4>>2]=t,s=T2[b+4>>2],T2[(l=l+8|0)>>2]=T2[b>>2],T2[l+4>>2]=s,a=a+16|0,o=o-1|0;);for(c=c!=z2(0)?z2(z2(1)/c):c,u=u!=z2(0)?z2(z2(1)/u):u,v=v!=z2(0)?z2(z2(1)/v):v,T2[156+n>>2]=r,l=(136+n|0)+(T2[112+n>>2]<<2)|0,s=(136+n|0)+(T2[120+n>>2]<<2)|0,t=(136+n|0)+(T2[116+n>>2]<<2)|0,a=T2[164+n>>2],G=j2[32+n>>2],C=j2[28+n>>2],E=j2[24+n>>2],o=0;T2[a+12>>2]=o,T2[148+n>>2]=0,j2[136+n>>2]=v*z2(j2[f>>2]-E),j2[144+n>>2]=c*z2(j2[f+8>>2]-G),j2[140+n>>2]=u*z2(j2[f+4>>2]-C),b=a,B=j2[t>>2],k=z2(O2(B))<z2(2147483648)?~~B:-2147483648,T2[b>>2]=k,k=a+4|0,B=j2[s>>2],b=z2(O2(B))<z2(2147483648)?~~B:-2147483648,T2[k>>2]=b,k=a+8|0,B=j2[l>>2],b=z2(O2(B))<z2(2147483648)?~~B:-2147483648,T2[k>>2]=b,f=f+16|0,a=a+16|0,(0|(o=o+1|0))!=(0|r););if(2<=(0|r)&&!function A(f,r,e){var i,a,n,o,b=0,t=0,c=0,u=0,k=0,l=0,s=0,v=0;for(L2=s=L2-16|0,u=T2[f+12>>2],o=T2[8+(c=u+((r+e|0)/2<<4)|0)>>2],a=T2[c+4>>2],n=T2[c>>2],c=r,l=e;;){for(b=(c<<4)+u|0;;){A:{if(!((0|(t=T2[b+4>>2]))<(0|a))){if((0|t)!=(0|a))break A;if(!((0|(t=T2[b>>2]))<(0|n))){if((0|t)!=(0|n))break A;if(T2[b+8>>2]>=(0|o))break A;}}b=b+16|0,c=c+1|0;continue;}break;}for(v=l<<4;;){A:{if(!((0|a)<(0|(k=T2[4+(t=u+v|0)>>2])))){if((0|k)!=(0|a))break A;if(!((0|n)<(0|(k=T2[t>>2])))){if((0|k)!=(0|n))break A;if(T2[t+8>>2]<=(0|o))break A;}}v=v-16|0,l=l-1|0;continue;}break;}if((0|c)<=(0|l)&&(i=T2[4+(k=b+8|0)>>2],T2[(u=8+s|0)>>2]=T2[k>>2],T2[u+4>>2]=i,i=T2[b+4>>2],T2[s>>2]=T2[b>>2],T2[4+s>>2]=i,i=T2[t+4>>2],T2[b>>2]=T2[t>>2],T2[b+4>>2]=i,t=T2[4+(b=t+8|0)>>2],T2[k>>2]=T2[b>>2],T2[k+4>>2]=t,b=T2[f+12>>2]+v|0,v=T2[4+s>>2],T2[b>>2]=T2[s>>2],T2[b+4>>2]=v,t=T2[u+4>>2],T2[(b=b+8|0)>>2]=T2[u>>2],T2[b+4>>2]=t,l=l-1|0,c=c+1|0),!((0|c)<=(0|l)))break;u=T2[f+12>>2];}(0|r)<(0|l)&&A(f,r,l),(0|c)<(0|e)&&A(f,c,e),L2=16+s|0;}(152+n|0,0,r-1|0),T2[48+n>>2]=0,T2[44+n>>2]=T2[40+n>>2],T2[52+n>>2]=r,(0|(b=T2[92+n>>2]))<(0|r)){if(T2[96+n>>2]<(0|r)){if(o=0,T2[5498]=T2[5498]+1,(f=K2(19+(r<<2)|0))&&(T2[(o=f+19&-16)-4>>2]=f),1<=(0|b))for(a=0,f=b;T2[a+o>>2]=T2[T2[100+n>>2]+a>>2],a=a+4|0,f=f-1|0;);(f=T2[100+n>>2])&&S2[104+n|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[100+n>>2]=o,p2[104+n|0]=1,T2[96+n>>2]=r;}for(a=b<<2,f=r-b|0;a=a+4|(T2[T2[100+n>>2]+a>>2]=0),f=f-1|0;);}for(T2[92+n>>2]=r,t=0;;){if(!((o=T2[48+n>>2])||((a=T2[44+n>>2])?T2[44+n>>2]=T2[a+8>>2]:(b=T2[5498],a=f=0,(o=K2(31))&&(T2[(a=o+19&-16)-4>>2]=o),T2[a+8>>2]=0,o=T2[52+n>>2],T2[a+4>>2]=o,T2[5498]=b+2,(o=K2(P2(o,112)+19|0))&&(T2[(f=o+19&-16)-4>>2]=o),T2[a>>2]=f,T2[a+8>>2]=T2[40+n>>2],T2[40+n>>2]=a),o=T2[a>>2],(0|(b=T2[a+4>>2]))<1||(a=o+112|0,T2[o>>2]=(f=1==(0|b))?0:a,f))))for(f=1;a=(s=a)+112|0,T2[s>>2]=(0|(f=f+1|0))<(0|b)?a:0,(0|f)!=(0|b););if(T2[48+n>>2]=T2[o>>2],T2[(f=o+8|0)>>2]=0,T2[f+4>>2]=0,T2[o+16>>2]=0,T2[o>>2]=0,T2[o+4>>2]=0,T2[o+104>>2]=-1,T2[f>>2]=0,f=T2[164+n>>2]+(t<<4)|0,a=T2[f+4>>2],T2[o+88>>2]=T2[f>>2],T2[o+92>>2]=a,b=T2[(f=f+8|0)+4>>2],T2[(a=o+96|0)>>2]=T2[f>>2],T2[a+4>>2]=b,T2[o+104>>2]=-1,T2[T2[100+n>>2]+(t<<2)>>2]=o,(0|(t=t+1|0))==(0|r))break;}if((f=T2[164+n>>2])&&S2[168+n|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[164+n>>2]=0,p2[168+n|0]=1,T2[156+n>>2]=0,T2[160+n>>2]=0,T2[124+n>>2]=0,T2[128+n>>2]=0,T2[64+n>>2]=0,T2[60+n>>2]=T2[56+n>>2],T2[108+n>>2]=-3,T2[68+n>>2]=P2(r,6),T2[(f=144+n|0)>>2]=0,T2[f+4>>2]=0,T2[136+n>>2]=0,function A(f,r,e,i){var a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0,l=0,s=0,v=0,d=0,B=0,Q=0,g=0,w=0,G=0,C=0,E=0,D=0,h=0,Z=0,Y=0,R=0,F=0,W=0,m=0,N=0,V=0,J=0,M=0,I=0,x=0;L2=b=L2-144|0;A:{f:{r:{e:{i:switch(0|(a=e-r|0)){case 1:break r;case 2:break e;case 0:break i;default:break f;}T2[i>>2]=0,T2[i+4>>2]=0,T2[(f=i+8|0)>>2]=0,T2[f+4>>2]=0;break A;}if(e=T2[T2[f+92>>2]+(r<<2)>>2],a=T2[e+204>>2],t=T2[e+92>>2],(0|(n=T2[e+88>>2]))!=(0|(o=T2[e+200>>2]))||(0|a)!=(0|t)||(a=t,T2[e+96>>2]!=T2[e+208>>2])){r=e+112|0,(c=t-a|0)|(a=n-o|0)?(T2[e+4>>2]=r,T2[e>>2]=r,T2[e+116>>2]=e,T2[e+112>>2]=e,T2[i+4>>2]=(a=(t=(0|a)<0)|(o=(0|c)<0)&!a)?r:e,T2[i>>2]=a?e:r,a=t&!c||o?(T2[i+8>>2]=e,r):(T2[i+8>>2]=r,e)):(t=T2[e+96>>2]>T2[e+208>>2],T2[i+8>>2]=a=t?r:e,T2[i+4>>2]=a,T2[i>>2]=a,T2[a+4>>2]=a,r=t?e:r,e=T2[a>>2]=a),T2[i+12>>2]=a,e=u2(f,i=e,r),T2[i+8>>2]=e,f=T2[e+8>>2],T2[r+8>>2]=f,T2[e+4>>2]=e,T2[e>>2]=e,T2[f+4>>2]=f,T2[f>>2]=f;break A;}T2[e+8>>2]=0,T2[i+12>>2]=e,T2[i+8>>2]=e,T2[i+4>>2]=e,T2[i>>2]=e,T2[e+4>>2]=e,T2[e>>2]=e;break A;}f=T2[T2[f+92>>2]+(r<<2)>>2],T2[f+8>>2]=0,T2[i+12>>2]=f,T2[i+8>>2]=f,T2[i+4>>2]=f,T2[i>>2]=f,T2[f+4>>2]=f,T2[f>>2]=f;break A;}f:if(!((0|e)<=(0|(n=t=(l=(0|a)/2|0)+r|0)))){for(a=T2[f+92>>2],o=T2[(a+(t<<2)|0)-4>>2],u=T2[o+88>>2],c=T2[o+96>>2],o=T2[o+92>>2],a=a+(r+l<<2)|0,n=t;;){if(l=T2[a>>2],(0|u)!=T2[l+88>>2])break f;if((0|o)!=T2[l+92>>2])break f;if((0|c)!=T2[l+96>>2])break f;if(a=a+4|0,!((0|(n=n+1|0))<(0|e)))break;}n=e;}if(A(f,r,t,i),T2[(r=16+b|0)>>2]=0,T2[r+4>>2]=0,T2[8+b>>2]=0,A(f,n,e,8+b|(T2[12+b>>2]=0)),C=T2[12+b>>2])if(Q=T2[i+4>>2]){J=T2[(r=f+100|0)>>2]-1|0,T2[r>>2]=J,E=T2[i+12>>2],r=T2[E+88>>2],l=T2[16+b>>2];f:{r:if((0|r)==T2[l+88>>2]&&(0|(Z=T2[E+92>>2]))==T2[l+92>>2]){if((0|(e=T2[l+4>>2]))==(0|l)){(e=T2[l+8>>2])&&(l=T2[e+12>>2],Z=T2[l+92>>2],r=T2[l+88>>2]),D=r+1|0,C=T2[l+96>>2];break f;}if(r=T2[l>>2],T2[r+4>>2]=e,T2[e>>2]=r,T2[8+b>>2]==(0|l)&&((0|(o=T2[(a=r)+88>>2]))<(0|(t=T2[e+88>>2]))||(0|o)==(0|t)&&T2[r+92>>2]<T2[e+92>>2]||(a=e),T2[8+b>>2]=a),(0|l)==(0|C)){e:{if((0|(t=T2[r+88>>2]))<=(0|(a=T2[e+88>>2]))){if((0|a)!=(0|t))break e;if(T2[r+92>>2]<=T2[e+92>>2])break e;}C=T2[12+b>>2]=r;break r;}C=T2[12+b>>2]=e;}}for(B=T2[i>>2],g=T2[8+b>>2],a=Q,r=C,t=e=0,v=o=1;;){l=t,E=e,t=T2[r+88>>2],u=T2[a+88>>2];r:if(1<=(0|(n=P2(t-u|0,o))))for(w=T2[r+92>>2],e=a;;){for(t=r,a=T2[e+92>>2],u=n;;){e:if(d=w-a|0,(0|(n=T2[(k=1&v?4:0)+e>>2]))!=(0|e)&&!(0<(0|(c=(r=T2[n+92>>2])-a|0)))){if(a=T2[n+88>>2],s=P2(a-T2[e+88>>2]|0,o)){if(-1<(0|s))break e;if((0|P2(c,u))>(0|P2(s,d)))break e;}u=P2(T2[t+88>>2]-a|0,o),a=r,e=n;continue;}break;}if((0|t)==(0|(r=T2[t+k>>2])))break r;if(-1<(0|(k=(a=T2[r+92>>2])-w|0)))break r;if(c=T2[r+88>>2],(0|(n=P2(c-T2[e+88>>2]|0,o)))<1)break r;if(w=a,a=P2(c-T2[t+88>>2]|0,o)){if(-1<(0|a))break r;if(!((0|P2(u,k))<(0|P2(a,d))))break;}}else if((0|n)<=-1){c=T2[a+92>>2],w=T2[r+92>>2];e:for(;;){for(k=T2[(F=1&v?0:4)+r>>2];;){e=a,s=n,W=w-c|0;i:if((0|r)!=(0|k)&&!((0|(n=(a=T2[k+92>>2])-w|0))<0)){if(u=T2[k+88>>2],t=P2(u-t|0,o)){if(-1<(0|t))break i;if((0|P2(n,s))>(0|P2(t,W)))break i;}n=P2(u-T2[e+88>>2]|0,o),t=u,w=a,r=k,a=e;continue e;}if((0|(a=T2[e+F>>2]))==(0|e)){t=r;break r;}if((0|(Y=(u=T2[a+92>>2])-c|0))<1){t=r;break r;}if(t=T2[r+88>>2],d=T2[a+88>>2],-1<(0|(n=P2(t-d|0,o)))){t=r;break r;}if(c=u,u=P2(d-T2[e+88>>2]|0,o)){if(-1<(0|u)){t=r;break r;}if(!((0|P2(s,Y))<(0|P2(u,W))))break;}}break;}t=r;}else {n=T2[a+92>>2];e:if(c=1&v)for(o=a;;){if((0|(o=T2[(e=o)+4>>2]))==(0|a))break e;if((0|u)!=T2[o+88>>2])break e;if(t=n,!((0|(n=T2[o+92>>2]))<=(0|t)))break;}else for(o=a;;){if((0|(o=T2[(e=o)>>2]))==(0|a))break e;if((0|u)!=T2[o+88>>2])break e;if(t=n,!((0|(n=T2[o+92>>2]))<=(0|t)))break;}if(o=T2[r+92>>2],c)for(a=r;;){if((0|(a=T2[(t=a)>>2]))==(0|r))break r;if((0|u)!=T2[a+88>>2])break r;if(!((0|(n=o))<=(0|(o=T2[a+92>>2]))))break;}else for(a=r;;){if((0|(a=T2[(t=a)+4>>2]))==(0|r))break r;if((0|u)!=T2[a+88>>2])break r;if(!((0|(n=o))<=(0|(o=T2[a+92>>2]))))break;}}if(n=1&v,v=0,o=-1,a=B,r=g,!n)break;}if(T2[t>>2]=e,T2[e+4>>2]=t,T2[E>>2]=l,T2[l+4>>2]=E,T2[g+88>>2]<T2[B+88>>2]&&(T2[i>>2]=g),T2[C+88>>2]>=T2[Q+88>>2]&&(T2[i+4>>2]=C),T2[i+12>>2]=T2[20+b>>2],M=T2[l+96>>2],G=T2[E+96>>2],x=T2[l+92>>2],I=T2[E+92>>2],i=T2[E+8>>2],W=T2[l+88>>2],F=T2[E+88>>2],g=e1(n=e=Y=M-G|(T2[104+b>>2]=r=0),o=e>>31,Z=e=d=x-I|0,D=e>>31),Q=z,e=e1(V=e=0-(R=W-F|0)|0,m=e>>31,R,R>>31),t=z,B=e-(a=e1(d,D,d,D))|0,v=t-(z+(e>>>0<a>>>0)|0)|0,C=0-(e=e1(n,o,V,m))|0,s=0-(z+(0!=(0|e))|0)|0,o=0,i){for(e=i;k=T2[e+12>>2],a=e1(w=a=T2[k+92>>2]-I|0,u=a>>31,V,m),t=z,(a=(0|a)!=(0-(a=e1(Z,D,c=a=T2[k+88>>2]-F|0,n=a>>31))|0)?1:(0-(z+(0!=(0|a))|0)|0)!=(0|t))||(a=e1(g,Q,w,u),t=z,u=a,a=e1(C,s,c,n),c=z+t|0,c=(n=u+a|0)>>>0<a>>>0?c+1|0:c,t=(a=e1(B,v,a=T2[k+96>>2]-G|0,a>>31))+n|0,n=z+c|0,n=t>>>0<a>>>0?n+1|0:n,a=t,(a=(0|n)<0?1:(0|n)<=0?a>>>0<1:0)||o&&1!=(0|k2(o,e,R,d,Y,0,0,-1))||(o=e)),(0|i)!=(0|(e=T2[e>>2])););T2[104+b>>2]=o;}if(i=T2[l+8>>2],T2[80+b>>2]=0,i){for(e=i;k=T2[e+12>>2],a=e1(w=a=T2[k+92>>2]-x|0,u=a>>31,V,m),t=z,(a=(0|a)!=(0-(a=e1(Z,D,c=a=T2[k+88>>2]-W|0,n=a>>31))|0)?1:(0-(z+(0!=(0|a))|0)|0)!=(0|t))||(a=e1(g,Q,w,u),t=z,u=a,a=e1(C,s,c,n),c=z+t|0,c=(n=u+a|0)>>>0<a>>>0?c+1|0:c,t=(a=e1(B,v,a=T2[k+96>>2]-M|0,a>>31))+n|0,n=z+c|0,n=t>>>0<a>>>0?n+1|0:n,a=t,(a=(0|n)<0?1:(0|n)<=0?a>>>0<1:0)||r&&2!=(0|k2(r,e,R,d,Y,0,0,-1))||(r=e)),(0|i)!=(0|(e=T2[e>>2])););T2[80+b>>2]=r;}r|o&&(l2(J,E,l,104+b|0,80+b|0),(r=T2[104+b>>2])&&(E=T2[r+12>>2]),(r=T2[80+b>>2])&&(l=T2[r+12>>2])),Z=T2[l+92>>2],D=T2[l+88>>2],C=T2[l+96>>2]+1|0;}for(x=f+100|0,r=E,c=l,J=1,w=k=g=t=s=v=0;;){if(T2[140+b>>2]=-1,n=T2[(W=r+92|0)>>2],a=T2[(I=c+92|0)>>2]-n|0,T2[132+b>>2]=a,e=T2[(Y=r+96|0)>>2],i=T2[(F=c+96|0)>>2]-e|0,T2[136+b>>2]=i,B=T2[r+88>>2],o=T2[c+88>>2]-B|0,T2[128+b>>2]=o,u=Z-n|0,n=C-e|0,R=(e=P2(u,i)-P2(n,a)|0)>>31,T2[104+b>>2]=M=e,T2[108+b>>2]=R,V=(e=(e=P2(n,o))-P2(n=D-B|0,i)|0)>>31,T2[112+b>>2]=G=e,T2[116+b>>2]=V,m=(e=P2(a,n)-P2(o,u)|0)>>31,T2[120+b>>2]=d=e,T2[124+b>>2]=m,e=e1(G,V,o,Q=o>>31),u=z,n=e1(M,R,a,B=a>>31),T2[96+b>>2]=e-n,T2[100+b>>2]=u-(z+(e>>>0<n>>>0)|0),e=e1(M,R,i,u=i>>31),n=z,o=e1(d,m,o,Q),T2[88+b>>2]=e-o,T2[92+b>>2]=n-(z+(e>>>0<o>>>0)|0),e=e1(a,B,d,m),a=z,i=e1(G,V,i,u),T2[80+b>>2]=e-i,T2[84+b>>2]=a-(z+(e>>>0<i>>>0)|0),T2[72+b>>2]=0,T2[(e=64+b|0)>>2]=0,T2[e+4>>2]=0,T2[56+b>>2]=0,d=s2(f,T2[60+b>>2]=0,r,128+b|0,104+b|0,80+b|0,56+b|0),T2[48+b>>2]=0,T2[(e=40+b|0)>>2]=0,T2[e+4>>2]=0,T2[32+b>>2]=0,(Q=s2(f,1,c,128+b|(T2[36+b>>2]=0),104+b|0,80+b|0,32+b|0))|d){G=d?-1:1,d&&Q&&(G=c2(T2[56+b>>2],T2[60+b>>2],T2[64+b>>2],T2[68+b>>2],T2[72+b>>2],32+b|0));f:{r:if(!J){e:{if(0<=(0|G)){if(-1<T2[48+b>>2])break r;if(!(T2[40+b>>2]|T2[44+b>>2]))break e;break r;}if(-1<T2[72+b>>2])break r;if(T2[64+b>>2]|T2[68+b>>2])break r;}i=v,u=s,B=g,a=k;break f;}a=B=u2(f,r,c),g&&(T2[g+4>>2]=B,a=k),T2[B>>2]=g,u=i=T2[B+8>>2],v&&(T2[v>>2]=i,u=s),T2[i+4>>2]=v;}if(T2[28+b>>2]=d,v=T2[24+b>>2]=Q,G||(l2(T2[x>>2],r,c,28+b|0,24+b|0),v=T2[24+b>>2]),(0|G)<0||!v)s=u;else {f:{r:{if(h){if((0|Q)!=(0|(e=T2[h>>2])))for(;s=T2[e+8>>2],((o=n=0)|(k=T2[e>>2]))!=(0|e)&&(T2[k+4>>2]=T2[e+4>>2],o=T2[T2[e+4>>2]>>2]=k),T2[T2[s+12>>2]+8>>2]=o,(0|(o=T2[s>>2]))!=(0|s)&&(T2[o+4>>2]=T2[s+4>>2],n=T2[T2[s+4>>2]>>2]=o),T2[T2[e+12>>2]+8>>2]=n,T2[e+16>>2]=0,T2[(o=e+8|0)>>2]=0,T2[o+4>>2]=0,T2[e>>2]=0,T2[e+4>>2]=0,T2[e>>2]=T2[f+56>>2],T2[f+56>>2]=e,T2[s+16>>2]=0,T2[(e=s+8|0)>>2]=0,T2[e+4>>2]=0,T2[s>>2]=0,T2[s+4>>2]=0,T2[s>>2]=T2[f+56>>2],T2[f+56>>2]=s,T2[f+116>>2]=T2[f+116>>2]-1,(0|Q)!=(0|(e=k)););if(i)break r;break f;}if(!i){t=Q;break f;}h=T2[Q+4>>2],t=u;}T2[h>>2]=u,T2[u+4>>2]=h,T2[i>>2]=Q,T2[Q+4>>2]=i,v=T2[24+b>>2],u=0;}s=u,C=T2[F>>2],Z=T2[I>>2],h=T2[v+8>>2],D=T2[c+88>>2],i=0,c=T2[v+12>>2];}if(o=c,v=i,0<(0|G)||!(G=T2[28+b>>2]))g=B;else {f:{r:{e:{i:{if(N){if((0|d)!=(0|(e=T2[N+4>>2])))for(;k=T2[e+8>>2],i=T2[e+4>>2],((c=n=0)|(u=T2[e>>2]))!=(0|e)&&(T2[u+4>>2]=i,c=T2[T2[e+4>>2]>>2]=u),T2[T2[k+12>>2]+8>>2]=c,(0|(c=T2[k>>2]))!=(0|k)&&(T2[c+4>>2]=T2[k+4>>2],n=T2[T2[k+4>>2]>>2]=c),T2[T2[e+12>>2]+8>>2]=n,T2[e+16>>2]=0,T2[(n=e+8|0)>>2]=0,T2[n+4>>2]=0,T2[e>>2]=0,T2[e+4>>2]=0,T2[e>>2]=T2[f+56>>2],T2[f+56>>2]=e,T2[k+16>>2]=0,T2[(e=k+8|0)>>2]=0,T2[e+4>>2]=0,T2[k>>2]=0,T2[k+4>>2]=0,T2[k>>2]=T2[f+56>>2],T2[f+56>>2]=k,T2[f+116>>2]=T2[f+116>>2]-1,(0|d)!=(0|(e=i)););if(B)break i;break f;}if(B)break e;w=d;break f;}e=(T2[a>>2]=N)+4|0;break r;}e=T2[d>>2],e=(T2[(w=a)>>2]=e)+4|0;}T2[e>>2]=a,T2[d>>2]=B,T2[B+4>>2]=d,G=T2[28+b>>2],a=0;}C=T2[Y>>2],Z=T2[W>>2],N=T2[G+8>>2],D=T2[r+88>>2],g=0,r=T2[G+12>>2];}if(k=a,e=1,(0|r)!=(0|E)||(0|o)!=(0|l))c=o,J=0;else {if(N){if((0|w)!=(0|(e=T2[N+4>>2])))for(;o=T2[e+8>>2],i=T2[e+4>>2],((c=n=0)|(a=T2[e>>2]))!=(0|e)&&(T2[a+4>>2]=i,c=T2[T2[e+4>>2]>>2]=a),T2[T2[o+12>>2]+8>>2]=c,(0|(a=T2[o>>2]))!=(0|o)&&(T2[a+4>>2]=T2[o+4>>2],n=T2[T2[o+4>>2]>>2]=a),T2[T2[e+12>>2]+8>>2]=n,T2[e+16>>2]=0,T2[(a=e+8|0)>>2]=0,T2[a+4>>2]=0,T2[e>>2]=0,T2[e+4>>2]=0,T2[e>>2]=T2[f+56>>2],T2[f+56>>2]=e,T2[o+16>>2]=0,T2[(e=o+8|0)>>2]=0,T2[e+4>>2]=0,T2[o>>2]=0,T2[o+4>>2]=0,T2[o>>2]=T2[f+56>>2],T2[f+56>>2]=o,T2[f+116>>2]=T2[f+116>>2]-1,(0|w)!=(0|(e=i)););g&&(T2[N+4>>2]=k,T2[k>>2]=N,T2[g+4>>2]=w,T2[w>>2]=g);}else T2[g+4>>2]=k,T2[k>>2]=g,T2[r+8>>2]=g;if(h){if((0|t)!=(0|(e=T2[h>>2])))for(;c=T2[e+8>>2],((o=n=0)|(i=T2[e>>2]))!=(0|e)&&(T2[i+4>>2]=T2[e+4>>2],o=T2[T2[e+4>>2]>>2]=i),T2[T2[c+12>>2]+8>>2]=o,(0|(a=T2[c>>2]))!=(0|c)&&(T2[a+4>>2]=T2[c+4>>2],n=T2[T2[c+4>>2]>>2]=a),T2[T2[e+12>>2]+8>>2]=n,T2[e+16>>2]=0,T2[(a=e+8|0)>>2]=0,T2[a+4>>2]=0,T2[e>>2]=0,T2[e+4>>2]=0,T2[e>>2]=T2[f+56>>2],T2[f+56>>2]=e,T2[c+16>>2]=0,T2[(e=c+8|0)>>2]=0,T2[e+4>>2]=0,T2[c>>2]=0,T2[c+4>>2]=0,T2[c>>2]=T2[f+56>>2],T2[f+56>>2]=c,T2[f+116>>2]=T2[f+116>>2]-1,(0|t)!=(0|(e=i)););e=0,v?(T2[s+4>>2]=h,T2[h>>2]=s,T2[t+4>>2]=v,T2[v>>2]=t,c=l):(c=l,v=0);}else T2[s+4>>2]=v,T2[v>>2]=s,T2[l+8>>2]=v,c=l,e=h=0;}}else i=u2(f,r,c),T2[r+8>>2]=i,e=T2[i+8>>2],T2[c+8>>2]=e,T2[i+4>>2]=i,T2[i>>2]=i,T2[e+4>>2]=e,T2[e>>2]=e,e=0;if(!e)break;}}else f=T2[12+b>>2],T2[i>>2]=T2[8+b>>2],T2[i+4>>2]=f,f=T2[4+(r=16+b|0)>>2],T2[(e=i+8|0)>>2]=T2[r>>2],T2[e+4>>2]=f;}L2=144+b|0;}(8+n|(T2[140+n>>2]=0),0,r,136+n|0),T2[132+n>>2]=T2[136+n>>2],(f=T2[164+n>>2])&&S2[168+n|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),(0|(a=T2[A+4>>2]))<=-1)for(T2[A+8>>2]<=-1&&((f=T2[A+12>>2])&&S2[A+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),p2[A+16|0]=1,T2[A+8>>2]=0,T2[A+12>>2]=0),f=a<<4;b=T2[156+n>>2],r=T2[A+12>>2]+f|0,T2[(o=r)>>2]=T2[152+n>>2],T2[o+4>>2]=b,b=T2[(o=160+n|0)+4>>2],T2[(r=r+8|0)>>2]=T2[o>>2],T2[r+4>>2]=b,f=f+16|0,(r=a)>>>0<=(a=a+1|0)>>>0;);if(T2[A+4>>2]=0,T2[160+n>>2]=0,T2[152+n>>2]=0,((T2[156+n>>2]=0)|(a=T2[A+24>>2]))<=-1)for(T2[A+28>>2]<=-1&&((f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+28>>2]=0,T2[A+32>>2]=0,p2[A+36|0]=1),f=P2(a,12);o=T2[156+n>>2],r=T2[A+32>>2]+f|0,T2[r>>2]=T2[152+n>>2],T2[r+4>>2]=o,T2[r+8>>2]=T2[160+n>>2],f=f+12|0,(r=a)>>>0<=(a=a+1|0)>>>0;);if(((T2[A+24>>2]=0)|(r=T2[A+44>>2]))<=-1&&(f=T2[A+52>>2],T2[A+48>>2]<=-1&&(f&&S2[A+56|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),p2[A+56|0]=1,T2[A+48>>2]=0,f=T2[A+52>>2]=0),d2((a=f)+(f=r<<2)|0,0,0-f|0)),T2[A+44>>2]=0,b=T2[132+n>>2],!(-1<T2[b+104>>2])){for(T2[b+104>>2]=0,T2[5498]=T2[5498]+1,f=K2(23),T2[(l=f+19&-16)>>2]=b,T2[l-4>>2]=f,d=s=1;;){A:{f:{r:{e:{if(0<=T2[b+100>>2])j2[(152+n|0)+(T2[116+n>>2]<<2)>>2]=T2[b+88>>2];else if(c=v2(b+24|0),u=v2(f=b+72|0),j2[(152+n|0)+(T2[116+n>>2]<<2)>>2]=c/u,T2[b+100>>2]<0)break e;j2[(152+n|0)+(T2[120+n>>2]<<2)>>2]=T2[b+92>>2];break r;}if(c=v2(b+40|0),u=v2(f),j2[(152+n|0)+(T2[120+n>>2]<<2)>>2]=c/u,T2[b+100>>2]<0)break f;}c=z2(T2[b+96>>2]);break A;}c=z2(v2(b+56|0)/v2(f));}if(j2[(152+n|0)+(T2[112+n>>2]<<2)>>2]=c,c=z2(z2(j2[160+n>>2]*j2[16+n>>2])+j2[32+n>>2]),u=z2(z2(j2[156+n>>2]*j2[12+n>>2])+j2[28+n>>2]),v=z2(z2(j2[152+n>>2]*j2[8+n>>2])+j2[24+n>>2]),(0|(f=T2[A+4>>2]))==T2[A+8>>2]&&!((0|(r=f?f<<1:1))<=(0|f))){if(t=0,r&&(T2[5498]=T2[5498]+1,(a=K2(19+(r<<4)|0))&&(T2[(t=a+19&-16)-4>>2]=a)),1<=(0|f))for(a=0;k=T2[A+12>>2]+a|0,D=T2[k+4>>2],T2[(o=a+t|0)>>2]=T2[k>>2],T2[o+4>>2]=D,D=T2[(k=k+8|0)+4>>2],T2[(o=o+8|0)>>2]=T2[k>>2],T2[o+4>>2]=D,a=a+16|0,f=f-1|0;);(f=T2[A+12>>2])&&S2[A+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+12>>2]=t,p2[A+16|0]=1,T2[A+8>>2]=r,f=T2[A+4>>2];}if(f=T2[A+12>>2]+(f<<4)|0,T2[f+12>>2]=0,j2[f+8>>2]=c,j2[f+4>>2]=u,j2[f>>2]=v,T2[A+4>>2]=T2[A+4>>2]+1,D=T2[b+8>>2]){for(f=D,k=r=-1;;){if((0|(a=T2[f+20>>2]))<=-1){if(b=T2[A+24>>2],T2[(e=160+n|0)>>2]=0,T2[152+n>>2]=0,((T2[156+n>>2]=0)|(a=b))==T2[A+28>>2]&&!((0|(Q=a?b<<1:1))<=(0|a))){if(t=0,Q&&(T2[5498]=T2[5498]+1,(a=K2(P2(Q,12)+19|0))&&(T2[(t=a+19&-16)-4>>2]=a)),1<=(0|b))for(a=0,o=b;g=T2[A+32>>2]+a|0,Y=T2[g+4>>2],T2[(w=a+t|0)>>2]=T2[g>>2],T2[w+4>>2]=Y,T2[w+8>>2]=T2[g+8>>2],a=a+12|0,o=o-1|0;);(a=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[A+32>>2]=t,p2[A+36|0]=1,T2[A+28>>2]=Q,a=T2[A+24>>2];}if(o=T2[156+n>>2],a=T2[A+32>>2]+P2(a,12)|0,T2[a>>2]=T2[152+n>>2],T2[a+4>>2]=o,T2[a+8>>2]=T2[e>>2],o=T2[A+24>>2],T2[A+24>>2]=a=o+1|0,T2[e>>2]=0,T2[152+n>>2]=0,T2[156+n>>2]=0,T2[A+28>>2]==(0|a)&&!((0|(Q=a?a<<1:1))<=(0|a))){if(t=0,Q&&(T2[5498]=T2[5498]+1,(a=K2(P2(Q,12)+19|0))&&(T2[(t=a+19&-16)-4>>2]=a)),0<=(0|o))for(o=o+1|0,a=0;g=T2[A+32>>2]+a|0,Y=T2[g+4>>2],T2[(w=a+t|0)>>2]=T2[g>>2],T2[w+4>>2]=Y,T2[w+8>>2]=T2[g+8>>2],a=a+12|0,o=o-1|0;);(a=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[A+32>>2]=t,p2[A+36|0]=1,T2[A+28>>2]=Q,a=T2[A+24>>2];}if(o=T2[156+n>>2],a=T2[A+32>>2]+P2(a,12)|0,T2[a>>2]=T2[152+n>>2],T2[a+4>>2]=o,T2[a+8>>2]=T2[e>>2],T2[A+24>>2]=T2[A+24>>2]+1,T2[f+20>>2]=b,T2[T2[f+8>>2]+20>>2]=w=b+1|0,e=(g=T2[A+32>>2])+P2(b,12)|0,T2[4+e>>2]=1,T2[16+e>>2]=-1,Q=T2[f+12>>2],-1<(0|(a=T2[Q+104>>2])))o=s,s=a;else {T2[Q+104>>2]=s;A:if((0|s)!=(0|d)||(0|(t=d?d<<1:1))<=(0|d))b=l,t=d;else {if(b=0,t&&(T2[5498]=T2[5498]+1,(a=K2(19+(t<<2)|0))&&(T2[(b=a+19&-16)-4>>2]=a)),1<=(0|d))for(a=b,o=l;T2[a>>2]=T2[o>>2],a=a+4|0,o=o+4|0,d=d-1|0;);else if(!l)break A;T2[5499]=T2[5499]+1,q2(T2[l-4>>2]);}T2[(s<<2)+b>>2]=Q,o=s+1|0,l=b,d=t;}T2[8+(g+P2(w,12)|0)>>2]=R,T2[8+e>>2]=s,s=o,a=T2[f+20>>2];}if(o=a,0<=(0|r)&&(T2[T2[A+32>>2]+P2(a,12)>>2]=r-a,o=k),r=a,k=o,(0|D)==(0|(f=T2[f>>2])))break;}T2[T2[A+32>>2]+P2(k,12)>>2]=r-k;}if(!((0|(f=R+1|0))<(0|s)))break;b=T2[(f<<2)+l>>2],R=f;}for(d=0;;){if(s=T2[T2[(d<<2)+l>>2]+8>>2])for(f=s;;){if(0<=(0|(a=T2[f+20>>2]))){if((0|(t=T2[A+44>>2]))==T2[A+48>>2]&&!((0|(k=t?t<<1:1))<=(0|t))){r=0,k&&(T2[5498]=T2[5498]+1,(a=K2(19+(k<<2)|0))&&(T2[(r=a+19&-16)-4>>2]=a)),b=T2[A+52>>2];A:{if(1<=(0|t))for(a=r,o=b;T2[a>>2]=T2[o>>2],a=a+4|0,o=o+4|0,t=t-1|0;);else if(!b)break A;S2[A+56|0]&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2])),t=T2[A+44>>2];}T2[A+48>>2]=k,T2[A+52>>2]=r,p2[A+56|0]=1,a=T2[f+20>>2];}for(T2[T2[A+52>>2]+(t<<2)>>2]=a,T2[A+44>>2]=T2[A+44>>2]+1,a=f;T2[a+20>>2]=-1,(0|(a=T2[T2[a+8>>2]+4>>2]))!=(0|f););}if((0|s)==(0|(f=T2[f>>2])))break;}if(f=(0|d)==(0|R),d=d+1|0,f)break;}l&&(T2[5499]=T2[5499]+1,q2(T2[l-4>>2]));}if((A=T2[100+n>>2])&&S2[104+n|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[100+n>>2]=0,p2[104+n|0]=1,T2[92+n>>2]=0,T2[96+n>>2]=0,a=T2[72+n>>2])for(;T2[72+n>>2]=T2[a+8>>2],(A=T2[a>>2])&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[5499]=T2[5499]+1,q2(T2[a-4>>2]),a=T2[72+n>>2];);if(a=T2[56+n>>2])for(;T2[56+n>>2]=T2[a+8>>2],(A=T2[a>>2])&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[5499]=T2[5499]+1,q2(T2[a-4>>2]),a=T2[56+n>>2];);if(a=T2[40+n>>2])for(;T2[40+n>>2]=T2[a+8>>2],(A=T2[a>>2])&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[5499]=T2[5499]+1,q2(T2[a-4>>2]),a=T2[40+n>>2];);}L2=176+n|0;}function g2(A,f,r,e){n1[T2[T2[(A|=0)>>2]+80>>2]](A,f|=0,r|=0,e|=0);}function w2(A,f){A|=0,f=z2(f),j2[A+52>>2]=f;}function G2(A){return 0;}function C2(A,f,r){}function E2(A,f){var r,e,i,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0,l=0,s=0,v=0,d=0;if(T2[A+8>>2]<(0|f)){if(f&&(T2[5498]=T2[5498]+1,(a=K2(P2(f,36)+19|0))&&(T2[(u=a+19&-16)-4>>2]=a)),!((0|(i=T2[A+4>>2]))<1)){for(;;){n=P2(k,36),T2[(a=n+u|0)+4>>2]=0,T2[a+8>>2]=0,p2[a+16|0]=1,r=a+4|(T2[a+12>>2]=0);A:{f:{r:{if(t=n+T2[A+12>>2]|0,1<=(0|(o=T2[t+4>>2]))){if(v=a+8|0,l=a+12|0,d=a+16|0,T2[5498]=T2[5498]+1,!(n=K2((s=o<<2)+19|0)))break r;if(T2[(c=n+19&-16)-4>>2]=n,e=T2[l>>2],1<=(0|(n=T2[r>>2])))for(b=0;T2[b+c>>2]=T2[b+e>>2],b=b+4|0,n=n-1|0;);else if(!e)break f;T2[5499]=T2[5499]+1,q2(T2[e-4>>2]);break f;}T2[r>>2]=o;break A;}c=0;}for(T2[l>>2]=c,p2[0|d]=1,T2[v>>2]=o,d2(c,0,s),T2[r>>2]=o,b=T2[t+12>>2],n=T2[l>>2];T2[n>>2]=T2[b>>2],n=n+4|0,b=b+4|0,o=o-1|0;);}if(n=T2[t+24>>2],T2[a+20>>2]=T2[t+20>>2],T2[a+24>>2]=n,o=T2[(n=t+28|0)+4>>2],T2[(a=a+28|0)>>2]=T2[n>>2],T2[a+4>>2]=o,(0|i)==(0|(k=k+1|0)))break;}if(!((0|(o=T2[A+4>>2]))<1))for(n=8;a=T2[A+12>>2]+n|0,(t=T2[(b=a+4|0)>>2])&&S2[a+8|0]&&(T2[5499]=T2[5499]+1,q2(T2[t-4>>2])),T2[b>>2]=0,p2[a+8|0]=1,T2[(a=a-4|0)>>2]=0,n=n+36|(T2[a+4>>2]=0),o=o-1|0;);}(a=T2[A+12>>2])&&S2[A+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[A+12>>2]=u,p2[A+16|0]=1,T2[A+8>>2]=f;}}function D2(A,f){var r,e,i,a,n,o,b=0,t=0,c=0,u=0;if((0|(u=T2[A+4>>2]))==T2[A+8>>2]&&(E2(A,u?u<<1:1),u=T2[A+4>>2]),b=(e=T2[A+12>>2])+P2(u,36)|0,T2[b+4>>2]=0,T2[b+8>>2]=0,p2[b+16|0]=1,i=b+4|(T2[b+12>>2]=0),1<=(0|(t=T2[f+4>>2])))for(n=b+8|0,r=b+12|0,o=b+16|0,T2[5498]=T2[5498]+1,(b=K2(19+(a=t<<2)|0))&&(T2[(c=b+19&-16)-4>>2]=b,(b=T2[r>>2])&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2]))),T2[r>>2]=c,p2[0|o]=1,T2[n>>2]=t,d2(c,0,a),T2[i>>2]=t,b=T2[f+12>>2],c=T2[r>>2];T2[c>>2]=T2[b>>2],c=c+4|0,b=b+4|0,t=t-1|0;);else T2[i>>2]=t;t=T2[f+24>>2],b=P2(u,36)+e|0,T2[b+20>>2]=T2[f+20>>2],T2[b+24>>2]=t,t=T2[(f=f+28|0)+4>>2],T2[(b=b+28|0)>>2]=T2[f>>2],T2[b+4>>2]=t,T2[A+4>>2]=T2[A+4>>2]+1;}function h2(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o=z2(n1[T2[T2[A>>2]+48>>2]](A)),b=j2[f+52>>2],t=j2[f+24>>2],c=j2[f+20>>2],u=j2[f+56>>2],k=j2[f+40>>2],l=j2[A+72>>2],s=j2[A+88>>2],v=j2[f+36>>2],d=j2[A+68>>2],B=j2[A+84>>2],Q=j2[f+48>>2],g=j2[f+8>>2],w=j2[f>>2],G=j2[f+4>>2],C=j2[f+16>>2],E=j2[f+32>>2],D=j2[A+64>>2],h=j2[A+80>>2];T2[r+12>>2]=0,i=u,u=z2(z2(h+D)*z2(.5)),a=z2(z2(B+d)*z2(.5)),n=z2(z2(s+l)*z2(.5)),i=z2(i+z2(z2(z2(E*u)+z2(v*a))+z2(k*n))),D=z2(o+z2(z2(h-D)*z2(.5))),d=z2(o+z2(z2(B-d)*z2(.5))),o=z2(o+z2(z2(s-l)*z2(.5))),k=z2(z2(z2(D*z2(O2(E)))+z2(d*z2(O2(v))))+z2(o*z2(O2(k)))),j2[r+8>>2]=i-k,l=z2(b+z2(z2(z2(u*C)+z2(a*c))+z2(n*t))),t=z2(z2(z2(D*z2(O2(C)))+z2(d*z2(O2(c))))+z2(o*z2(O2(t)))),j2[r+4>>2]=l-t,c=z2(Q+z2(z2(z2(u*w)+z2(a*G))+z2(n*g))),o=z2(z2(z2(D*z2(O2(w)))+z2(d*z2(O2(G))))+z2(o*z2(O2(g)))),j2[r>>2]=c-o,T2[e+12>>2]=0,j2[e+8>>2]=k+i,j2[e+4>>2]=t+l,j2[e>>2]=o+c;}function Z2(A,f){A|=0,f=z2(f);var r,e,i,a,n,o,b,t=z2(n1[T2[T2[A>>2]+48>>2]](A)),c=z2(n1[T2[T2[A>>2]+48>>2]](A)),u=z2(n1[T2[T2[A>>2]+48>>2]](A));j2[A+52>>2]=f,f=j2[(r=A+44|0)>>2],i=j2[(e=A+40|0)>>2],a=j2[A+36>>2],n=z2(n1[T2[T2[A>>2]+48>>2]](A)),o=z2(n1[T2[T2[A>>2]+48>>2]](A)),b=z2(n1[T2[T2[A>>2]+48>>2]](A)),T2[A+48>>2]=0,j2[e>>2]=z2(c+i)-o,j2[A+36>>2]=z2(t+a)-n,j2[r>>2]=z2(u+f)-b;}function Y2(A){var f;T2[(A|=0)>>2]=7916,(f=T2[A+60>>2])&&(n1[T2[T2[f>>2]>>2]](f),(f=T2[A+60>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);}function R2(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i=z2(n1[T2[T2[A>>2]+48>>2]](A)),a=j2[f+52>>2],n=j2[f+20>>2],o=j2[f+24>>2],b=j2[f+56>>2],t=j2[f+36>>2],c=j2[A+40>>2],u=j2[f+40>>2],k=j2[A+44>>2],l=j2[f+48>>2],s=j2[f>>2],v=j2[f+4>>2],d=j2[f+8>>2],B=j2[f+16>>2],Q=j2[f+32>>2],g=j2[A+36>>2];T2[r+12>>2]=0,g=z2(i+g),c=z2(i+c),i=z2(i+k),t=z2(z2(z2(g*z2(O2(Q)))+z2(c*z2(O2(t))))+z2(i*z2(O2(u)))),j2[r+8>>2]=b-t,n=z2(z2(z2(g*z2(O2(B)))+z2(c*z2(O2(n))))+z2(i*z2(O2(o)))),j2[r+4>>2]=a-n,i=z2(z2(z2(g*z2(O2(s)))+z2(c*z2(O2(v))))+z2(i*z2(O2(d)))),j2[r>>2]=l-i,T2[e+12>>2]=0,j2[e+8>>2]=b+t,j2[e+4>>2]=n+a,j2[e>>2]=i+l;}function V2(A,f){A|=0,f|=0;var r,e,i,a=z2(n1[T2[T2[A>>2]+48>>2]](A)),n=z2(n1[T2[T2[A>>2]+48>>2]](A)),o=z2(n1[T2[T2[A>>2]+48>>2]](A)),b=j2[f>>2],t=j2[f+4>>2],c=j2[f+8>>2];T2[A+48>>2]=0,T2[A+32>>2]=0,r=j2[(f=A+28|0)>>2],c=z2(O2(c)),j2[f>>2]=c,e=j2[(f=A+24|0)>>2],t=z2(O2(t)),j2[f>>2]=t,i=j2[A+20>>2],b=z2(O2(b)),j2[A+20>>2]=b,j2[(f=A+44|0)>>2]=z2(z2(z2(o+j2[f>>2])/r)*c)-o,j2[(f=A+40|0)>>2]=z2(z2(z2(n+j2[f>>2])/e)*t)-n,j2[A+36>>2]=z2(z2(z2(a+j2[A+36>>2])/i)*b)-a;}function J2(A){return 52;}function M2(A){return 6;}function I2(A){A|=0,T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);}function x2(A,f){f|=0;var r;T2[(A|=0)>>2]=0,T2[A+4>>2]=0,T2[(r=A+8|0)>>2]=0,T2[4+r>>2]=0,T2[(T2[f+60>>2]<<2)+A>>2]=1065353216;}function y2(A,f){}function U2(A){return 60;}function X2(A,f,r){A|=0,T2[(r|=0)>>2]=0,T2[r+4>>2]=0,T2[(A=r+8|0)>>2]=0,T2[A+4>>2]=0;}function A0(A){var f=0;(f=T2[A>>2])&&f0(A,f),(f=T2[A+4>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+4>>2]=0,T2[A+8>>2]=-1,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+16>>2]=0,T2[A+32>>2]=0,p2[A+36|0]=1,T2[(A=A+24|0)>>2]=0,T2[A+4>>2]=0;}function f0(A,f){var r;T2[f+40>>2]&&(f0(A,T2[f+36>>2]),f0(A,T2[f+40>>2])),T2[A>>2]==(0|f)&&(T2[A>>2]=0),(r=T2[A+4>>2])&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+4>>2]=f;}function r0(A){var f=0;(f=T2[A>>2])&&f0(A,f),(f=T2[A+4>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+4>>2]=0,T2[A+8>>2]=-1,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,T2[A+16>>2]=0,p2[A+36|0]=1,T2[(A=A+24|0)>>2]=0,T2[A+4>>2]=0;}function e0(A,f){var r,e,i,a,n,o,b,t,c,u,k,l=0,s=0,v=0,d=0,B=0,Q=0,g=0;L2=Q=L2-32|0;A:if(!((0|(f=(0|f)<=-1?T2[A+12>>2]:f))<1)&&(l=T2[A>>2]))for(;;){if(T2[(d=l+40|0)>>2])for(g=0;(v=T2[l+32>>2])>>>0<=l>>>0?v=l:(e=(0|(r=T2[v+40>>2]))==(0|l),a=T2[36+((i=((0|l)!=(0|r))<<2)+v|0)>>2],B=A,(s=T2[v+32>>2])&&(B=36+(s+((T2[s+40>>2]==(0|v))<<2)|0)|0),T2[B>>2]=l,T2[a+32>>2]=l,T2[v+32>>2]=l,T2[l+32>>2]=s,T2[v+36>>2]=T2[l+36>>2],T2[v+40>>2]=T2[d>>2],T2[T2[l+36>>2]+32>>2]=v,T2[T2[d>>2]+32>>2]=v,T2[(r=l+36|0)+(e<<2)>>2]=v,T2[r+i>>2]=a,d=T2[4+(r=v+24|0)>>2],t=T2[r>>2],T2[(s=24+Q|0)>>2]=t,T2[s+4>>2]=d,a=T2[(s=v+16|0)+4>>2],c=T2[s>>2],T2[(e=16+Q|0)>>2]=c,T2[4+e>>2]=a,i=T2[4+(e=v+8|0)>>2],u=T2[e>>2],T2[(n=8+Q|0)>>2]=u,T2[4+n>>2]=i,n=T2[v+4>>2],k=T2[v>>2],T2[Q>>2]=k,T2[4+Q>>2]=n,o=T2[(B=b=l+24|0)+4>>2],T2[r>>2]=T2[B>>2],T2[4+r>>2]=o,o=T2[4+(r=l+16|0)>>2],T2[s>>2]=T2[r>>2],T2[s+4>>2]=o,o=T2[(s=l+8|0)+4>>2],T2[e>>2]=T2[s>>2],T2[4+e>>2]=o,e=T2[l+4>>2],T2[v>>2]=T2[l>>2],T2[v+4>>2]=e,T2[b>>2]=t,T2[4+b>>2]=d,T2[r>>2]=c,T2[4+r>>2]=a,T2[s>>2]=u,T2[s+4>>2]=i,T2[l>>2]=k,T2[l+4>>2]=n),l=T2[A+16>>2]>>>g|0,g=g+1&31,l=T2[36+(((1&l)<<2)+v|0)>>2],T2[(d=l+40|0)>>2];);if(s=0,a0(B=A,s=i0(A,l)?T2[A>>2]:s,l),T2[A+16>>2]=T2[A+16>>2]+1,!(f=f-1|0))break A;l=T2[A>>2];}L2=32+Q|0;}function i0(A,f){var r,e,i,a=0,n=0,o=z2(0),b=z2(0),t=z2(0),c=z2(0),u=z2(0),k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=z2(0),B=z2(0);if(T2[A>>2]==(0|f))return T2[A>>2]=0;if(n=T2[f+32>>2],a=T2[36+(((T2[n+40>>2]!=(0|f))<<2)+n|0)>>2],f=T2[n+32>>2]){for(T2[36+((((0|n)==T2[f+40>>2])<<2)+f|0)>>2]=a,T2[a+32>>2]=f,(a=T2[A+4>>2])&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[A+4>>2]=n;;){if(i=j2[f>>2],a=T2[f+36>>2],o=j2[a>>2],n=T2[f+40>>2],l=j2[n>>2],j2[f>>2]=o=o<l?o:l,l=j2[f+16>>2],b=j2[a+16>>2],s=j2[n+16>>2],j2[f+16>>2]=b=s<b?b:s,s=j2[f+4>>2],t=j2[a+4>>2],v=j2[n+4>>2],j2[f+4>>2]=t=t<v?t:v,v=j2[(r=f+20|0)>>2],c=j2[a+20>>2],d=j2[n+20>>2],j2[r>>2]=c=d<c?c:d,d=j2[f+8>>2],u=j2[a+8>>2],B=j2[n+8>>2],j2[f+8>>2]=u=u<B?u:B,B=j2[(r=f+24|0)>>2],k=j2[a+24>>2],e=j2[n+24>>2],j2[r>>2]=k=e<k?k:e,v==c&&l==b&&o==i&&s==t&&d==u&&B==k)return f;if(!(f=T2[f+32>>2]))break;}return T2[A>>2];}return T2[a+32>>2]=0,T2[A>>2]=a,(f=T2[A+4>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]),a=T2[A>>2]),T2[A+4>>2]=n,a;}function a0(A,f,r){var e=0,i=z2(0),a=z2(0),n=z2(0),o=0,b=0;if(!T2[A>>2])return T2[r+32>>2]=0,void(T2[A>>2]=r);if(e=T2[f+40>>2])for(a=z2(j2[r>>2]+j2[r+16>>2]),i=z2(j2[r+8>>2]+j2[r+24>>2]),n=z2(j2[r+4>>2]+j2[r+20>>2]);b=f+36|0,f=T2[f+36>>2],f=T2[b+(!(z2(z2(z2(O2(z2(a-z2(j2[f>>2]+j2[f+16>>2]))))+z2(O2(z2(n-z2(j2[f+4>>2]+j2[f+20>>2])))))+z2(O2(z2(i-z2(j2[f+8>>2]+j2[f+24>>2])))))<z2(z2(z2(O2(z2(a-z2(j2[e>>2]+j2[e+16>>2]))))+z2(O2(z2(n-z2(j2[e+4>>2]+j2[e+20>>2])))))+z2(O2(z2(i-z2(j2[e+8>>2]+j2[e+24>>2]))))))<<2)>>2],e=T2[f+40>>2];);b=T2[f+32>>2],(e=T2[A+4>>2])?T2[A+4>>2]=0:(T2[5498]=T2[5498]+1,e=0,(o=K2(63))&&(T2[(e=o+19&-16)-4>>2]=o),T2[e>>2]=0,T2[e+4>>2]=0,T2[e+40>>2]=0,T2[(o=e+32|0)>>2]=0,T2[o+4>>2]=0,T2[(o=e+24|0)>>2]=0,T2[o+4>>2]=0,T2[(o=e+16|0)>>2]=0,T2[o+4>>2]=0,T2[(o=e+8|0)>>2]=0,T2[o+4>>2]=0),T2[e+36>>2]=0,T2[e+40>>2]=0,a=j2[r>>2],i=j2[f>>2],j2[e>>2]=a<i?a:i,a=j2[r+16>>2],i=j2[f+16>>2],j2[e+16>>2]=i<a?a:i,a=j2[r+4>>2],i=j2[f+4>>2],j2[e+4>>2]=a<i?a:i,a=j2[r+20>>2],i=j2[f+20>>2],j2[e+20>>2]=i<a?a:i,a=j2[r+8>>2],i=j2[f+8>>2],j2[e+8>>2]=a<i?a:i,T2[e+32>>2]=b,a=j2[r+24>>2],i=j2[f+24>>2],j2[e+24>>2]=i<a?a:i;A:if(b)for(T2[36+(((T2[T2[f+32>>2]+40>>2]==(0|f))<<2)+b|0)>>2]=e,T2[e+36>>2]=f,T2[f+32>>2]=e,T2[e+40>>2]=r,T2[r+32>>2]=e,a=j2[e>>2];;){if(A=e,j2[(e=b)>>2]<=a&&j2[e+4>>2]<=j2[A+4>>2]&&j2[e+8>>2]<=j2[A+8>>2]&&j2[e+16>>2]>=j2[A+16>>2]&&j2[e+20>>2]>=j2[A+20>>2]&&j2[e+24>>2]>=j2[A+24>>2])break A;if(A=T2[e+36>>2],a=j2[A>>2],f=T2[e+40>>2],i=j2[f>>2],j2[e>>2]=a=a<i?a:i,i=j2[A+16>>2],n=j2[f+16>>2],j2[e+16>>2]=n<i?i:n,i=j2[A+4>>2],n=j2[f+4>>2],j2[e+4>>2]=i<n?i:n,i=j2[A+20>>2],n=j2[f+20>>2],j2[e+20>>2]=n<i?i:n,i=j2[A+8>>2],n=j2[f+8>>2],j2[e+8>>2]=i<n?i:n,i=j2[A+24>>2],n=j2[f+24>>2],j2[e+24>>2]=n<i?i:n,!(b=T2[e+32>>2]))break;}else T2[e+36>>2]=f,T2[f+32>>2]=e,T2[e+40>>2]=r,T2[A>>2]=e,T2[r+32>>2]=e;}function n0(A,f){return 1;}function o0(A){var f=0;return T2[(A|=0)>>2]=9180,(f=T2[A+72>>2])&&(A0(f),(f=T2[A+72>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,p2[A+36|0]=1,T2[(f=A+24|0)>>2]=0,(T2[f+4>>2]=0)|A;}function b0(A,f){var r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B=0,Q=0,g=0,w=0;L2=g=L2-80|0,T2[A+76>>2]=T2[A+76>>2]+1,(B=T2[A+72>>2])&&(i0(B,Q=T2[76+(T2[A+32>>2]+P2(f,80)|0)>>2]),(w=T2[B+4>>2])&&(T2[5499]=T2[5499]+1,q2(T2[w-4>>2])),T2[B+4>>2]=Q,T2[B+12>>2]=T2[B+12>>2]-1),Q=T2[A+24>>2],s=P2(f,80),b=T2[(v=A+32|0)>>2],i=T2[4+(r=(B=s+b|0)+8|0)>>2],T2[(w=8+g|0)>>2]=T2[r>>2],T2[w+4>>2]=i,c=T2[4+(a=B+24|0)>>2],T2[(i=u=24+g|0)>>2]=T2[a>>2],T2[4+i>>2]=c,o=T2[4+(k=B+40|0)>>2],T2[(i=40+g|0)>>2]=T2[k>>2],T2[4+i>>2]=o,e=T2[4+(n=B+56|0)>>2],T2[(o=c=56+g|0)>>2]=T2[n>>2],T2[4+o>>2]=e,d=T2[4+(l=B+72|0)>>2],T2[(e=o=72+g|0)>>2]=T2[l>>2],T2[4+e>>2]=d,e=T2[B+4>>2],T2[g>>2]=T2[B>>2],T2[4+g>>2]=e,e=T2[B+20>>2],T2[16+g>>2]=T2[B+16>>2],T2[20+g>>2]=e,e=T2[B+36>>2],T2[32+g>>2]=T2[B+32>>2],T2[36+g>>2]=e,e=T2[B+52>>2],T2[48+g>>2]=T2[B+48>>2],T2[52+g>>2]=e,e=T2[B+68>>2],T2[64+g>>2]=T2[B+64>>2],T2[68+g>>2]=e,e=P2(Q,80)-80|0,t=T2[(Q=e+b|0)+68>>2],T2[B+64>>2]=T2[Q+64>>2],T2[B+68>>2]=t,t=T2[4+(b=Q+8|0)>>2],T2[r>>2]=T2[b>>2],T2[4+r>>2]=t,r=T2[Q+4>>2],T2[B>>2]=T2[Q>>2],T2[B+4>>2]=r,b=T2[4+(r=Q+24|0)>>2],T2[a>>2]=T2[r>>2],T2[4+a>>2]=b,r=T2[Q+20>>2],T2[B+16>>2]=T2[Q+16>>2],T2[B+20>>2]=r,a=T2[4+(r=Q+40|0)>>2],T2[k>>2]=T2[r>>2],T2[4+k>>2]=a,r=T2[Q+36>>2],T2[B+32>>2]=T2[Q+32>>2],T2[B+36>>2]=r,a=T2[4+(r=Q+56|0)>>2],T2[n>>2]=T2[r>>2],T2[4+n>>2]=a,r=T2[Q+52>>2],T2[B+48>>2]=T2[Q+48>>2],T2[B+52>>2]=r,Q=T2[(B=Q+72|0)+4>>2],T2[l>>2]=T2[B>>2],T2[4+l>>2]=Q,r=T2[4+g>>2],B=e+T2[v>>2]|0,T2[B>>2]=T2[g>>2],T2[B+4>>2]=r,r=T2[w+4>>2],T2[(Q=B+8|0)>>2]=T2[w>>2],T2[Q+4>>2]=r,w=T2[4+u>>2],T2[(Q=B+24|0)>>2]=T2[u>>2],T2[Q+4>>2]=w,Q=T2[20+g>>2],T2[B+16>>2]=T2[16+g>>2],T2[B+20>>2]=Q,w=T2[4+i>>2],T2[(Q=B+40|0)>>2]=T2[i>>2],T2[Q+4>>2]=w,Q=T2[36+g>>2],T2[B+32>>2]=T2[32+g>>2],T2[B+36>>2]=Q,w=T2[4+c>>2],T2[(Q=B+56|0)>>2]=T2[c>>2],T2[Q+4>>2]=w,Q=T2[52+g>>2],T2[B+48>>2]=T2[48+g>>2],T2[B+52>>2]=Q,w=T2[4+o>>2],T2[(Q=B+72|0)>>2]=T2[o>>2],T2[Q+4>>2]=w,Q=T2[68+g>>2],T2[B+64>>2]=T2[64+g>>2],T2[B+68>>2]=Q,T2[A+72>>2]&&(T2[T2[76+(T2[A+32>>2]+s|0)>>2]+36>>2]=f),T2[A+24>>2]=T2[A+24>>2]-1,L2=80+g|0;}function t0(A,f,r,e,i,a,n,o,b,t){f|=0,e|=0,i|=0,a|=0,n|=0,o|=0,b|=0,A=T2[(A|=0)+32>>2]+((t|=0)<<5)|0,T2[(r|=0)>>2]=T2[A+12>>2],T2[i>>2]=T2[A+20>>2],T2[f>>2]=T2[A+16>>2],T2[e>>2]=T2[A+28>>2],T2[o>>2]=T2[A>>2],T2[a>>2]=T2[A+4>>2],T2[b>>2]=T2[A+24>>2],T2[n>>2]=T2[A+8>>2];}function c0(A,f){}function u0(A){var f=0;return T2[(A|=0)>>2]=9704,(f=T2[A+156>>2])&&S2[A+160|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+156>>2]=0,p2[A+160|0]=1,T2[(f=A+148|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+136>>2])&&S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+136>>2]=0,p2[A+140|0]=1,T2[(f=A+128|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+116>>2])&&S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+116>>2]=0,p2[A+120|0]=1,T2[(f=A+108|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+96>>2]=0,T2[A>>2]=9592,p2[A+100|0]=1,T2[(f=A+88|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,p2[A+36|0]=1,T2[(f=A+24|0)>>2]=0,(T2[f+4>>2]=0)|A;}function k0(A){return T2[(A|=0)+24>>2];}function l0(A,f){var r,e=0,i=0,a=0,n=0,o=0,b=0;if(S2[A+164|0]){if((0|(a=T2[A+128>>2]))==T2[A+132>>2]&&!((0|(n=a?a<<1:1))<=(0|a))){n&&(T2[5498]=T2[5498]+1,(e=K2(19+(n<<2)|0))&&(T2[(i=e+19&-16)-4>>2]=e)),o=T2[A+136>>2];A:{if(1<=(0|a))for(e=i,b=o;T2[e>>2]=T2[b>>2],e=e+4|0,b=b+4|0,a=a-1|0;);else if(!o)break A;S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[o-4>>2])),a=T2[A+128>>2];}T2[A+136>>2]=i,T2[A+132>>2]=n,p2[A+140|0]=1;}return i=T2[A+136>>2],T2[i+(a<<2)>>2]=f,T2[T2[A+32>>2]+4>>2]=i,void(T2[A+128>>2]=T2[A+128>>2]+1);}if((0|(i=T2[A+148>>2]))==T2[A+152>>2]&&!((0|(r=i?i<<1:1))<=(0|i))){r&&(T2[5498]=T2[5498]+1,(e=K2(19+(r<<1)|0))&&(T2[(n=e+19&-16)-4>>2]=e)),o=T2[A+156>>2];A:{if(1<=(0|i))for(e=n,b=o,a=i;$[e>>1]=A2[b>>1],e=e+2|0,b=b+2|0,a=a-1|0;);else if(!o)break A;S2[A+160|0]&&(T2[5499]=T2[5499]+1,q2(T2[o-4>>2]),i=T2[A+148>>2]);}T2[A+156>>2]=n,T2[A+152>>2]=r,p2[A+160|0]=1;}T2[A+148>>2]=i+1,e=T2[A+32>>2],A=T2[A+156>>2],T2[e+4>>2]=A,$[A+(i<<1)>>1]=f;}function s0(A,f,r){var e=0,i=0,a=0,n=0,o=0,b=0,t=z2(0),c=z2(0),u=z2(0),k=z2(0),l=z2(0),s=z2(0);A:{if(S2[A+165|0]){if(!((0|(a=T2[A+88>>2]))<1)&&r)for(r=T2[A+96>>2],u=j2[A+168>>2],k=j2[f+8>>2],l=j2[f+4>>2],s=j2[f>>2];;){if(t=z2(j2[r>>2]-s),c=z2(t*t),t=z2(j2[r+4>>2]-l),c=z2(c+z2(t*t)),t=z2(j2[r+8>>2]-k),u>=z2(c+z2(t*t)))break A;if(r=r+16|0,(0|(o=o+1|0))==(0|a))break;}if(r=T2[A+32>>2],T2[r+12>>2]=T2[r+12>>2]+1,T2[A+92>>2]==(0|a)&&!((0|(o=a?a<<1:1))<=(0|a))){if(o&&(T2[5498]=T2[5498]+1,(r=K2(19+(o<<4)|0))&&(T2[(e=r+19&-16)-4>>2]=r)),1<=(0|a))for(r=0;i=T2[A+96>>2]+r|0,n=T2[i+4>>2],T2[(b=r+e|0)>>2]=T2[i>>2],T2[b+4>>2]=n,n=T2[(i=i+8|0)+4>>2],T2[(b=b+8|0)>>2]=T2[i>>2],T2[b+4>>2]=n,r=r+16|0,a=a-1|0;);(r=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+96>>2]=e,T2[A+92>>2]=o,p2[A+100|0]=1,a=T2[A+88>>2];}return r=T2[f+4>>2],e=T2[(n=A+96|0)>>2]+(a<<4)|0,T2[e>>2]=T2[f>>2],T2[e+4>>2]=r,f=T2[(r=f+8|0)+4>>2],T2[(e=e+8|0)>>2]=T2[r>>2],T2[e+4>>2]=f,T2[T2[A+32>>2]+16>>2]=T2[n>>2],A=T2[(f=A)+88>>2],T2[f+88>>2]=A+1,A;}if(!((0|(i=T2[A+108>>2]))<1)&&r)for(r=T2[A+116>>2],u=j2[A+168>>2],k=j2[f+8>>2],l=j2[f+4>>2],s=j2[f>>2];;){if(t=z2(j2[r>>2]-s),c=z2(t*t),t=z2(j2[r+4>>2]-l),c=z2(c+z2(t*t)),t=z2(j2[r+8>>2]-k),u>=z2(c+z2(t*t)))break A;if(r=r+12|0,o=o+1|0,!((0|(a=a+3|0))<(0|i)))break;}if((0|i)==(0|(e=T2[A+112>>2])))if((0|(e=i?i<<1:1))<=(0|i))e=i;else {e&&(T2[5498]=T2[5498]+1,(r=K2(19+(e<<2)|0))&&(T2[(n=r+19&-16)-4>>2]=r)),b=T2[A+116>>2];f:{if(1<=(0|i))for(r=n,o=b,a=i;j2[r>>2]=j2[o>>2],r=r+4|0,o=o+4|0,a=a-1|0;);else if(!b)break f;S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2]),i=T2[A+108>>2]);}T2[A+116>>2]=n,T2[A+112>>2]=e,p2[A+120|0]=1;}if(T2[A+108>>2]=r=i+1|0,b=T2[A+116>>2],j2[b+(i<<2)>>2]=j2[f>>2],(0|r)==(0|e)){if((0|(i=e?e<<1:1))<=(0|e))i=e,n=b;else {n=0,i&&(T2[5498]=T2[5498]+1,(r=K2(19+(i<<2)|0))&&(T2[(n=r+19&-16)-4>>2]=r,b=T2[A+116>>2]));f:{if(1<=(0|e))for(r=n,o=b,a=e;j2[r>>2]=j2[o>>2],r=r+4|0,o=o+4|0,a=a-1|0;);else if(!b)break f;S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2]),e=T2[A+108>>2]);}T2[A+116>>2]=n,T2[A+112>>2]=i,p2[A+120|0]=1;}}else i=e,n=b,e=r;if(T2[A+108>>2]=r=e+1|0,j2[(e<<2)+n>>2]=j2[f+4>>2],(0|r)==(0|i)){if((0|(b=i?i<<1:1))<=(0|i))e=n;else {e=0,b&&(T2[5498]=T2[5498]+1,(r=K2(19+(b<<2)|0))&&(T2[(e=r+19&-16)-4>>2]=r,n=T2[A+116>>2]));f:{if(1<=(0|i))for(r=e,o=n,a=i;j2[r>>2]=j2[o>>2],r=r+4|0,o=o+4|0,a=a-1|0;);else if(!n)break f;S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[n-4>>2]),i=T2[A+108>>2]);}T2[A+116>>2]=e,T2[A+112>>2]=b,p2[A+120|0]=1;}}else e=n,i=r;T2[A+108>>2]=r=i+1|0,j2[(i<<2)+e>>2]=j2[f+8>>2],A=T2[A+32>>2],T2[A+16>>2]=e,T2[A+12>>2]=T2[A+12>>2]+1,o=((0|r)/3|0)-1|0;}return o;}function v0(A,f){var r,e,i,a=0;L2=a=L2-48|0,i=T2[(f|=0)+4>>2],e=T2[(A|=0)+56>>2],T2[(r=e)+4>>2]=T2[f>>2],T2[r+8>>2]=i,r=T2[(f=f+8|0)+4>>2],T2[(e=e+12|0)>>2]=T2[f>>2],T2[4+e>>2]=r,T2[44+a>>2]=0,T2[36+a>>2]=0,T2[40+a>>2]=0,T2[32+a>>2]=1065353216,n1[T2[T2[A>>2]+68>>2]](16+a|0,A,32+a|0),j2[A+40>>2]=j2[16+a>>2]+j2[A+20>>2],T2[32+a>>2]=-1082130432,n1[T2[T2[A>>2]+68>>2]](a,A,32+a|0),r=T2[4+(e=8+a|0)>>2],T2[(f=24+a|0)>>2]=T2[e>>2],T2[f+4>>2]=r,r=T2[4+a>>2],T2[16+a>>2]=T2[a>>2],T2[20+a>>2]=r,j2[A+24>>2]=j2[16+a>>2]-j2[A+20>>2],T2[(r=40+a|0)>>2]=0,T2[4+r>>2]=0,T2[32+a>>2]=0,T2[36+a>>2]=0,T2[36+a>>2]=1065353216,n1[T2[T2[A>>2]+68>>2]](16+a|0,A,32+a|0),j2[A+44>>2]=j2[20+a>>2]+j2[A+20>>2],T2[36+a>>2]=-1082130432,n1[T2[T2[A>>2]+68>>2]](a,A,32+a|0),i=T2[4+e>>2],T2[f>>2]=T2[e>>2],T2[f+4>>2]=i,i=T2[4+a>>2],T2[16+a>>2]=T2[a>>2],T2[20+a>>2]=i,j2[A+28>>2]=j2[20+a>>2]-j2[A+20>>2],T2[r>>2]=0,T2[4+r>>2]=0,T2[r>>2]=1065353216,T2[32+a>>2]=0,T2[36+a>>2]=0,n1[T2[T2[A>>2]+68>>2]](16+a|0,A,32+a|0),T2[r>>2]=-1082130432,j2[A+48>>2]=j2[f>>2]+j2[A+20>>2],n1[T2[T2[A>>2]+68>>2]](a,A,32+a|0),r=T2[4+e>>2],T2[f>>2]=T2[e>>2],T2[f+4>>2]=r,e=T2[4+a>>2],T2[16+a>>2]=T2[a>>2],T2[20+a>>2]=e,j2[A+32>>2]=j2[f>>2]-j2[A+20>>2],L2=48+a|0;}function d0(A){var f=0;return T2[(A|=0)>>2]=10128,(f=T2[A+160>>2])&&S2[A+164|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+160>>2]=0,p2[A+164|0]=1,T2[(f=A+152|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+136>>2])&&S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+136>>2]=0,p2[A+140|0]=1,T2[(f=A+128|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+116>>2])&&S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+116>>2]=0,p2[A+120|0]=1,T2[(f=A+108|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+96>>2]=0,p2[A+100|0]=1,T2[(f=A+88|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+76>>2])&&S2[A+80|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+76>>2]=0,p2[A+80|0]=1,T2[(f=A+68|0)>>2]=0,(T2[f+4>>2]=0)|A;}function B0(A,f,r,e){f|=0,r|=0,e|=0;var i=0,a=0,n=0,o=0,b=0,t=0,c=0,u=0;if(T2[(A|=0)+168>>2]=T2[A+152>>2],p2[f+80|0]=1,p2[f+60|0]=0,T2[f+52>>2]=287,T2[f>>2]=10128,T2[f+76>>2]=0,p2[f+100|0]=1,T2[f+68>>2]=0,T2[f+72>>2]=0,T2[f+96>>2]=0,p2[f+120|0]=1,T2[f+88>>2]=0,T2[f+92>>2]=0,T2[f+116>>2]=0,p2[f+140|0]=1,T2[f+108>>2]=0,T2[f+112>>2]=0,T2[f+136>>2]=0,T2[f+144>>2]=0,p2[f+164|0]=1,T2[f+128>>2]=0,T2[f+132>>2]=0,T2[f+152>>2]=0,T2[f+156>>2]=0,T2[f+4>>2]=-8388609,T2[f+8>>2]=-8388609,T2[f+12>>2]=-8388609,T2[f+16>>2]=0,T2[f+20>>2]=2139095039,T2[f+24>>2]=2139095039,T2[f+28>>2]=2139095039,T2[f+32>>2]=0,T2[f+168>>2]=0,T2[f+160>>2]=0,r=T2[A+56>>2],r=e?(T2[f+56>>2]=r<<8&16711680|r<<24|r>>>8&65280|r>>>24,p2[f+4|0]=S2[A+7|0],p2[f+5|0]=S2[A+6|0],p2[f+6|0]=S2[A+5|0],p2[f+7|0]=S2[A+4|0],p2[f+8|0]=S2[A+11|0],p2[f+9|0]=S2[A+10|0],p2[f+10|0]=S2[A+9|0],p2[f+11|0]=S2[A+8|0],p2[f+12|0]=S2[A+15|0],p2[f+13|0]=S2[A+14|0],p2[f+14|0]=S2[A+13|0],p2[f+15|0]=S2[A+12|0],p2[f+16|0]=S2[A+19|0],p2[f+17|0]=S2[A+18|0],p2[f+18|0]=S2[A+17|0],p2[f+19|0]=S2[A+16|0],p2[f+20|0]=S2[A+23|0],p2[f+21|0]=S2[A+22|0],p2[f+22|0]=S2[A+21|0],p2[f+23|0]=S2[A+20|0],p2[f+24|0]=S2[A+27|0],p2[f+25|0]=S2[A+26|0],p2[f+26|0]=S2[A+25|0],p2[f+27|0]=S2[A+24|0],p2[f+28|0]=S2[A+31|0],p2[f+29|0]=S2[A+30|0],p2[f+30|0]=S2[A+29|0],p2[f+31|0]=S2[A+28|0],p2[f+32|0]=S2[A+35|0],p2[f+33|0]=S2[A+34|0],p2[f+34|0]=S2[A+33|0],p2[f+35|0]=S2[A+32|0],p2[f+36|0]=S2[A+39|0],p2[f+37|0]=S2[A+38|0],p2[f+38|0]=S2[A+37|0],p2[f+39|0]=S2[A+36|0],p2[f+40|0]=S2[A+43|0],p2[f+41|0]=S2[A+42|0],p2[f+42|0]=S2[A+41|0],p2[f+43|0]=S2[A+40|0],p2[f+44|0]=S2[A+47|0],p2[f+45|0]=S2[A+46|0],p2[f+46|0]=S2[A+45|0],p2[f+47|0]=S2[A+44|0],p2[f+48|0]=S2[A+51|0],p2[f+49|0]=S2[A+50|0],p2[f+50|0]=S2[A+49|0],p2[f+51|0]=S2[A+48|0],r=T2[A+144>>2],T2[f+144>>2]=r<<24|r<<8&16711680|r>>>8&65280|r>>>24,(r=T2[A+168>>2])<<24|r<<8&16711680|r>>>8&65280|r>>>24):(T2[f+56>>2]=r,i=T2[(b=A+12|0)+4>>2],T2[(t=(r=f+4|0)+8|0)>>2]=T2[b>>2],T2[t+4>>2]=i,t=T2[A+8>>2],T2[r>>2]=T2[A+4>>2],T2[r+4>>2]=t,i=T2[(b=A+28|0)+4>>2],T2[(t=(r=f+20|0)+8|0)>>2]=T2[b>>2],T2[t+4>>2]=i,t=T2[A+24>>2],T2[r>>2]=T2[A+20>>2],T2[r+4>>2]=t,r=T2[A+40>>2],T2[f+36>>2]=T2[A+36>>2],T2[f+40>>2]=r,b=T2[(t=A+44|0)+4>>2],T2[(r=f+44|0)>>2]=T2[t>>2],T2[r+4>>2]=b,T2[f+144>>2]=T2[A+144>>2],T2[A+168>>2]),p2[f+60|0]=S2[A+60|0],T2[f+168>>2]=r,b=f+172|0,t=T2[A+56>>2],S2[A+60|0]){if((r=T2[f+136>>2])&&S2[f+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[f+136>>2]=b,p2[f+140|0]=0,e){if(!((0|t)<1))for(c=T2[A+136>>2],i=t;n=A2[(a=o+c|0)>>1],$[(r=f+o|0)+172>>1]=(n<<24|n<<8&16711680)>>>16,n=A2[a+2>>1],$[r+174>>1]=(n<<24|n<<8&16711680)>>>16,n=A2[a+4>>1],$[r+176>>1]=(n<<24|n<<8&16711680)>>>16,n=A2[a+6>>1],$[r+178>>1]=(n<<24|n<<8&16711680)>>>16,n=A2[a+8>>1],$[r+180>>1]=(n<<24|n<<8&16711680)>>>16,n=T2[a+12>>2],T2[r+184>>2]=n<<24|n<<8&16711680|n>>>8&65280|n>>>24,n=r+182|0,r=A2[a+10>>1],$[n>>1]=(r<<24|r<<8&16711680)>>>16,o=o+16|0,i=i-1|0;);}else if(!((0|t)<1))for(n=T2[A+136>>2],r=t;$[(i=f+o|0)+172>>1]=A2[(a=n+o|0)>>1],$[i+174>>1]=A2[a+2>>1],$[i+176>>1]=A2[a+4>>1],$[i+178>>1]=A2[a+6>>1],$[i+180>>1]=A2[a+8>>1],T2[i+184>>2]=T2[a+12>>2],$[i+182>>1]=A2[a+10>>1],o=o+16|0,r=r-1|0;);n=f+128|0,o=t<<4;}else {(r=T2[f+96>>2])&&S2[f+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[f+96>>2]=b,p2[f+100|0]=0,T2[f+92>>2]=t,T2[f+88>>2]=t;A:{f:{if(!e){if(1<=(0|t))break f;r=b;break A;}if((0|t)<1){r=b;break A;}for(a=T2[A+96>>2],o=40,i=t,r=b;p2[(r=r+o|0)-40|0]=S2[(a=a+o|0)-37|0],p2[r-39|0]=S2[a-38|0],p2[r-38|0]=S2[a-39|0],p2[r-37|0]=S2[a-40|0],p2[r-36|0]=S2[a-33|0],p2[r-35|0]=S2[a-34|0],p2[r-34|0]=S2[a-35|0],p2[r-33|0]=S2[a-36|0],p2[r-32|0]=S2[a-29|0],p2[r-31|0]=S2[a-30|0],p2[r-30|0]=S2[a-31|0],p2[r-29|0]=S2[a-32|0],p2[r-28|0]=S2[a-25|0],p2[r-27|0]=S2[a-26|0],p2[r-26|0]=S2[a-27|0],p2[r-25|0]=S2[a-28|0],r=T2[f+96>>2]+o|0,a=T2[A+96>>2]+o|0,p2[r-24|0]=S2[a-21|0],p2[r-23|0]=S2[a-22|0],p2[r-22|0]=S2[a-23|0],p2[r-21|0]=S2[a-24|0],p2[r-20|0]=S2[a-17|0],p2[r-19|0]=S2[a-18|0],p2[r-18|0]=S2[a-19|0],p2[r-17|0]=S2[a-20|0],p2[r-16|0]=S2[a-13|0],p2[r-15|0]=S2[a-14|0],p2[r-14|0]=S2[a-15|0],p2[r-13|0]=S2[a-16|0],p2[r-12|0]=S2[a-9|0],p2[r-11|0]=S2[a-10|0],p2[r-10|0]=S2[a-11|0],p2[r-9|0]=S2[a-12|0],r=T2[f+96>>2],a=T2[A+96>>2],n=T2[(u=o+a|0)>>2],T2[(c=o+r|0)>>2]=n<<24|n<<8&16711680|n>>>8&65280|n>>>24,n=T2[u-8>>2],T2[c-8>>2]=n<<24|n<<8&16711680|n>>>8&65280|n>>>24,n=T2[u-4>>2],T2[c-4>>2]=n<<24|n<<8&16711680|n>>>8&65280|n>>>24,o=o- -64|0,i=i-1|0;);break A;}for(i=T2[A+96>>2],n=40,a=t,r=b;o=T2[(i=(i+n|0)-40|0)+4>>2],T2[(r=(r+n|0)-40|0)>>2]=T2[i>>2],T2[r+4>>2]=o,o=T2[(i=i+8|0)+4>>2],T2[(r=r+8|0)>>2]=T2[i>>2],T2[r+4>>2]=o,i=(T2[A+96>>2]+n|0)-24|0,o=T2[i+4>>2],r=(T2[f+96>>2]+n|0)-24|0,T2[r>>2]=T2[i>>2],T2[r+4>>2]=o,o=T2[(i=i+8|0)+4>>2],T2[(r=r+8|0)>>2]=T2[i>>2],T2[r+4>>2]=o,r=T2[f+96>>2],i=T2[A+96>>2],T2[(o=n+r|0)>>2]=T2[(c=i+n|0)>>2],T2[o-4>>2]=T2[c-4>>2],T2[o-8>>2]=T2[c-8>>2],n=n- -64|0,a=a-1|0;);}n=f+88|0,o=t<<6,S2[f+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]));}if(T2[n>>2]=0,T2[n+4>>2]=0,p2[0|(r=n+5|0)]=0,p2[r+1|0]=0,p2[r+2|0]=0,p2[r+3|0]=0,p2[r+4|0]=0,p2[r+5|0]=0,p2[r+6|0]=0,r=o+b|(p2[r+7|0]=0),(t=T2[f+160>>2])&&S2[f+164|0]&&(T2[5499]=T2[5499]+1,q2(T2[t-4>>2])),t=f+152|0,p2[f+164|0]=0,T2[f+160>>2]=r,r=T2[A+168>>2],e){if(!((0|r)<1))for(a=f+o|0,o=T2[A+160>>2],A=0;i=A2[(b=A+o|0)>>1],$[(e=A+a|0)+172>>1]=(i<<24|i<<8&16711680)>>>16,i=A2[b+2>>1],$[e+174>>1]=(i<<24|i<<8&16711680)>>>16,i=A2[b+4>>1],$[e+176>>1]=(i<<24|i<<8&16711680)>>>16,i=A2[b+6>>1],$[e+178>>1]=(i<<24|i<<8&16711680)>>>16,i=A2[b+8>>1],$[e+180>>1]=(i<<24|i<<8&16711680)>>>16,i=T2[b+12>>2],T2[e+184>>2]=i<<24|i<<8&16711680|i>>>8&65280|i>>>24,i=T2[b+16>>2],T2[e+188>>2]=i<<24|i<<8&16711680|i>>>8&65280|i>>>24,i=e+182|0,e=A2[b+10>>1],$[i>>1]=(e<<24|e<<8&16711680)>>>16,A=A+32|0,r=r-1|0;);}else if(!((0|r)<1))for(i=f+o|0,a=T2[A+160>>2],r=o=0;$[(e=i+o|0)+172>>1]=A2[(b=a+o|0)>>1],$[e+174>>1]=A2[b+2>>1],$[e+176>>1]=A2[b+4>>1],$[e+178>>1]=A2[b+6>>1],$[e+180>>1]=A2[b+8>>1],c=T2[(n=b+12|0)+4>>2],n=T2[n>>2],T2[e+200>>2]=0,T2[(u=e+184|0)>>2]=n,T2[u+4>>2]=c,b=A2[b+10>>1],T2[(n=e+192|0)>>2]=0,T2[n+4>>2]=0,$[e+182>>1]=b,o=o+32|0,(0|(r=r+1|0))<T2[A+168>>2];);return T2[(A=t)>>2]=0,T2[A+4>>2]=0,T2[f>>2]=0,p2[0|(A=A+5|0)]=0,p2[A+1|0]=0,p2[A+2|0]=0,p2[A+3|0]=0,p2[A+4|0]=0,p2[A+5|0]=0,p2[A+6|0]=0,p2[A+7|0]=0,1;}function Q0(A,f,r,e,i,a,n,o){var b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z=0,Y=0,R=0,F=z2(0),W=z2(0),m=z2(0),N=z2(0),V=0,J=z2(0),M=z2(0),I=0,x=z2(0),y=z2(0),U=z2(0),X=0,p=0,T=0;L2=Z=L2-32|0;A:if(!((0|(T=T2[A+56>>2]))<1))for(F=j2[r+8>>2],y=N=z2(a-F),J=j2[r>>2],W=z2(e-J),M=j2[r+4>>2],m=z2(i-M),x=z2(z2(1)/z2(_2(z2(z2(z2(W*W)+z2(m*m))+z2(N*N))))),N=z2(N*x),W=z2((U=W)*x),m=z2((b=m)*x),b=z2(z2(y*N)+z2(z2(U*W)+z2(b*m))),x=j2[o+8>>2],u=z2((F<a?a:F)+x),y=j2[o+4>>2],k=z2((M<i?i:M)+y),U=j2[o>>2],l=z2((J<e?e:J)+U),F=a<F?a:F,a=j2[n+8>>2],s=z2(F+a),F=i<M?i:M,i=j2[n+4>>2],v=z2(F+i),F=e<J?e:J,e=j2[n>>2],d=z2(F+e),R=T2[A+96>>2],B=((Y=(F=N==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/N))<z2(0))<<4)+Z|8,Q=((V=(J=m==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/m))<z2(0))<<4)+Z|4,g=(!Y<<4)+Z|8,w=(!V<<4)+Z|4,G=((Y=(M=W==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/W))<z2(0))<<4)+Z|0,C=(!Y<<4)+Z|0,t=16+Z|0,X=1;;){V=T2[(Y=R+8|0)>>2],Y=T2[Y+4>>2],E=T2[R>>2],D=T2[R+4>>2],I=T2[R+20>>2],T2[t>>2]=T2[R+16>>2],T2[4+t>>2]=I,h=T2[(I=R+24|0)+4>>2],T2[(c=8+t|0)>>2]=T2[I>>2],T2[4+c>>2]=h,T2[Z>>2]=E,T2[4+Z>>2]=D,T2[8+Z>>2]=V,T2[12+Z>>2]=Y,j2[Z>>2]=j2[Z>>2]-U,j2[4+Z>>2]=j2[4+Z>>2]-y,j2[16+Z>>2]=j2[16+Z>>2]-e,j2[20+Z>>2]=j2[20+Z>>2]-i,j2[8+Z>>2]=j2[8+Z>>2]-x,j2[24+Z>>2]=j2[24+Z>>2]-a,Y=0,j2[R+16>>2]<d||(Y=0,j2[R>>2]>l||(Y=1)),V=0,j2[I>>2]<s||j2[R+8>>2]>u||(V=Y);f:{r:{e:{i:{if(!(j2[R+20>>2]<v||1^V|j2[R+4>>2]>k||(W=j2[r+4>>2],e=z2(J*z2(j2[Q>>2]-W)),a=j2[r>>2],(i=z2(M*z2(j2[C>>2]-a)))<e||(a=z2(M*z2(j2[G>>2]-a)),(W=z2(J*z2(j2[w>>2]-W)))<a||(N=j2[r+8>>2],(i=W<i?W:i)<(m=z2(F*z2(j2[B>>2]-N)))||(e=a<e?e:a,(a=z2(F*z2(j2[g>>2]-N)))<e)))))){if(I=-1==(0|(Y=T2[R+32>>2])),!(V=(e<m?m:e)<b&(a<i?a:i)>z2(0)))break i;if(-1!=(0|Y))break i;n1[T2[T2[f>>2]+8>>2]](f,T2[R+36>>2],T2[R+40>>2]),T=T2[A+56>>2];break e;}I=-1==(0|(Y=T2[R+32>>2])),V=0;}if(!I&&!V)break r;}p=p+1|0,R=R- -64|0;break f;}p=Y+p|0,R=(Y<<6)+R|0;}if((0|T)<=(0|p))break A;X=X+1|0,a=j2[n+8>>2],i=j2[n+4>>2],e=j2[n>>2],x=j2[o+8>>2],y=j2[o+4>>2],U=j2[o>>2];}T2[5592]<(0|X)&&(T2[5592]=X),L2=32+Z|0;}function g0(A,f,r,e,i,a,n,o,b){var t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N=z2(0),V=0,J=0,M=0,I=(z2(0)),x=z2(0),y=z2(0),U=(0),X=0,p=(0),T=0,S=0,j=0;if(L2=M=L2-32|0,s=j2[r+4>>2],v=j2[r>>2],I=j2[A+28>>2],u=j2[A+12>>2],d=j2[r+8>>2],N=z2((a<d?a:d)+j2[n+8>>2]),B=j2[A+44>>2],U=(N=z2(z2((I<(N=N<u?u:N)?I:N)-u)*B))<z2(4294967296)&N>=z2(0)?~~N>>>0:0,x=j2[A+24>>2],k=j2[A+8>>2],N=z2((i<s?i:s)+j2[n+4>>2]),t=j2[A+40>>2],X=(N=z2(z2((x<(N=N<k?k:N)?x:N)-k)*t))<z2(4294967296)&N>=z2(0)?~~N>>>0:0,y=j2[A+20>>2],l=j2[A+4>>2],N=z2((e<v?e:v)+j2[n>>2]),c=j2[A+36>>2],p=(N=z2(z2((y<(N=N<l?l:N)?y:N)-l)*c))<z2(4294967296)&N>=z2(0)?~~N>>>0:0,N=z2((d<a?a:d)+j2[o+8>>2]),T=(N=z2(z2(z2((I<(N=N<u?u:N)?I:N)-u)*B)+z2(1)))<z2(4294967296)&N>=z2(0)?~~N>>>0:0,N=z2((s<i?i:s)+j2[o+4>>2]),J=(N=z2(z2(z2((x<(N=N<k?k:N)?x:N)-k)*t)+z2(1)))<z2(4294967296)&N>=z2(0)?~~N>>>0:0,N=z2((v<e?e:v)+j2[o>>2]),V=(N=z2(z2(z2((y<(N=N<l?l:N)?y:N)-l)*c)+z2(1)))<z2(4294967296)&N>=z2(0)?~~N>>>0:0,1<=(0|b))for(a=N=z2(a-d),t=z2(e-v),c=z2(i-s),e=z2(z2(1)/z2(_2(z2(z2(z2(t*t)+z2(c*c))+z2(N*N))))),N=z2(N*e),i=z2(t*e),e=z2(c*e),B=z2(z2(a*N)+z2(z2(t*i)+z2(c*e))),w=65534&U,G=65534&X,C=65534&p,E=1|T,D=1|J,h=1|V,Z=((J=(I=N==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/N))<z2(0))<<4)+M|8,Y=((V=(x=e==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/e))<z2(0))<<4)+M|4,R=(!J<<4)+M|8,F=(!V<<4)+M|4,V=T2[A+136>>2],W=((J=(y=i==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/i))<z2(0))<<4)+M|0,m=(!J<<4)+M|0;;){Q=T2[V+12>>2],J=0;A:{f:{r:{e:if(!(A2[V+6>>1]<C>>>0||h>>>0<(g=A2[V>>1])>>>0||A2[V+10>>1]<w>>>0||E>>>0<(U=A2[V+4>>1])>>>0||A2[V+8>>1]<G>>>0||D>>>0<(X=A2[V+2>>1])>>>0)){if(T2[12+M>>2]=0,p=A2[V+10>>1],T=A2[V+8>>1],J=A2[V+6>>1],T2[28+M>>2]=0,t=j2[A+36>>2],c=j2[A+4>>2],j2[M>>2]=z2(z2(z2(g>>>0)/t)+c)-j2[o>>2],N=j2[A+40>>2],a=j2[A+8>>2],j2[4+M>>2]=z2(z2(z2(X>>>0)/N)+a)-j2[o+4>>2],i=j2[A+44>>2],e=j2[A+12>>2],j2[8+M>>2]=z2(z2(z2(U>>>0)/i)+e)-j2[o+8>>2],j2[16+M>>2]=z2(c+z2(z2(J>>>0)/t))-j2[n>>2],j2[20+M>>2]=z2(a+z2(z2(T>>>0)/N))-j2[n+4>>2],j2[24+M>>2]=z2(e+z2(z2(p>>>0)/i))-j2[n+8>>2],i=j2[r+4>>2],t=z2(x*z2(j2[Y>>2]-i)),e=j2[r>>2],!((a=z2(y*z2(j2[m>>2]-e)))<t||(c=z2(y*z2(j2[W>>2]-e)),(i=z2(x*z2(j2[F>>2]-i)))<c||(e=j2[r+8>>2],(a=i<a?i:a)<(N=z2(I*z2(j2[Z>>2]-e)))||(i=c<t?t:c,(e=z2(I*z2(j2[R>>2]-e)))<i))))){if(J=(i<N?N:i)<B&(e<a?e:a)>z2(0),(0|Q)<0)break e;if(!J)break e;J=T2[V+12>>2],n1[T2[T2[f>>2]+8>>2]](f,J>>21,2097151&J);break r;}J=0;}if(!(-1<(0|Q))&&!J)break f;}S=S+1|0,V=V+16|0;break A;}S=S-(J=T2[V+12>>2])|0,V=V-(J<<4)|0;}if(j=j+1|0,!((0|S)<(0|b)))break;}T2[5592]<(0|j)&&(T2[5592]=j),L2=32+M|0;}function w0(A){return 84;}function G0(A,f,r,e,i){var a,n,o,b,t,c=0,u=0,k=z2(0),l=z2(0),s=0,v=0,d=0,B=z2(0),Q=z2(0),g=z2(0),w=0,G=0,C=z2(0),E=z2(0),D=z2(0),h=z2(0);if(L2=c=L2-112|0,p2[A+60|0]=r){if(k=j2[e>>2],Q=j2[e+4>>2],g=j2[e+8>>2],T2[A+16>>2]=0,C=z2(g+z2(-1)),j2[A+12>>2]=C,Q=z2(Q+z2(-1)),j2[A+8>>2]=Q,k=z2(k+z2(-1)),j2[A+4>>2]=k,p2[A+60|0]=1,g=j2[i>>2],l=j2[i+4>>2],E=j2[i+8>>2],T2[A+32>>2]=0,o=z2(E+z2(1)),j2[A+28>>2]=o,E=z2(l+z2(1)),j2[A+24>>2]=E,g=z2(g+z2(1)),j2[A+20>>2]=g,D=z2(o-C),h=z2(z2(65533)/D),j2[A+44>>2]=h,l=z2(z2(65533)/z2(E-Q)),j2[A+40>>2]=l,n=z2(z2(65533)/z2(g-k)),j2[A+36>>2]=n,r=(B=z2(z2(C-C)*h))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,t=z2((65534&r)>>>0),r=(B=z2(z2((b=Q)-Q)*l))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,b=z2(b+z2(z2((65534&r)>>>0)/l)),r=(B=z2(z2((l=k)-k)*n))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,(l=z2(z2(l+z2(z2((65534&r)>>>0)/n))+z2(-1)))<k&&(k=j2[A+4>>2]=l),(l=z2(b+z2(-1)))<Q&&(Q=j2[A+8>>2]=l),(l=z2(z2(C+z2(t/h))+z2(-1)))<C&&(j2[A+12>>2]=l,D=z2(o-l),h=z2(z2(65533)/D),C=l),l=z2(E-Q),n=z2(z2(65533)/l),r=(l=z2(z2(n*l)+z2(1)))<z2(4294967296)&l>=z2(0)?~~l>>>0:0,n=z2(z2((1|r)>>>0)/n),k=z2(g-(l=k)),B=z2(z2(65533)/k),r=(k=z2(z2(B*k)+z2(1)))<z2(4294967296)&k>=z2(0)?~~k>>>0:0,e=!(g<(k=z2(z2(l+z2(z2((1|r)>>>0)/B))+z2(1)))),r=(D=z2(z2(h*D)+z2(1)))<z2(4294967296)&D>=z2(0)?~~D>>>0:0,e||(g=j2[A+20>>2]=k),E<(k=z2(z2(Q+n)+z2(1)))&&(E=j2[A+24>>2]=k),o<(k=z2(z2(C+z2(z2((1|r)>>>0)/h))+z2(1)))&&(j2[A+28>>2]=k,h=z2(z2(65533)/z2(k-C))),T2[A+48>>2]=0,j2[A+44>>2]=h,j2[A+40>>2]=z2(65533)/z2(E-Q),j2[A+36>>2]=z2(65533)/z2(g-l),T2[96+c>>2]=A,T2[92+c>>2]=A+104,T2[88+c>>2]=10352,n1[T2[T2[f>>2]+8>>2]](f,88+c|0,A+4|0,A+20|0),w=T2[A+108>>2],T2[(f=16+c|0)>>2]=0,T2[f+4>>2]=0,T2[8+c>>2]=0,((T2[12+c>>2]=0)|(e=T2[A+128>>2]))<(0|(i=w<<1))){if((0|i)>T2[A+132>>2]){if(w&&(T2[5498]=T2[5498]+1,(f=K2(w<<5|19))&&(T2[(v=f+19&-16)-4>>2]=f)),1<=(0|e))for(r=0,f=e;u=T2[A+136>>2]+r|0,d=T2[u+4>>2],T2[(s=G=r+v|0)>>2]=T2[u>>2],T2[s+4>>2]=d,s=T2[(u=u+8|0)+4>>2],T2[(G=G+8|0)>>2]=T2[u>>2],T2[G+4>>2]=s,r=r+16|0,f=f-1|0;);(f=T2[A+136>>2])&&S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+136>>2]=v,T2[A+132>>2]=i,p2[A+140|0]=1;}for(r=e<<4,f=e-(w<<1)|0;v=T2[12+c>>2],e=T2[A+136>>2]+r|0,T2[e>>2]=T2[8+c>>2],T2[e+4>>2]=v,v=T2[(u=16+c|0)+4>>2],T2[(e=e+8|0)>>2]=T2[u>>2],T2[e+4>>2]=v,r=r+16|0,(e=f)>>>0<=(f=f+1|0)>>>0;);}T2[A+128>>2]=i;}else {if(T2[104+c>>2]=10372,T2[108+c>>2]=A- -64,T2[96+c>>2]=-581039253,T2[100+c>>2]=0,T2[88+c>>2]=-581039253,T2[92+c>>2]=-581039253,T2[80+c>>2]=1566444395,T2[84+c>>2]=0,T2[72+c>>2]=1566444395,T2[76+c>>2]=1566444395,n1[T2[T2[f>>2]+8>>2]](f,104+c|0,88+c|0,72+c|0),w=T2[A+68>>2],T2[(f=c+64|0)>>2]=0,T2[f+4>>2]=0,T2[(f=56+c|0)>>2]=0,T2[f+4>>2]=0,T2[(f=48+c|0)>>2]=0,T2[f+4>>2]=0,T2[(f=40+c|0)>>2]=0,T2[f+4>>2]=0,T2[(f=32+c|0)>>2]=0,T2[f+4>>2]=0,T2[(f=24+c|0)>>2]=0,T2[f+4>>2]=0,T2[(f=16+c|0)>>2]=0,T2[f+4>>2]=0,T2[8+c>>2]=0,((T2[12+c>>2]=0)|(r=T2[A+88>>2]))<(0|(G=w<<1))){if((0|G)>T2[A+92>>2]){if(w&&(T2[5498]=T2[5498]+1,(f=K2(w<<7|19))&&(T2[(v=f+19&-16)-4>>2]=f)),1<=(0|r))for(e=0,i=r;u=T2[A+96>>2]+e|0,a=T2[u+4>>2],T2[(f=e+v|0)>>2]=T2[u>>2],T2[f+4>>2]=a,a=T2[(s=u+56|0)+4>>2],T2[(d=f+56|0)>>2]=T2[s>>2],T2[d+4>>2]=a,a=T2[(d=u+48|0)+4>>2],T2[(s=f+48|0)>>2]=T2[d>>2],T2[s+4>>2]=a,a=T2[(d=u+40|0)+4>>2],T2[(s=f+40|0)>>2]=T2[d>>2],T2[s+4>>2]=a,a=T2[(d=u+32|0)+4>>2],T2[(s=f+32|0)>>2]=T2[d>>2],T2[s+4>>2]=a,a=T2[(d=u+24|0)+4>>2],T2[(s=f+24|0)>>2]=T2[d>>2],T2[s+4>>2]=a,a=T2[(d=u+16|0)+4>>2],T2[(s=f+16|0)>>2]=T2[d>>2],T2[s+4>>2]=a,s=T2[(u=u+8|0)+4>>2],T2[(f=f+8|0)>>2]=T2[u>>2],T2[f+4>>2]=s,e=e- -64|0,i=i-1|0;);(f=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+96>>2]=v,T2[A+92>>2]=G,p2[A+100|0]=1;}for(f=r<<6,e=r-(w<<1)|0;u=T2[12+c>>2],r=T2[A+96>>2]+f|0,T2[r>>2]=T2[8+c>>2],T2[r+4>>2]=u,v=T2[(u=c+64|0)+4>>2],T2[(i=r+56|0)>>2]=T2[u>>2],T2[i+4>>2]=v,v=T2[(u=56+c|0)+4>>2],T2[(i=r+48|0)>>2]=T2[u>>2],T2[i+4>>2]=v,v=T2[(u=48+c|0)+4>>2],T2[(i=r+40|0)>>2]=T2[u>>2],T2[i+4>>2]=v,v=T2[(u=40+c|0)+4>>2],T2[(i=r+32|0)>>2]=T2[u>>2],T2[i+4>>2]=v,v=T2[(u=32+c|0)+4>>2],T2[(i=r+24|0)>>2]=T2[u>>2],T2[i+4>>2]=v,v=T2[(u=24+c|0)+4>>2],T2[(i=r+16|0)>>2]=T2[u>>2],T2[i+4>>2]=v,u=T2[(i=16+c|0)+4>>2],T2[(r=r+8|0)>>2]=T2[i>>2],T2[r+4>>2]=u,f=f- -64|0,(r=e)>>>0<=(e=r+1|0)>>>0;);}T2[A+88>>2]=G;}(function A(f,r,e){var i,a,n,o,b,t,c,u,k,l,s,v=0,d=0,B=z2(0),Q=0,g=0,w=0,G=0,C=0,E=0,D=z2(0),h=z2(0),Z=0,Y=z2(0),R=0,F=0,W=z2(0),m=z2(0),N=z2(0),V=z2(0),J=z2(0),M=0,I=0,x=z2(0),y=0,U=0,X=0,p=0,T=0,S=z2(0),j=z2(0),P=z2(0),z=z2(0);if(L2=C=L2-112|0,p=T2[f+56>>2],1!=(0|(w=e-r|0))){if(F=(0|r)<(0|e)){if(Q=S2[f+60|0])for(v=T2[f+116>>2]+(r<<4)|0,G=e-r|0,W=j2[f+12>>2],m=j2[f+8>>2],Y=j2[f+44>>2],D=j2[f+40>>2],h=j2[f+4>>2],B=j2[f+36>>2];V=z2(V+z2(z2(z2(z2(z2(A2[v+10>>1])/Y)+W)+z2(z2(z2(A2[v+4>>1])/Y)+W))*z2(.5))),J=z2(J+z2(z2(z2(z2(z2(A2[v+8>>1])/D)+m)+z2(z2(z2(A2[v+2>>1])/D)+m))*z2(.5))),N=z2(N+z2(z2(z2(z2(z2(A2[v+6>>1])/B)+h)+z2(z2(z2(A2[v>>1])/B)+h))*z2(.5))),v=v+16|0,G=G-1|0;);else for(v=T2[f+76>>2]+(r<<6)|0,G=e-r|0;V=z2(V+z2(z2(j2[v+24>>2]+j2[v+8>>2])*z2(.5))),J=z2(J+z2(z2(j2[v+20>>2]+j2[v+4>>2])*z2(.5))),N=z2(N+z2(z2(j2[v+16>>2]+j2[v>>2])*z2(.5))),v=v- -64|0,G=G-1|0;);if(P=z2(0|w),B=z2(z2(1)/P),V=z2(B*V),J=z2(B*J),N=z2(B*N),Q)for(v=T2[f+116>>2]+(r<<4)|0,G=e-r|0,x=j2[f+12>>2],W=j2[f+8>>2],m=j2[f+44>>2],Y=j2[f+40>>2],D=j2[f+4>>2],h=j2[f+36>>2];B=z2(z2(z2(z2(z2(z2(A2[v+10>>1])/m)+x)+z2(z2(z2(A2[v+4>>1])/m)+x))*z2(.5))-V),S=z2(S+z2(B*B)),B=z2(z2(z2(z2(z2(z2(A2[v+8>>1])/Y)+W)+z2(z2(z2(A2[v+2>>1])/Y)+W))*z2(.5))-J),z=z2(z+z2(B*B)),B=z2(z2(z2(z2(z2(z2(A2[v+6>>1])/h)+D)+z2(z2(z2(A2[v>>1])/h)+D))*z2(.5))-N),j=z2(j+z2(B*B)),v=v+16|0,G=G-1|0;);else for(v=T2[f+76>>2]+(r<<6)|0,G=e-r|0;B=z2(z2(z2(j2[v+24>>2]+j2[v+8>>2])*z2(.5))-V),S=z2(S+z2(B*B)),B=z2(z2(z2(j2[v+20>>2]+j2[v+4>>2])*z2(.5))-J),z=z2(z+z2(B*B)),B=z2(z2(z2(j2[v+16>>2]+j2[v>>2])*z2(.5))-N),j=z2(j+z2(B*B)),v=v- -64|0,G=G-1|0;);}else P=z2(0|w);if(T2[28+C>>2]=0,V=z2(0),J=z2(0),N=z2(0),!(d=(0|e)<=(0|r)))if(S2[f+60|0])for(v=T2[f+116>>2]+(r<<4)|0,G=e-r|0,W=j2[f+12>>2],m=j2[f+8>>2],Y=j2[f+44>>2],D=j2[f+40>>2],h=j2[f+4>>2],B=j2[f+36>>2];V=z2(z2(z2(z2(z2(z2(A2[v+10>>1])/Y)+W)+z2(z2(z2(A2[v+4>>1])/Y)+W))*z2(.5))+V),J=z2(z2(z2(z2(z2(z2(A2[v+8>>1])/D)+m)+z2(z2(z2(A2[v+2>>1])/D)+m))*z2(.5))+J),N=z2(z2(z2(z2(z2(z2(A2[v+6>>1])/B)+h)+z2(z2(z2(A2[v>>1])/B)+h))*z2(.5))+N),v=v+16|0,G=G-1|0;);else for(v=T2[f+76>>2]+(r<<6)|0,G=e-r|0;V=z2(z2(z2(j2[v+24>>2]+j2[v+8>>2])*z2(.5))+V),J=z2(z2(z2(j2[v+20>>2]+j2[v+4>>2])*z2(.5))+J),N=z2(z2(z2(j2[v+16>>2]+j2[v>>2])*z2(.5))+N),v=v- -64|0,G=G-1|0;);if(B=z2(z2(1)/z2(0|w)),j2[24+C>>2]=B*V,j2[20+C>>2]=B*J,j2[16+C>>2]=B*N,G=p,Q=r,!d){for(D=z2(z2(1)/z2(P+z2(-1))),d=(h=z2(D*z))<(B=z2(D*S))?2:1,P=B,B=z2(D*j),x=j2[(16+C|0)+((v=B<h?d:(B<P)<<1)<<2)>>2],y=e-r|0,G=r<<4,T=r<<6,X=(v<<2)+C|0;B=(v=S2[f+60|0])?(d=T2[f+116>>2]+G|0,W=j2[f+36>>2],m=j2[f+4>>2],V=z2(z2(z2(A2[d>>1])/W)+m),Y=j2[f+44>>2],D=j2[f+12>>2],J=z2(z2(z2(A2[d+4>>1])/Y)+D),h=j2[f+40>>2],B=j2[f+8>>2],N=z2(z2(z2(A2[d+2>>1])/h)+B),j=z2(z2(z2(A2[d+10>>1])/Y)+D),S=z2(z2(z2(A2[d+6>>1])/W)+m),z2(z2(z2(A2[d+8>>1])/h)+B)):(d=T2[f+76>>2]+T|0,V=j2[d>>2],J=j2[d+8>>2],N=j2[d+4>>2],j=j2[d+24>>2],S=j2[d+16>>2],j2[d+20>>2]),T2[12+C>>2]=0,j2[8+C>>2]=z2(j+J)*z2(.5),j2[4+C>>2]=z2(B+N)*z2(.5),j2[C>>2]=z2(S+V)*z2(.5),x<j2[X>>2]&&(v?(v=T2[f+116>>2],U=T2[(g=v+G|0)>>2],M=T2[g+4>>2],v=T2[4+(d=I=(R=Q<<4)+v|0)>>2],T2[g>>2]=T2[d>>2],T2[g+4>>2]=v,E=T2[(Z=g+8|0)>>2],g=T2[Z+4>>2],v=T2[4+(d=d+8|0)>>2],T2[Z>>2]=T2[d>>2],T2[Z+4>>2]=v,v=R+T2[f+116>>2]|0,T2[v>>2]=U,T2[v+4>>2]=M,T2[(v=v+8|0)>>2]=E,T2[v+4>>2]=g):(v=T2[f+76>>2],R=T2[(i=v+T|0)>>2],I=T2[4+i>>2],v=T2[4+(d=a=(E=Q<<6)+v|0)>>2],T2[i>>2]=T2[d>>2],T2[4+i>>2]=v,v=T2[4+(d=n=8+i|0)>>2],T2[(g=o=40+C|0)>>2]=T2[d>>2],T2[g+4>>2]=v,v=T2[4+(d=b=16+i|0)>>2],T2[(g=t=48+C|0)>>2]=T2[d>>2],T2[g+4>>2]=v,v=T2[4+(d=c=24+i|0)>>2],T2[(g=u=56+C|0)>>2]=T2[d>>2],T2[g+4>>2]=v,v=T2[4+(d=k=32+i|0)>>2],T2[(g=l=64+C|0)>>2]=T2[d>>2],T2[g+4>>2]=v,v=T2[4+(d=Z=40+i|0)>>2],T2[(g=s=72+C|0)>>2]=T2[d>>2],T2[g+4>>2]=v,v=T2[4+(d=M=48+i|0)>>2],T2[(g=U=80+C|0)>>2]=T2[d>>2],T2[g+4>>2]=v,v=T2[4+(i=56+i|0)>>2],T2[(d=g=88+C|0)>>2]=T2[i>>2],T2[d+4>>2]=v,v=T2[4+(d=8+a|0)>>2],T2[n>>2]=T2[d>>2],T2[4+n>>2]=v,v=T2[4+(d=16+a|0)>>2],T2[b>>2]=T2[d>>2],T2[4+b>>2]=v,v=T2[4+(d=24+a|0)>>2],T2[c>>2]=T2[d>>2],T2[4+c>>2]=v,v=T2[4+(d=32+a|0)>>2],T2[k>>2]=T2[d>>2],T2[4+k>>2]=v,v=T2[4+(d=40+a|0)>>2],T2[Z>>2]=T2[d>>2],T2[Z+4>>2]=v,v=T2[4+(d=48+a|0)>>2],T2[M>>2]=T2[d>>2],T2[M+4>>2]=v,v=T2[4+(d=56+a|0)>>2],T2[i>>2]=T2[d>>2],T2[4+i>>2]=v,T2[32+C>>2]=R,T2[36+C>>2]=I,v=T2[36+C>>2],E=E+T2[f+76>>2]|0,T2[E>>2]=T2[32+C>>2],T2[E+4>>2]=v,v=T2[g+4>>2],T2[(d=E+56|0)>>2]=T2[g>>2],T2[d+4>>2]=v,v=T2[U+4>>2],T2[(d=E+48|0)>>2]=T2[U>>2],T2[d+4>>2]=v,v=T2[4+s>>2],T2[(d=E+40|0)>>2]=T2[s>>2],T2[d+4>>2]=v,v=T2[4+l>>2],T2[(d=E+32|0)>>2]=T2[l>>2],T2[d+4>>2]=v,v=T2[4+u>>2],T2[(d=E+24|0)>>2]=T2[u>>2],T2[d+4>>2]=v,v=T2[4+t>>2],T2[(d=E+16|0)>>2]=T2[t>>2],T2[d+4>>2]=v,v=T2[4+o>>2],T2[(d=E+8|0)>>2]=T2[o>>2],T2[d+4>>2]=v),Q=Q+1|0),G=G+16|0,T=T- -64|0,y=y-1|0;);G=T2[f+56>>2];}if(M=(w>>1)+r|0,E=((-1^(v=(0|w)/3|0))+e|0)<=(0|Q),I=r+v|0,S2[f+60|0]?(d=v=T2[f+136>>2]+(G<<4)|0,g=(B=z2(z2(j2[f+20>>2]-j2[f+4>>2])*j2[f+36>>2]))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,$[d>>1]=65534&g,D=j2[f+40>>2],h=j2[f+8>>2],B=j2[f+24>>2],d=v,g=(Y=z2(z2(j2[f+28>>2]-j2[f+12>>2])*j2[f+44>>2]))<z2(4294967296)&Y>=z2(0)?~~Y>>>0:0,$[d+4>>1]=65534&g,d=(B=z2(D*z2(B-h)))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,$[v+2>>1]=65534&d):(v=T2[4+(R=f+20|0)>>2],g=T2[f+96>>2]+(G<<6)|0,T2[(d=g)>>2]=T2[R>>2],T2[d+4>>2]=v,v=T2[4+(d=R+8|0)>>2],T2[(g=g+8|0)>>2]=T2[d>>2],T2[g+4>>2]=v),E=E?M:Q,g=(0|Q)<=(0|I),v=T2[f+56>>2],S2[f+60|0]?(v=d=T2[f+136>>2]+(v<<4)|0,B=j2[f+4>>2],Q=(B=z2(z2(z2(B-B)*j2[f+36>>2])+z2(1)))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,$[v+6>>1]=1|Q,h=j2[f+40>>2],D=j2[f+8>>2],v=d+10|0,B=j2[f+12>>2],Q=(B=z2(z2(z2(B-B)*j2[f+44>>2])+z2(1)))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,$[v>>1]=1|Q,d=d+8|0,v=(B=z2(z2(h*z2(D-D))+z2(1)))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,$[d>>1]=1|v):(d=T2[f+96>>2]+(v<<6)|0,v=T2[4+(I=f+4|0)>>2],T2[d+16>>2]=T2[I>>2],T2[d+20>>2]=v,v=T2[4+(Q=I+8|0)>>2],T2[(d=d+24|0)>>2]=T2[Q>>2],T2[d+4>>2]=v),U=g?M:E,F)for(T=r<<4,y=r<<6|16,X=T2[f+56>>2],R=S2[f+60|0];R?(F=T2[f+116>>2]+T|0,x=j2[f+36>>2],W=j2[f+4>>2],v=(B=z2(z2(z2(z2(z2(A2[F>>1])/x)+W)-W)*x))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,Z=T2[f+136>>2]+(X<<4)|0,I=A2[Z>>1],m=j2[f+44>>2],Y=j2[f+12>>2],E=(B=z2(z2(z2(z2(z2(A2[F+4>>1])/m)+Y)-Y)*m))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,D=j2[f+40>>2],h=j2[f+8>>2],g=(B=z2(z2(z2(z2(z2(A2[F+2>>1])/D)+h)-h)*D))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,d=(B=z2(z2(m*z2(z2(z2(z2(A2[F+10>>1])/m)+Y)-Y))+z2(1)))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,M=65534&v,Q=(B=z2(z2(D*z2(z2(z2(z2(A2[F+8>>1])/D)+h)-h))+z2(1)))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,I=I>>>0<=M>>>0,v=(B=z2(z2(x*z2(z2(z2(z2(A2[F+6>>1])/x)+W)-W))+z2(1)))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,I||($[Z>>1]=M),(v|=1)>>>0>A2[Z+6>>1]&&($[Z+6>>1]=v),(v=65534&g)>>>0<A2[Z+2>>1]&&($[Z+2>>1]=v),(v=1|Q)>>>0>A2[(g=Z+8|0)>>1]&&($[g>>1]=v),(v=65534&E)>>>0<A2[Z+4>>1]&&($[Z+4>>1]=v),(v=1|d)>>>0<=A2[(Q=Z+10|0)>>1]||($[Q>>1]=v)):(v=T2[f+76>>2]+y|0,N=j2[v>>2],x=j2[v+12>>2],W=j2[v+8>>2],m=j2[v+4>>2],Y=j2[v-4>>2],D=j2[v-8>>2],h=j2[v-12>>2],B=j2[v-16>>2],Q=T2[f+96>>2]+(X<<6)|0,B<j2[Q>>2]&&(j2[Q>>2]=B),h<j2[Q+4>>2]&&(j2[Q+4>>2]=h),D<j2[Q+8>>2]&&(j2[Q+8>>2]=D),Y<j2[Q+12>>2]&&(j2[Q+12>>2]=Y),N>j2[Q+16>>2]&&(j2[Q+16>>2]=N),m>j2[(v=Q+20|0)>>2]&&(j2[v>>2]=m),W>j2[(v=Q+24|0)>>2]&&(j2[v>>2]=W),x>j2[(v=Q+28|0)>>2]&&(j2[v>>2]=x)),T=T+16|0,y=y- -64|0,w=w-1|0;);else X=T2[f+56>>2];if(T2[f+56>>2]=F=X+1|0,A(f,r,U),X=T2[f+56>>2],A(f,U,e),U=T2[f+56>>2]-p|0,(v=S2[f+60|0])&&!((0|U)<129)){if(M=T2[f+136>>2],I=-1<(0|(r=T2[12+(M+(X<<4)|0)>>2]))?1:0-r|0,(0|(g=-1<(0|(r=T2[12+(M+(F<<4)|0)>>2]))?1:0-r|0))<=128){if((0|(v=r=T2[f+152>>2]))==T2[f+156>>2]&&!((0|(Z=(v=r)?v<<1:1))<=(0|v))){if(y=0,Z&&(T2[5498]=T2[5498]+1,(e=K2(Z<<5|19))&&(T2[(y=e+19&-16)-4>>2]=e)),1<=(0|r))for(v=0,w=r;p=T2[f+160>>2]+v|0,e=T2[(E=p)+4>>2],T2[(Q=R=v+y|0)>>2]=T2[E>>2],T2[Q+4>>2]=e,e=T2[4+(Q=E+24|0)>>2],T2[(d=R+24|0)>>2]=T2[Q>>2],T2[d+4>>2]=e,e=T2[4+(Q=E+16|0)>>2],T2[(d=R+16|0)>>2]=T2[Q>>2],T2[d+4>>2]=e,e=T2[4+(Q=E+8|0)>>2],T2[(d=R+8|0)>>2]=T2[Q>>2],T2[d+4>>2]=e,v=v+32|0,w=w-1|0;);(e=T2[f+160>>2])&&S2[f+164|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[f+160>>2]=y,T2[f+156>>2]=Z,p2[f+164|0]=1,v=T2[f+152>>2];}T2[f+152>>2]=v+1,d=(w=r<<5)+T2[(Q=f+160|0)>>2]|0,r=T2[36+C>>2],T2[d>>2]=T2[32+C>>2],T2[d+4>>2]=r,r=T2[4+(e=56+C|0)>>2],T2[(v=d+24|0)>>2]=T2[e>>2],T2[v+4>>2]=r,r=T2[4+(e=48+C|0)>>2],T2[(v=d+16|0)>>2]=T2[e>>2],T2[v+4>>2]=r,r=T2[4+(e=40+C|0)>>2],T2[(v=d+8|0)>>2]=T2[e>>2],T2[v+4>>2]=r,e=w+T2[Q>>2]|0,$[e>>1]=A2[(r=M+(F<<4)|0)>>1],$[e+2>>1]=A2[r+2>>1],$[e+4>>1]=A2[r+4>>1],$[e+6>>1]=A2[r+6>>1],$[e+8>>1]=A2[r+8>>1],T2[e+16>>2]=g,T2[e+12>>2]=F,$[e+10>>1]=A2[r+10>>1];}if((0|I)<=128){if((0|(v=r=T2[f+152>>2]))==T2[f+156>>2]&&!((0|(F=(v=r)?v<<1:1))<=(0|v))){if(Q=0,F&&(T2[5498]=T2[5498]+1,(e=K2(F<<5|19))&&(T2[(Q=e+19&-16)-4>>2]=e)),1<=(0|r))for(v=0,w=r;p=T2[f+160>>2]+v|0,e=T2[(E=p)+4>>2],T2[(d=R=v+Q|0)>>2]=T2[E>>2],T2[d+4>>2]=e,e=T2[4+(d=E+24|0)>>2],T2[(g=R+24|0)>>2]=T2[d>>2],T2[g+4>>2]=e,e=T2[4+(d=E+16|0)>>2],T2[(g=R+16|0)>>2]=T2[d>>2],T2[g+4>>2]=e,e=T2[4+(d=E+8|0)>>2],T2[(g=R+8|0)>>2]=T2[d>>2],T2[g+4>>2]=e,v=v+32|0,w=w-1|0;);(e=T2[f+160>>2])&&S2[f+164|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[f+160>>2]=Q,T2[f+156>>2]=F,p2[f+164|0]=1,v=T2[f+152>>2];}T2[f+152>>2]=v+1,d=(w=r<<5)+T2[(Q=f+160|0)>>2]|0,r=T2[36+C>>2],T2[d>>2]=T2[32+C>>2],T2[d+4>>2]=r,r=T2[4+(e=56+C|0)>>2],T2[(v=d+24|0)>>2]=T2[e>>2],T2[v+4>>2]=r,r=T2[4+(e=48+C|0)>>2],T2[(v=d+16|0)>>2]=T2[e>>2],T2[v+4>>2]=r,r=T2[4+(e=40+C|0)>>2],T2[(v=d+8|0)>>2]=T2[e>>2],T2[v+4>>2]=r,e=w+T2[Q>>2]|0,$[e>>1]=A2[(r=M+(X<<4)|0)>>1],$[e+2>>1]=A2[r+2>>1],$[e+4>>1]=A2[r+4>>1],$[e+6>>1]=A2[r+6>>1],$[e+8>>1]=A2[r+8>>1],T2[e+16>>2]=I,T2[e+12>>2]=X,$[e+10>>1]=A2[r+10>>1];}T2[f+168>>2]=T2[f+152>>2],v=S2[f+60|0];}255&v?T2[12+(T2[f+136>>2]+(G<<4)|0)>>2]=0-U:T2[32+(T2[f+96>>2]+(G<<6)|0)>>2]=U;}else S2[f+60|0]?(r=T2[f+116>>2]+(r<<4)|0,v=T2[r+4>>2],e=T2[f+136>>2]+(p<<4)|0,T2[e>>2]=T2[r>>2],T2[e+4>>2]=v):(r=T2[f+76>>2]+(r<<6)|0,v=T2[(d=r)+4>>2],e=T2[f+96>>2]+(p<<6)|0,T2[e>>2]=T2[d>>2],T2[e+4>>2]=v,v=T2[4+(w=d+56|0)>>2],T2[(Q=e+56|0)>>2]=T2[w>>2],T2[Q+4>>2]=v,v=T2[4+(w=d+48|0)>>2],T2[(Q=e+48|0)>>2]=T2[w>>2],T2[Q+4>>2]=v,v=T2[4+(w=d+40|0)>>2],T2[(Q=e+40|0)>>2]=T2[w>>2],T2[Q+4>>2]=v,v=T2[4+(w=d+32|0)>>2],T2[(Q=e+32|0)>>2]=T2[w>>2],T2[Q+4>>2]=v,v=T2[4+(w=d+24|0)>>2],T2[(Q=e+24|0)>>2]=T2[w>>2],T2[Q+4>>2]=v,v=T2[4+(w=d+16|0)>>2],T2[(Q=e+16|0)>>2]=T2[w>>2],T2[Q+4>>2]=v),v=e+8|0,r=T2[4+(e=r+8|0)>>2],T2[v>>2]=T2[e>>2],T2[v+4>>2]=r,T2[f+56>>2]=T2[f+56>>2]+1;L2=112+C|0;})(A,T2[A+56>>2]=0,w),S2[A+60|0]&&(T2[A+152>>2]||(T2[A+156>>2]?(r=T2[A+160>>2],f=1):(r=0,T2[5498]=T2[5498]+(f=1),(e=K2(51))&&(T2[(r=e+19&-16)-4>>2]=e),(e=T2[A+160>>2])&&S2[A+164|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]),f=T2[A+152>>2]+1|0),T2[A+160>>2]=r,T2[A+156>>2]=1,p2[A+164|0]=1),T2[A+152>>2]=f,f=T2[12+c>>2],T2[r>>2]=T2[8+c>>2],T2[r+4>>2]=f,i=T2[(e=32+c|0)+4>>2],T2[(f=r+24|0)>>2]=T2[e>>2],T2[f+4>>2]=i,i=T2[(e=24+c|0)+4>>2],T2[(f=r+16|0)>>2]=T2[e>>2],T2[f+4>>2]=i,f=r+8|0,e=T2[(r=16+c|0)+4>>2],T2[f>>2]=T2[r>>2],T2[f+4>>2]=e,f=T2[A+160>>2],r=T2[A+136>>2],$[f>>1]=A2[r>>1],$[f+2>>1]=A2[r+2>>1],$[f+4>>1]=A2[r+4>>1],$[f+6>>1]=A2[r+6>>1],$[f+8>>1]=A2[r+8>>1],T2[f+12>>2]=0,e=T2[r+12>>2],T2[f+16>>2]=-1<(0|e)?1:0-e|0,$[f+10>>1]=A2[r+10>>1])),T2[A+168>>2]=T2[A+152>>2],(f=T2[A+116>>2])&&S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+116>>2]=0,p2[A+120|0]=1,T2[(f=A+108|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+76>>2])&&S2[A+80|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+76>>2]=0,p2[A+80|0]=1,T2[(A=A+68|0)>>2]=0,T2[A+4>>2]=0,L2=112+c|0;}function C0(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b=0,t=0,c=z2(0),u=z2(0),k=z2(0),l=0,s=z2(0);L2=t=L2-80|0,l=T2[A+4>>2],n1[T2[T2[l>>2]+16>>2]](l,28+t|0,24+t|0,20+t|0,16+t|0,12+t|0,8+t|0,4+t|0,t,f),l=(e=T2[A+4>>2])+12|0,i=T2[12+t>>2]+P2(T2[8+t>>2],r)|0,a=T2[16+t>>2],n=T2[28+t>>2],o=T2[20+t>>2];A:{f:{r:{e:{i:{a:{n:{if(3!=T2[t>>2]){if(b=P2(T2[8+i>>2],a)+n|0,o)break n;k=z2(j2[b+4>>2]*j2[e+8>>2]),u=z2(j2[b>>2]*j2[e+4>>2]),c=j2[e+12>>2],b=b+8|0;break a;}if(b=P2(A2[4+i>>1],a)+n|0,b=o?(k=z2(j2[e+8>>2]*z2(X[b+8>>3])),u=z2(j2[e+4>>2]*z2(X[b>>3])),c=z2(X[b+16>>3]),l):(k=z2(j2[b+4>>2]*j2[e+8>>2]),u=z2(j2[b>>2]*j2[e+4>>2]),c=j2[e+12>>2],b+8|0),s=j2[b>>2],T2[76+t>>2]=0,j2[68+t>>2]=k,j2[72+t>>2]=s*c,j2[64+t>>2]=u,b=P2(A2[2+i>>1],a)+n|0,!o)break i;k=z2(j2[e+8>>2]*z2(X[b+8>>3])),u=z2(j2[e+4>>2]*z2(X[b>>3])),c=z2(X[b+16>>3]),b=l;break e;}k=z2(j2[e+8>>2]*z2(X[b+8>>3])),u=z2(j2[e+4>>2]*z2(X[b>>3])),c=z2(X[b+16>>3]),b=l;}if(s=j2[b>>2],T2[76+t>>2]=0,j2[68+t>>2]=k,j2[72+t>>2]=s*c,j2[64+t>>2]=u,b=P2(T2[4+i>>2],a)+n|0,!o)break r;k=z2(j2[e+8>>2]*z2(X[b+8>>3])),u=z2(j2[e+4>>2]*z2(X[b>>3])),c=z2(X[b+16>>3]),b=l;break f;}k=z2(j2[b+4>>2]*j2[e+8>>2]),u=z2(j2[b>>2]*j2[e+4>>2]),c=j2[e+12>>2],b=b+8|0;}s=j2[b>>2],T2[60+t>>2]=0,j2[52+t>>2]=k,j2[56+t>>2]=s*c,j2[48+t>>2]=u,b=P2(A2[i>>1],a)+n|0,c=o?(k=z2(j2[e+8>>2]*z2(X[b+8>>3])),u=z2(j2[e+4>>2]*z2(X[b>>3])),z2(X[b+16>>3])):(l=b+8|0,k=z2(j2[b+4>>2]*j2[e+8>>2]),u=z2(j2[b>>2]*j2[e+4>>2]),j2[e+12>>2]),s=j2[l>>2],j2[32+t>>2]=u,c=z2(s*c);break A;}k=z2(j2[b+4>>2]*j2[e+8>>2]),u=z2(j2[b>>2]*j2[e+4>>2]),c=j2[e+12>>2],b=b+8|0;}s=j2[b>>2],T2[60+t>>2]=0,j2[52+t>>2]=k,j2[56+t>>2]=s*c,j2[48+t>>2]=u,b=P2(T2[i>>2],a)+n|0,c=o?(k=z2(j2[e+8>>2]*z2(X[b+8>>3])),u=z2(j2[e+4>>2]*z2(X[b>>3])),z2(X[b+16>>3])):(l=b+8|0,k=z2(j2[b+4>>2]*j2[e+8>>2]),u=z2(j2[b>>2]*j2[e+4>>2]),j2[e+12>>2]),s=j2[l>>2],j2[32+t>>2]=u,c=z2(s*c);}T2[44+t>>2]=0,j2[40+t>>2]=c,j2[36+t>>2]=k,l=T2[A+8>>2],n1[T2[T2[l>>2]+8>>2]](l,32+t|0,f,r),A=T2[A+4>>2],n1[T2[T2[A>>2]+24>>2]](A,f),L2=80+t|0;}function E0(A,f,r,e){}function D0(A,f,r){return 0;}function h0(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a=z2(n1[T2[T2[A>>2]+48>>2]](A)),n=z2(n1[T2[T2[A>>2]+48>>2]](A)),o=z2(n1[T2[T2[A>>2]+48>>2]](A)),b=j2[(A=f+52|0)>>2],t=j2[(i=f+56|0)>>2],c=j2[f+48>>2];T2[r+12>>2]=0,j2[r+8>>2]=t-o,j2[r+4>>2]=b-n,j2[r>>2]=c-a,b=j2[A>>2],t=j2[i>>2],c=j2[f+48>>2],T2[e+12>>2]=0,j2[e+8>>2]=o+t,j2[e+4>>2]=n+b,j2[e>>2]=a+c;}function Z0(A){return T2[(A|=0)+16>>2];}function Y0(A){return T2[(A|=0)+8>>2];}function R0(A,f,r,e){n1[T2[T2[(A|=0)>>2]+8>>2]](A,f|=0,r|=0,e|=0);}function F0(A,f){n1[T2[T2[(A|=0)>>2]+64>>2]](A,f|=0);}function W0(A,f){var r,e,i,a=z2(0),n=z2(0),o=0,b=z2(0),t=z2(0),c=z2(0),u=0,k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=z2(0),B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=z2(0),C=z2(0),E=z2(0);A:{f:{r:{e:{i:{if(4==(0|(o=T2[A+844>>2]))){if(c=j2[f>>2],u=(o=(a=j2[A+84>>2])<(b=j2[f+80>>2]))?0:-1,e=(o=(n=j2[A+292>>2])<(a=o?a:b))?1:u,b=j2[A+500>>2],!(o=(u=j2[A+708>>2]<((o=b<(a=o?n:a))?b:a))?3:o?2:e)){k=j2[A+636>>2],g=j2[A+428>>2],n=z2(k-g),s=j2[A+632>>2],w=j2[A+424>>2],t=z2(s-w),G=j2[A+628>>2],C=j2[A+420>>2],l=z2(G-C),E=j2[A+220>>2],v=j2[A+216>>2],d=j2[A+212>>2],a=j2[f+8>>2],b=j2[f+4>>2];break i;}if(d=j2[A+212>>2],B=z2(c-d),s=j2[A+632>>2],w=j2[A+424>>2],t=z2(s-w),b=j2[f+4>>2],v=j2[A+216>>2],a=z2(b-v),G=j2[A+628>>2],C=j2[A+420>>2],l=z2(G-C),n=z2(z2(B*t)-z2(a*l)),i=z2(n*n),k=j2[A+636>>2],g=j2[A+428>>2],n=z2(k-g),r=z2(a*n),a=j2[f+8>>2],E=j2[A+220>>2],Q=z2(a-E),r=z2(r-z2(Q*t)),B=z2(z2(Q*l)-z2(B*n)),B=z2(i+z2(z2(r*r)+z2(B*B))),1!=(0|o))break i;c=z2(c-j2[A+4>>2]),a=z2(a-j2[A+12>>2]),b=z2(b-j2[A+8>>2]),l=z2(0);break e;}T2[A+844>>2]=o+1;break A;}if(c=z2(c-j2[A+4>>2]),b=z2(b-j2[A+8>>2]),Q=z2(z2(c*t)-z2(b*l)),a=z2(a-j2[A+12>>2]),t=z2(z2(b*n)-z2(a*t)),n=z2(z2(a*l)-z2(c*n)),l=z2(z2(Q*Q)+z2(z2(t*t)+z2(n*n))),n=z2(0),2==(0|o))break r;}if(n=z2(s-v),t=z2(G-d),s=z2(z2(c*n)-z2(b*t)),k=z2(k-E),n=z2(z2(b*k)-z2(a*n)),Q=z2(n*n),n=z2(z2(a*t)-z2(c*k)),n=z2(z2(s*s)+z2(Q+z2(n*n))),t=z2(0),u)break f;}t=z2(w-v),v=z2(C-d),d=z2(z2(c*t)-z2(b*v)),k=b,b=z2(g-E),t=z2(z2(k*b)-z2(a*t)),a=z2(z2(a*v)-z2(c*b)),t=z2(z2(d*d)+z2(z2(t*t)+z2(a*a)));}u=(o=(a=z2(O2(B)))>z2(-0xde0b6b000000000))?0:-1,b=z2(O2(l)),u=(o=(a=o?a:z2(-0xde0b6b000000000))<b)?1:u,o=(a=o?b:a)<(n=z2(O2(n))),o=z2(O2(t))>(o?n:a)?3:o?2:u;}return $2(4+((u=A)+P2(A=0<(0|o)?o:0,208)|0)|0,f,208),A;}function m0(A,f,r){var e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q=0,g=z2(0),w=z2(0),G=z2(0),C=0,E=0,D=(z2(0));if(1<=(0|(C=T2[A+844>>2]))){for(E=C+1|0,Q=(P2(C,208)+A|0)-204|0;a=j2[f+48>>2],b=j2[f+8>>2],t=j2[f+4>>2],c=j2[f>>2],n=j2[f+52>>2],u=j2[f+24>>2],e=j2[f+20>>2],k=j2[f+16>>2],g=j2[f+56>>2],w=j2[f+40>>2],G=j2[f+36>>2],o=j2[f+32>>2],T2[Q+60>>2]=0,D=g,g=j2[Q>>2],l=G,G=j2[Q+4>>2],i=w,w=j2[Q+8>>2],o=z2(D+z2(z2(z2(o*g)+z2(l*G))+z2(i*w))),j2[Q+56>>2]=o,n=z2(n+z2(z2(z2(g*k)+z2(G*e))+z2(w*u))),j2[Q+52>>2]=n,a=z2(a+z2(z2(z2(g*c)+z2(G*t))+z2(w*b))),j2[Q+48>>2]=a,b=j2[r+56>>2],t=j2[r+40>>2],c=j2[r+32>>2],u=j2[r+36>>2],e=j2[r+52>>2],k=j2[r+24>>2],v=j2[r+16>>2],d=j2[r+20>>2],g=j2[r+48>>2],w=j2[r+8>>2],G=j2[r>>2],i=j2[r+4>>2],T2[Q+44>>2]=0,D=g,g=j2[Q+16>>2],B=z2(G*g),G=j2[Q+20>>2],l=w,w=j2[Q+24>>2],i=z2(D+z2(z2(B+z2(i*G))+z2(l*w))),j2[Q+32>>2]=i,e=z2(e+z2(z2(z2(g*v)+z2(G*d))+z2(w*k))),j2[Q+36>>2]=e,g=z2(b+z2(z2(z2(g*c)+z2(G*u))+z2(w*t))),j2[Q+40>>2]=g,j2[Q+80>>2]=z2(z2(z2(a-i)*j2[Q- -64>>2])+z2(z2(n-e)*j2[Q+68>>2]))+z2(z2(o-g)*j2[Q+72>>2]),T2[(s=Q+164|0)>>2]=T2[s>>2]+1,Q=Q-208|0,1<(0|(E=E-1|0)););for(Q=(P2(C,208)+A|0)-204|0;C=(f=C)-1|0,(g=j2[Q+80>>2])<=(G=j2[A+848>>2])?(w=z2(j2[Q+32>>2]-z2(j2[Q+48>>2]-z2(j2[Q- -64>>2]*g))),D=z2(w*w),w=z2(j2[Q+36>>2]-z2(j2[Q+52>>2]-z2(g*j2[Q+68>>2]))),g=z2(j2[Q+40>>2]-z2(j2[Q+56>>2]-z2(g*j2[Q+72>>2]))),z2(z2(D+z2(w*w))+z2(g*g))>z2(G*G)&&(f=(0|(r=f))!=(0|(f=T2[(E=A)+844>>2]))?($2(Q,(f=P2(f-1|0,208)+A|0)+4|0,208),T2[f+168>>2]=0,T2[f+120>>2]=0,T2[(r=f+132|0)>>2]=0,T2[r+4>>2]=0,T2[(f=f+140|0)>>2]=0,T2[f+4>>2]=0,T2[A+844>>2]-1|0):C,T2[E+844>>2]=f)):(f=(0|(r=f))!=(0|(f=T2[(E=A)+844>>2]))?($2(Q,(f=P2(f-1|0,208)+A|0)+4|0,208),T2[f+168>>2]=0,T2[f+120>>2]=0,T2[(r=f+132|0)>>2]=0,T2[r+4>>2]=0,T2[(f=f+140|0)>>2]=0,T2[f+4>>2]=0,T2[A+844>>2]-1|0):C,T2[E+844>>2]=f),Q=Q-208|0,1<(C+1|0););}}function N0(A){var f,r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g=0,w=0,G=0,C=0,E=z2(0),D=z2(0),h=0,Z=0,Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=z2(0),N=z2(0),V=0,J=0,M=0,I=0,x=0,y=z2(0),U=z2(0),X=0,p=z2(0),T=z2(0),S=0,j=0,P=z2(0),z=(z2(0)),O=z2(0),H=0,_=z2(0),L=(z2(0));L2=h=L2+-64|0;A:if(S2[A+356|0]){p2[A+356|0]=0,p2[0|(Z=A+352|0)]=0,T2[(w=I=A+344|0)>>2]=0,T2[w+4>>2]=0,T2[(w=H=A+336|0)>>2]=0,T2[w+4>>2]=0,w=S2[0|(g=A+332|0)],p2[0|g]=M=-16&w,g=A+316|0;f:{r:{e:switch(T2[A>>2]){case 1:G=T2[A+168>>2],T2[A+260>>2]=T2[A+164>>2],T2[A+264>>2]=G,G=T2[A+88>>2],T2[A+244>>2]=T2[A+84>>2],T2[A+248>>2]=G,G=T2[(w=A+172|0)+4>>2],T2[(g=C=A+268|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=A+92|0)+4>>2],T2[(g=A+252|0)>>2]=T2[w>>2],T2[g+4>>2]=G,p2[0|Z]=0,T2[A+288>>2]=0,j2[A+280>>2]=j2[A+248>>2]-j2[A+264>>2],j2[A+276>>2]=j2[A+244>>2]-j2[A+260>>2],j2[A+284>>2]=j2[g>>2]-j2[C>>2],T2[I>>2]=0,T2[I+4>>2]=0,T2[A+336>>2]=1065353216,T2[A+340>>2]=0,p2[A+332|0]=M,p2[A+312|0]=G=1;break A;case 2:R=j2[(C=A)+4>>2],W=z2(j2[A+20>>2]-R),Y=j2[A+8>>2],m=z2(j2[A+24>>2]-Y),E=j2[A+12>>2],F=z2(j2[A+28>>2]-E),G=(E=z2(z2(z2(z2(z2(0)-R)*W)+z2(z2(z2(0)-Y)*m))+z2(z2(z2(0)-E)*F)))>z2(0)?E<(D=z2(z2(z2(W*W)+z2(m*m))+z2(F*F)))?(D=z2(E/D),3|M):(D=z2(1),2|M):1|M,p2[C+332|0]=G,T2[(w=A+344|0)>>2]=0,T2[w+4>>2]=0,j2[A+340>>2]=D,N=z2(z2(1)-D),j2[A+336>>2]=N,T2[A+256>>2]=0,E=j2[A+92>>2],R=z2(E+z2(D*z2(j2[A+108>>2]-E))),j2[A+252>>2]=R,E=j2[A+88>>2],W=z2(E+z2(D*z2(j2[A+104>>2]-E))),j2[A+248>>2]=W,E=j2[A+84>>2],m=z2(E+z2(D*z2(j2[A+100>>2]-E))),j2[A+244>>2]=m,F=j2[A+180>>2],Y=j2[A+184>>2],z=j2[A+168>>2],E=j2[A+188>>2],O=j2[A+172>>2],y=j2[A+164>>2],T2[A+288>>2]=0,U=R,R=z2(O+z2(D*z2(E-O))),j2[A+284>>2]=U-R,Y=z2(z+z2(D*z2(Y-z))),j2[A+280>>2]=W-Y,E=z2(y+z2(D*z2(F-y))),j2[A+276>>2]=m-E,T2[A+272>>2]=0,j2[A+268>>2]=R,j2[A+264>>2]=Y,j2[A+260>>2]=E,J=1,2&G||(T2[A>>2]=1,J=0),1&G||(T2[A>>2]=J,M=T2[(G=(x=(J<<4)+A|0)+12|0)>>2],I=T2[G+4>>2],H=T2[(G=x+4|0)>>2],Z=T2[G+4>>2],G=T2[(w=x+84|0)+4>>2],T2[(g=C=A+84|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=x+92|0)+4>>2],T2[(g=g+8|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=x+164|0)+4>>2],T2[(g=C=A+164|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=x+172|0)+4>>2],T2[(g=g+8|0)>>2]=T2[w>>2],T2[g+4>>2]=G,T2[(G=A+4|0)>>2]=H,T2[G+4>>2]=Z,T2[(G=G+8|0)>>2]=M,T2[G+4>>2]=I),G=N>=z2(0)&D>=z2(0),p2[A+312|0]=G;break A;case 3:T2[(G=32+h|0)>>2]=0,T2[G+4>>2]=0,T2[24+h>>2]=0,V0(24+h|(T2[28+h>>2]=0),X=A+4|0,S=A+20|0,j=A+36|0,g),T2[A+256>>2]=0,P=j2[A+336>>2],p=j2[A+340>>2],T=j2[I>>2],_=z2(z2(z2(P*j2[A+92>>2])+z2(p*j2[A+108>>2]))+z2(T*j2[A+124>>2])),j2[A+252>>2]=_,z=z2(z2(z2(P*j2[A+88>>2])+z2(p*j2[A+104>>2]))+z2(T*j2[A+120>>2])),j2[A+248>>2]=z,x=A+100|0,M=A+116|0,O=z2(z2(z2(P*j2[A+84>>2])+z2(p*j2[x>>2]))+z2(T*j2[M>>2])),j2[A+244>>2]=O,y=j2[(I=A+180|0)>>2],N=j2[(Z=A+196|0)>>2],W=j2[A+168>>2],m=j2[A+184>>2],F=j2[A+200>>2],R=j2[A+172>>2],Y=j2[A+188>>2],E=j2[A+204>>2],D=j2[A+164>>2],T2[A+288>>2]=0,Y=z2(z2(z2(P*R)+z2(p*Y))+z2(T*E)),j2[A+284>>2]=_-Y,E=z2(z2(z2(P*W)+z2(p*m))+z2(T*F)),j2[A+280>>2]=z-E,D=z2(z2(z2(P*D)+z2(p*y))+z2(T*N)),j2[A+276>>2]=O-D,T2[A+272>>2]=0,j2[A+268>>2]=Y,j2[A+264>>2]=E,j2[A+260>>2]=D;i:{a:{n:{o:{b:{if(4<=(0|(w=T2[A>>2])))8&(J=S2[A+332|0])?G=w:(w=T2[(g=(V=((G=w-1|0)<<4)+A|0)+12|0)+4>>2],T2[(C=A+60|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=V+4|0)+4>>2],T2[(C=A+52|0)>>2]=T2[g>>2],T2[C+4>>2]=w,T2[A>>2]=G,w=T2[(g=V+84|0)+4>>2],T2[(C=A+132|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=V+92|0)+4>>2],T2[(C=A+140|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=V+164|0)+4>>2],T2[(C=A+212|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=V+172|0)+4>>2],T2[(C=A+220|0)>>2]=T2[g>>2],T2[C+4>>2]=w);else {if((G=3)!=(0|w))break b;J=S2[A+332|0];}if(4&J)break o;T2[A>>2]=G=G-1|0,w=T2[(g=(V=(G<<4)+A|0)+12|0)+4>>2],T2[(C=j+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=V+4|0)+4>>2],T2[j>>2]=T2[g>>2],T2[j+4>>2]=w,w=T2[(g=V+92|0)+4>>2],T2[(C=M+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=V+84|0)+4>>2],T2[M>>2]=T2[g>>2],T2[M+4>>2]=w,w=T2[(g=V+164|0)+4>>2],T2[Z>>2]=T2[g>>2],T2[Z+4>>2]=w,w=T2[(g=V+172|0)+4>>2],T2[(C=Z+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w;break o;}if((0|w)<(G=2))break n;J=S2[A+332|0];}if(2&J)break a;T2[A>>2]=G=G-1|0,w=T2[(g=(Z=(G<<4)+A|0)+12|0)+4>>2],T2[(C=S+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=Z+4|0)+4>>2],T2[S>>2]=T2[g>>2],T2[S+4>>2]=w,w=T2[(g=Z+92|0)+4>>2],T2[(C=x+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=Z+84|0)+4>>2],T2[x>>2]=T2[g>>2],T2[x+4>>2]=w,w=T2[(g=Z+164|0)+4>>2],T2[I>>2]=T2[g>>2],T2[I+4>>2]=w,w=T2[(g=Z+172|0)+4>>2],T2[(C=I+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w;break a;}if((G=1)!=(0|w))break i;J=S2[A+332|0];}1&J||(T2[A>>2]=G=G-1|0,G=T2[(w=(Z=(G<<4)+A|0)+12|0)+4>>2],T2[(g=X+8|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=Z+4|0)+4>>2],T2[X>>2]=T2[w>>2],T2[X+4>>2]=G,G=T2[(w=Z+92|0)+4>>2],T2[(g=(C=A+84|0)+8|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=Z+84|0)+4>>2],T2[C>>2]=T2[w>>2],T2[C+4>>2]=G,G=T2[(w=Z+164|0)+4>>2],T2[(g=C=A+164|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=Z+172|0)+4>>2],T2[(g=g+8|0)>>2]=T2[w>>2],T2[g+4>>2]=G);}if(!(j2[H>>2]>=z2(G=0)))break f;if(!(p>=z2(0)))break f;if(!(T>=z2(0)))break f;G=j2[A+348>>2]>=z2(0),p2[A+312|0]=G;break A;case 0:break f;case 4:break e;default:break r;}if(T2[(G=16+h|0)>>2]=0,T2[G+4>>2]=0,T2[8+h>>2]=0,T2[12+h>>2]=0,T2[g>>2]=0,T2[g+4>>2]=0,T2[(G=g+8|0)>>2]=0,T2[G+4>>2]=0,p2[A+332|0]=15|w,p2[40+h|0]=0,a=j2[A+12>>2],d=z2(z2(0)-a),n=j2[A+28>>2],o=z2(n-a),F=j2[(r=A+36|0)>>2],b=j2[A+4>>2],t=z2(F-b),R=j2[A+56>>2],c=j2[A+8>>2],N=z2(R-c),E=j2[A+40>>2],u=z2(E-c),D=j2[(e=A+52|0)>>2],k=z2(D-b),L=z2(z2(t*N)-z2(u*k)),l=j2[(i=A+20|0)>>2],s=z2(l-b),p=j2[A+60>>2],f=z2(p-a),Y=j2[A+44>>2],W=z2(Y-a),T=z2(z2(u*f)-z2(W*N)),v=j2[A+24>>2],m=z2(v-c),P=z2(z2(W*k)-z2(t*f)),B=z2(z2(o*L)+z2(z2(s*T)+z2(m*P))),_=z2(z2(m*W)-z2(o*u)),z=z2(z2(o*t)-z2(s*W)),O=z2(z2(s*u)-z2(m*t)),Q=z2(z2(z2(_*k)+z2(z*N))+z2(O*f)),y=z2(z2(m*k)-z2(s*N)),U=z2(W*y),N=z2(z2(o*N)-z2(m*f)),W=z2(z2(s*f)-z2(o*k)),f=z2(U+z2(z2(t*N)+z2(u*W))),E=z2(E-v),m=z2(D-l),F=z2(F-l),D=z2(R-v),R=z2(z2(E*m)-z2(F*D)),Y=z2(Y-n),U=z2(Y*D),D=z2(p-n),E=z2(U-z2(E*D)),D=z2(z2(F*D)-z2(Y*m)),m=z2(z2(z2(a-n)*R)+z2(z2(z2(b-l)*E)+z2(z2(c-v)*D))),C=z2(m*m)<z2(9.99999905104687e-9)?-1:z2(z2(z2(z2(z2(0)-n)*R)+z2(z2(z2(z2(0)-l)*E)+z2(z2(z2(0)-v)*D)))*m)<z2(0),F=z2(z2(0)-b),Y=z2(z2(0)-c),(0|(G=C|(g=z2(B*B)<z2(9.99999905104687e-9)?-1:z2(z2(z2(d*L)+z2(z2(F*T)+z2(Y*P)))*B)<z2(0))|(w=z2(Q*Q)<z2(9.99999905104687e-9)?-1:z2(z2(z2(z2(F*_)+z2(Y*z))+z2(O*d))*Q)<z2(0))|(Z=z2(f*f)<z2(9.99999905104687e-9)?-1:z2(z2(z2(d*y)+z2(z2(F*N)+z2(Y*W)))*f)<z2(0))))<=-1)p2[A+352|0]=1;else {if(G){V=A+4|0,D=z2(34028234663852886e22),w&&(V0(8+h|0,V,i,r,24+h|0),F=j2[24+h>>2],E=z2(F-j2[8+h>>2]),D=z2(E*E),R=j2[28+h>>2],E=z2(R-j2[12+h>>2]),D=z2(D+z2(E*E)),Y=j2[32+h>>2],E=z2(Y-j2[16+h>>2]),E=z2(D+z2(E*E)),D=z2(34028234663852886e22),E<z2(34028234663852886e22)&&(j2[A+316>>2]=F,G=T2[48+h>>2],T2[A+336>>2]=T2[44+h>>2],T2[A+340>>2]=G,j2[A+328>>2]=j2[36+h>>2],j2[A+324>>2]=Y,j2[A+320>>2]=R,T2[A+348>>2]=0,j2[A+344>>2]=j2[52+h>>2],G=S2[40+h|0],p2[A+332|0]=1&G|240&S2[A+332|0]|2&G|4&G,D=E)),g&&(V0(8+h|0,V,r,e,24+h|0),F=j2[24+h>>2],E=z2(F-j2[8+h>>2]),U=z2(E*E),R=j2[28+h>>2],E=z2(R-j2[12+h>>2]),U=z2(U+z2(E*E)),Y=j2[32+h>>2],E=z2(Y-j2[16+h>>2]),(E=z2(U+z2(E*E)))<D&&(j2[A+316>>2]=F,j2[A+336>>2]=j2[44+h>>2],j2[A+328>>2]=j2[36+h>>2],j2[A+324>>2]=Y,j2[A+320>>2]=R,T2[A+340>>2]=0,G=T2[(w=48+h|0)+4>>2],T2[(g=A+344|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=S2[40+h|0],p2[A+332|0]=8&(w=G<<1)|(4&w|(1&G|240&S2[A+332|0])),D=E)),Z&&(V0(8+h|0,V,e,i,24+h|0),F=j2[24+h>>2],E=z2(F-j2[8+h>>2]),U=z2(E*E),R=j2[28+h>>2],E=z2(R-j2[12+h>>2]),U=z2(U+z2(E*E)),Y=j2[32+h>>2],E=z2(Y-j2[16+h>>2]),(E=z2(U+z2(E*E)))<D&&(j2[A+316>>2]=F,j2[A+336>>2]=j2[44+h>>2],j2[A+328>>2]=j2[36+h>>2],j2[A+324>>2]=Y,j2[A+320>>2]=R,T2[A+344>>2]=0,j2[A+348>>2]=j2[48+h>>2],j2[A+340>>2]=j2[52+h>>2],G=S2[40+h|0],p2[A+332|0]=1&G|240&S2[A+332|0]|G>>>1&2|G<<2&8,D=E)),C&&(V0(8+h|0,i,e,r,24+h|0),U=D,R=j2[24+h>>2],D=z2(R-j2[8+h>>2]),E=z2(D*D),Y=j2[28+h>>2],D=z2(Y-j2[12+h>>2]),L=z2(E+z2(D*D)),E=j2[32+h>>2],D=z2(E-j2[16+h>>2]),U>z2(L+z2(D*D))&&(j2[A+316>>2]=R,T2[A+336>>2]=0,j2[A+328>>2]=j2[36+h>>2],j2[A+324>>2]=E,j2[A+320>>2]=Y,j2[A+340>>2]=j2[44+h>>2],j2[A+348>>2]=j2[48+h>>2],j2[A+344>>2]=j2[52+h>>2],G=S2[40+h|0],p2[A+332|0]=4&G|240&S2[A+332|0]|G<<1&2|G<<2&8)),T2[A+256>>2]=0,N=j2[A+336>>2],W=j2[A+340>>2],D=j2[A+344>>2],y=j2[A+348>>2],m=z2(z2(z2(z2(N*j2[A+92>>2])+z2(W*j2[A+108>>2]))+z2(D*j2[A+124>>2]))+z2(y*j2[A+140>>2])),j2[A+252>>2]=m,F=z2(z2(z2(z2(N*j2[A+88>>2])+z2(W*j2[A+104>>2]))+z2(D*j2[A+120>>2]))+z2(y*j2[A+136>>2])),j2[A+248>>2]=F,S=A+100|0,j=A+116|0,x=A+132|0,R=z2(z2(z2(z2(N*j2[A+84>>2])+z2(W*j2[S>>2]))+z2(D*j2[j>>2]))+z2(y*j2[x>>2])),j2[A+244>>2]=R,T2[A+288>>2]=0,M=A+180|(T2[A+272>>2]=0),I=A+196|0,Z=A+212|0,Y=z2(z2(z2(z2(N*j2[A+164>>2])+z2(W*j2[M>>2]))+z2(D*j2[I>>2]))+z2(y*j2[Z>>2])),j2[A+260>>2]=Y,E=z2(z2(z2(z2(N*j2[A+168>>2])+z2(W*j2[A+184>>2]))+z2(D*j2[A+200>>2]))+z2(y*j2[A+216>>2])),j2[A+264>>2]=E,D=z2(z2(z2(z2(N*j2[A+172>>2])+z2(W*j2[A+188>>2]))+z2(D*j2[A+204>>2]))+z2(y*j2[A+220>>2])),j2[A+268>>2]=D,j2[A+276>>2]=R-Y,j2[A+280>>2]=F-E,j2[A+284>>2]=m-D;e:{i:{a:{n:{o:{if(4<=(0|(w=T2[A>>2])))8&(J=S2[A+332|0])?G=w:(w=T2[(g=(X=((G=w-1|0)<<4)+A|0)+12|0)+4>>2],T2[(C=8+e|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=X+4|0)+4>>2],T2[e>>2]=T2[g>>2],T2[4+e>>2]=w,T2[A>>2]=G,w=T2[(g=X+84|0)+4>>2],T2[x>>2]=T2[g>>2],T2[x+4>>2]=w,w=T2[(g=X+92|0)+4>>2],T2[(C=x+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=X+164|0)+4>>2],T2[Z>>2]=T2[g>>2],T2[Z+4>>2]=w,w=T2[(g=X+172|0)+4>>2],T2[(C=Z+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w);else {if((G=3)!=(0|w))break o;J=S2[A+332|0];}if(4&J)break n;T2[A>>2]=G=G-1|0,w=T2[(g=(Z=(G<<4)+A|0)+12|0)+4>>2],T2[(C=8+r|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=Z+4|0)+4>>2],T2[r>>2]=T2[g>>2],T2[4+r>>2]=w,w=T2[(g=Z+92|0)+4>>2],T2[(C=j+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=Z+84|0)+4>>2],T2[j>>2]=T2[g>>2],T2[j+4>>2]=w,w=T2[(g=Z+164|0)+4>>2],T2[I>>2]=T2[g>>2],T2[I+4>>2]=w,w=T2[(g=Z+172|0)+4>>2],T2[(C=I+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w;break n;}if((0|w)<(G=2))break a;J=S2[A+332|0];}if(2&J)break i;T2[A>>2]=G=G-1|0,w=T2[(g=(Z=(G<<4)+A|0)+12|0)+4>>2],T2[(C=8+i|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=Z+4|0)+4>>2],T2[i>>2]=T2[g>>2],T2[4+i>>2]=w,w=T2[(g=Z+92|0)+4>>2],T2[(C=S+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w,w=T2[(g=Z+84|0)+4>>2],T2[S>>2]=T2[g>>2],T2[S+4>>2]=w,w=T2[(g=Z+164|0)+4>>2],T2[M>>2]=T2[g>>2],T2[M+4>>2]=w,w=T2[(g=Z+172|0)+4>>2],T2[(C=M+8|0)>>2]=T2[g>>2],T2[C+4>>2]=w;break i;}if((G=1)!=(0|w))break e;J=S2[A+332|0];}1&J||(T2[A>>2]=G=G-1|0,G=T2[(w=(Z=(G<<4)+A|0)+12|0)+4>>2],T2[(g=V+8|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=Z+4|0)+4>>2],T2[V>>2]=T2[w>>2],T2[V+4>>2]=G,G=T2[(w=Z+92|0)+4>>2],T2[(g=(C=A+84|0)+8|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=Z+84|0)+4>>2],T2[C>>2]=T2[w>>2],T2[C+4>>2]=G,G=T2[(w=Z+164|0)+4>>2],T2[(g=C=A+164|0)>>2]=T2[w>>2],T2[g+4>>2]=G,G=T2[(w=Z+172|0)+4>>2],T2[(g=g+8|0)>>2]=T2[w>>2],T2[g+4>>2]=G);}if(!(j2[H>>2]>=z2(G=0)))break f;if(!(j2[A+340>>2]>=z2(0)))break f;if(!(j2[A+344>>2]>=z2(0)))break f;G=y>=z2(0),p2[A+312|0]=G;break A;}if(!S2[A+352|0]){T2[A+276>>2]=0,T2[A+280>>2]=0,p2[A+312|0]=G=1,T2[(A=A+284|0)>>2]=0,T2[A+4>>2]=0;break A;}}}G=0;}p2[A+312|0]=0;}else G=S2[A+312|0];return L2=h+64|0,0!=(255&G);}function V0(A,f,r,e,i){var a,n,o,b,t,c,u,k,l,s,v,d,B,Q=z2(0),g=z2(0),w=z2(0),G=z2(0),C=z2(0),E=(z2(0)),D=(z2(0)),h=z2(0),Z=z2(0),Y=z2(0),R=z2(0),F=z2(0),W=(-16&S2[i+16|0]);p2[i+16|0]=W,s=j2[e>>2],n=j2[f>>2],c=z2(s-n),a=j2[A>>2],Q=z2(a-n),v=j2[e+4>>2],o=j2[f+4>>2],u=z2(v-o),G=j2[A+4>>2],g=z2(G-o),d=j2[e+8>>2],b=j2[f+8>>2],k=z2(d-b),t=j2[A+8>>2],w=z2(t-b),C=z2(z2(z2(c*Q)+z2(u*g))+z2(k*w)),B=i,Y=j2[r>>2],D=z2(Y-n),R=j2[r+4>>2],h=z2(R-o),F=j2[r+8>>2],Z=z2(F-b),w=(g=z2(z2(z2(D*Q)+z2(h*g))+z2(Z*w)))<=z2(0)&&C<=z2(0)?(A=T2[f+4>>2],T2[i>>2]=T2[f>>2],T2[i+4>>2]=A,r=T2[(f=f+8|0)+4>>2],T2[(A=i+8|0)>>2]=T2[f>>2],T2[A+4>>2]=r,p2[i+16|0]=1|W,g=z2(0),Q=z2(0),z2(1)):(Q=z2(a-Y),w=z2(G-R),E=z2(t-F),l=z2(z2(z2(c*Q)+z2(u*w))+z2(k*E)),(w=z2(z2(z2(D*Q)+z2(h*w))+z2(Z*E)))>=z2(0)&&l<=w?(A=T2[r+4>>2],T2[i>>2]=T2[r>>2],T2[i+4>>2]=A,r=T2[(f=r+8|0)+4>>2],T2[(A=i+8|0)>>2]=T2[f>>2],T2[A+4>>2]=r,p2[i+16|0]=2|W,g=z2(1),Q=z2(0),z2(0)):(E=z2(z2(g*l)-z2(w*C)),w<=z2(0)&&g>=z2(0)&&(Q=z2(0),E<=z2(0))?(T2[i+12>>2]=0,p2[i+16|0]=3|W,g=z2(g/z2(g-w)),j2[i+8>>2]=b+z2(Z*g),j2[i+4>>2]=o+z2(h*g),j2[i>>2]=n+z2(D*g),z2(z2(1)-g)):(Q=z2(a-s),G=z2(G-v),t=z2(t-d),a=z2(z2(z2(D*Q)+z2(h*G))+z2(Z*t)),(Q=z2(z2(z2(c*Q)+z2(u*G))+z2(k*t)))>=z2(0)&&a<=Q?(A=T2[e+4>>2],T2[i>>2]=T2[e>>2],T2[i+4>>2]=A,r=T2[(f=e+8|0)+4>>2],T2[(A=i+8|0)>>2]=T2[f>>2],T2[A+4>>2]=r,p2[i+16|0]=4|W,Q=z2(1),g=z2(0),z2(0)):(G=z2(z2(a*C)-z2(g*Q)),Q<=z2(0)&&C>=z2(0)&&(g=z2(0),G<=z2(0))?(T2[i+12>>2]=0,p2[i+16|0]=5|W,Q=z2(C/z2(C-Q)),j2[i+8>>2]=b+z2(k*Q),j2[i+4>>2]=o+z2(u*Q),j2[i>>2]=n+z2(c*Q),z2(z2(1)-Q)):(g=z2(z2(w*Q)-z2(a*l)),(C=z2(a-Q))>=z2(0)&&(Q=z2(l-w))>=z2(0)&&g<=z2(0)?(T2[i+12>>2]=0,p2[i+16|0]=6|W,Q=z2(Q/z2(Q+C)),j2[i+8>>2]=F+z2(z2(d-F)*Q),j2[i+4>>2]=R+z2(z2(v-R)*Q),j2[i>>2]=Y+z2(z2(s-Y)*Q),g=z2(z2(1)-Q),z2(0)):(T2[i+12>>2]=0,p2[i+16|0]=7|W,g=z2(z2(1)/z2(E+z2(g+G))),Q=z2(E*g),g=z2(G*g),j2[i+8>>2]=z2(k*Q)+z2(b+z2(Z*g)),j2[i+4>>2]=z2(u*Q)+z2(o+z2(h*g)),j2[i>>2]=z2(c*Q)+z2(n+z2(D*g)),z2(z2(z2(1)-g)-Q))))))),j2[B+20>>2]=w,T2[i+32>>2]=0,j2[i+28>>2]=Q,j2[i+24>>2]=g;}function J0(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I,x,y,U,X=0,p=0,T=z2(0),S=z2(0),j=z2(0),P=z2(0),z=0,O=z2(0),H=z2(0),_=z2(0),L=z2(0),K=z2(0),q=z2(0),$=z2(0),A2=0,f2=z2(0),r2=z2(0),e2=z2(0),i2=z2(0),a2=z2(0),n2=z2(0),o2=0,b2=(0);for(L2=i=L2-208|0,T2[A+56>>2]=0,T2[(X=i+200|0)>>2]=0,T2[X+4>>2]=0,T2[i+192>>2]=0,T2[i+196>>2]=0,a=T2[(p=f+8|0)+4>>2],T2[(X=i+136|0)>>2]=T2[p>>2],T2[X+4>>2]=a,a=T2[(p=f+24|0)+4>>2],T2[(X=i+152|0)>>2]=T2[p>>2],T2[X+4>>2]=a,a=T2[(p=f+40|0)+4>>2],T2[(X=i+168|0)>>2]=T2[p>>2],T2[X+4>>2]=a,z=T2[4+(a=f+56|0)>>2],T2[(X=i+184|0)>>2]=T2[a>>2],T2[X+4>>2]=z,p=T2[f+4>>2],T2[i+128>>2]=T2[f>>2],T2[i+132>>2]=p,p=T2[f+20>>2],T2[i+144>>2]=T2[f+16>>2],T2[i+148>>2]=p,p=T2[f+36>>2],T2[i+160>>2]=T2[f+32>>2],T2[i+164>>2]=p,p=T2[f+52>>2],T2[i+176>>2]=T2[f+48>>2],T2[i+180>>2]=p,A2=T2[(z=f+120|0)+4>>2],T2[(p=i+120|0)>>2]=T2[z>>2],T2[p+4>>2]=A2,A2=T2[(z=f+72|0)+4>>2],T2[(a=i+72|0)>>2]=T2[z>>2],T2[4+a>>2]=A2,A2=T2[(z=f+88|0)+4>>2],T2[(a=i+88|0)>>2]=T2[z>>2],T2[4+a>>2]=A2,A2=T2[(z=f+104|0)+4>>2],T2[(a=i+104|0)>>2]=T2[z>>2],T2[4+a>>2]=A2,a=T2[f+68>>2],T2[i+64>>2]=T2[f+64>>2],T2[i+68>>2]=a,z=T2[4+(a=f+80|0)>>2],T2[i+80>>2]=T2[a>>2],T2[i+84>>2]=z,z=T2[4+(a=f+96|0)>>2],T2[i+96>>2]=T2[a>>2],T2[i+100>>2]=z,z=T2[4+(a=f+112|0)>>2],T2[i+112>>2]=T2[a>>2],T2[i+116>>2]=z,T=j2[(a=i+116|0)>>2],_=j2[(z=i+180|0)>>2],L=j2[i+112>>2],S=j2[i+176>>2],K=j2[X>>2],j=j2[p>>2],n=z2(z2(K+j)*z2(.5)),j2[X>>2]=K-n,o=z2(z2(_+T)*z2(.5)),j2[z>>2]=_-o,b=z2(z2(S+L)*z2(.5)),j2[i+176>>2]=S-b,j2[p>>2]=j-n,j2[a>>2]=T-o,j2[i+112>>2]=L-b,u=T2[T2[A+28>>2]+4>>2]-17>>>0<=1?T2[T2[A+32>>2]+4>>2]-17>>>0<2:0,T2[A+68>>2]=0,T2[A+4>>2]=0,T2[A+8>>2]=1065353216,T2[A+60>>2]=-1,T2[A+64>>2]=0,T2[(X=A+12|0)>>2]=0,T2[X+4>>2]=0,T2[5604]=T2[5604]+1,X=T2[A+24>>2],p2[X+312|0]=0,p2[X+356|0]=1,k=S2[A+52|0],q=j2[A+48>>2],f2=j2[A+44>>2],T2[(p=X+336|0)>>2]=0,T2[p+4>>2]=0,T2[(p=X+300|0)>>2]=1566444395,T2[p+4>>2]=0,T2[X+292>>2]=1566444395,T2[X+296>>2]=1566444395,T2[(p=X+344|0)>>2]=0,T2[p+4>>2]=0,p2[X+352|0]=0,T2[X>>2]=0,p2[0|(X=X+332|0)]=240&S2[0|X],a=A+4|0,S=z2(0xde0b6b000000000);;){T2[i+60>>2]=0,L=j2[A+8>>2],K=z2(-L),T=j2[A+4>>2],_=j2[A+12>>2],j2[i+56>>2]=z2(z2(j2[f+24>>2]*K)-z2(T*j2[f+8>>2]))-z2(_*j2[f+40>>2]),j2[i+52>>2]=z2(z2(j2[f+20>>2]*K)-z2(T*j2[f+4>>2]))-z2(_*j2[f+36>>2]),j2[i+48>>2]=z2(z2(j2[f+16>>2]*K)-z2(T*j2[f>>2]))-z2(_*j2[f+32>>2]),T2[i+44>>2]=0,j2[i+40>>2]=z2(z2(T*j2[f+72>>2])+z2(L*j2[f+88>>2]))+z2(_*j2[f+104>>2]),j2[i+36>>2]=z2(z2(T*j2[f+68>>2])+z2(L*j2[f+84>>2]))+z2(_*j2[f+100>>2]),j2[i+32>>2]=z2(z2(T*j2[f+64>>2])+z2(L*j2[f+80>>2]))+z2(_*j2[f+96>>2]),t2(i+16|0,T2[A+28>>2],i+48|0),t2(i,T2[A+32>>2],i+32|0);A:{if(K=j2[i+16>>2],j=j2[i+20>>2],L=j2[i+24>>2],$=z2(z2(z2(z2(K*j2[i+128>>2])+z2(j*j2[i+132>>2]))+z2(L*j2[i+136>>2]))+j2[i+176>>2]),P=j2[i>>2],H=j2[i+4>>2],O=j2[i+8>>2],r2=z2(z2(z2(z2(P*j2[i+64>>2])+z2(H*j2[i+68>>2]))+z2(O*j2[i+72>>2]))+j2[i+112>>2]),_=z2($-r2),i2=z2(z2(z2(z2(K*j2[i+144>>2])+z2(j*j2[i+148>>2]))+z2(L*j2[i+152>>2]))+j2[i+180>>2]),a2=z2(z2(z2(z2(P*j2[i+80>>2])+z2(H*j2[i+84>>2]))+z2(O*j2[i+88>>2]))+j2[i+116>>2]),T=z2(i2-a2),n2=z2(u?0:z2(z2(z2(K*j2[i+160>>2])+z2(j*j2[i+164>>2]))+z2(L*j2[i+168>>2]))+j2[i+184>>2]),P=z2(u?0:z2(z2(z2(P*j2[i+96>>2])+z2(H*j2[i+100>>2]))+z2(O*j2[i+104>>2]))+j2[i+120>>2]),j=z2(n2-P),(K=z2(z2(z2(_*j2[A+4>>2])+z2(T*j2[A+8>>2]))+z2(j*j2[A+12>>2])))>z2(0)&&z2(K*K)>z2(S*j2[f+128>>2]))T2[A+68>>2]=10;else {X=T2[A+24>>2];f:if((0|(o2=T2[X>>2]))<1)A2=0;else for(p=X+12|0,L=j2[X+308>>2],z=0,A2=1;;){if(H=z2(_-j2[p-8>>2]),O=z2(H*H),H=z2(T-j2[p-4>>2]),O=z2(O+z2(H*H)),H=z2(j-j2[p>>2]),z2(O+z2(H*H))<=L)break f;if(p=p+16|0,A2=(0|(z=z+1|0))<(0|o2),(0|z)==(0|o2))break;}f:{r:{if(j2[X+304>>2]==z2(0)&&j==j2[X+300>>2]&&T==j2[X+296>>2]){if(j2[X+292>>2]==_|A2)break r;break f;}if(!A2)break f;}T2[A+68>>2]=b2=1,p=0;break A;}if((H=z2(S-K))<=z2(S*z2(9.999999974752427e-7)))T2[A+68>>2]=H<=z2(0)?2:11;else if(T2[X+304>>2]=0,j2[X+296>>2]=T,j2[X+300>>2]=j,p2[X+356|0]=1,j2[X+292>>2]=_,T2[(p=X+(o2<<4)|0)+16>>2]=0,j2[p+8>>2]=T,j2[p+12>>2]=j,j2[p+4>>2]=_,p=X+(T2[X>>2]<<4)|0,T2[p+96>>2]=0,j2[p+88>>2]=i2,j2[p+92>>2]=n2,j2[p+84>>2]=$,p=X+(T2[X>>2]<<4)|0,T2[p+176>>2]=0,j2[p+168>>2]=a2,j2[p+172>>2]=P,j2[p+164>>2]=r2,T2[X>>2]=T2[X>>2]+1,N0(X=T2[A+24>>2])){if(L=j2[X+288>>2],T=j2[X+276>>2],j=j2[X+280>>2],P=j2[X+284>>2],!((_=z2(z2(z2(T*T)+z2(j*j))+z2(P*P)))<z2(9.999999974752427e-7))){z2(S-_)<=z2(S*z2(1.1920928955078125e-7))?(T2[A+68>>2]=12,b2=1,p=0):(j2[A+16>>2]=L,j2[A+12>>2]=P,j2[A+8>>2]=j,j2[A+4>>2]=T,X=T2[A+64>>2],T2[A+64>>2]=X+1,1e3<((p=0)|X)||(4==T2[T2[A+24>>2]>>2]?T2[A+68>>2]=13:p=1)),S=_;break A;}T2[A+68>>2]=6,j2[A+16>>2]=L,j2[A+12>>2]=P,j2[A+8>>2]=j,j2[A+4>>2]=T;}else T2[A+68>>2]=3;}b2=1,p=0;}if(!p)break;}T=z2(0),j=k?z2(0):q,P=z2((k?z2(0):f2)+j),p=z=0,b2&&(N0(X=T2[A+24>>2]),o2=T2[(A2=8+a|0)+4>>2],T2[(p=i+200|0)>>2]=T2[A2>>2],T2[p+4>>2]=o2,p=T2[4+a>>2],T2[i+192>>2]=T2[a>>2],T2[i+196>>2]=p,K=j2[X+268>>2],L=j2[X+264>>2],_=j2[X+260>>2],H=j2[A+4>>2],O=j2[A+8>>2],q=j2[A+12>>2],(T=z2(z2(z2(H*H)+z2(O*O))+z2(q*q)))<z2(9.999999974752427e-7)&&(T2[A+68>>2]=5),X=1,T=(p=T>z2(14210854715202004e-30))?(T=z2(z2(1)/z2(_2(T))),j2[i+192>>2]=T*j2[i+192>>2],j2[i+196>>2]=T*j2[i+196>>2],j2[i+200>>2]=T*j2[i+200>>2],S=z2(j/z2(_2(S))),K=z2(z2(S*q)+K),L=z2(z2(S*O)+L),_=z2(z2(S*H)+_),z2(z2(z2(1)/T)-P)):(X=2,z2(0)),T2[A+60>>2]=X),T2[A+72>>2]&&T2[A+20>>2]&&T2[A+68>>2]&&(z=z2(P+T)<z2(.0010000000474974513));A:{f:{if((1^p||z)&&(X=T2[A+20>>2])){if(T2[a>>2]=0,T2[4+a>>2]=0,T2[(z=8+a|0)>>2]=0,T2[z+4>>2]=0,T2[5605]=T2[5605]+1,0|n1[T2[T2[X>>2]+8>>2]](X,T2[A+24>>2],T2[A+28>>2],T2[A+32>>2],i+128|0,i- -64|0,a,i+48|0,i+32|0,e)){if(S=z2(0),j=j2[i+32>>2],O=j2[i+48>>2],q=z2(j-O),P=j2[i+36>>2],i2=j2[i+52>>2],f2=z2(P-i2),H=j2[i+40>>2],a2=j2[i+56>>2],$=z2(H-a2),(r2=z2(z2(z2(q*q)+z2(f2*f2))+z2($*$)))<=z2(14210854715202004e-30)&&(q=j2[A+4>>2],f2=j2[A+8>>2],$=j2[A+12>>2],r2=z2(z2(z2(q*q)+z2(f2*f2))+z2($*$)),S=j2[A+16>>2]),r2>z2(14210854715202004e-30)){if(T2[A+60>>2]=3,O=z2(O-j),e2=z2(O*O),O=z2(i2-P),e2=z2(e2+z2(O*O)),O=z2(a2-H),!(!((O=z2(-z2(_2(z2(e2+z2(O*O))))))<T)&p)){j2[i+204>>2]=S,T=z2(z2(1)/z2(_2(r2))),j2[i+200>>2]=$*T,j2[i+196>>2]=f2*T,j2[i+192>>2]=q*T,_=j,L=P,K=H,T=O;break f;}T2[A+60>>2]=8;break f;}if(T2[A+60>>2]=9,p)break f;break A;}if(H=j2[A+4>>2],O=j2[A+8>>2],q=j2[A+12>>2],z2(z2(z2(H*H)+z2(O*O))+z2(q*q))>z2(0)){if(f2=j2[i+32>>2],S=z2(j2[i+48>>2]-f2),e2=z2(S*S),$=j2[i+36>>2],S=z2(j2[i+52>>2]-$),e2=z2(e2+z2(S*S)),r2=j2[i+40>>2],S=z2(j2[i+56>>2]-r2),!(!((S=z2(z2(_2(z2(e2+z2(S*S))))-P))<T)&p)){z=T2[(p=8+a|0)+4>>2],T2[(X=e=i+200|0)>>2]=T2[p>>2],T2[X+4>>2]=z,T2[A+60>>2]=6,X=T2[4+a>>2],T2[i+192>>2]=T2[a>>2],T2[i+196>>2]=X,_=j2[i+192>>2],L=j2[i+196>>2],K=j2[e>>2],T=z2(z2(1)/z2(_2(z2(z2(z2(_*_)+z2(L*L))+z2(K*K))))),j2[e>>2]=K*T,j2[i+192>>2]=_*T,j2[i+196>>2]=L*T,K=z2(z2(j*q)+r2),L=z2(z2(j*O)+$),_=z2(z2(j*H)+f2),T=S;break f;}T2[A+60>>2]=5;break f;}}if(!p)break A;}(j2[f+128>>2]>z2(T*T)||T<z2(0))&&(e=T2[i+196>>2],T2[a>>2]=T2[i+192>>2],T2[4+a>>2]=e,j2[A+56>>2]=T,p=T2[(e=i+200|0)+4>>2],T2[(X=8+a|0)>>2]=T2[e>>2],T2[X+4>>2]=p,T2[i+60>>2]=0,S=j2[i+192>>2],P=j2[i+196>>2],j=j2[e>>2],j2[i+56>>2]=z2(z2(S*j2[f+8>>2])+z2(P*j2[f+24>>2]))+z2(j*j2[f+40>>2]),j2[i+52>>2]=z2(z2(S*j2[f+4>>2])+z2(P*j2[f+20>>2]))+z2(j*j2[f+36>>2]),j2[i+48>>2]=z2(z2(S*j2[f>>2])+z2(P*j2[f+16>>2]))+z2(j*j2[f+32>>2]),T2[i+44>>2]=0,P=z2(-P),j2[i+40>>2]=z2(z2(j2[f+88>>2]*P)-z2(S*j2[f+72>>2]))-z2(j*j2[f+104>>2]),j2[i+36>>2]=z2(z2(j2[f+84>>2]*P)-z2(S*j2[f+68>>2]))-z2(j*j2[f+100>>2]),j2[i+32>>2]=z2(z2(j2[f+80>>2]*P)-z2(S*j2[f+64>>2]))-z2(j*j2[f+96>>2]),t2(i+16|0,T2[A+28>>2],i+48|0),t2(i,T2[A+32>>2],i+32|0),S=j2[e>>2],v=j2[i+184>>2],d=j2[i+168>>2],B=j2[i+160>>2],Q=j2[i+164>>2],g=j2[i+120>>2],w=j2[i+104>>2],G=j2[i+96>>2],C=j2[i+100>>2],E=j2[i+180>>2],D=j2[i+152>>2],h=j2[i+144>>2],Z=j2[i+148>>2],Y=j2[i+116>>2],R=j2[i+88>>2],F=j2[i+80>>2],W=j2[i+84>>2],m=j2[i+176>>2],N=j2[i+136>>2],H=j2[i+24>>2],V=j2[i+128>>2],O=j2[i+16>>2],J=j2[i+132>>2],q=j2[i+20>>2],M=j2[i+112>>2],I=j2[i+72>>2],f2=j2[i+8>>2],x=j2[i+64>>2],$=j2[i>>2],y=j2[i+68>>2],r2=j2[i+4>>2],P=j2[i+196>>2],j=j2[i+192>>2],T2[i+60>>2]=0,i2=z2(-P),j2[i+56>>2]=z2(z2(j2[f+24>>2]*i2)-z2(j*j2[f+8>>2]))-z2(S*j2[f+40>>2]),j2[i+52>>2]=z2(z2(j2[f+20>>2]*i2)-z2(j*j2[f+4>>2]))-z2(S*j2[f+36>>2]),j2[i+48>>2]=z2(z2(j2[f+16>>2]*i2)-z2(j*j2[f>>2]))-z2(S*j2[f+32>>2]),T2[i+44>>2]=0,j2[i+40>>2]=z2(z2(j*j2[f+72>>2])+z2(P*j2[f+88>>2]))+z2(S*j2[f+104>>2]),j2[i+36>>2]=z2(z2(j*j2[f+68>>2])+z2(P*j2[f+84>>2]))+z2(S*j2[f+100>>2]),j2[i+32>>2]=z2(z2(j*j2[f+64>>2])+z2(P*j2[f+80>>2]))+z2(S*j2[f+96>>2]),t2(i+16|0,T2[A+28>>2],i+48|0),t2(i,T2[A+32>>2],i+32|0),P=j2[i+16>>2],a2=j2[i+20>>2],n2=j2[i+24>>2],t=j2[i>>2],c=j2[i+4>>2],e2=j2[i+8>>2],l=j2[i+192>>2],s=j2[i+196>>2],U=z2(z2(z2(z2(z2(z2(z2(P*j2[i+128>>2])+z2(a2*j2[i+132>>2]))+z2(n2*j2[i+136>>2]))+j2[i+176>>2])-z2(z2(z2(z2(t*j2[i+64>>2])+z2(c*j2[i+68>>2]))+z2(e2*j2[i+72>>2]))+j2[i+112>>2]))*l)+z2(z2(z2(z2(z2(z2(P*j2[i+144>>2])+z2(a2*j2[i+148>>2]))+z2(n2*j2[i+152>>2]))+j2[i+180>>2])-z2(z2(z2(z2(t*j2[i+80>>2])+z2(c*j2[i+84>>2]))+z2(e2*j2[i+88>>2]))+j2[i+116>>2]))*s)),e2=z2(z2(z2(z2(z2(P*j2[i+160>>2])+z2(a2*j2[i+164>>2]))+z2(n2*j2[i+168>>2]))+j2[i+184>>2])-z2(z2(z2(z2(t*j2[i+96>>2])+z2(c*j2[i+100>>2]))+z2(e2*j2[i+104>>2]))+j2[i+120>>2])),P=j2[e>>2],z2(U+z2(e2*P))<z2(z2(z2(z2(z2(E+z2(z2(z2(O*h)+z2(q*Z))+z2(H*D)))-z2(Y+z2(z2(z2($*F)+z2(r2*W))+z2(f2*R))))*i2)-z2(j*z2(z2(m+z2(z2(z2(O*V)+z2(q*J))+z2(H*N)))-z2(M+z2(z2(z2($*x)+z2(r2*y))+z2(f2*I))))))-z2(S*z2(z2(v+z2(z2(z2(O*B)+z2(q*Q))+z2(H*d)))-z2(g+z2(z2(z2($*G)+z2(r2*C))+z2(f2*w))))))&&(T2[A+60>>2]=10,j2[i+200>>2]=-P,j2[i+196>>2]=-s,j2[i+192>>2]=-l),T2[i+60>>2]=0,j2[i+56>>2]=n+K,j2[i+52>>2]=o+L,j2[i+48>>2]=b+_,n1[T2[T2[r>>2]+16>>2]](r,i+192|0,i+48|0,T));}L2=i+208|0;}function M0(A,f,r,e,i,a,n,o,b,t,c){var u,k;return r=z2(z2(z2(r*a)+z2(e*n))+z2(i*o)),e=z2(z2(z2(j2[A>>2]*a)+z2(j2[A+16>>2]*n))+z2(j2[A+32>>2]*o)),i=j2[b+80>>2],u=z2(e*(e<z2(0)?z2(-i):i)),e=z2(z2(z2(j2[A+4>>2]*a)+z2(j2[A+20>>2]*n))+z2(j2[A+36>>2]*o)),i=j2[b+84>>2],u=z2(u+z2(e*(e<z2(0)?z2(-i):i))),e=z2(z2(z2(j2[A+8>>2]*a)+z2(j2[A+24>>2]*n))+z2(j2[A+40>>2]*o)),i=j2[b+88>>2],e=z2(u+z2(e*(e<z2(0)?z2(-i):i))),u=(i=j2[b+96>>2])<e?e:i,e=z2(z2(z2(j2[f>>2]*a)+z2(j2[f+16>>2]*n))+z2(j2[f+32>>2]*o)),i=j2[t+80>>2],k=z2(e*(e<z2(0)?z2(-i):i)),e=z2(z2(z2(j2[f+4>>2]*a)+z2(j2[f+20>>2]*n))+z2(j2[f+36>>2]*o)),i=j2[t+84>>2],k=z2(k+z2(e*(e<z2(0)?z2(-i):i))),e=z2(z2(z2(j2[f+8>>2]*a)+z2(j2[f+24>>2]*n))+z2(j2[f+40>>2]*o)),i=j2[t+88>>2],e=z2(k+z2(e*(e<z2(0)?z2(-i):i))),i=j2[t+96>>2],e=z2(u+(i<e?e:i)),!(c<((i=z2(r+e))<(r=z2(e-r))?i:r));}function I0(A,f,r,e,i,a,n,o){var b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C=0,E=0,D=0,h=0,Z=z2(0),Y=0,R=z2(0),F=z2(0),W=0,m=z2(0),N=0,V=z2(0),J=z2(0),M=z2(0),I=0,x=z2(0),y=z2(0),U=z2(0),X=0,p=0,T=z2(0),S=z2(0),j=z2(0),P=z2(0),z=z2(0),O=0,H=z2(0),_=z2(0);if(L2=X=L2-16|0,(0|(C=T2[i+4>>2]))<=-1)for(T2[i+8>>2]<=-1&&((D=T2[i+12>>2])&&S2[i+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[D-4>>2])),p2[i+16|0]=1,T2[i+8>>2]=0,T2[i+12>>2]=0),E=C<<4;p=T2[4+X>>2],D=T2[i+12>>2]+E|0,T2[D>>2]=T2[X>>2],T2[D+4>>2]=p,p=T2[(W=8+X|0)+4>>2],T2[(D=D+8|0)>>2]=T2[W>>2],T2[D+4>>2]=p,E=E+16|0,(D=C)>>>0<=(C=C+1|0)>>>0;);if(((T2[i+4>>2]=E=0)|(D=T2[e+4>>2]))>T2[i+8>>2]&&(D&&(T2[5498]=T2[5498]+1,(C=K2(19+(D<<4)|0))&&(T2[(E=C+19&-16)-4>>2]=C)),(C=T2[i+12>>2])&&S2[i+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[C-4>>2])),T2[i+12>>2]=E,p2[i+16|0]=1,T2[i+8>>2]=D),!((0|(p=T2[f+28>>2]))<1)){for(C=(b=T2[f+36>>2])+28|0,Z=j2[r+40>>2],T=j2[r+36>>2],m=j2[r+24>>2],F=j2[r+20>>2],S=j2[A+8>>2],j=j2[A+4>>2],H=j2[A>>2],U=j2[r+32>>2],M=j2[r+16>>2],V=j2[r+8>>2],J=j2[r+4>>2],x=j2[r>>2],E=0,R=z2(34028234663852886e22),W=-1;y=j2[C-8>>2],P=j2[C-4>>2],z=j2[C>>2],R=(D=(y=z2(z2(z2(z2(z2(z2(y*x)+z2(P*J))+z2(z*V))*H)+z2(z2(z2(z2(y*M)+z2(P*F))+z2(z*m))*j))+z2(z2(z2(z2(y*U)+z2(P*T))+z2(z*Z))*S)))<R)?y:R,W=D?E:W,C=C+36|0,(0|p)!=(0|(E=E+1|0)););if(!((0|W)<0)){if(b=b+P2(W,36)|0,1<=(0|(k=T2[4+b>>2])))for(Q=28+b|0,g=24+b|0,w=20+b|0,G=12+b|0,E=0;;){if(l=(0|(p=E+1|0))==(0|k),2<=(0|(W=T2[(D=e)+4>>2]))){for(C=T2[G>>2],e=T2[C+(E<<2)>>2]<<4,E=T2[f+16>>2],R=j2[(e=e+E|0)>>2],C=E+(T2[C+((l?0:p)<<2)>>2]<<4)|0,S=z2(R-j2[C>>2]),y=j2[e+4>>2],j=z2(y-j2[C+4>>2]),P=j2[e+8>>2],H=z2(P-j2[C+8>>2]),s=z2(z2(z2(S*U)+z2(j*T))+z2(H*Z)),t=j2[w>>2],c=j2[g>>2],u=j2[Q>>2],v=z2(z2(z2(x*t)+z2(J*c))+z2(V*u)),d=z2(z2(z2(S*x)+z2(j*J))+z2(H*V)),B=z2(z2(z2(U*t)+z2(T*c))+z2(Z*u)),z=z2(-z2(z2(s*v)-z2(d*B))),_=z2(z2(z2(z2(z2(R*M)+z2(y*F))+z2(P*m))+j2[r+52>>2])*z),j=z2(z2(z2(S*M)+z2(j*F))+z2(H*m)),m=z2(z2(z2(M*t)+z2(F*c))+z2(m*u)),S=z2(z2(j*B)-z2(s*m)),M=z2(_-z2(S*z2(z2(z2(z2(R*x)+z2(y*J))+z2(P*V))+j2[r+48>>2]))),x=z2(z2(d*m)-z2(j*v)),y=z2(M-z2(x*z2(z2(z2(z2(R*U)+z2(y*T))+z2(P*Z))+j2[r+56>>2]))),C=T2[D+12>>2],R=j2[(e=(C+(W<<4)|0)-16|0)+4>>2],m=j2[e>>2],F=j2[e+8>>2],Z=z2(z2(z2(z2(R*z)-z2(S*m))-z2(x*F))-y),O=0;;){U=j2[(e=(O<<4)+C|0)+4>>2],M=j2[e>>2],V=j2[e+8>>2],J=z2(z2(z2(z2(U*z)-z2(S*M))-z2(x*V))-y),T=j2[e+12>>2];A:{if(Z<z2(0)){if(J<z2(0)){if((0|(E=T2[i+4>>2]))==T2[i+8>>2]&&!((0|(N=E?E<<1:1))<=(0|E))){if(e=0,N&&(T2[5498]=T2[5498]+1,(C=K2(19+(N<<4)|0))&&(T2[(e=C+19&-16)-4>>2]=C)),1<=(0|E))for(C=0;Y=T2[i+12>>2]+C|0,I=T2[Y+4>>2],T2[(h=e+C|0)>>2]=T2[Y>>2],T2[h+4>>2]=I,I=T2[(Y=Y+8|0)+4>>2],T2[(h=h+8|0)>>2]=T2[Y>>2],T2[h+4>>2]=I,C=C+16|0,E=E-1|0;);(C=T2[i+12>>2])&&S2[i+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[C-4>>2])),T2[i+12>>2]=e,p2[i+16|0]=1,T2[i+8>>2]=N,E=T2[i+4>>2];}e=T2[i+12>>2]+(E<<4)|0,j2[e+8>>2]=V,j2[e+4>>2]=U,j2[e>>2]=M,e=e+12|0;}else {if(Z=z2(Z/z2(Z-J)),F=z2(F+z2(z2(V-F)*Z)),R=z2(R+z2(z2(U-R)*Z)),Z=z2(m+z2(z2(M-m)*Z)),(0|(E=T2[i+4>>2]))==T2[i+8>>2]&&!((0|(N=E?E<<1:1))<=(0|E))){if(e=0,N&&(T2[5498]=T2[5498]+1,(C=K2(19+(N<<4)|0))&&(T2[(e=C+19&-16)-4>>2]=C)),1<=(0|E))for(C=0;Y=T2[i+12>>2]+C|0,I=T2[Y+4>>2],T2[(h=e+C|0)>>2]=T2[Y>>2],T2[h+4>>2]=I,I=T2[(Y=Y+8|0)+4>>2],T2[(h=h+8|0)>>2]=T2[Y>>2],T2[h+4>>2]=I,C=C+16|0,E=E-1|0;);(C=T2[i+12>>2])&&S2[i+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[C-4>>2])),T2[i+12>>2]=e,p2[i+16|0]=1,T2[i+8>>2]=N,E=T2[i+4>>2];}e=T2[i+12>>2]+(E<<4)|0,j2[e+8>>2]=F,j2[e+4>>2]=R,j2[e>>2]=Z,T=z2(0),e=e+12|0;}}else {if(!(J<z2(0)))break A;if(Z=z2(Z/z2(Z-J)),F=z2(F+z2(z2(V-F)*Z)),R=z2(R+z2(z2(U-R)*Z)),Z=z2(m+z2(z2(M-m)*Z)),(0|(E=T2[i+4>>2]))==T2[i+8>>2]&&!((0|(N=E?E<<1:1))<=(0|E))){if(e=0,N&&(T2[5498]=T2[5498]+1,(C=K2(19+(N<<4)|0))&&(T2[(e=C+19&-16)-4>>2]=C)),1<=(0|E))for(C=0;Y=T2[i+12>>2]+C|0,I=T2[Y+4>>2],T2[(h=e+C|0)>>2]=T2[Y>>2],T2[h+4>>2]=I,I=T2[(Y=Y+8|0)+4>>2],T2[(h=h+8|0)>>2]=T2[Y>>2],T2[h+4>>2]=I,C=C+16|0,E=E-1|0;);(C=T2[i+12>>2])&&S2[i+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[C-4>>2])),T2[i+12>>2]=e,p2[i+16|0]=1,T2[i+8>>2]=N,E=T2[i+4>>2];}if(e=T2[i+12>>2]+(E<<4)|0,T2[e+12>>2]=0,j2[e+8>>2]=F,j2[e+4>>2]=R,j2[e>>2]=Z,E=T2[i+4>>2],T2[i+4>>2]=C=E+1|0,T2[i+8>>2]==(0|C)&&!((0|(N=C?C<<1:1))<=(0|C))){if(e=0,N&&(T2[5498]=T2[5498]+1,(C=K2(19+(N<<4)|0))&&(T2[(e=C+19&-16)-4>>2]=C)),0<=(0|E))for(E=E+1|0,C=0;Y=T2[i+12>>2]+C|0,I=T2[Y+4>>2],T2[(h=e+C|0)>>2]=T2[Y>>2],T2[h+4>>2]=I,I=T2[(Y=Y+8|0)+4>>2],T2[(h=h+8|0)>>2]=T2[Y>>2],T2[h+4>>2]=I,C=C+16|0,E=E-1|0;);(C=T2[i+12>>2])&&S2[i+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[C-4>>2])),T2[i+12>>2]=e,p2[i+16|0]=1,T2[i+8>>2]=N,C=T2[i+4>>2];}e=T2[i+12>>2]+(C<<4)|0,j2[e+8>>2]=V,j2[e+4>>2]=U,j2[e>>2]=M,e=e+12|0;}j2[e>>2]=T,T2[i+4>>2]=T2[i+4>>2]+1;}if((0|(O=O+1|0))==(0|W))break;C=T2[D+12>>2],Z=J,F=V,R=U,m=M;}W=T2[D+4>>2];}if((0|W)<=-1)for(T2[D+8>>2]<=-1&&((e=T2[D+12>>2])&&S2[D+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),p2[D+16|0]=1,T2[D+8>>2]=0,T2[D+12>>2]=0),C=W<<4;E=T2[4+X>>2],e=T2[D+12>>2]+C|0,T2[e>>2]=T2[X>>2],T2[e+4>>2]=E,O=T2[(E=8+X|0)+4>>2],T2[(e=e+8|0)>>2]=T2[E>>2],T2[e+4>>2]=O,C=C+16|0,(e=W)>>>0<=(W=e+1|0)>>>0;);if(T2[D+4>>2]=0,Z=j2[r+40>>2],T=j2[r+36>>2],U=j2[r+32>>2],m=j2[r+24>>2],F=j2[r+20>>2],M=j2[r+16>>2],V=j2[r+8>>2],J=j2[r+4>>2],x=j2[r>>2],e=i,E=p,i=D,l)break;}if(!((0|(W=T2[e+4>>2]))<1))for(R=j2[20+b>>2],_=z2(R*x),x=j2[24+b>>2],_=z2(_+z2(x*J)),J=j2[28+b>>2],V=z2(_+z2(J*V)),m=z2(z2(z2(R*M)+z2(x*F))+z2(J*m)),Z=z2(z2(z2(R*U)+z2(x*T))+z2(J*Z)),R=z2(j2[32+b>>2]-z2(z2(z2(V*j2[r+48>>2])+z2(m*j2[r+52>>2]))+z2(Z*j2[r+56>>2]))),E=C=0;r=(f=T2[e+12>>2]+C|0)+8|0,C=C+16|0,(F=(F=z2(R+z2(z2(z2(V*j2[f>>2])+z2(m*j2[f+4>>2]))+z2(Z*j2[r>>2]))))<=a?a:F)<=n&&(D=T2[r+4>>2],T2[(i=8+X|0)>>2]=T2[r>>2],T2[i+4>>2]=D,r=T2[f+4>>2],T2[X>>2]=T2[f>>2],T2[4+X>>2]=r,n1[T2[T2[o>>2]+16>>2]](o,A,X,F),W=T2[e+4>>2]),(0|(E=E+1|0))<(0|W););}}L2=16+X|0;}function x0(A,f,r,e,i,a){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0;var n,o,b,t,c,u,k,l,s,v,d,B,Q=0,g=0,w=z2(0),G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=z2(0);L2=Q=L2-288|0,n=T2[A+4>>2],T2[n+292>>2]=1566444395,T2[n+296>>2]=1566444395,T2[(g=n+336|0)>>2]=0,T2[g+4>>2]=0,T2[(g=n+300|0)>>2]=1566444395,T2[g+4>>2]=0,T2[(g=n+344|0)>>2]=0,T2[g+4>>2]=0,p2[n+352|0]=0,p2[0|(g=n+332|0)]=240&S2[0|g],p2[n+312|0]=0,p2[n+356|0]=1,T2[n>>2]=0,w=j2[r+52>>2],G=j2[f+52>>2],E=j2[i+52>>2],D=j2[e+52>>2],h=j2[r+56>>2],C=j2[(o=f+56|0)>>2],t=j2[i+56>>2],c=j2[(b=e+56|0)>>2],u=j2[r+48>>2],k=j2[f+48>>2],l=j2[i+48>>2],s=j2[e+48>>2],p2[264+Q|0]=0,T2[260+Q>>2]=1566444395,T2[224+Q>>2]=12428,T2[(n=156+Q|0)>>2]=0,T2[4+n>>2]=0,T2[144+Q>>2]=12272,T2[164+Q>>2]=0,T2[148+Q>>2]=0,T2[152+Q>>2]=1065353216,n=T2[A+12>>2],T2[176+Q>>2]=n,g=T2[A+8>>2],T2[172+Q>>2]=g,T2[168+Q>>2]=T2[A+4>>2],T2[180+Q>>2]=T2[g+4>>2],T2[184+Q>>2]=T2[n+4>>2],d=Q,B=z2(n1[T2[T2[g>>2]+48>>2]](g)),j2[188+d>>2]=B,v=z2(n1[T2[T2[n>>2]+48>>2]](n)),T2[216+Q>>2]=1,T2[220+Q>>2]=1,T2[204+Q>>2]=-1,p2[196+Q|0]=0,j2[192+Q>>2]=v,g=T2[4+(n=f+8|0)>>2],T2[(A=16+Q|0)>>2]=T2[n>>2],T2[A+4>>2]=g,g=T2[4+(n=f+24|0)>>2],T2[(A=32+Q|0)>>2]=T2[n>>2],T2[A+4>>2]=g,g=T2[4+(n=f+40|0)>>2],T2[(A=48+Q|0)>>2]=T2[n>>2],T2[A+4>>2]=g,n=T2[4+o>>2],T2[(A=Q+64|0)>>2]=T2[o>>2],T2[A+4>>2]=n,g=T2[4+(n=e+8|0)>>2],T2[(A=80+Q|0)>>2]=T2[n>>2],T2[A+4>>2]=g,T2[136+Q>>2]=1566444395,A=T2[f+4>>2],T2[8+Q>>2]=T2[f>>2],T2[12+Q>>2]=A,A=T2[f+20>>2],T2[24+Q>>2]=T2[f+16>>2],T2[28+Q>>2]=A,A=T2[f+36>>2],T2[40+Q>>2]=T2[f+32>>2],T2[44+Q>>2]=A,A=T2[f+52>>2],T2[56+Q>>2]=T2[f+48>>2],T2[60+Q>>2]=A,A=T2[e+4>>2],T2[72+Q>>2]=T2[e>>2],T2[76+Q>>2]=A,g=T2[4+(n=e+24|0)>>2],T2[(A=96+Q|0)>>2]=T2[n>>2],T2[A+4>>2]=g,n=T2[e+20>>2],T2[(A=88+Q|0)>>2]=T2[e+16>>2],T2[A+4>>2]=n,g=T2[4+(n=e+40|0)>>2],T2[(A=112+Q|0)>>2]=T2[n>>2],T2[A+4>>2]=g,n=T2[e+36>>2],T2[(A=104+Q|0)>>2]=T2[e+32>>2],T2[A+4>>2]=n,n=T2[4+b>>2],T2[(A=128+Q|0)>>2]=T2[b>>2],T2[A+4>>2]=n,n=T2[e+52>>2],T2[(A=120+Q|0)>>2]=T2[e+48>>2],T2[A+4>>2]=n,J0(144+Q|0,8+Q|0,224+Q|0,0,0),g=T2[4+(n=252+Q|0)>>2],T2[(A=280+Q|0)>>2]=T2[n>>2],T2[A+4>>2]=g,A=T2[248+Q>>2],T2[272+Q>>2]=T2[244+Q>>2],T2[276+Q>>2]=A;A:if(S2[264+Q|(A=0)]){t=z2(z2(h-C)-z2(t-c)),c=z2(z2(w-G)-z2(E-D)),u=z2(z2(u-k)-z2(l-s)),E=j2[236+Q>>2],D=j2[232+Q>>2],h=j2[228+Q>>2];f:{if((C=j2[260+Q>>2])>z2(.0010000000474974513)){for(n=244+Q|0,g=33,G=z2(0);;){if(!(g=g-1|(A=0)))break A;if(A=0,(w=z2(G-z2(C/z2(z2(z2(u*h)+z2(c*D))+z2(t*E)))))<=G)break A;if(A=0,w>z2(1))break A;if(w<z2(A=0))break A;if(n1[T2[T2[a>>2]>>2]](a,w),G=z2(z2(1)-w),j2[56+Q>>2]=z2(G*j2[f+48>>2])+z2(w*j2[r+48>>2]),j2[60+Q>>2]=z2(G*j2[f+52>>2])+z2(w*j2[r+52>>2]),j2[64+Q>>2]=z2(G*j2[f+56>>2])+z2(w*j2[r+56>>2]),j2[120+Q>>2]=z2(G*j2[e+48>>2])+z2(w*j2[i+48>>2]),j2[124+Q>>2]=z2(G*j2[e+52>>2])+z2(w*j2[i+52>>2]),j2[128+Q>>2]=z2(G*j2[e+56>>2])+z2(w*j2[i+56>>2]),J0(144+Q|0,8+Q|0,224+Q|0,0,0),!S2[264+Q|(A=0)])break A;if((C=j2[260+Q>>2])<z2(0)){j2[a+164>>2]=w,A=T2[232+Q>>2],T2[a+132>>2]=T2[228+Q>>2],T2[a+136>>2]=A,f=T2[240+Q>>2],T2[(A=a+140|0)>>2]=T2[236+Q>>2],T2[A+4>>2]=f,A=T2[4+n>>2],T2[a+148>>2]=T2[n>>2],T2[a+152>>2]=A,r=T2[(f=8+n|0)+4>>2],T2[(A=a+156|0)>>2]=T2[f>>2],T2[A+4>>2]=r;break f;}if(b=T2[4+(o=8+n|0)>>2],T2[(A=280+Q|0)>>2]=T2[o>>2],T2[A+4>>2]=b,A=T2[4+n>>2],T2[272+Q>>2]=T2[n>>2],T2[276+Q>>2]=A,E=j2[236+Q>>2],D=j2[232+Q>>2],h=j2[228+Q>>2],G=w,!(C>z2(.0010000000474974513)))break;}G=j2[240+Q>>2];}else w=z2(0),G=j2[240+Q>>2];if(A=0,z2(-j2[a+172>>2])<=z2(z2(z2(u*h)+z2(c*D))+z2(t*E)))break A;j2[a+132>>2]=h,j2[a+164>>2]=w,A=T2[276+Q>>2],T2[a+148>>2]=T2[272+Q>>2],T2[a+152>>2]=A,j2[a+144>>2]=G,j2[a+140>>2]=E,j2[a+136>>2]=D,r=T2[(f=280+Q|0)+4>>2],T2[(A=a+156|0)>>2]=T2[f>>2],T2[A+4>>2]=r;}A=1;}return L2=288+Q|0,0|A;}function y0(A,f,r,e,i,a,n,o,b,t,c){var u,k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=z2(0),B=(z2(0)),Q=(j2[(o=(o<<2)+t|0)>>2]),g=z2(j2[t+48>>2]-j2[b+48>>2]),w=j2[o+16>>2],G=z2(j2[t+52>>2]-j2[b+52>>2]),C=j2[o+32>>2],E=z2(j2[t+56>>2]-j2[b+56>>2]),s=z2(z2(z2(Q*g)+z2(w*G))+z2(C*E)),D=j2[(n=(n<<2)+b|0)>>2],v=j2[n+16>>2],h=j2[n+32>>2],B=z2(z2(z2(D*g)+z2(v*G))+z2(h*E)),d=z2(z2(z2(D*Q)+z2(v*w))+z2(h*C));(l=z2(z2(1)-z2(d*d)))!=z2(0)&&(k=z2(-r),(l=z2(z2(B-z2(d*s))/l))<k||r<(k=l)&&(k=r));A:{if((l=z2(z2(d*k)-s))<(s=z2(-i))){if(k=z2(-r),(i=z2(B-z2(d*i)))<k){l=s;break A;}if(!(r<i)){l=s,k=i;break A;}i=s;}else {if(!(i<l))break A;if(k=z2(-r),(s=z2(z2(d*i)+B))<k){l=i;break A;}if(!(r<s)){l=i,k=s;break A;}}l=i,k=r;}return u=c,s=z2(C*l),r=z2(s+z2(E-z2(h*k))),d=z2(Q*l),i=z2(d+z2(g-z2(D*k))),l=z2(w*l),c=z2(l+z2(G-z2(v*k))),k=z2(z2(r*r)+z2(z2(i*i)+z2(c*c))),B=z2(_2(k)),u<(Q=z2(z2(B-e)-a))||(k<=z2(14210854715202004e-30)?z2(O2(h))>z2(.7071067690849304)?(T2[A>>2]=0,e=z2(z2(1)/z2(_2(z2(z2(v*v)+z2(h*h))))),r=z2(v*e),j2[A+8>>2]=r,k=z2(e*z2(-h)),j2[A+4>>2]=k,e=z2(0)):(T2[A+8>>2]=0,r=z2(z2(1)/z2(_2(z2(z2(D*D)+z2(v*v))))),k=z2(D*r),j2[A+4>>2]=k,e=z2(r*z2(-v)),j2[A>>2]=e,r=z2(0)):(T2[A+12>>2]=0,e=z2(z2(-1)/B),r=z2(r*e),j2[A+8>>2]=r,k=z2(c*e),j2[A+4>>2]=k,e=z2(i*e),j2[A>>2]=e),i=j2[t+48>>2],c=j2[t+52>>2],v=j2[t+56>>2],T2[f+12>>2]=0,j2[f+8>>2]=z2(s+v)+z2(r*a),j2[f+4>>2]=z2(l+c)+z2(k*a),j2[f>>2]=z2(d+i)+z2(e*a)),Q;}function U0(A,f,r,e){}function X0(A,f,r,e,i,a){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0;var n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I=0,x=0,y=z2(0),U=0,X=z2(0),p=0,T=z2(0),S=(z2(0)),j=z2(0),P=z2(0),z=0,O=z2(0),H=z2(0),_=z2(0),L=z2(0),K=0,q=(z2(0)),$=z2(0),A2=0,f2=z2(0),r2=(z2(0)),e2=(z2(0)),i2=z2(0),a2=z2(0),n2=z2(0),o2=(z2(0)),b2=z2(0),t2=(z2(0)),c2=z2(0),u2=(z2(0)),k2=z2(0),l2=z2(0),s2=(z2(0));L2=x=L2-32|0,p=T2[A+4>>2],p2[p+312|0]=0,p2[p+356|0]=1,T2[p>>2]=0,T2[p+292>>2]=1566444395,T2[p+296>>2]=1566444395,T2[(I=p+336|0)>>2]=0,T2[I+4>>2]=0,T2[(I=p+300|0)>>2]=1566444395,T2[I+4>>2]=0,T2[(I=p+344|0)>>2]=0,T2[I+4>>2]=0,p2[p+352|0]=0,p2[0|(I=p+332|0)]=240&S2[0|I],D=j2[(u=e+40|0)>>2],h=j2[(k=e+36|0)>>2],Z=j2[(l=e+24|0)>>2],Y=j2[(s=e+20|0)>>2],v=j2[(R=f+20|0)>>2],d=j2[(F=f+36|0)>>2],B=j2[(U=f+24|0)>>2],T=j2[r+52>>2],o2=j2[(z=f+52|0)>>2],O=j2[i+52>>2],b2=j2[(K=e+52|0)>>2],Q=j2[(A2=f+40|0)>>2],r2=j2[r+56>>2],t2=j2[(p=f+56|0)>>2],S=j2[i+56>>2],c2=j2[(I=e+56|0)>>2],W=j2[e+32>>2],m=j2[e+16>>2],N=j2[e+8>>2],V=j2[e+4>>2],J=j2[e>>2],g=j2[f>>2],w=j2[f+16>>2],G=j2[f+32>>2],C=j2[f+4>>2],E=j2[f+8>>2],y=j2[r+48>>2],u2=j2[f+48>>2],j=j2[i+48>>2],k2=j2[e+48>>2],M=T2[A+8>>2],T2[12+x>>2]=0,c=z2(z2(T-o2)-z2(O-b2)),O=z2(-c),o=z2(z2(y-u2)-z2(j-k2)),b=z2(z2(r2-t2)-z2(S-c2)),j2[8+x>>2]=z2(z2(B*O)-z2(E*o))-z2(Q*b),j2[4+x>>2]=z2(z2(v*O)-z2(o*C))-z2(b*d),j2[x>>2]=z2(z2(w*O)-z2(o*g))-z2(b*G),n1[T2[T2[M>>2]+64>>2]](16+x|0,M,x),P=j2[p>>2],e2=j2[A2>>2],i2=j2[F>>2],a2=j2[z>>2],n2=j2[U>>2],q=j2[R>>2],$=j2[f+32>>2],n=j2[f+48>>2],X=j2[f+8>>2],T=j2[f>>2],S=j2[f+4>>2],y=j2[f+16>>2],_=j2[24+x>>2],L=j2[16+x>>2],f2=j2[20+x>>2],p=T2[A+12>>2],T2[12+x>>2]=0,j2[8+x>>2]=z2(z2(o*j2[e+8>>2])+z2(c*j2[l>>2]))+z2(b*j2[u>>2]),j2[4+x>>2]=z2(z2(o*j2[e+4>>2])+z2(c*j2[s>>2]))+z2(b*j2[k>>2]),j2[x>>2]=z2(z2(o*j2[e>>2])+z2(c*j2[e+16>>2]))+z2(b*j2[e+32>>2]),n1[T2[T2[p>>2]+64>>2]](16+x|0,p,x),O=z2(0),r2=z2(0),j=z2(0);A:{f:if(X=z2(n+z2(z2(z2(L*T)+z2(f2*S))+z2(_*X))),t=j2[16+x>>2],n=j2[20+x>>2],S=j2[24+x>>2],X=z2(X-z2(z2(z2(z2(t*j2[e>>2])+z2(n*j2[e+4>>2]))+z2(S*j2[e+8>>2]))+j2[e+48>>2])),T=z2(z2(a2+z2(z2(z2(L*y)+z2(f2*q))+z2(_*n2)))-z2(z2(z2(z2(t*j2[e+16>>2])+z2(n*j2[s>>2]))+z2(S*j2[l>>2]))+j2[K>>2])),y=z2(z2(P+z2(z2(z2(L*$)+z2(f2*i2))+z2(_*e2)))-z2(z2(z2(z2(t*j2[e+32>>2])+z2(n*j2[k>>2]))+z2(S*j2[u>>2]))+j2[I>>2])),z2(z2(z2(X*X)+z2(T*T))+z2(y*y))>z2(9999999747378752e-20))for(p=31,S=z2(0);;){if(I=T2[A+8>>2],T2[12+x>>2]=z=0,n=z2(-T),j2[8+x>>2]=z2(z2(B*n)-z2(E*X))-z2(Q*y),j2[4+x>>2]=z2(z2(v*n)-z2(C*X))-z2(d*y),j2[x>>2]=z2(z2(w*n)-z2(g*X))-z2(G*y),n1[T2[T2[I>>2]+64>>2]](16+x|0,I,x),f2=j2[24+x>>2],t=j2[16+x>>2],q=j2[20+x>>2],I=T2[A+12>>2],T2[12+x>>2]=0,j2[8+x>>2]=z2(z2(N*X)+z2(Z*T))+z2(D*y),j2[4+x>>2]=z2(z2(V*X)+z2(Y*T))+z2(h*y),j2[x>>2]=z2(z2(J*X)+z2(m*T))+z2(W*y),n1[T2[T2[I>>2]+64>>2]](16+x|0,I,x),H>z2(1))break A;if(e2=z2(u2+z2(z2(z2(g*t)+z2(C*q))+z2(E*f2))),P=j2[16+x>>2],$=j2[20+x>>2],n=j2[24+x>>2],i2=z2(k2+z2(z2(z2(J*P)+z2(V*$))+z2(N*n))),_=z2(e2-i2),a2=z2(o2+z2(z2(z2(w*t)+z2(v*q))+z2(B*f2))),n2=z2(b2+z2(z2(z2(m*P)+z2(Y*$))+z2(Z*n))),L=z2(a2-n2),q=z2(t2+z2(z2(z2(G*t)+z2(d*q))+z2(Q*f2))),$=z2(c2+z2(z2(z2(W*P)+z2(h*$))+z2(D*n))),P=z2(q-$),(n=z2(z2(z2(_*X)+z2(L*T))+z2(P*y)))>z2(0)){if((j=z2(z2(z2(o*X)+z2(c*T))+z2(b*y)))>=z2(-14210854715202004e-30))break A;H=z2(H-z2(n/j)),j=z2(z2(1)-H),c2=z2(z2(j*j2[e+56>>2])+z2(H*j2[i+56>>2])),b2=z2(z2(j*j2[e+52>>2])+z2(H*j2[i+52>>2])),k2=z2(z2(j*j2[e+48>>2])+z2(H*j2[i+48>>2])),t2=z2(z2(j*j2[f+56>>2])+z2(H*j2[r+56>>2])),o2=z2(z2(j*j2[f+52>>2])+z2(H*j2[r+52>>2])),u2=z2(z2(j*j2[f+48>>2])+z2(H*j2[r+48>>2])),O=X,r2=T,l2=y,j=S;}U=T2[A+4>>2];r:if((0|(I=T2[U>>2]))<1)A2=0;else for(K=U+12|0,S=j2[U+308>>2],A2=1;;){if(y=z2(_-j2[K-8>>2]),X=z2(y*y),y=z2(L-j2[K-4>>2]),X=z2(X+z2(y*y)),y=z2(P-j2[K>>2]),S>=z2(X+z2(y*y)))break r;if(K=K+16|0,A2=(0|(z=z+1|0))<(0|I),(0|I)==(0|z))break;}r:{e:{if(j2[U+304>>2]==z2(0)&&P==j2[U+300>>2]&&L==j2[U+296>>2]){if(!(_==j2[U+292>>2]|A2))break e;break r;}if(A2)break r;}T2[U+304>>2]=0,j2[U+296>>2]=L,j2[U+300>>2]=P,p2[U+356|0]=1,j2[U+292>>2]=_,T2[(I=(I<<4)+U|0)+16>>2]=0,j2[I+8>>2]=L,j2[I+12>>2]=P,j2[I+4>>2]=_,I=(T2[U>>2]<<4)+U|0,T2[I+96>>2]=0,j2[I+88>>2]=a2,j2[I+92>>2]=q,j2[I+84>>2]=e2,I=(T2[U>>2]<<4)+U|0,T2[I+176>>2]=0,j2[I+168>>2]=n2,j2[I+172>>2]=$,j2[I+164>>2]=i2,T2[U>>2]=T2[U>>2]+1,U=T2[A+4>>2];}if(!N0(U))break f;if(X=j2[U+276>>2],T=j2[U+280>>2],y=j2[U+284>>2],!(z2(z2(z2(X*X)+z2(T*T))+z2(y*y))>z2(9999999747378752e-20)))break f;if(!p)break f;S=j2[U+288>>2],p=p-1|0;}j2[a+164>>2]=H,X=z2(0),T=z2(0),y=z2(0),(S=z2(z2(z2(O*O)+z2(r2*r2))+z2(l2*l2)))>=z2(14210854715202004e-30)&&(y=z2(z2(1)/z2(_2(S))),T=z2(l2*y),X=z2(r2*y),s2=z2(O*y),y=j),j2[a+132>>2]=s2,j2[a+144>>2]=y,j2[a+140>>2]=T,j2[a+136>>2]=X,z=0,z2(-j2[a+172>>2])<=z2(z2(z2(o*s2)+z2(c*X))+z2(b*T))||(N0(A=T2[A+4>>2]),i=T2[A+260>>2],e=T2[A+264>>2],A=T2[(f=A+268|0)+4>>2],T2[(r=a+156|0)>>2]=T2[f>>2],T2[r+4>>2]=A,T2[a+148>>2]=i,T2[a+152>>2]=e,z=1);}return L2=32+x|0,0|z;}function p0(A){return 2;}function T0(A){return 3;}function S0(A){return 1;}function j0(A,f,r){var e,i,a,n,o=0,b=0,t=0,c=0,u=0;if(L2=t=L2-32|0,n=S2[A+68|0],a=T2[(i=n?r:f)+4>>2],e=T2[a+24>>2],(0|(u=T2[A+52>>2]))<(0|e)){if(T2[A+56>>2]<(0|e)){if(e&&(T2[5498]=T2[5498]+1,(o=K2(19+(e<<2)|0))&&(T2[(c=o+19&-16)-4>>2]=o)),1<=(0|u))for(o=u;T2[b+c>>2]=T2[T2[A+60>>2]+b>>2],b=b+4|0,o=o-1|0;);(o=T2[A+60>>2])&&S2[A- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[o-4>>2])),T2[A+60>>2]=c,T2[A+56>>2]=e,p2[A- -64|0]=1;}for(b=u<<2,o=e-u|0;b=b+4|(T2[T2[A+60>>2]+b>>2]=0),o=o-1|0;);}if(1<=(0|(T2[A+52>>2]=e)))for(f=n?f:r,o=64,c=b=0;T2[a+72>>2]?T2[T2[A+60>>2]+b>>2]=0:(r=T2[T2[a+32>>2]+o>>2],T2[28+t>>2]=c,T2[24+t>>2]=-1,T2[8+t>>2]=i,u=T2[i+12>>2],T2[16+t>>2]=T2[i+8>>2],T2[20+t>>2]=u,T2[12+t>>2]=r,r=T2[A+4>>2],r=0|n1[T2[T2[r>>2]+8>>2]](r,8+t|0,f,T2[A+72>>2],1),T2[T2[A+60>>2]+b>>2]=r),o=o+80|0,b=b+4|0,(0|(c=c+1|0))!=(0|e););L2=32+t|0;}function P0(A){var f,r=0,e=0;if(T2[(A|=0)>>2]=13820,1<=(0|(e=T2[A+52>>2])))for(;(f=T2[T2[A+60>>2]+r>>2])&&(n1[T2[T2[f>>2]>>2]](f),f=T2[A+4>>2],n1[T2[T2[f>>2]+60>>2]](f,T2[T2[A+60>>2]+r>>2])),r=r+4|0,e=e-1|0;);return (r=T2[A+60>>2])&&S2[A- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+60>>2]=0,T2[A+52>>2]=0,T2[A+56>>2]=0,p2[A- -64|0]=1,(r=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+40>>2]=0,p2[A+44|0]=1,T2[(r=A+32|0)>>2]=0,T2[r+4>>2]=0,(r=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+20>>2]=0,p2[A+24|0]=1,T2[(r=A+12|0)>>2]=0,(T2[r+4>>2]=0)|A;}function z0(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k=0,l=0,s=0,v=0,d=z2(0),B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=z2(0),Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=z2(0),N=z2(0),V=z2(0),J=z2(0),M=z2(0),I=z2(0),x=z2(0),y=z2(0),U=z2(0);if(L2=l=L2-160|0,a=S2[A+68|0],n=T2[(o=a?r:f)+4>>2],T2[n+76>>2]!=T2[A+80>>2]){if(1<=(0|(v=T2[A+52>>2])))for(;(s=T2[T2[A+60>>2]+k>>2])&&(n1[T2[T2[s>>2]>>2]](s),s=T2[A+4>>2],n1[T2[T2[s>>2]+60>>2]](s,T2[T2[A+60>>2]+k>>2])),k=k+4|0,v=v-1|0;);j0(A,f,r),T2[A+80>>2]=T2[n+76>>2];}if(s=T2[A+52>>2]){if(v=T2[n+72>>2],T2[148+l>>2]=i,T2[144+l>>2]=e,T2[136+l>>2]=a=a?f:r,T2[132+l>>2]=o,T2[128+l>>2]=13860,T2[156+l>>2]=T2[A+72>>2],T2[152+l>>2]=T2[A+60>>2],T2[140+l>>2]=T2[A+4>>2],(0|(k=T2[A+32>>2]))<=-1){for(T2[A+36>>2]<=-1&&((f=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+36>>2]=0,T2[A+40>>2]=0,p2[A+44|0]=1),s=k<<2;s=s+4|(T2[T2[A+40>>2]+s>>2]=0),(f=k)>>>0<=(k=f+1|0)>>>0;);s=T2[A+52>>2];}if(1<=((T2[A+32>>2]=0)|s))for(c=A+28|0,r=0;;){if(f=T2[T2[A+60>>2]+(r<<2)>>2]){if(n1[T2[T2[f>>2]+16>>2]](f,c),1<=(0|(k=T2[A+32>>2])))for(f=s=0;e=T2[T2[A+40>>2]+s>>2],T2[e+844>>2]&&(T2[i+4>>2]=e,b=T2[T2[i+8>>2]+8>>2],t=T2[e+836>>2],u=e,e=T2[T2[i+12>>2]+8>>2],m0(u,((k=(0|b)==(0|t))?t:e)+4|0,(k?e:b)+4|0),T2[i+4>>2]=0,k=T2[A+32>>2]),s=s+4|0,(0|(f=f+1|0))<(0|k););if((0|k)<=-1)for(T2[A+36>>2]<=-1&&((f=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),p2[A+44|0]=1,T2[A+36>>2]=0,T2[A+40>>2]=0),s=k<<2;s=s+4|(T2[T2[A+40>>2]+s>>2]=0),(f=k)>>>0<=(k=f+1|0)>>>0;);T2[A+32>>2]=0,s=T2[A+52>>2];}if(!((0|(r=r+1|0))<(0|s)))break;}if(v){if(f=T2[o+12>>2],h=j2[f+52>>2],Z=j2[f+56>>2],r=T2[a+12>>2],Y=j2[r+52>>2],R=j2[r+56>>2],d=j2[f+20>>2],B=j2[f+36>>2],F=j2[r+20>>2],W=j2[r+36>>2],m=j2[r+24>>2],Q=j2[f+24>>2],N=j2[r+40>>2],g=j2[f+40>>2],V=j2[r+32>>2],w=j2[f+32>>2],J=j2[r>>2],G=j2[f>>2],M=j2[r+16>>2],C=j2[f+16>>2],I=j2[f+48>>2],x=j2[r+48>>2],E=j2[f+4>>2],y=j2[r+4>>2],U=j2[r+8>>2],D=j2[f+8>>2],T2[92+l>>2]=0,T2[76+l>>2]=0,T2[60+l>>2]=0,j2[72+l>>2]=z2(z2(D*U)+z2(Q*m))+z2(g*N),j2[68+l>>2]=z2(z2(D*y)+z2(Q*F))+z2(g*W),j2[56+l>>2]=z2(z2(E*U)+z2(d*m))+z2(B*N),j2[52+l>>2]=z2(z2(E*y)+z2(d*F))+z2(B*W),h=z2(-h),j2[88+l>>2]=z2(z2(z2(Q*h)-z2(D*I))-z2(g*Z))+z2(z2(z2(D*x)+z2(Q*Y))+z2(g*R)),j2[84+l>>2]=z2(z2(z2(d*h)-z2(E*I))-z2(B*Z))+z2(z2(z2(E*x)+z2(d*Y))+z2(B*R)),T2[44+l>>2]=0,j2[32+l>>2]=z2(z2(G*J)+z2(C*M))+z2(w*V),j2[64+l>>2]=z2(z2(D*J)+z2(Q*M))+z2(g*V),j2[48+l>>2]=z2(z2(E*J)+z2(d*M))+z2(B*V),j2[40+l>>2]=z2(z2(G*U)+z2(C*m))+z2(w*N),j2[36+l>>2]=z2(z2(G*y)+z2(C*F))+z2(w*W),j2[80+l>>2]=z2(z2(z2(C*h)-z2(G*I))-z2(w*Z))+z2(z2(z2(G*x)+z2(C*Y))+z2(w*R)),f=T2[a+4>>2],n1[T2[T2[f>>2]+8>>2]](f,32+l|0,112+l|0,96+l|0),d=j2[i+32>>2],B=z2(j2[112+l>>2]-d),j2[112+l>>2]=B,Q=z2(j2[116+l>>2]-d),j2[116+l>>2]=Q,g=z2(j2[120+l>>2]-d),j2[120+l>>2]=g,w=z2(d+j2[96+l>>2]),j2[96+l>>2]=w,G=z2(d+j2[100+l>>2]),j2[100+l>>2]=G,d=z2(d+j2[104+l>>2]),j2[104+l>>2]=d,e=T2[v>>2]){if(f=T2[A+16>>2],(0|(k=T2[A+12>>2]))<=-1)for((0|f)<=-1&&((f=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+16>>2]=0,T2[A+20>>2]=0,p2[A+24|0]=1,f=0),s=k<<2;s=s+4|(T2[T2[A+20>>2]+s>>2]=0),(r=k)>>>0<=(k=r+1|0)>>>0;);if(((T2[A+12>>2]=k=0)|f)<=63&&(T2[5498]=T2[5498]+1,s=0,(f=K2(275))&&(T2[(s=f+19&-16)-4>>2]=f),(f=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]),k=T2[A+12>>2]),T2[A+20>>2]=s,T2[A+16>>2]=64,p2[A+24|0]=1,f=64),(0|f)==(0|k))if((0|(i=f<<1))<=(0|f))k=f;else {for(k=0,T2[5498]=T2[5498]+1,(r=K2(19+(f<<3)|(v=0)))&&(T2[(v=r+19&-16)-4>>2]=r),s=f;T2[k+v>>2]=T2[T2[A+20>>2]+k>>2],k=k+4|0,s=s-1|0;);(r=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),f=T2[A+12>>2]),k=f,T2[A+20>>2]=v,T2[A+16>>2]=i,p2[A+24|0]=1;}for(T2[T2[A+20>>2]+(k<<2)>>2]=e,k=k+1|0;;){if(T2[A+12>>2]=s=k-1|0,i=T2[A+20>>2],e=T2[i+(s<<2)>>2],w>=j2[e>>2]){if(B<=j2[e+16>>2]){if(G>=j2[e+4>>2]){if(Q<=j2[e+20>>2]){if(d>=j2[e+8>>2]){if(g<=j2[e+24>>2]){if(T2[e+40>>2]){if((0|s)==(0|(r=T2[A+16>>2])))if((0|(r=s?s<<1:1))<(0|k))r=s;else {if(i=0,r&&(T2[5498]=T2[5498]+1,(f=K2(19+(r<<2)|0))&&(T2[(i=f+19&-16)-4>>2]=f)),2<=(0|k))for(f=k-1|0,k=0;T2[i+k>>2]=T2[T2[A+20>>2]+k>>2],k=k+4|0,f=f-1|0;);(f=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]),s=T2[A+12>>2]),T2[A+20>>2]=i,p2[A+24|0]=1,T2[A+16>>2]=r;}if(T2[A+12>>2]=f=s+1|0,T2[(s<<2)+i>>2]=T2[e+36>>2],(0|f)==(0|r))if((0|(v=r?r<<1:1))<=(0|r))f=r;else {if(i=0,v&&(T2[5498]=T2[5498]+1,(f=K2(19+(v<<2)|0))&&(T2[(i=f+19&-16)-4>>2]=f)),1<=(0|r))for(k=0,s=r;T2[i+k>>2]=T2[T2[A+20>>2]+k>>2],k=k+4|0,s=s-1|0;);f=r,(r=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),f=T2[A+12>>2]),T2[A+20>>2]=i,p2[A+24|0]=1,T2[A+16>>2]=v;}T2[A+12>>2]=k=f+1|0,T2[T2[A+20>>2]+(f<<2)>>2]=T2[e+40>>2];}else n1[T2[T2[128+l>>2]+12>>2]](128+l|0,e),k=T2[A+12>>2];}else k=s;}else k=s;}else k=s;}else k=s;}else k=s;}else k=s;if(!(0<(0|k)))break;}}}else if(!((0|s)<1))for(k=0,v=64;O0(128+l|0,T2[T2[n+32>>2]+v>>2],k),v=v+80|0,(0|s)!=(0|(k=k+1|0)););if(f=T2[A+52>>2],(0|(k=T2[A+32>>2]))<=-1)for(T2[A+36>>2]<=-1&&((r=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+36>>2]=0,T2[A+40>>2]=0,p2[A+44|0]=1),s=k<<2;s=s+4|(T2[T2[A+40>>2]+s>>2]=0),(r=k)>>>0<=(k=r+1|0)>>>0;);if(!(((T2[A+32>>2]=0)|f)<1))for(i=32,v=0;T2[T2[A+60>>2]+v>>2]&&(r=T2[n+32>>2]+i|0,k=T2[r+32>>2],e=T2[o+12>>2],y=j2[e+52>>2],U=j2[e+56>>2],Z=j2[r+16>>2],Y=j2[r+20>>2],R=j2[r+24>>2],d=j2[e+20>>2],B=j2[e+24>>2],F=j2[r-32>>2],W=j2[r-16>>2],m=j2[r>>2],N=j2[r-28>>2],V=j2[r-12>>2],J=j2[r+4>>2],M=j2[r-24>>2],Q=j2[e+36>>2],I=j2[r-8>>2],g=j2[e+40>>2],x=j2[r+8>>2],h=j2[e+48>>2],w=j2[e+8>>2],G=j2[e>>2],C=j2[e+4>>2],E=j2[e+16>>2],D=j2[e+32>>2],T2[92+l>>2]=s=0,T2[76+l>>2]=0,T2[60+l>>2]=0,T2[44+l>>2]=0,j2[72+l>>2]=z2(z2(D*M)+z2(Q*I))+z2(g*x),j2[68+l>>2]=z2(z2(D*N)+z2(Q*V))+z2(g*J),j2[64+l>>2]=z2(z2(D*F)+z2(Q*W))+z2(g*m),j2[56+l>>2]=z2(z2(E*M)+z2(d*I))+z2(B*x),j2[52+l>>2]=z2(z2(E*N)+z2(d*V))+z2(B*J),j2[48+l>>2]=z2(z2(E*F)+z2(d*W))+z2(B*m),j2[40+l>>2]=z2(z2(G*M)+z2(C*I))+z2(w*x),j2[36+l>>2]=z2(z2(G*N)+z2(C*V))+z2(w*J),j2[32+l>>2]=z2(z2(G*F)+z2(C*W))+z2(w*m),j2[88+l>>2]=U+z2(z2(z2(D*Z)+z2(Q*Y))+z2(g*R)),j2[84+l>>2]=y+z2(z2(z2(E*Z)+z2(d*Y))+z2(B*R)),j2[80+l>>2]=h+z2(z2(z2(G*Z)+z2(C*Y))+z2(w*R)),n1[T2[T2[k>>2]+8>>2]](k,32+l|0,112+l|0,96+l|0),r=T2[a+4>>2],n1[T2[T2[r>>2]+8>>2]](r,T2[a+12>>2],16+l|0,l),r=0,j2[112+l>>2]>j2[l>>2]||(r=0,j2[96+l>>2]<j2[16+l>>2]||(r=1)),j2[120+l>>2]>j2[8+l>>2]||j2[104+l>>2]<j2[24+l>>2]||(s=r),!(j2[100+l>>2]<j2[20+l>>2])&s&&!(j2[116+l>>2]>j2[4+l>>2])||(r=T2[T2[A+60>>2]+v>>2],n1[T2[T2[r>>2]>>2]](r),r=T2[A+4>>2],n1[T2[T2[r>>2]+60>>2]](r,T2[T2[A+60>>2]+v>>2]),T2[T2[A+60>>2]+v>>2]=0)),i=i+80|0,v=v+4|0,f=f-1|0;);}L2=160+l|0;}function O0(A,f,r){var e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z=0,Y=0,R=(0);L2=Z=L2-160|0,R=T2[A+4>>2],Y=T2[R+12>>2],s=j2[Y+52>>2],o=j2[Y+56>>2],e=j2[Y+24>>2],b=j2[Y+20>>2],i=j2[Y+40>>2],a=j2[Y+36>>2],t=T2[T2[R+4>>2]+32>>2],D=j2[Y+48>>2],c=j2[Y+8>>2],u=j2[Y>>2],k=j2[Y+4>>2],l=j2[Y+16>>2],n=j2[Y+32>>2],T2[156+Z>>2]=R=0,T2[140+Z>>2]=0,T2[124+Z>>2]=0,Y=t+P2(r,80)|0,v=j2[Y+8>>2],d=j2[Y+24>>2],B=j2[Y+40>>2],j2[136+Z>>2]=z2(z2(n*v)+z2(a*d))+z2(i*B),Q=j2[Y+4>>2],g=j2[Y+20>>2],w=j2[Y+36>>2],j2[132+Z>>2]=z2(z2(n*Q)+z2(a*g))+z2(i*w),j2[120+Z>>2]=z2(z2(l*v)+z2(b*d))+z2(e*B),j2[116+Z>>2]=z2(z2(l*Q)+z2(b*g))+z2(e*w),G=o,o=j2[Y+48>>2],C=j2[Y+52>>2],E=j2[Y+56>>2],j2[152+Z>>2]=G+z2(z2(z2(n*o)+z2(a*C))+z2(i*E)),j2[148+Z>>2]=s+z2(z2(z2(l*o)+z2(b*C))+z2(e*E)),T2[108+Z>>2]=0,G=n,n=j2[Y>>2],s=a,a=j2[Y+16>>2],h=i,i=j2[Y+32>>2],j2[128+Z>>2]=z2(z2(G*n)+z2(s*a))+z2(h*i),j2[112+Z>>2]=z2(z2(l*n)+z2(b*a))+z2(e*i),j2[96+Z>>2]=z2(z2(u*n)+z2(k*a))+z2(c*i),j2[104+Z>>2]=z2(z2(u*v)+z2(k*d))+z2(c*B),j2[100+Z>>2]=z2(z2(u*Q)+z2(k*g))+z2(c*w),j2[144+Z>>2]=D+z2(z2(z2(u*o)+z2(k*C))+z2(c*E)),n1[T2[T2[f>>2]+8>>2]](f,96+Z|0,80+Z|0,Z+64|0),e=j2[T2[A+20>>2]+32>>2],j2[80+Z>>2]=j2[80+Z>>2]-e,j2[84+Z>>2]=j2[84+Z>>2]-e,j2[88+Z>>2]=j2[88+Z>>2]-e,j2[64+Z>>2]=e+j2[64+Z>>2],j2[68+Z>>2]=e+j2[68+Z>>2],j2[72+Z>>2]=e+j2[72+Z>>2],Y=T2[A+8>>2],t=T2[Y+4>>2],n1[T2[T2[t>>2]+8>>2]](t,T2[Y+12>>2],48+Z|0,32+Z|0),Y=0,j2[80+Z>>2]>j2[32+Z>>2]||(Y=0,j2[64+Z>>2]<j2[48+Z>>2]||(Y=1)),j2[88+Z>>2]>j2[40+Z>>2]||j2[72+Z>>2]<j2[56+Z>>2]||(R=Y),j2[84+Z>>2]>j2[36+Z>>2]||1^R|j2[68+Z>>2]<j2[52+Z>>2]||(T2[28+Z>>2]=r,T2[24+Z>>2]=-1,T2[12+Z>>2]=f,f=T2[A+4>>2],T2[8+Z>>2]=f,T2[16+Z>>2]=T2[f+8>>2],e=j2[T2[A+20>>2]+32>>2],T2[20+Z>>2]=96+Z,e>z2(0)?(f=T2[A+12>>2],f=0|n1[T2[T2[f>>2]+8>>2]](f,8+Z|0,T2[A+8>>2],0,2)):(f=T2[(Y=r<<2)+T2[A+24>>2]>>2])||(f=T2[A+12>>2],f=0|n1[T2[T2[f>>2]+8>>2]](f,8+Z|0,T2[A+8>>2],T2[A+28>>2],1),T2[Y+T2[A+24>>2]>>2]=f,f=T2[Y+T2[A+24>>2]>>2]),Y=T2[A+20>>2],R=T2[Y+8>>2],T2[R+8>>2]!=T2[T2[A+4>>2]+8>>2]?(R=T2[Y+12>>2],T2[Y+12>>2]=8+Z,n1[T2[T2[Y>>2]+12>>2]](Y,-1,r)):(T2[Y+8>>2]=8+Z,n1[T2[T2[Y>>2]+8>>2]](Y,-1,r)),n1[T2[T2[f>>2]+8>>2]](f,8+Z|0,T2[A+8>>2],T2[A+16>>2],T2[A+20>>2]),f=T2[A+20>>2],T2[(T2[T2[f+8>>2]+8>>2]==T2[T2[A+4>>2]+8>>2]?8:12)+f>>2]=R),L2=160+Z|0;}function H0(A){var f,r,e,i,a=0,n=0,o=0,b=0,t=0;if(!((0|(f=T2[A+12>>2]))<=(0|(r=T2[A+28>>2])))){A:if(T2[A+32>>2]>=(0|f))o=T2[A+36>>2];else {if(f&&(T2[5498]=T2[5498]+1,(n=K2(19+(f<<2)|0))&&(T2[(o=n+19&-16)-4>>2]=n)),a=T2[A+36>>2],1<=(0|r))for(n=o,t=a,b=r;T2[n>>2]=T2[t>>2],n=n+4|0,t=t+4|0,b=b-1|0;);else if(!a){T2[A+36>>2]=o,T2[A+32>>2]=f,p2[A+40|0]=1;break A;}S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[A+36>>2]=o,p2[A+40|0]=1,T2[A+32>>2]=f;}if(d2((r<<2)+o|0,0,f-r<<2),e=(T2[A+28>>2]=f)<<2,(0|(a=T2[A+48>>2]))<(0|f)){A:if(T2[A+52>>2]>=(0|f))o=T2[A+56>>2];else {if(o=0,f&&(T2[5498]=T2[5498]+1,(n=K2(16+(3|e)|0))&&(T2[(o=n+19&-16)-4>>2]=n)),i=T2[A+56>>2],1<=(0|a))for(n=o,t=i,b=a;T2[n>>2]=T2[t>>2],n=n+4|0,t=t+4|0,b=b-1|0;);else if(!i){T2[A+56>>2]=o,T2[A+52>>2]=f,p2[A+60|0]=1;break A;}S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2])),T2[A+56>>2]=o,p2[A+60|0]=1,T2[A+52>>2]=f;}d2((a<<2)+o|0,0,f-a<<2);}if(1<=(0|(T2[A+48>>2]=f))&&(d2(T2[A+36>>2],255,e),d2(T2[A+56>>2],255,e)),!((0|r)<1))for(t=T2[A+56>>2],n=T2[A+16>>2],o=T2[A+36>>2],b=0;a=T2[n>>2]|T2[n+4>>2]<<16,a=P2((a=(a<<15^-1)+a|0)>>>10^a,9),a=o+((T2[A+12>>2]-1&((a=((a^=a>>>6)<<11^-1)+a|0)>>>16^a))<<2)|0,T2[t>>2]=T2[a>>2],n=n+12|0,t=t+4|0,(0|r)!=(0|(b=(T2[a>>2]=b)+1|0)););}}function _0(A){return T2[(A|=0)+16>>2];}function L0(A){var f,r,e,i=0,a=0,n=0;if((i=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2])),T2[A+16>>2]=0,p2[A+20|0]=1,T2[(i=A+8|0)>>2]=0,T2[i+4>>2]=0,(i=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2])),T2[A+36>>2]=0,p2[A+40|0]=1,T2[(i=A+28|0)>>2]=0,T2[i+4>>2]=0,(i=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2])),T2[A+56>>2]=0,p2[A+60|0]=1,T2[(i=A+48|0)>>2]=0,T2[i+4>>2]=0,T2[A+12>>2]<=1){if(T2[5498]=T2[5498]+1,(i=K2(43))&&(T2[(n=i+19&-16)-4>>2]=i),1<=(0|(a=T2[A+8>>2])))for(i=0;f=T2[A+16>>2]+i|0,e=T2[4+f>>2],T2[(r=i+n|0)>>2]=T2[f>>2],T2[4+r>>2]=e,T2[8+r>>2]=T2[8+f>>2],i=i+12|0,a=a-1|0;);(i=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2])),T2[A+16>>2]=n,p2[A+20|0]=1,T2[A+12>>2]=2;}H0(A);}function K0(A){var f,r,e=0,i=0,a=0;if(T2[(A|=0)>>2]=14028,e=T2[A+84>>2],1<=(0|(i=T2[e+(a=8)>>2]))){for(;(f=T2[T2[e+16>>2]+a>>2])&&(n1[T2[T2[f>>2]>>2]](f),r=T2[A+4>>2],n1[T2[T2[r>>2]+60>>2]](r,f)),a=a+12|0,i=i-1|0;);e=T2[A+84>>2];}return L0(e),e=T2[A+84>>2],n1[T2[T2[e>>2]>>2]](e),(e=T2[A+84>>2])&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),(e=T2[A+100>>2])&&S2[A+104|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+100>>2]=0,p2[A+104|0]=1,T2[(e=A+92|0)>>2]=0,T2[e+4>>2]=0,P0(A),0|A;}function q0(A,f,r,e,i){return z2(z2(1));}function $0(A,f){A|=0,f|=0;var r,e=0,i=0,a=0,n=0;if((a=T2[A+12>>2])&&S2[A+8|0]){if((0|(i=T2[f+4>>2]))==T2[f+8>>2]&&!((0|(r=i?i<<1:1))<=(0|i))){if(r&&(T2[5498]=T2[5498]+1,(e=K2(19+(r<<2)|0))&&(T2[(n=e+19&-16)-4>>2]=e)),1<=(0|i))for(a=0,e=i;T2[a+n>>2]=T2[T2[f+12>>2]+a>>2],a=a+4|0,e=e-1|0;);(e=T2[f+12>>2])&&S2[f+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]),i=T2[f+4>>2]),T2[f+12>>2]=n,p2[f+16|0]=1,T2[f+8>>2]=r,a=T2[A+12>>2];}T2[f+4>>2]=i+1,T2[T2[f+12>>2]+(i<<2)>>2]=a;}}function A4(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t=z2(0),c=z2(0),u=z2(0),k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=z2(0),B=z2(0),Q=0,g=z2(0),w=z2(0),G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=z2(0),Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=z2(0),N=0;L2=e=L2-32|0,Q=T2[A+8>>2],D=j2[Q+80>>2],u=j2[Q+64>>2],l=z2(D-u),G=j2[Q+100>>2],s=j2[Q+68>>2],t=z2(G-s),h=j2[Q+84>>2],B=z2(h-s),R=j2[Q+96>>2],k=z2(R-u),d=z2(z2(l*t)-z2(B*k)),E=j2[Q+104>>2],F=j2[Q+72>>2],c=z2(E-F),m=j2[Q+88>>2],g=z2(m-F),t=z2(z2(B*c)-z2(g*t)),k=z2(z2(g*k)-z2(l*c)),c=z2(z2(d*d)+z2(z2(t*t)+z2(k*k)));A:if(c>=z2(14210854715202004e-30)&&(N=T2[A+4>>2],W=z2(j2[N+36>>2]*j2[N+20>>2]),v=z2(W+j2[A+12>>2]),c=z2(z2(1)/z2(_2(c))),t=z2(t*c),w=z2(j2[f+48>>2]-j2[f+112>>2]),C=z2(j2[f+52>>2]-j2[f+116>>2]),a=z2(j2[f+56>>2]-j2[f+120>>2]),Z=z2(z2(z2(w*j2[f+64>>2])+z2(C*j2[f+80>>2]))+z2(a*j2[f+96>>2])),o=z2(Z-u),k=z2(k*c),Y=z2(z2(z2(w*j2[f+68>>2])+z2(C*j2[f+84>>2]))+z2(a*j2[f+100>>2])),b=z2(Y-s),d=z2(d*c),w=z2(z2(z2(w*j2[f+72>>2])+z2(C*j2[f+88>>2]))+z2(a*j2[f+104>>2])),C=z2(w-F),(c=z2(z2(z2(t*o)+z2(k*b))+z2(d*C)))<z2(0)&&(d=z2(-d),k=z2(-k),c=z2(-c),t=z2(-t)),c<v)){l=z2(z2(C*z2(z2(l*k)-z2(B*t)))+z2(z2(o*z2(z2(B*d)-z2(g*k)))+z2(b*z2(z2(g*t)-z2(l*d))))),B=z2(R-D),g=z2(G-h),C=z2(z2(w-m)*z2(z2(B*k)-z2(g*t))),a=z2(g*d),g=z2(E-m),B=z2(C+z2(z2(z2(Z-D)*z2(a-z2(g*k)))+z2(z2(Y-h)*z2(z2(g*t)-z2(B*d)))));f:{r:{if(u=z2(u-R),s=z2(s-G),g=z2(z2(w-E)*z2(z2(u*k)-z2(s*t))),C=z2(s*d),s=z2(F-E),!((u=z2(g+z2(z2(z2(Z-R)*z2(C-z2(s*k)))+z2(z2(Y-G)*z2(z2(s*t)-z2(u*d))))))>z2(0)&&l>z2(0)&&B>z2(0))){if(!(u<=z2(0)))break r;if(!(l<=z2(0)))break r;if(!(B<=z2(0)))break r;}E=z2(w-z2(c*d)),D=z2(Y-z2(c*k)),h=z2(Z-z2(c*t)),R=z2(v*v);break f;}if((0|n1[T2[T2[Q>>2]+100>>2]](Q))<1)break A;for(R=z2(v*v),Q=N=0;n=T2[A+8>>2],n1[T2[T2[n>>2]+104>>2]](n,Q,e+16|0,e),c=z2(0),F=j2[e+16>>2],v=z2(Z-F),G=z2(j2[e>>2]-F),g=j2[e+20>>2],u=z2(Y-g),s=z2(j2[e+4>>2]-g),m=j2[e+24>>2],l=z2(w-m),B=z2(j2[e+8>>2]-m),(C=z2(z2(z2(v*G)+z2(u*s))+z2(l*B)))>z2(0)&&(C<(c=z2(z2(z2(G*G)+z2(s*s))+z2(B*B)))?(c=z2(C/c),l=z2(l-z2(B*c)),u=z2(u-z2(s*c)),v=z2(v-z2(G*c))):(l=z2(l-B),u=z2(u-s),v=z2(v-G),c=z2(1))),z2(z2(z2(v*v)+z2(u*u))+z2(l*l))<R&&(h=z2(F+z2(G*c)),D=z2(g+z2(s*c)),N=1,E=z2(m+z2(B*c))),n=T2[A+8>>2],Q=Q+1|0,(0|n1[T2[T2[n>>2]+100>>2]](n))>(0|Q););if(!N)break A;}c=z2(Z-h),v=z2(Y-D),u=z2(w-E),(l=z2(z2(z2(c*c)+z2(v*v))+z2(u*u)))<R&&(l>z2(1.1920928955078125e-7)&&(t=z2(_2(l)),W=z2(W-t),t=z2(z2(1)/t),d=z2(u*t),k=z2(v*t),t=z2(c*t)),c=z2(-W),i?(v=j2[f+72>>2],u=j2[f+64>>2],l=j2[f+68>>2],Z=j2[f+88>>2],Y=j2[f+80>>2],w=j2[f+84>>2],G=j2[f+104>>2],s=j2[f+96>>2],B=j2[f+100>>2],T2[e+28>>2]=0,R=z2(z2(z2(t*s)+z2(k*B))+z2(d*G)),j2[e+24>>2]=-R,F=z2(z2(z2(t*Y)+z2(k*w))+z2(d*Z)),j2[e+20>>2]=-F,t=z2(z2(z2(u*t)+z2(l*k))+z2(v*d)),j2[e+16>>2]=-t,T2[e+12>>2]=0,j2[e+8>>2]=z2(z2(z2(z2(h*s)+z2(D*B))+z2(E*G))+j2[f+120>>2])-z2(W*R),j2[e+4>>2]=z2(z2(z2(z2(h*Y)+z2(D*w))+z2(E*Z))+j2[f+116>>2])-z2(W*F),j2[e>>2]=z2(z2(z2(z2(h*u)+z2(D*l))+z2(E*v))+j2[f+112>>2])-z2(W*t)):(T2[e+28>>2]=0,W=j2[f+96>>2],v=j2[f+100>>2],u=j2[f+104>>2],j2[e+24>>2]=z2(z2(t*W)+z2(k*v))+z2(d*u),l=j2[f+80>>2],Z=j2[f+84>>2],Y=j2[f+88>>2],j2[e+20>>2]=z2(z2(t*l)+z2(k*Z))+z2(d*Y),w=j2[f+64>>2],s=z2(w*t),t=j2[f+68>>2],s=z2(s+z2(t*k)),k=j2[f+72>>2],j2[e+16>>2]=s+z2(k*d),T2[e+12>>2]=0,j2[e+8>>2]=z2(z2(z2(h*W)+z2(D*v))+z2(E*u))+j2[f+120>>2],j2[e+4>>2]=z2(z2(z2(h*l)+z2(D*Z))+z2(E*Y))+j2[f+116>>2],j2[e>>2]=z2(z2(z2(h*w)+z2(D*t))+z2(E*k))+j2[f+112>>2]),n1[T2[T2[r>>2]+16>>2]](r,e+16|0,e,c));}L2=e+32|0;}function f4(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z=0,Y=z2(0),R=z2(0),F=z2(0),W=0,m=z2(0),N=z2(0),V=z2(0),J=z2(0),M=z2(0),I=z2(0),x=z2(0),y=0,U=z2(0),X=z2(0),p=z2(0),T=0,S=z2(0),j=z2(0),P=z2(0),z=z2(0),O=z2(0),H=z2(0),_=z2(0),L=z2(0),K=z2(0),q=z2(0),$=0,A2=z2(0),f2=z2(0),r2=z2(0),e2=z2(0),i2=z2(0),a2=z2(0),n2=z2(0),o2=z2(0),b2=z2(0),t2=z2(0),c2=0,u2=0,k2=(z2(0)),l2=0,s2=(z2(0)),v2=0,d2=(0);j2[48+(L2=Z=L2-448|0)>>2]=j2[f>>2],j2[Z>>2]=j2[f+64>>2],e=T2[f+8>>2],T2[52+Z>>2]=T2[f+4>>2],T2[56+Z>>2]=e,i=T2[(e=f+68|0)+4>>2],T2[4+Z>>2]=T2[e>>2],T2[8+Z>>2]=i,e=T2[f+20>>2],T2[64+Z>>2]=T2[f+16>>2],T2[68+Z>>2]=e,i=T2[(e=f+80|0)+4>>2],T2[16+Z>>2]=T2[e>>2],T2[20+Z>>2]=i,j2[72+Z>>2]=j2[f+24>>2],j2[24+Z>>2]=j2[f+88>>2],j2[80+Z>>2]=j2[f+32>>2],Y=j2[f+96>>2],i=T2[(e=f+36|0)+4>>2],T2[84+Z>>2]=T2[e>>2],T2[88+Z>>2]=i,j2[40+Z>>2]=j2[f+104>>2],j2[36+Z>>2]=j2[f+100>>2],j2[32+Z>>2]=Y,e=T2[A+4>>2],Y=j2[e+40>>2],R=j2[e+44>>2],M=j2[e+36>>2],U=z2(n1[T2[T2[e>>2]+48>>2]](e)),X=z2(n1[T2[T2[e>>2]+48>>2]](e)),V=z2(n1[T2[T2[e>>2]+48>>2]](e)),A=T2[A+8>>2],F=j2[A+44>>2],J=j2[A+40>>2],N=j2[A+36>>2],I=z2(n1[T2[T2[A>>2]+48>>2]](A)),m=z2(n1[T2[T2[A>>2]+48>>2]](A)),P=z2(n1[T2[T2[A>>2]+48>>2]](A)),R=z2(R+V),V=z2(z2(R+R)*z2(.5)),j2[380+Z>>2]=V,Y=z2(Y+X),p=z2(z2(Y+Y)*z2(.5)),j2[376+Z>>2]=p,Y=z2(M+U),x=z2(z2(Y+Y)*z2(.5)),j2[372+Z>>2]=x,Y=z2(J+m),J=z2(z2(Y+Y)*z2(.5)),j2[364+Z>>2]=J,Y=z2(N+I),N=z2(z2(Y+Y)*z2(.5)),j2[360+Z>>2]=N,Y=z2(F+P),I=z2(z2(Y+Y)*z2(.5)),j2[368+Z>>2]=I;A:if(M=z2(j2[(i=f+112|0)>>2]-j2[f+48>>2]),s2=j2[48+Z>>2],U=z2(j2[f+116>>2]-j2[f+52>>2]),Y=j2[64+Z>>2],X=z2(j2[f+120>>2]-j2[f+56>>2]),R=j2[80+Z>>2],P=z2(z2(z2(M*s2)+z2(U*Y))+z2(X*R)),f2=j2[Z>>2],q=j2[16+Z>>2],z=j2[32+Z>>2],A2=z2(z2(z2(s2*f2)+z2(Y*q))+z2(R*z)),a=z2(O2(A2)),n=j2[4+Z>>2],e2=j2[20+Z>>2],o2=j2[36+Z>>2],i2=z2(z2(z2(s2*n)+z2(Y*e2))+z2(R*o2)),b=z2(O2(i2)),o=j2[8+Z>>2],k2=j2[24+Z>>2],k=j2[40+Z>>2],r2=z2(z2(z2(s2*o)+z2(Y*k2))+z2(R*k)),t=z2(O2(r2)),!((R=z2(z2(O2(P))-z2(z2(z2(x+z2(N*a))+z2(J*b))+z2(I*t))))>z2(0)||(Y=j2[52+Z>>2],m=j2[68+Z>>2],S=j2[84+Z>>2],F=z2(z2(z2(M*Y)+z2(U*m))+z2(X*S)),L=z2(z2(z2(Y*o)+z2(m*k2))+z2(S*k)),c=z2(O2(L)),K=z2(z2(z2(Y*n)+z2(m*e2))+z2(S*o2)),a2=z2(O2(K)),S=z2(z2(z2(Y*f2)+z2(m*q))+z2(S*z)),O=z2(O2(S)),Y=z2(-34028234663852886e22),A=e=0,R>z2(-34028234663852886e22)&&(e=P<z2(0),W=48+Z|0,Y=R,A=1),(R=z2(z2(O2(F))-z2(z2(z2(p+z2(N*O))+z2(J*a2))+z2(I*c))))>z2(0)||(j=j2[56+Z>>2],b2=j2[72+Z>>2],n2=j2[88+Z>>2],m=z2(z2(z2(M*j)+z2(U*b2))+z2(X*n2)),H=z2(z2(z2(j*o)+z2(b2*k2))+z2(n2*k)),l=z2(O2(H)),_=z2(z2(z2(j*n)+z2(b2*e2))+z2(n2*o2)),s=z2(O2(_)),j=z2(z2(z2(j*f2)+z2(b2*q))+z2(n2*z)),u=z2(O2(j)),Y<R&&(W=48+Z|4,e=F<z2(0),Y=R,A=2),(R=z2(z2(O2(m))-z2(z2(z2(V+z2(N*u))+z2(J*s))+z2(I*l))))>z2(0)||(Y<R&&(W=48+Z|8,e=m<z2(0),Y=R,A=3),f2=z2(z2(z2(M*f2)+z2(U*q))+z2(X*z)),(R=z2(z2(O2(f2))-z2(N+z2(z2(V*u)+z2(z2(x*a)+z2(p*O))))))>z2(0)||(Y<R&&(e=f2<z2(0),W=Z,Y=R,A=4),f2=z2(z2(z2(M*n)+z2(U*e2))+z2(X*o2)),(R=z2(z2(O2(f2))-z2(J+z2(z2(V*s)+z2(z2(x*b)+z2(p*a2))))))>z2(0)||(Y<R&&(W=4|Z,e=f2<z2(0),Y=R,A=5),M=z2(z2(z2(M*o)+z2(U*k2))+z2(X*k)),(R=z2(z2(O2(M))-z2(I+z2(z2(V*l)+z2(z2(x*t)+z2(p*c))))))>z2(0)||(Y<R&&(W=8|Z,e=M<z2(0),Y=R,A=6),t2=z2(z2(m*S)-z2(F*j)),b=z2(b+z2(9999999747378752e-21)),u=z2(u+z2(9999999747378752e-21)),v=z2(O+z2(9999999747378752e-21)),t=z2(t+z2(9999999747378752e-21)),(R=z2(z2(O2(t2))-z2(z2(I*b)+z2(z2(z2(p*u)+z2(V*v))+z2(J*t)))))>z2(1.1920928955078125e-7)||(f2=z2(s+z2(9999999747378752e-21)),n=z2(a2+z2(9999999747378752e-21)),o=z2(a+z2(9999999747378752e-21)),X=z2(0),s=z2(S*S),a=z2(z2(j*j)+z2(0)),(a2=z2(_2(z2(s+a))))>z2(1.1920928955078125e-7)?(U=z2(0),R=z2(R/a2),M=z2(0),z2(R*z2(1.0499999523162842))>Y&&(e=t2<z2(0),U=z2(S/a2),X=z2(z2(0)/a2),W=0,A=7,Y=R,M=z2(z2(-j)/a2))):(U=z2(0),M=z2(0)),t2=z2(z2(m*K)-z2(F*_)),(R=z2(z2(O2(t2))-z2(z2(I*o)+z2(z2(z2(p*f2)+z2(V*n))+z2(N*t)))))>z2(1.1920928955078125e-7)||(a2=z2(l+z2(9999999747378752e-21)),c=z2(c+z2(9999999747378752e-21)),l=z2(K*K),Q=z2(z2(_*_)+z2(0)),(O=z2(_2(z2(l+Q))))>z2(1.1920928955078125e-7)&&(R=z2(R/O),z2(R*z2(1.0499999523162842))>Y&&(e=t2<z2(0),U=z2(K/O),M=z2(z2(-_)/O),X=z2(z2(0)/O),W=0,A=8,Y=R)),t2=z2(z2(m*L)-z2(F*H)),(R=z2(z2(O2(t2))-z2(z2(J*o)+z2(z2(N*b)+z2(z2(p*a2)+z2(V*c))))))>z2(1.1920928955078125e-7)||(g=z2(L*L),w=z2(z2(H*H)+z2(0)),(O=z2(_2(z2(g+w))))>z2(1.1920928955078125e-7)&&(R=z2(R/O),z2(R*z2(1.0499999523162842))>Y&&(e=t2<z2(0),U=z2(L/O),M=z2(z2(-H)/O),X=z2(z2(0)/O),W=0,A=9,Y=R)),t2=z2(z2(P*j)-z2(m*A2)),(R=z2(z2(O2(t2))-z2(z2(I*n)+z2(z2(z2(x*u)+z2(V*o))+z2(J*c)))))>z2(1.1920928955078125e-7)||(G=z2(A2*A2),(O=z2(_2(z2(G+a))))>z2(1.1920928955078125e-7)&&(R=z2(R/O),z2(R*z2(1.0499999523162842))>Y&&(e=t2<z2(0),U=z2(z2(-A2)/O),M=z2(z2(0)/O),X=z2(j/O),W=0,A=10,Y=R)),O=z2(z2(P*_)-z2(m*i2)),(R=z2(z2(O2(O))-z2(z2(I*v)+z2(z2(z2(x*f2)+z2(V*b))+z2(N*c)))))>z2(1.1920928955078125e-7)||(a=z2(i2*i2),(j=z2(_2(z2(a+Q))))>z2(1.1920928955078125e-7)&&(R=z2(R/j),z2(R*z2(1.0499999523162842))>Y&&(e=O<z2(0),U=z2(z2(-i2)/j),M=z2(z2(0)/j),X=z2(_/j),W=0,A=11,Y=R)),_=z2(z2(P*H)-z2(m*r2)),(R=z2(z2(O2(_))-z2(z2(J*v)+z2(z2(N*n)+z2(z2(x*a2)+z2(V*t))))))>z2(1.1920928955078125e-7)||(j=z2(r2*r2),(m=z2(_2(z2(j+w))))>z2(1.1920928955078125e-7)&&(R=z2(R/m),z2(R*z2(1.0499999523162842))>Y&&(e=_<z2(0),U=z2(z2(-r2)/m),M=z2(z2(0)/m),X=z2(H/m),W=0,A=12,Y=R)),H=z2(z2(F*A2)-z2(P*S)),(R=z2(z2(O2(H))-z2(z2(I*f2)+z2(z2(z2(x*v)+z2(p*o))+z2(J*a2)))))>z2(1.1920928955078125e-7)||((m=z2(_2(z2(z2(s+G)+z2(0)))))>z2(1.1920928955078125e-7)&&(R=z2(R/m),z2(R*z2(1.0499999523162842))>Y&&(e=H<z2(0),U=z2(z2(0)/m),M=z2(A2/m),X=z2(z2(-S)/m),W=0,A=13,Y=R)),A2=z2(z2(F*i2)-z2(P*K)),(R=z2(z2(O2(A2))-z2(z2(I*u)+z2(z2(z2(x*n)+z2(p*b))+z2(N*a2)))))>z2(1.1920928955078125e-7)||((m=z2(_2(z2(z2(l+a)+z2(0)))))>z2(1.1920928955078125e-7)&&(R=z2(R/m),z2(R*z2(1.0499999523162842))>Y&&(e=A2<z2(0),U=z2(z2(0)/m),M=z2(i2/m),X=z2(z2(-K)/m),W=0,A=14,Y=R)),m=z2(z2(F*r2)-z2(P*L)),(R=z2(z2(O2(m))-z2(z2(J*u)+z2(z2(N*f2)+z2(z2(x*c)+z2(p*t))))))>z2(1.1920928955078125e-7))))))))))))))))){f:{r:{if((F=z2(_2(z2(z2(g+j)+z2(0)))))>z2(1.1920928955078125e-7)&&(R=z2(R/F),z2(R*z2(1.0499999523162842))>Y))e=m<z2(0),U=z2(z2(0)/F),M=z2(r2/F),X=z2(z2(-L)/F),A=15;else {if(!A)break A;if(W)break r;R=Y;}m=z2(z2(z2(X*j2[80+Z>>2])+z2(M*j2[84+Z>>2]))+z2(U*n2)),F=z2(z2(z2(s2*X)+z2(M*j2[52+Z>>2]))+z2(U*j2[56+Z>>2])),Y=z2(z2(z2(X*j2[64+Z>>2])+z2(M*j2[68+Z>>2]))+z2(U*b2));break f;}m=j2[W+32>>2],F=j2[W>>2],R=Y,Y=j2[W+16>>2];}if(M=e?z2(-m):m,U=e?z2(-Y):Y,X=e?z2(-F):F,7<=(0|A))j=j2[f+48>>2],s2=j2[f+52>>2],f2=j2[f+56>>2],Y=j2[56+Z>>2],m=j2[80+Z>>2],P=j2[48+Z>>2],A2=j2[64+Z>>2],i2=j2[84+Z>>2],r2=j2[52+Z>>2],L=j2[68+Z>>2],T2[(f=184+Z|0)>>2]=T2[i+8>>2],e=T2[i+4>>2],T2[176+Z>>2]=T2[i>>2],T2[180+Z>>2]=e,F=z2(0),H=j2[Z>>2],N=z2(z2(z2(X*H)+z2(U*q))+z2(M*z))>z2(0)?z2(-N):N,_=j2[4+Z>>2],J=z2(z2(z2(X*_)+z2(U*e2))+z2(M*o2))>z2(0)?z2(-J):J,S=z2(z2(j2[f>>2]+z2(N*z))+z2(J*o2)),z=j2[8+Z>>2],I=z2(z2(z2(X*z)+z2(U*k2))+z2(M*k))>z2(0)?z2(-I):I,K=z2(S+z2(I*k)),S=z2(z2(z2(j2[180+Z>>2]+z2(N*q))+z2(J*e2))+z2(I*k2)),J=z2(z2(z2(j2[176+Z>>2]+z2(N*H))+z2(J*_))+z2(I*z)),q=j2[(A=(48+Z|0)+((0|(f=A-7|0))/3<<24>>24<<2)|0)>>2],N=j2[(f=((0|f)%3<<24>>24<<2)+Z|0)>>2],z=j2[A+16>>2],I=j2[f+16>>2],e2=j2[A+32>>2],H=j2[f+32>>2],_=z2(z2(z2(q*N)+z2(z*I))+z2(e2*H)),(o2=z2(z2(1)-z2(_*_)))<=z2(9999999747378752e-20)||(x=z2(z2(z2(X*P)+z2(U*A2))+z2(M*m))>z2(0)?x:z2(-x),p=z2(z2(z2(X*r2)+z2(U*L))+z2(M*i2))>z2(0)?p:z2(-p),V=z2(z2(z2(X*Y)+z2(U*b2))+z2(M*n2))>z2(0)?V:z2(-V),Y=z2(J-z2(z2(z2(j+z2(x*P))+z2(p*r2))+z2(V*Y))),F=z2(S-z2(z2(z2(s2+z2(x*A2))+z2(p*L))+z2(V*b2))),V=z2(K-z2(z2(z2(f2+z2(x*m))+z2(p*i2))+z2(V*n2))),F=z2(z2(z2(z2(z2(z2(Y*q)+z2(F*z))+z2(V*e2))*_)-z2(z2(z2(Y*N)+z2(F*I))+z2(V*H)))*z2(z2(1)/o2))),j2[184+Z>>2]=K+z2(F*H),j2[180+Z>>2]=S+z2(F*I),j2[176+Z>>2]=J+z2(F*N),T2[284+Z>>2]=0,j2[280+Z>>2]=-M,j2[276+Z>>2]=-U,j2[272+Z>>2]=-X,n1[T2[T2[r>>2]+16>>2]](r,272+Z|0,176+Z|0,R);else {$=f+48|0,f=(0|A)<4?(y=48+Z|0,u2=372+Z|0,W=360+Z|0,R=X,p=U,V=M,Z):(V=z2(-M),p=z2(-U),R=z2(-X),f=i,W=372+(y=Z)|0,u2=360+Z|0,i=$,$=f,48+Z|0),x=z2(z2(z2(R*j2[f>>2])+z2(p*j2[f+16>>2]))+z2(V*j2[f+32>>2])),j2[344+Z>>2]=x,F=z2(z2(z2(R*j2[f+4>>2])+z2(p*j2[f+20>>2]))+z2(V*j2[f+36>>2])),j2[348+Z>>2]=F,l2=1,Y=z2(z2(z2(R*j2[f+8>>2])+z2(p*j2[f+24>>2]))+z2(V*j2[f+40>>2])),j2[352+Z>>2]=Y,Y=z2(O2(Y)),F=z2(O2(F));f:{if((x=z2(O2(x)))<F){if(l2=0,Y<F){v2=2,e=1;break f;}}else {if(Y<x){v2=2,e=0;break f;}l2=0;}v2=1,e=2;}Y=j2[(e<<=2)+W>>2],x=z2(Y*j2[f+e>>2]),F=z2(j2[i>>2]-j2[$>>2]),x=j2[e+(344+Z|0)>>2]<z2(0)?(A2=z2(z2(j2[i+8>>2]-j2[$+8>>2])+z2(Y*j2[f+(32|e)>>2])),i2=z2(F+x),z2(z2(j2[i+4>>2]-j2[$+4>>2])+z2(Y*j2[f+(16|e)>>2]))):(A2=z2(z2(j2[i+8>>2]-j2[$+8>>2])-z2(Y*j2[f+(32|e)>>2])),i2=z2(F-x),z2(z2(j2[i+4>>2]-j2[$+4>>2])-z2(Y*j2[f+(16|e)>>2]))),e=1,i=2;f:{r:{e:switch(0|(d2=((0|A)<4?-1:-4)+A|0)){case 0:break f;case 1:break e;default:break r;}e=0;break f;}i=1,e=0;}Y=j2[(i=(T=i<<2)+y|0)>>2],F=j2[i+16>>2],J=j2[i+32>>2],b2=z2(z2(z2(i2*Y)+z2(x*F))+z2(A2*J)),I=j2[(d=(i=l2<<2)+f|0)>>2],m=j2[16+d>>2],P=j2[32+d>>2],n2=z2(z2(z2(Y*I)+z2(F*m))+z2(J*P)),L=j2[i+W>>2],K=z2(n2*L),z=z2(b2+K),S=j2[(B=(i=v2<<2)+f|0)>>2],q=j2[16+B>>2],e2=j2[32+B>>2],H=z2(z2(z2(Y*S)+z2(F*q))+z2(J*e2)),o2=j2[i+W>>2],Y=z2(H*o2),r2=z2(z-Y),F=j2[(e=(i=e<<2)+y|0)>>2],J=j2[e+16>>2],N=j2[e+32>>2],_=z2(z2(z2(i2*F)+z2(x*J))+z2(A2*N)),j=z2(z2(z2(F*I)+z2(J*m))+z2(N*P)),k2=z2(j*L),m=z2(_+k2),q=z2(z2(z2(F*S)+z2(J*q))+z2(N*e2)),S=z2(q*o2),I=z2(m-S),L=z2(z+Y),m=z2(m+S),F=z2(b2-K),P=z2(F+Y),z=z2(_-k2),N=z2(z+S),K=z2(F-Y),J=j2[T+u2>>2],F=j2[i+u2>>2],Y=z2(-F);f:{r:{e:{i:{a:{n:{o:{b:{t:{c:{u:{k:{l:{s:{S=z2(z-S);v:{if(!(y=F>z2(-S))){if(T=1,e=i=272+Z|(W=0),F>z2(-N))break v;break k;}if(j2[276+Z>>2]=K,j2[272+Z>>2]=S,e=272+Z|8,T=2,F>z2(-N))break s;}if(j2[(i=e)>>2]=Y,j2[i+4>>2]=K+z2(z2(Y-S)*z2(z2(P-K)/z2(N-S))),e=i+8|0,y){W=T,i=e;break k;}j2[i+12>>2]=P,j2[i+8>>2]=N,W=T+1|0;break l;}j2[284+Z>>2]=P,j2[280+Z>>2]=N,W=2;}if(i=e+8|0,e=0,F>z2(-m))break t;break u;}if(e=1,!(F>z2(-m)))break c;}if(j2[i>>2]=Y,j2[i+4>>2]=P+z2(z2(Y-N)*z2(z2(L-P)/z2(m-N))),8&(W=W+1|0)){e=W;break f;}if(i=i+8|0,e)break t;}if(e=1,F>z2(-I))break b;break o;}if(j2[i+4>>2]=L,j2[i>>2]=m,8&(W=W+1|0)){e=W;break f;}if(i=i+8|0,e=0,F>z2(-I))break n;}if(j2[i>>2]=Y,j2[i+4>>2]=L+z2(z2(Y-m)*z2(z2(r2-L)/z2(I-m))),8&(W=W+1|0)){e=W;break f;}if(i=i+8|0,e)break n;}if(y)break a;if(((e=0)|W)<=0)break e;break i;}if(j2[i+4>>2]=r2,j2[i>>2]=I,8&(W=W+1|0)){e=W;break f;}if(y)break i;i=i+8|0;}if(j2[i>>2]=Y,j2[i+4>>2]=r2+z2(z2(Y-I)*z2(z2(K-r2)/z2(S-I))),8&(e=W=W+1|0))break f;}for(C=272+Z|4,i=272+Z|(e=0),y=176+Z|0;;){if((Y=j2[i>>2])<F){if(j2[y>>2]=Y,j2[y+4>>2]=j2[i+4>>2],8&(e=e+1|0))break e;y=y+8|0,Y=j2[i>>2];}if(T=i+8|0,(Y<F|0)!=((I=j2[((c2=1<(0|W))?T:272+Z|0)>>2])<F|0)){if(m=j2[(c2?i+12|0:C)>>2],N=j2[i+4>>2],j2[y>>2]=F,j2[y+4>>2]=N+z2(z2(F-Y)*z2(z2(m-N)/z2(I-Y))),8&(e=e+1|0))break e;y=y+8|0;}if(W=W-1|0,i=T,!c2)break;}if((0|e)<1)e=0;else {for(N=z2(-J),E=176+Z|4,W=272+Z|(y=0),i=176+Z|0;;){if(Y=j2[(T=i+4|0)>>2],(F=z2(-Y))<J){if(j2[W>>2]=j2[i>>2],j2[W+4>>2]=j2[T>>2],8&(y=y+1|0)){e=y;break r;}Y=j2[T>>2],F=z2(-Y),W=W+8|0;}if(T=i+8|0,I=j2[((c2=1<(0|e))?i+12|0:E)>>2],(F<J|0)!=(J>z2(-I)|0)){if(m=j2[(c2?T:176+Z|0)>>2],F=j2[i>>2],j2[W+4>>2]=N,j2[W>>2]=F+z2(z2(N-Y)*z2(z2(m-F)/z2(I-Y))),8&(y=y+1|0)){e=y;break r;}W=W+8|0;}if(e=e-1|0,i=T,!c2)break;}if(!(((e=0)|y)<1))for(i=272+Z|0,W=176+Z|0;;){if((F=j2[(T=i+4|0)>>2])<J){if(j2[W>>2]=j2[i>>2],j2[W+4>>2]=j2[T>>2],8&(e=e+1|0))break e;F=j2[T>>2],W=W+8|0;}if(T=i+8|0,(F<J|0)!=((N=j2[((c2=1<(0|y))?i+12|0:C)>>2])<J|0)){if(I=j2[(c2?T:272+Z|0)>>2],Y=j2[i>>2],j2[W+4>>2]=J,j2[W>>2]=Y+z2(z2(J-F)*z2(z2(I-Y)/z2(N-F))),8&(e=e+1|0))break e;W=W+8|0;}if(y=y-1|0,i=T,!c2)break;}}}$2(272+Z|0,176+Z|0,e<<3);}if((0|e)<1)break A;}for(Y=z2(z2(1)/z2(z2(j*H)-z2(n2*q))),J=z2(Y*z2(-n2)),N=z2(H*Y),I=z2(q*Y),m=z2(j*Y),P=j2[(d2<<2)+u2>>2],r2=j2[f+(32|(i=v2<<2))>>2],L=j2[f+(32|(W=l2<<2))>>2],K=j2[f+(16|i)>>2],S=j2[f+(16|W)>>2],n2=j2[B>>2],H=j2[d>>2],f=272+Z|(W=0);i=(176+Z|0)+P2(W,12)|0,j=j2[f>>2],F=z2(j-_),q=j2[f+4>>2],z=z2(q-b2),Y=z2(z2(N*F)-z2(I*z)),F=z2(z2(J*F)+z2(m*z)),z=z2(z2(i2+z2(Y*H))+z2(F*n2)),j2[i>>2]=z,e2=z2(z2(x+z2(Y*S))+z2(F*K)),j2[i+4>>2]=e2,Y=z2(z2(A2+z2(Y*L))+z2(F*r2)),j2[i+8>>2]=Y,Y=z2(P-z2(z2(z2(R*z)+z2(p*e2))+z2(V*Y))),(j2[(144+Z|0)+(W<<2)>>2]=Y)>=z2(0)&&(j2[(i=W<<3)+(272+Z|0)>>2]=j,j2[(272+Z|0)+(4|i)>>2]=q,W=W+1|0),f=f+8|0,e=e-1|0;);if(!((0|W)<1))if((0|W)<=(0|(u2=1<(0|(y=(0|W)<4?W:4))?y:1))){if(4<=(0|A))for(R=z2(-M),V=z2(-U),p=z2(-X),i=144+Z|0,f=176+Z|0;Y=j2[i>>2],j2[416+Z>>2]=z2(j2[f>>2]+j2[$>>2])-z2(X*Y),j2[420+Z>>2]=z2(j2[f+4>>2]+j2[$+4>>2])-z2(U*Y),j2[424+Z>>2]=z2(j2[f+8>>2]+j2[$+8>>2])-z2(M*Y),T2[396+Z>>2]=0,j2[392+Z>>2]=R,j2[388+Z>>2]=V,j2[384+Z>>2]=p,n1[T2[T2[r>>2]+16>>2]](r,384+Z|0,416+Z|0,z2(-Y)),f=f+12|0,i=i+4|0,W=W-1|0;);else for(Y=z2(-M),R=z2(-U),M=z2(-X),i=144+Z|0,f=176+Z|0;j2[416+Z>>2]=j2[f>>2]+j2[$>>2],j2[420+Z>>2]=j2[f+4>>2]+j2[$+4>>2],j2[424+Z>>2]=j2[f+8>>2]+j2[$+8>>2],T2[396+Z>>2]=0,j2[392+Z>>2]=Y,j2[388+Z>>2]=R,j2[384+Z>>2]=M,n1[T2[T2[r>>2]+16>>2]](r,384+Z|0,416+Z|0,z2(-j2[i>>2])),f=f+12|0,i=i+4|0,W=W-1|0;);}else {for(f=144+Z|4,T=0,F=j2[144+Z>>2],i=1;F=(e=F<(Y=j2[f>>2]))?Y:F,T=e?i:T,f=f+4|0,(0|W)!=(0|(i=i+1|0)););f:{r:{e:{i:switch(0|(i=W-1|0)){case 1:break e;case 0:break i;default:break r;}F=j2[276+Z>>2],Y=j2[272+Z>>2];break f;}F=z2(z2(j2[276+Z>>2]+j2[284+Z>>2])*z2(.5)),Y=z2(z2(j2[272+Z>>2]+j2[280+Z>>2])*z2(.5));break f;}for(Y=z2(0),f=272+Z|0,m=z2(0),R=z2(0);N=Y,Y=j2[f+12>>2],V=j2[f+4>>2],F=z2(Y+V),p=j2[f>>2],x=j2[(f=f+8|0)>>2],V=z2(z2(p*Y)-z2(x*V)),Y=z2(N+z2(F*V)),R=z2(R+V),m=z2(m+z2(z2(p+x)*V)),i=i-1|0;);V=z2(0xde0b6b000000000),N=R,p=j2[(f=(272+Z|0)+(W<<3)|0)-8>>2],x=j2[276+Z>>2],J=j2[272+Z>>2],F=j2[f-4>>2],R=z2(z2(p*x)-z2(J*F)),N=z2(N+R),z2(O2(N))>z2(1.1920928955078125e-7)&&(V=z2(z2(1)/z2(N*z2(3)))),F=z2(z2(Y+z2(z2(x+F)*R))*V),Y=z2(z2(m+z2(z2(p+J)*R))*V);}for(i=416+Z|0,f=272+Z|0,e=W;D=i,h=B2(z2(j2[f+4>>2]-F),z2(j2[f>>2]-Y)),j2[D>>2]=h,f=f+8|0,i=i+4|0,e=e-1|0;);for(f=384+Z|0,i=W;T2[f>>2]=1,f=f+4|0,i=i-1|0;);if(T2[112+Z>>2]=T,2<=((T2[(f=T<<2)+(384+Z|0)>>2]=0)|y))for(V=z2(z2(6.2831854820251465)/z2(0|u2)),p=j2[f+(416+Z|0)>>2],y=112+Z|0,l2=1;;){for(T2[y+4>>2]=T,x=(Y=z2(z2(V*z2(0|l2))+p))>z2(3.1415927410125732)?z2(Y+z2(-6.2831854820251465)):Y,y=y+4|0,e=0,Y=z2(1e9),i=416+Z|0,f=384+Z|0,v2=T;T2[f>>2]&&(R=(R=z2(O2(z2(j2[i>>2]-x))))>z2(3.1415927410125732)?z2(z2(6.2831854820251465)-R):R)<Y&&(v2=T2[y>>2]=e,Y=R),f=f+4|0,i=i+4|0,(0|W)!=(0|(e=e+1|0)););if(((T2[(384+Z|0)+(v2<<2)>>2]=0)|u2)==(0|(l2=l2+1|0)))break;}if(R=z2(-M),V=z2(-U),p=z2(-X),4<=(0|A))for(i=u2-1|0,A=112+Z|4;;){if(f=(176+Z|0)+P2(T,12)|0,x=z2(j2[f>>2]+j2[$>>2]),j2[416+Z>>2]=x,F=z2(j2[f+4>>2]+j2[$+4>>2]),j2[420+Z>>2]=F,Y=z2(j2[f+8>>2]+j2[$+8>>2]),j2[424+Z>>2]=Y,T2[396+Z>>2]=0,j2[392+Z>>2]=R,j2[388+Z>>2]=V,j2[384+Z>>2]=p,T2[108+Z>>2]=0,N=Y,Y=j2[(144+Z|0)+(T<<2)>>2],j2[104+Z>>2]=N-z2(M*Y),j2[100+Z>>2]=F-z2(U*Y),j2[96+Z>>2]=x-z2(X*Y),n1[T2[T2[r>>2]+16>>2]](r,384+Z|0,96+Z|0,z2(-Y)),!i)break A;i=i-1|0,T=T2[A>>2],A=A+4|0;}for(i=u2-1|0,A=112+Z|4;;){if(f=(176+Z|0)+P2(T,12)|0,j2[416+Z>>2]=j2[f>>2]+j2[$>>2],j2[420+Z>>2]=j2[f+4>>2]+j2[$+4>>2],j2[424+Z>>2]=j2[f+8>>2]+j2[$+8>>2],T2[396+Z>>2]=0,j2[392+Z>>2]=R,j2[388+Z>>2]=V,j2[384+Z>>2]=p,n1[T2[T2[r>>2]+16>>2]](r,384+Z|0,416+Z|0,z2(-j2[(144+Z|0)+(T<<2)>>2])),!i)break A;i=i-1|0,T=T2[A>>2],A=A+4|0;}}}}L2=448+Z|0;}function r4(A,f,r){var e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G=0,C=z2(0),E=0,D=z2(0),h=0,Z=0,Y=z2(0),R=z2(0),F=z2(0),W=0,m=z2(0),N=z2(0),V=0,J=z2(0),M=0,I=z2(0),x=z2(0),y=z2(0),U=0,X=z2(0),p=z2(0),T=z2(0),S=0,j=(0),P=z2(0),z=(0),O=(z2(0)),H=(0),_=0;L2=G=L2-128|0,T2[A+376>>2]=0,T2[A+364>>2]=4,T2[A+368>>2]=0,T2[A+360>>2]=W=A+316|0,T2[A+356>>2]=A+284,T2[A+352>>2]=A+252,T2[A+348>>2]=A+220,h=T2[f+4>>2],T2[A>>2]=T2[f>>2],T2[A+4>>2]=h,h=T2[(E=f+16|0)+4>>2],T2[(Z=A+16|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[f+12>>2],T2[A+8>>2]=T2[f+8>>2],T2[A+12>>2]=h,h=T2[(E=f+32|0)+4>>2],T2[(Z=A+32|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f+24|0)+4>>2],T2[(Z=A+24|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f+48|0)+4>>2],T2[(Z=A+48|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f+40|0)+4>>2],T2[(Z=A+40|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f- -64|0)+4>>2],T2[(Z=A- -64|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[f+60>>2],T2[A+56>>2]=T2[f+56>>2],T2[A+60>>2]=h,h=T2[(E=f+80|0)+4>>2],T2[(Z=A+80|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f+72|0)+4>>2],T2[(Z=A+72|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f+96|0)+4>>2],T2[(Z=A+96|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f+88|0)+4>>2],T2[(Z=A+88|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f+104|0)+4>>2],T2[(Z=A+104|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,h=T2[(E=f+112|0)+4>>2],T2[(Z=A+112|0)>>2]=T2[E>>2],T2[Z+4>>2]=h,E=T2[f+120>>2],f=T2[f+124>>2],T2[A+144>>2]=0,T2[(h=A+180|0)>>2]=0,T2[A+120>>2]=E,T2[A+124>>2]=f,f=T2[r+4>>2],T2[A+128>>2]=T2[r>>2],T2[A+132>>2]=f,f=T2[(r=r+8|0)+4>>2],T2[(E=Z=A+136|0)>>2]=T2[r>>2],T2[E+4>>2]=f,R=j2[E>>2],C=j2[(r=A+132|0)>>2],D=j2[A+128>>2],T2[A+364>>2]=3,T2[(f=A+164|0)>>2]=0,T2[h>>2]=1,T2[(B=A+148|0)>>2]=W,Y=z2(-D),e4(A,(h=(D=z2(z2(z2(D*D)+z2(C*C))+z2(R*R)))>z2(0))?Y:z2(1),z2(h?-C:0),z2(h?-R:0),W),T2[f>>2]=1065353216,E=T2[B>>2],f=T2[E+20>>2],T2[A+128>>2]=T2[E+16>>2],T2[A+132>>2]=f,f=T2[(h=E+24|0)+4>>2],T2[Z>>2]=T2[h>>2],T2[Z+4>>2]=f,V=T2[h+4>>2],h=T2[h>>2],T2[(f=88+G|0)>>2]=h,T2[f+4>>2]=V,T2[(f=72+G|0)>>2]=h,T2[f+4>>2]=V,T2[(f=56+G|0)>>2]=h,T2[f+4>>2]=V,W=T2[E+20>>2],f=T2[E+16>>2],T2[80+G>>2]=f,T2[84+G>>2]=W,T2[64+G>>2]=f,T2[68+G>>2]=W,T2[48+G>>2]=f,T2[52+G>>2]=W,T2[40+G>>2]=h,T2[44+G>>2]=V,T2[32+G>>2]=f,T2[36+G>>2]=W,h=A+128|0,x=j2[r>>2],C=j2[Z>>2],U=T2[A+368>>2],y=j2[A+128>>2];A:{f:{r:{for(;;){if((R=z2(_2(z2(z2(z2(y*y)+z2(x*x))+z2(C*C)))))<z2(9999999747378752e-20)){T2[A+376>>2]=1;break r;}if(f=T2[A+364>>2]-1|0,T2[A+364>>2]=f,z=P2(U,36),r=T2[(j=180+(n=z+A|0)|0)>>2],T2[j>>2]=r+1,f=T2[348+((f<<2)+A|0)>>2],T2[(r=(M=148+n|0)+(r<<2)|0)>>2]=f,T2[r+16>>2]=0,e4(A,z2(-y),z2(-x),z2(-C),f),Z=T2[j>>2],f=T2[(M+(Z<<2)|0)-4>>2],m=j2[f+16>>2],C=z2(m-j2[32+G>>2]),Y=z2(C*C),N=j2[f+20>>2],C=z2(N-j2[36+G>>2]),Y=z2(Y+z2(C*C)),F=j2[f+24>>2],C=z2(F-j2[40+G>>2]),z2(Y+z2(C*C))<z2(9999999747378752e-20)||(C=z2(m-j2[48+G>>2]),Y=z2(C*C),C=z2(N-j2[52+G>>2]),Y=z2(Y+z2(C*C)),C=z2(F-j2[56+G>>2]),z2(Y+z2(C*C))<z2(9999999747378752e-20)||(C=z2(m-j2[64+G>>2]),Y=z2(C*C),C=z2(N-j2[68+G>>2]),Y=z2(Y+z2(C*C)),C=z2(F-j2[72+G>>2]),z2(Y+z2(C*C))<z2(9999999747378752e-20)||(C=z2(m-j2[80+G>>2]),Y=z2(C*C),C=z2(N-j2[84+G>>2]),Y=z2(Y+z2(C*C)),C=z2(F-j2[88+G>>2]),z2(Y+z2(C*C))<z2(9999999747378752e-20)))))break;if(f=T2[(r=(W=f+16|0)+8|0)+4>>2],T2[(E=V=(32+G|0)+((H=H+1&3)<<4)|0)+8>>2]=T2[r>>2],T2[E+12>>2]=f,f=T2[W+4>>2],T2[E>>2]=T2[W>>2],T2[E+4>>2]=f,C=z2(z2(z2(z2(j2[A+128>>2]*m)+z2(j2[A+132>>2]*N))+z2(j2[A+136>>2]*F))/R),z2(z2(R-(O=O<C?C:O))+z2(R*z2(-9999999747378752e-20)))<=z2(0)){h=T2[A+364>>2],T2[A+364>>2]=h+1,U=T2[A+368>>2],r=P2(U,36)+A|0,E=T2[(f=r+180|0)>>2]-1|0,T2[f>>2]=E,T2[348+((h<<2)+A|0)>>2]=T2[148+(r+(E<<2)|0)>>2];break r;}e:{i:{a:{n:{o:switch(Z-2|(T2[12+G>>2]=0)){case 0:if(r=T2[152+n>>2],F=j2[r+16>>2],f=T2[M>>2],I=j2[f+16>>2],T=z2(F-I),R=j2[r+20>>2],X=j2[f+20>>2],m=z2(R-X),C=j2[r+24>>2],p=j2[f+24>>2],N=z2(C-p),!((D=z2(z2(z2(T*T)+z2(m*m))+z2(N*N)))>z2(0)))break i;if((J=z2(z2(-z2(z2(z2(I*T)+z2(X*m))+z2(p*N)))/D))>=z2(1)){T2[16+G>>2]=0,T2[20+G>>2]=1065353216,T2[12+G>>2]=2,D=z2(z2(z2(F*F)+z2(R*R))+z2(C*C));break a;}if(!(J<=z2(0)))break n;T2[16+G>>2]=1065353216,T2[20+G>>2]=0,T2[12+G>>2]=1,D=z2(z2(z2(I*I)+z2(X*X))+z2(p*p));break a;case 1:D=i4(T2[M>>2]+16|0,T2[152+n>>2]+16|0,T2[156+n>>2]+16|0,16+G|0,12+G|0);break a;case 2:break o;default:break a;}if(S=T2[M>>2],Q=j2[S+16>>2],e=T2[160+n>>2],x=j2[e+16>>2],u=z2(Q-x),M=T2[152+n>>2],c=j2[M+20>>2],y=j2[e+20>>2],k=z2(c-y),i=z2(u*k),V=T2[156+n>>2],J=j2[V+24>>2],P=j2[e+24>>2],o=z2(J-P),g=j2[S+20>>2],l=z2(g-y),w=j2[M+24>>2],s=z2(w-P),I=z2(l*s),C=j2[V+16>>2],b=z2(C-x),Y=j2[S+24>>2],v=z2(Y-P),R=j2[M+16>>2],d=z2(R-x),X=z2(v*d),D=j2[V+20>>2],t=z2(D-y),p=z2(u*s),T=z2(l*d),m=z2(v*k),!((a=z2(z2(z2(i*o)+z2(z2(z2(z2(I*b)+z2(X*t))-z2(p*t))-z2(T*o)))-z2(m*b)))>z2(0)|a<z2(0)))break i;if(N=z2(g-c),F=z2(R-C),R=z2(Q-R),D=z2(c-D),c=z2(Y*z2(z2(N*F)-z2(R*D))),C=z2(Y-w),Y=z2(C*D),D=z2(w-J),!(z2(a*z2(c+z2(z2(Q*z2(Y-z2(N*D)))+z2(g*z2(z2(R*D)-z2(C*F))))))<=z2(0)))break i;if(Z=S+16|0,W=e+16|0,E=M+16|0,T2[120+G>>2]=0,T2[112+G>>2]=0,T2[116+G>>2]=0,T2[108+G>>2]=0,D=z2(-1),z2(a*z2(z2(z2(z2(I-m)*x)+z2(y*z2(X-p)))+z2(z2(i-T)*P)))>z2(0)&&(D=i4(Z,E,W,112+G|0,108+G|0),T2[24+G>>2]=0,f=T2[116+G>>2],T2[16+G>>2]=T2[112+G>>2],T2[20+G>>2]=f,j2[28+G>>2]=j2[120+G>>2],f=T2[108+G>>2],T2[12+G>>2]=2&f|f<<1&8|1&f,y=j2[e+20>>2],x=j2[e+16>>2],P=j2[e+24>>2]),r=V+16|0,z2(a*z2(z2(z2(z2(z2(k*o)-z2(s*t))*x)+z2(y*z2(z2(s*b)-z2(o*d))))+z2(z2(z2(t*d)-z2(k*b))*P)))>z2(0)&&((C=i4(E,r,W,112+G|0,108+G|0))<D||D<z2(0))&&(j2[20+G>>2]=j2[112+G>>2],T2[16+G>>2]=0,f=T2[120+G>>2],T2[24+G>>2]=T2[116+G>>2],T2[28+G>>2]=f,T2[12+G>>2]=T2[108+G>>2]<<1&14,D=C),z2(a*z2(z2(z2(z2(z2(t*v)-z2(o*l))*j2[e+16>>2])+z2(j2[e+20>>2]*z2(z2(o*u)-z2(v*b))))+z2(z2(z2(l*b)-z2(t*u))*j2[e+24>>2])))>z2(0)&&((C=i4(r,Z,W,112+G|0,108+G|0))<D||D<z2(0))&&(j2[24+G>>2]=j2[112+G>>2],T2[20+G>>2]=0,j2[16+G>>2]=j2[116+G>>2],j2[28+G>>2]=j2[120+G>>2],f=T2[108+G>>2],T2[12+G>>2]=f>>>1&1|f<<1&8|f<<2&4,D=C),!(D<z2(0)))break a;T2[12+G>>2]=15,X=j2[S+20>>2],p=j2[V+24>>2],i=j2[e+16>>2],T=j2[S+24>>2],C=j2[V+16>>2],J=j2[e+20>>2],m=j2[S+16>>2],I=j2[e+24>>2],D=j2[V+20>>2],R=z2(z2(z2(z2(z2(z2(z2(z2(X*p)*i)+z2(z2(T*C)*J))-z2(J*z2(p*m)))-z2(z2(X*C)*I))+z2(I*z2(m*D)))-z2(i*z2(T*D)))/a),j2[20+G>>2]=R,N=j2[M+24>>2],F=j2[M+16>>2],Y=z2(z2(z2(z2(i*z2(D*N))+z2(J*z2(p*F)))-z2(J*z2(N*C)))-z2(I*z2(D*F))),D=j2[M+20>>2],C=z2(z2(z2(Y+z2(I*z2(C*D)))-z2(i*z2(p*D)))/a),j2[16+G>>2]=C,D=z2(z2(z2(z2(z2(z2(z2(i*z2(D*T))+z2(J*z2(N*m)))-z2(J*z2(T*F)))-z2(I*z2(D*m)))+z2(I*z2(F*X)))-z2(i*z2(N*X)))/a),j2[24+G>>2]=D,j2[28+G>>2]=z2(1)-z2(z2(C+R)+D),D=z2(0);break a;}T2[12+G>>2]=3,j2[20+G>>2]=J,j2[16+G>>2]=z2(1)-J,D=z2(p+z2(N*J)),Y=z2(D*D),D=z2(I+z2(T*J)),C=z2(D*D),D=z2(X+z2(m*J)),D=z2(Y+z2(C+z2(D*D)));}if(D>=z2(0)){if(V=P2(U=1-U|0,36)+A|0,T2[(W=V+180|0)>>2]=0,T2[h>>2]=0,T2[h+4>>2]=0,T2[A+368>>2]=U,T2[(f=h+8|0)>>2]=0,T2[f+4>>2]=0,M=T2[12+G>>2],!(Z=T2[j>>2])){C=z2(0),x=z2(0),y=z2(0);break e;}for(f=z+B|0,C=z2(0),j=16+G|(S=0),x=z2(0),y=z2(0),r=0;z=T2[f>>2],M>>>r&1?(T2[(E=V+(S<<2)|0)+148>>2]=z,F=j2[j>>2],j2[E+164>>2]=F,T2[W>>2]=S=S+1|0,E=T2[f>>2],R=j2[E+24>>2],C=j2[E+20>>2],y=z2(z2(F*j2[E+16>>2])+j2[A+128>>2]),j2[A+128>>2]=y,x=z2(z2(F*C)+j2[A+132>>2]),j2[A+132>>2]=x,C=z2(z2(F*R)+j2[A+136>>2]),j2[A+136>>2]=C):(E=T2[A+364>>2],T2[A+364>>2]=E+1,T2[348+((E<<2)+A|0)>>2]=z),f=f+4|0,j=j+4|0,(0|Z)!=(0|(r=r+1|0)););break e;}}h=T2[A+364>>2],T2[A+364>>2]=h+1,U=T2[A+368>>2],r=P2(U,36)+A|0,E=T2[(f=r+180|0)>>2]-1|0,T2[f>>2]=E,T2[348+((h<<2)+A|0)>>2]=T2[148+(r+(E<<2)|0)>>2];break r;}if(15==(0|M)&&(T2[A+376>>2]=1),127==(0|_)){T2[A+376>>(f=2)]=2,T2[A+372>>2]=148+(P2(U,36)+A|0);break A;}if(_=_+1|0,f=T2[A+376>>2])break f;}h=T2[A+364>>2],T2[A+364>>2]=h+1,U=T2[A+368>>2],r=P2(U,36)+A|0,E=T2[(f=r+180|0)>>2]-1|0,T2[f>>2]=E,T2[348+((h<<2)+A|0)>>2]=T2[148+(r+(E<<2)|0)>>2];}f=T2[A+376>>2];}T2[A+372>>2]=148+(P2(U,36)+A|0);f:switch(0|f){case 0:D=j2[A+128>>2],C=z2(D*D),D=j2[A+132>>2],C=z2(C+z2(D*D)),D=j2[A+136>>2],j2[A+144>>2]=_2(z2(C+z2(D*D))),f=0;break A;case 1:break f;default:break A;}T2[A+144>>2]=0,f=1;}return L2=128+G|0,f;}function e4(A,f,r,e,i){var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C=0,E=0,D=0;L2=C=L2-48|0,T2[i+12>>2]=0,a=z2(z2(1)/z2(_2(z2(z2(z2(f*f)+z2(r*r))+z2(e*e))))),j2[i+8>>2]=a*e,j2[i+4>>2]=a*r,j2[i>>2]=a*f,D=T2[A+120>>2],c=T2[A+124>>2],E=T2[A>>2]+(c>>1)|0,1&c&&(D=T2[D+T2[E>>2]>>2]),n1[0|D](C,E,i),e=j2[i+8>>2],r=j2[i>>2],D=T2[A+124>>2],n=T2[A+4>>2]+(D>>1)|0,f=z2(-j2[i+4>>2]),E=T2[A+120>>2],E=1&D?T2[T2[n>>2]+E>>2]:E,T2[28+C>>2]=0,j2[24+C>>2]=z2(z2(j2[A+44>>2]*f)-z2(r*j2[A+40>>2]))-z2(e*j2[A+48>>2]),j2[20+C>>2]=z2(z2(j2[A+28>>2]*f)-z2(r*j2[A+24>>2]))-z2(e*j2[A+32>>2]),j2[16+C>>2]=z2(z2(j2[A+12>>2]*f)-z2(r*j2[A+8>>2]))-z2(e*j2[A+16>>2]),n1[0|E](32+C|0,n,16+C|0),u=j2[A+104>>2],k=j2[A- -64>>2],l=j2[A+60>>2],s=j2[A+108>>2],v=j2[A+80>>2],d=j2[A+72>>2],B=j2[A+76>>2],Q=j2[A+112>>2],g=j2[A+96>>2],w=j2[A+88>>2],G=j2[A+92>>2],a=j2[A+56>>2],o=j2[40+C>>2],b=j2[32+C>>2],t=j2[36+C>>2],e=j2[C>>2],r=j2[4+C>>2],f=j2[8+C>>2],T2[i+28>>2]=0,j2[i+24>>2]=f-z2(Q+z2(z2(z2(b*w)+z2(t*G))+z2(o*g))),j2[i+20>>2]=r-z2(s+z2(z2(z2(b*d)+z2(t*B))+z2(o*v))),j2[i+16>>2]=e-z2(u+z2(z2(z2(b*a)+z2(t*l))+z2(o*k))),L2=48+C|0;}function i4(A,f,r,e,i){var a=z2(0),n=z2(0),o=z2(0),b=z2(0),t=z2(0),c=z2(0),u=z2(0),k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=z2(0),B=z2(0),Q=z2(0),g=0,w=z2(0),G=z2(0),C=z2(0),E=(z2(0)),D=z2(0),a=z2(-1),u=j2[A>>2],o=j2[f>>2],n=z2(u-o),c=j2[f+4>>2],w=j2[r+4>>2],h=z2(c-w),d=j2[A+4>>2],t=z2(d-c),G=j2[r>>2],Z=z2(o-G),k=z2(z2(n*h)-z2(t*Z)),b=j2[f+8>>2],C=j2[r+8>>2],Y=z2(b-C),B=j2[A+8>>2],s=z2(B-b),R=z2(z2(t*Y)-z2(s*h)),F=z2(z2(s*Z)-z2(n*Y));return (D=z2(z2(k*k)+z2(z2(R*R)+z2(F*F))))>z2(0)&&(z2(z2(z2(u*z2(z2(k*t)-z2(F*s)))+z2(d*z2(z2(R*s)-z2(k*n))))+z2(z2(z2(F*n)-z2(R*t))*B))>z2(0)?(t=z2(-1),s=z2(o-u),l=z2(c-d),v=z2(b-B),(a=z2(z2(z2(s*s)+z2(l*l))+z2(v*v)))>z2(0)?(n=z2(1),(a=z2(z2(-z2(z2(z2(u*s)+z2(d*l))+z2(B*v)))/a))>=z2(1)?(t=z2(z2(z2(o*o)+z2(c*c))+z2(b*b)),g=2):(n=z2(0),g=1,a<=z2(0)?(t=z2(z2(z2(u*u)+z2(d*d))+z2(B*B)),Q=z2(1)):(n=z2(B+z2(v*a)),t=z2(n*n),n=z2(u+z2(s*a)),o=z2(n*n),n=z2(d+z2(l*a)),t=z2(t+z2(o+z2(n*n))),Q=z2(z2(1)-a),g=3,n=a))):n=z2(0),T2[e+8>>2]=0,j2[e+4>>2]=n,j2[e>>2]=Q,T2[i>>2]=g,b=j2[f+8>>2],c=j2[f+4>>2],o=j2[f>>2]):(t=z2(-1),n=z2(0)),B=z2(C-B),d=z2(w-d),s=z2(G-u),z2(z2(z2(o*z2(z2(k*h)-z2(F*Y)))+z2(c*z2(z2(R*Y)-z2(k*Z))))+z2(z2(z2(F*Z)-z2(R*h))*b))>z2(0)?(w=j2[r>>2],u=z2(w-o),G=j2[r+4>>2],l=z2(G-c),C=j2[r+8>>2],v=z2(C-b),E=z2(z2(z2(u*u)+z2(l*l))+z2(v*v)),a=z2(-1),E>z2(0)&&(n=z2(1),a=(a=z2(z2(-z2(z2(z2(o*u)+z2(c*l))+z2(b*v)))/E))>=z2(1)?(Q=z2(0),g=2,z2(z2(z2(w*w)+z2(G*G))+z2(C*C))):(n=z2(0),g=1,a<=z2(0)?(Q=z2(1),z2(z2(z2(o*o)+z2(c*c))+z2(b*b))):(Q=z2(z2(1)-a),g=3,a=z2(b+z2(v*(n=a))),b=z2(a*a),a=z2(o+z2(u*n)),o=z2(a*a),a=z2(c+z2(l*n)),z2(b+z2(o+z2(a*a)))))),t<z2(0)||a<t?(j2[e+8>>2]=n,j2[e+4>>2]=Q,T2[e>>2]=0,T2[i>>2]=g<<1):a=t):a=t,c=j2[r>>2],b=j2[r+4>>2],u=j2[r+8>>2],z2(z2(z2(c*z2(z2(k*d)-z2(F*B)))+z2(b*z2(z2(R*B)-z2(k*s))))+z2(z2(z2(F*s)-z2(R*d))*u))>z2(0)&&(o=z2(-1),G=j2[A>>2],l=z2(G-c),C=j2[A+4>>2],v=z2(C-b),E=j2[A+8>>2],w=z2(E-u),(t=z2(z2(z2(l*l)+z2(v*v))+z2(w*w)))>z2(0)&&(n=z2(1),(t=z2(z2(-z2(z2(z2(c*l)+z2(b*v))+z2(u*w)))/t))>=z2(1)?(o=z2(z2(z2(G*G)+z2(C*C))+z2(E*E)),Q=z2(0),g=2):(n=z2(0),t<=z2(0)?(o=z2(z2(z2(c*c)+z2(b*b))+z2(u*u)),Q=z2(1),g=1):(n=z2(u+z2(w*t)),o=z2(n*n),n=z2(c+z2(l*t)),c=z2(n*n),n=z2(b+z2(v*t)),o=z2(o+z2(c+z2(n*n))),Q=z2(z2(1)-t),g=3,n=t))),(o<a||a<z2(0))&&(j2[e+8>>2]=Q,T2[e+4>>2]=0,j2[e>>2]=n,T2[i>>2]=g<<2&4|g>>>1,a=o)),a<z2(0)&&(t=z2(z2(z2(z2(R*j2[A>>2])+z2(F*j2[A+4>>2]))+z2(k*j2[A+8>>2]))/D),a=z2(F*t),o=z2(j2[f+4>>2]-a),n=z2(R*t),c=z2(j2[f>>2]-n),b=z2(z2(Z*o)-z2(h*c)),u=z2(b*b),t=z2(k*t),b=z2(j2[f+8>>2]-t),o=z2(z2(h*b)-z2(o*Y)),k=z2(o*o),o=z2(z2(c*Y)-z2(Z*b)),b=z2(_2(z2(u+z2(k+z2(o*o))))),o=z2(_2(D)),c=z2(b/o),j2[e>>2]=c,T2[i>>2]=7,b=z2(j2[r+4>>2]-a),Q=z2(j2[r>>2]-n),k=z2(z2(s*b)-z2(Q*d)),u=z2(k*k),k=z2(j2[r+8>>2]-t),b=z2(z2(d*k)-z2(b*B)),l=z2(b*b),b=z2(z2(Q*B)-z2(s*k)),o=z2(z2(_2(z2(u+z2(l+z2(b*b)))))/o),j2[e+4>>2]=o,j2[e+8>>2]=z2(1)-z2(c+o),a=z2(z2(t*t)+z2(z2(n*n)+z2(a*a))))),a;}function a4(A,f,r,e,i){var a,n,o,b,t,c,u,k,l,s,v,d=0,B=0,Q=z2(0),g=z2(0),w=z2(0),G=(0);if(d=T2[A+18504>>2]){if((B=T2[d+48>>2])&&(T2[B+44>>2]=T2[d+44>>2]),(B=T2[d+44>>2])&&(T2[B+48>>2]=T2[d+48>>2]),T2[A+18504>>2]==(0|d)&&(T2[A+18504>>2]=T2[d+48>>2]),T2[d+44>>2]=0,T2[d+48>>2]=T2[A+18496>>2],T2[(B=A+18508|0)>>2]=T2[B>>2]-1,(B=T2[A+18496>>2])&&(T2[B+44>>2]=d),T2[A+18496>>2]=d,T2[(B=A+18500|0)>>2]=T2[B>>2]+1,p2[d+55|0]=0,T2[d+28>>2]=e,T2[d+24>>2]=r,T2[d+20>>2]=f,a=j2[e+16>>2],n=j2[(B=r+16|0)>>2],w=j2[(o=f+16|0)>>2],t=j2[(b=r+20|0)>>2],c=j2[e+24>>2],u=j2[(k=r+24|0)>>2],Q=j2[(l=f+24|0)>>2],g=j2[(s=f+20|0)>>2],v=j2[e+20>>2],T2[d+12>>2]=0,t=z2(t-g),c=z2(c-Q),u=z2(u-Q),g=z2(v-g),Q=z2(z2(t*c)-z2(u*g)),j2[d>>2]=Q,a=z2(a-w),n=z2(n-w),w=z2(z2(u*a)-z2(n*c)),j2[d+4>>2]=w,g=z2(z2(n*g)-z2(t*a)),j2[d+8>>2]=g,G=2,(a=z2(_2(z2(z2(z2(Q*Q)+z2(w*w))+z2(g*g)))))>z2(9999999747378752e-20)){if(n=j2[B>>2],n4(Q,w,g,j2[o>>2],j2[s>>2],j2[l>>2],n,j2[b>>2],j2[k>>2],B=d+16|0)||(Q=j2[r+16>>2],g=j2[r+20>>2],w=j2[r+24>>2],n4(j2[d>>2],j2[(G=d+4|0)>>2],j2[(o=d+8|0)>>2],Q,g,w,j2[(r=e+16|0)>>2],j2[(b=e+20|0)>>2],j2[(e=e+24|0)>>2],B)||n4(j2[d>>2],j2[G>>2],j2[o>>2],j2[r>>2],j2[b>>2],j2[e>>2],j2[f+16>>2],j2[f+20>>2],j2[f+24>>2],B)||(j2[d+16>>2]=z2(z2(z2(j2[f+16>>2]*j2[d>>2])+z2(j2[f+20>>2]*j2[d+4>>2]))+z2(j2[f+24>>2]*j2[d+8>>2]))/a)),Q=z2(z2(1)/a),j2[d>>2]=Q*j2[d>>2],j2[(f=d+4|0)>>2]=Q*j2[f>>2],j2[(f=d+8|0)>>2]=Q*j2[f>>2],i)return d;if(G=3,j2[B>>2]>=z2(-9999999747378752e-21))return d;}return T2[A>>2]=G,(f=T2[d+48>>2])&&(T2[f+44>>2]=T2[d+44>>2]),(f=T2[d+44>>2])&&(T2[f+48>>2]=T2[d+48>>2]),T2[A+18496>>2]==(0|d)&&(T2[A+18496>>2]=T2[d+48>>2]),T2[d+44>>2]=0,T2[d+48>>2]=T2[A+18504>>2],T2[A+18500>>2]=T2[A+18500>>2]-1,(f=T2[A+18504>>2])&&(T2[f+44>>2]=d),T2[A+18504>>2]=d,T2[A+18508>>2]=T2[A+18508>>2]+1,0;}return T2[A>>2]=5,0;}function n4(A,f,r,e,i,a,n,o,b,t){var c=0,u=z2(n-e),k=z2(o-i),l=z2(b-a);return (c=z2(z2(z2(z2(u*f)-z2(k*A))*a)+z2(z2(z2(z2(k*r)-z2(l*f))*e)+z2(z2(z2(l*A)-z2(u*r))*i)))<z2(0))&&(A=z2(z2(z2(e*e)+z2(i*i))+z2(a*a)),z2(z2(z2(u*e)+z2(k*i))+z2(l*a))>z2(0)||(A=z2(z2(z2(n*n)+z2(o*o))+z2(b*b)),z2(z2(z2(u*n)+z2(k*o))+z2(l*b))<z2(0)||(A=z2(z2(z2(n*e)+z2(o*i))+z2(b*a)),A=(A=z2(z2(z2(z2(z2(z2(n*n)+z2(o*o))+z2(b*b))*z2(z2(z2(e*e)+z2(i*i))+z2(a*a)))-z2(A*A))/z2(z2(z2(u*u)+z2(k*k))+z2(l*l))))>z2(0)?A:z2(0))),j2[t>>2]=_2(A)),c;}function o4(){S2[23440]||(T2[5778]=1062847606,T2[5779]=0,T2[5776]=1042701022,T2[5777]=1056964440,T2[5774]=1062847606,T2[5775]=0,T2[5772]=-1093024784,T2[5773]=1050556081,T2[5770]=1062847606,T2[5771]=0,T2[5768]=-1093024784,T2[5769]=-1096927567,T2[5766]=1062847606,T2[5767]=0,T2[5764]=1042701022,T2[5765]=-1090519208,T2[5762]=1062847572,T2[5763]=0,T2[5760]=1057396286,T2[5761]=0,T2[5758]=1057396386,T2[5759]=0,T2[5756]=1060121912,T2[5757]=1056964507,T2[5754]=1057396420,T2[5755]=0,T2[5752]=-1098475836,T2[5753]=1062148969,T2[5750]=1057396386,T2[5751]=0,T2[5748]=-1084636143,T2[5749]=0,T2[5746]=1057396420,T2[5747]=0,T2[5744]=-1098475836,T2[5745]=-1085334679,T2[5742]=1057396386,T2[5743]=0,T2[5740]=1060121912,T2[5741]=-1090519141,T2[5738]=-2147483648,T2[5739]=0,T2[5736]=1058437413,T2[5737]=1062149053,T2[5734]=-2147483648,T2[5735]=0,T2[5732]=-2147483648,T2[5733]=1065353216,T2[5730]=-2147483648,T2[5731]=0,T2[5728]=-1089046235,T2[5729]=1062149053,T2[5726]=-2147483648,T2[5727]=0,T2[5724]=-1082951543,T2[5725]=1050556148,T2[5722]=-2147483648,T2[5723]=0,T2[5720]=-1082951543,T2[5721]=-1096927500,T2[5718]=0,T2[5719]=0,T2[5716]=-1089046235,T2[5717]=-1085334595,T2[5714]=0,T2[5715]=0,T2[5712]=0,T2[5713]=-1082130432,T2[5710]=0,T2[5711]=0,T2[5708]=1058437413,T2[5709]=-1085334595,T2[5706]=0,T2[5707]=0,T2[5704]=1064532105,T2[5705]=-1096927500,T2[5702]=0,T2[5703]=0,T2[5700]=1064532105,T2[5701]=1050556148,T2[5698]=-1090087228,T2[5699]=0,T2[5696]=1049007812,T2[5697]=1062148969,T2[5694]=-1090087262,T2[5695]=0,T2[5692]=-1087361736,T2[5693]=1056964507,T2[5690]=-1084636042,T2[5691]=0,T2[5688]=-1104782626,T2[5689]=1056964440,T2[5686]=-1090087262,T2[5687]=0,T2[5684]=-1087361736,T2[5685]=-1090519141,T2[5682]=-1084636076,T2[5683]=0,T2[5680]=-1090087362,T2[5681]=-2147483648,T2[5678]=-1090087262,T2[5679]=0,T2[5676]=1062847505,T2[5677]=-2147483648,T2[5674]=-1084636042,T2[5675]=0,T2[5672]=1054458864,T2[5673]=1050556081,T2[5670]=-1090087228,T2[5671]=0,T2[5668]=1049007812,T2[5669]=-1085334679,T2[5666]=-1084636042,T2[5667]=0,T2[5664]=-1104782626,T2[5665]=-1090519208,T2[5662]=-1084636042,T2[5663]=0,T2[5660]=1054458864,T2[5661]=-1096927567,T2[5658]=1065353216,T2[5659]=0,T2[5656]=-2147483648,T2[5657]=0,T2[5654]=1055193471,T2[5655]=0,T2[5652]=1063581978,T2[5653]=0,T2[5650]=1055193572,T2[5651]=0,T2[5648]=1049461434,T2[5649]=1062847522,T2[5646]=1055193572,T2[5647]=0,T2[5644]=-1086767520,T2[5645]=1057396202,T2[5642]=1055193572,T2[5643]=0,T2[5640]=-1086767520,T2[5641]=-1090087446,T2[5638]=1055193605,T2[5639]=0,T2[5636]=1049461434,T2[5637]=-1084636126,T2[5634]=-1092290076,T2[5635]=0,T2[5632]=1060716128,T2[5633]=1057396202,T2[5630]=-1092290043,T2[5631]=0,T2[5628]=-1098022214,T2[5629]=1062847522,T2[5626]=-1092290177,T2[5627]=0,T2[5624]=-1083901670,T2[5625]=-2147483648,T2[5622]=-1092290076,T2[5623]=0,T2[5620]=-1098022214,T2[5621]=-1084636126,T2[5618]=-1092290076,T2[5619]=0,T2[5616]=1060716128,T2[5617]=-1090087446,T2[5614]=-1082130432,T2[5615]=0,T2[5612]=0,T2[5613]=-2147483648,p2[23440]=1);}function b4(A){var f,r=0,e=0,i=0,a=0,n=0,o=0;if(T2[6041]=15080,a=T2[5498],r=T2[A+20>>2],(n=K2(23))&&(T2[(i=n+19&-16)-4>>2]=n),T2[6047]=i,T2[i>>2]=r?14688:15012,T2[5498]=a+2,(r=K2(39))&&(T2[(e=r+19&-16)-4>>2]=r,i=T2[6047]),T2[e+12>>2]=0,T2[e+16>>2]=3,T2[e>>2]=12568,p2[e+4|(n=0)]=0,T2[e+8>>2]=i,T2[6048]=e,e=0,(r=K2(27))&&(T2[(e=r+19&-16)-4>>2]=r),T2[e>>2]=15112,p2[e+4|0]=0,T2[6049]=e,(r=K2(27))&&(T2[(n=r+19&-16)-4>>2]=r),T2[n>>2]=15132,p2[n+4|(e=0)]=0,T2[6050]=n,T2[5498]=a+5,i=0,(r=K2(27))&&(T2[(i=r+19&-16)-4>>2]=r),T2[i>>2]=15152,p2[i+4|0]=0,T2[6051]=i,(r=K2(27))&&(T2[(e=r+19&-16)-4>>2]=r),T2[e>>2]=15172,p2[e+4|(i=0)]=0,T2[6052]=e,e=0,(r=K2(27))&&(T2[(e=r+19&-16)-4>>2]=r),T2[e>>2]=15192,p2[e+4|0]=0,T2[6053]=e,T2[5498]=a+8,(r=K2(27))&&(T2[(i=r+19&-16)-4>>2]=r),T2[i>>2]=15212,p2[i+4|(e=0)]=0,T2[6054]=i,i=0,(r=K2(27))&&(T2[(i=r+19&-16)-4>>2]=r),T2[i>>2]=15232,p2[i+4|0]=0,T2[6055]=i,(r=K2(27))&&(T2[(e=r+19&-16)-4>>2]=r),T2[e>>2]=15252,p2[e+4|(i=0)]=0,T2[6059]=e,T2[5498]=a+11,e=0,(r=K2(27))&&(T2[(e=r+19&-16)-4>>2]=r),T2[6060]=e,T2[e>>2]=15252,p2[e+4|0]=1,(r=K2(27))&&(T2[(i=r+19&-16)-4>>2]=r),T2[i>>2]=15272,p2[i+4|(e=0)]=0,T2[6058]=i,i=0,(r=K2(35))&&(T2[(i=r+19&-16)-4>>2]=r),T2[i+8>>2]=1,T2[i+12>>2]=0,T2[i>>2]=15292,p2[i+4|0]=0,T2[6062]=i,T2[5498]=o=a+14|0,(r=K2(35))&&(T2[(e=r+19&-16)-4>>2]=r),T2[e+8>>2]=1,T2[e+12>>2]=0,T2[e>>2]=15292,T2[6061]=e,p2[e+4|0]=1,f=T2[A+16>>2],r=T2[A>>2])T2[6043]=r,p2[24176]=0;else {if(p2[24176]=1,e=0,T2[5498]=a+15,a=0,(r=K2(43))&&(T2[(a=r+19&-16)-4>>2]=r),T2[a>>2]=868,T2[a+20>>2]=0,n=T2[A+8>>2],T2[a+4>>2]=n,o=T2[5498]+1|0,T2[5498]=o,(r=K2(P2(n,868)+19|0))&&(T2[(e=r+19&-16)-4>>2]=r),T2[a+12>>2]=e,T2[a+16>>2]=e,i=(T2[a+8>>2]=n)-1|0)for(n=T2[a>>2];e=T2[e>>2]=r=e+n|0,i=i-1|0;);else r=e;T2[r>>2]=0,T2[6043]=a;}if(r=T2[A+4>>2])return T2[6045]=r,void(p2[24184]=0);if(n=116<(0|(r=80<(0|f)?f:80))?r+16&-16:128,p2[24184]=1,e=0,T2[5498]=o+1,a=0,(r=K2(43))&&(T2[(a=r+19&-16)-4>>2]=r),T2[a>>2]=n,T2[a+20>>2]=0,r=T2[A+12>>2],T2[a+4>>2]=r,T2[5498]=T2[5498]+1,(A=K2(16+(3|P2(r,n))|0))&&(T2[(e=A+19&-16)-4>>2]=A),T2[a+12>>2]=e,T2[a+16>>2]=e,i=(T2[a+8>>2]=r)-1|0)for(A=T2[a>>2];e=T2[e>>2]=r=A+e|0,i=i-1|0;);else r=e;T2[r>>2]=0,T2[6045]=a;}function t4(A){var f=0,r=0;return T2[(A|=0)>>2]=15080,S2[A+20|0]&&(f=T2[A+16>>2],(r=T2[f+16>>2])&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),f=T2[A+16>>2]),f&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),S2[A+12|0]&&(f=T2[A+8>>2],(r=T2[f+16>>2])&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),f=T2[A+8>>2]),f&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),f=T2[A+28>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+28>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+32>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+32>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+36>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+36>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+40>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+40>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+44>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+44>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+48>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+48>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+52>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+52>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+56>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+56>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+72>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+72>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+76>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+76>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+68>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+68>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+84>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+84>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+80>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+80>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),f=T2[A+24>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+24>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),0|A;}function c4(A){return T2[(A|=0)+72>>2];}function u4(A){var f,r,e,i,a=0,n=0,o=0,b=0,t=0;if(!((0|(f=T2[A+12>>2]))<=(0|(r=T2[A+32>>2])))){A:if(T2[A+36>>2]>=(0|f))o=T2[A+40>>2];else {if(f&&(T2[5498]=T2[5498]+1,(n=K2(19+(f<<2)|0))&&(T2[(o=n+19&-16)-4>>2]=n)),a=T2[A+40>>2],1<=(0|r))for(n=o,t=a,b=r;T2[n>>2]=T2[t>>2],n=n+4|0,t=t+4|0,b=b-1|0;);else if(!a){T2[A+40>>2]=o,T2[A+36>>2]=f,p2[A+44|0]=1;break A;}S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[A+40>>2]=o,p2[A+44|0]=1,T2[A+36>>2]=f;}if(d2((r<<2)+o|0,0,f-r<<2),e=(T2[A+32>>2]=f)<<2,(0|(a=T2[A+52>>2]))<(0|f)){A:if(T2[A+56>>2]>=(0|f))o=T2[A+60>>2];else {if(o=0,f&&(T2[5498]=T2[5498]+1,(n=K2(16+(3|e)|0))&&(T2[(o=n+19&-16)-4>>2]=n)),i=T2[A+60>>2],1<=(0|a))for(n=o,t=i,b=a;T2[n>>2]=T2[t>>2],n=n+4|0,t=t+4|0,b=b-1|0;);else if(!i){T2[A+60>>2]=o,T2[A+56>>2]=f,p2[A- -64|0]=1;break A;}S2[A- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2])),T2[A+60>>2]=o,p2[A+64|0]=1,T2[A+56>>2]=f;}d2((a<<2)+o|0,0,f-a<<2);}if(1<=(0|(T2[A+52>>2]=f))&&(d2(T2[A+40>>2],255,e),d2(T2[A+60>>2],255,e)),!((0|r)<1))for(t=T2[A+60>>2],n=T2[A+16>>2],o=T2[A+40>>2],b=0;a=T2[T2[n>>2]+12>>2]|T2[T2[n+4>>2]+12>>2]<<16,a=P2((a=(a<<15^-1)+a|0)>>>10^a,9),a=o+((T2[A+12>>2]-1&((a=((a^=a>>>6)<<11^-1)+a|0)>>>16^a))<<2)|0,T2[t>>2]=T2[a>>2],n=n+16|0,t=t+4|0,(0|r)!=(0|(b=(T2[a>>2]=b)+1|0)););}}function k4(A,f,r){for(var e,i,a,n,o,b=0,t=0,c=0,u=0,k=0,l=0,s=0,v=0,d=0,B=0,Q=0;;){for(B=T2[A+12>>2],a=T2[(k=B+(((n=f)+r|0)/2<<4)|0)+8>>2],e=T2[k+4>>2],i=T2[k>>2],l=r;;){A:{if(!i)for(c=(f<<4)+B|0;;){t=u=-1,(s=T2[c>>2])&&(t=T2[s+12>>2]),(k=T2[c+4>>2])&&(u=T2[k+12>>2]),b=e?T2[e+12>>2]:-1;f:if(!(-1<(0|t))){if(!((0|b)<(0|u)||s)){if((0|e)!=(0|k))break A;if(T[c+8>>2]>a>>>0)break f;k=e;break A;}if(s)break A;if((0|u)<=(0|b))break A;}c=c+16|0,f=f+1|0;}for(c=(f<<4)+B|0,v=T2[i+12>>2];;){t=u=-1,(s=T2[c>>2])&&(t=T2[s+12>>2]),(k=T2[c+4>>2])&&(u=T2[k+12>>2]),b=e?T2[e+12>>2]:-1;f:if(!((0|v)<(0|t))){if(!((0|b)<(0|u))&&(0|i)==(0|s)){if((0|e)!=(0|k))break A;if(T[c+8>>2]>a>>>0)break f;k=e;break A;}if((0|i)!=(0|s))break A;if((0|u)<=(0|b))break A;}c=c+16|0,f=f+1|0;}}A:{if(!i)for(t=(l<<4)+B|0;;){u=-1,(d=T2[t>>2])&&(u=T2[d+12>>2]),v=e?T2[e+12>>2]:-1,b=-1,(Q=T2[t+4>>2])&&(b=T2[Q+12>>2]);f:if(!((0|u)<-1)){if(!((0|b)<(0|v)||d)){if((0|e)!=(0|Q))break A;if(T[t+8>>2]<a>>>0)break f;break A;}if(d)break A;if((0|v)<=(0|b))break A;}t=t-16|0,l=l-1|0;}for(t=(l<<4)+B|0,o=T2[i+12>>2];;){if(u=-1,(d=T2[t>>2])&&(u=T2[d+12>>2]),v=e?T2[e+12>>2]:-1,b=-1,(Q=T2[t+4>>2])&&(b=T2[Q+12>>2]),!((0|u)<(0|o)))if((0|b)<(0|v)||(0|i)!=(0|d)){if((0|i)!=(0|d))break A;if((0|v)<=(0|b))break A;}else {if((0|e)!=(0|Q))break A;if(T[t+8>>2]>=a>>>0)break A;}t=t-16|0,l=l-1|0;}}if((0|f)<=(0|l)&&(u=T2[(b=(f<<4)+B|0)+8>>2],v=T2[b+12>>2],b=T2[t+4>>2],T2[c>>2]=T2[t>>2],T2[c+4>>2]=b,b=c+8|0,c=T2[(t=t+8|0)+4>>2],T2[b>>2]=T2[t>>2],T2[b+4>>2]=c,b=T2[A+12>>2]+(l<<4)|0,T2[b+4>>2]=k,T2[b+8>>2]=u,T2[b+12>>2]=v,T2[b>>2]=s,l=l-1|0,f=f+1|0),!((0|f)<=(0|l)))break;B=T2[A+12>>2];}if((0|n)<(0|l)&&k4(A,n,l),!((0|f)<(0|r)))break;}}function l4(A){var f,r,e=0,i=0,a=0;if(T2[(A|=0)>>2]=16780,S2[A+152|0]&&(e=T2[A+96>>2],n1[T2[T2[e>>2]>>2]](e),(e=T2[A+96>>2])&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]))),1<=(0|(a=T2[A+160>>2])))for(e=8;i=T2[A+168>>2]+e|0,(r=T2[(f=i+4|0)>>2])&&S2[i+8|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[f>>2]=0,p2[i+8|0]=1,T2[(i=i-4|0)>>2]=0,e=e+20|(T2[i+4>>2]=0),a=a-1|0;);return (e=T2[A+168>>2])&&S2[A+172|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+168>>2]=0,T2[A+160>>2]=0,T2[A+164>>2]=0,p2[A+172|0]=1,A0(A+44|0),A0(A+4|0),0|A;}function s4(A,f,r){var e,i,a,n,o,b,t=0,c=0,u=0,k=0,l=0,s=0,v=0,d=0,B=0;if(L2=d=L2-256|0,A){for(e=j2[f+24>>2],i=j2[f+20>>2],a=j2[f+16>>2],n=j2[f+8>>2],o=j2[f+4>>2],b=j2[f>>2],T2[d>>2]=A,u=64,A=d,f=1;;){A:{f:{r:{if(l=T2[(B=(c=f-1|0)<<2)+A>>2],j2[l>>2]<=a&&j2[l+16>>2]>=b&&j2[l+4>>2]<=i&&j2[l+20>>2]>=o&&j2[l+8>>2]<=e&&j2[l+24>>2]>=n){if(T2[l+40>>2]){if((0|c)!=(0|u))break r;if((0|(t=u?u<<1:1))<(0|f))break r;if(c=0,t&&(T2[5498]=T2[5498]+1,(k=K2(19+(t<<2)|0))&&(T2[(c=k+19&-16)-4>>2]=k)),2<=(0|f))for(s=c,k=A;T2[s>>2]=T2[k>>2],s=s+4|0,k=k+4|0,u=u-1|0;);if(!v){v=1;break f;}T2[5499]=T2[5499]+(v=1),q2(T2[A-4>>2]);break f;}n1[T2[T2[r>>2]+12>>2]](r,l);}f=c;break A;}t=u,c=A;}if(T2[c+B>>2]=T2[l+36>>2],(0|f)==(0|t)){if((0|(u=f<<1))<=(0|f))u=f,A=c;else {if(A=0,T2[5498]=T2[5498]+1,(t=K2(19+(f<<3)|0))&&(T2[(A=t+19&-16)-4>>2]=t),1<=(0|f))for(s=A,t=c,k=f;T2[s>>2]=T2[t>>2],s=s+4|0,t=t+4|0,k=k-1|0;);v?(T2[5499]=T2[5499]+(v=1),q2(T2[c-4>>2])):v=1;}}else u=t,A=c;T2[(f<<2)+A>>2]=T2[l+40>>2],f=f+1|0;}if(!(0<(0|f)))break;}v&&A&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2]));}L2=256+d|0;}function v4(A,f,r,e){var i,a,n,o,b=0,t=0,c=0,u=0,k=0,l=0;if(f&&r){if(!(127<(0|(u=T2[A+24>>2]))||127<T2[A+28>>2])){if(T2[5498]=T2[5498]+1,(b=K2(1043))&&(T2[(t=b+19&-16)-4>>2]=b),1<=(0|u))for(;k=T2[A+32>>2]+c|0,l=T2[k+4>>2],T2[(b=t+c|0)>>2]=T2[k>>2],T2[b+4>>2]=l,c=c+8|0,u=u-1|0;);(b=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2])),T2[A+32>>2]=t,T2[A+28>>2]=128,p2[A+36|0]=1;}for(T2[A+24>>2]=128,b=T2[A+32>>2],T2[b+4>>2]=r,T2[b>>2]=f,u=124,f=1;;){if(k=T2[A+32>>2],t=T2[(b=k+(i=(f=(r=f)-1|0)<<3)|0)+4>>2],b=T2[b>>2],(0|u)<(0|f)){if(!((0|(l=(u=T2[A+24>>2])<<1))<=(0|u)||T2[A+28>>2]>=(0|l))){if(k=0,u&&(T2[5498]=T2[5498]+1,(c=K2(19+(u<<4)|0))&&(T2[(k=c+19&-16)-4>>2]=c),!((0|u)<1)))for(c=0;a=T2[A+32>>2]+c|0,o=T2[4+a>>2],T2[(n=c+k|0)>>2]=T2[a>>2],T2[4+n>>2]=o,c=c+8|0,u=u-1|0;);(u=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[u-4>>2])),T2[A+32>>2]=k,p2[A+36|0]=1,T2[A+28>>2]=l;}u=(T2[A+24>>2]=l)-4|0;}if((0|b)!=(0|t)?j2[b>>2]<=j2[t+16>>2]&&j2[b+16>>2]>=j2[t>>2]&&j2[b+4>>2]<=j2[t+20>>2]&&j2[b+20>>2]>=j2[t+4>>2]&&j2[b+8>>2]<=j2[t+24>>2]&&j2[b+24>>2]>=j2[t+8>>2]&&(c=T2[t+40>>2],T2[b+40>>2]?(f=T2[b+36>>2],f=c?(T2[(c=k+i|0)+4>>2]=T2[t+36>>2],T2[c>>2]=f,c=T2[b+40>>2],k=(f=r<<3)+T2[A+32>>2]|0,T2[k+4>>2]=T2[t+36>>2],T2[k>>2]=c,c=T2[b+36>>2],k=f+T2[A+32>>2]|0,T2[k+12>>2]=T2[t+40>>2],T2[k+8>>2]=c,b=T2[b+40>>2],f=f+T2[A+32>>2]|0,T2[f+20>>2]=T2[t+40>>2],T2[f+16>>2]=b,r+3|0):(T2[(c=k+i|0)+4>>2]=t,T2[c>>2]=f,f=T2[b+40>>2],b=T2[A+32>>2]+(r<<3)|0,T2[b+4>>2]=t,T2[b>>2]=f,r+1|0)):c?(T2[(f=k+i|0)+4>>2]=T2[t+36>>2],T2[f>>2]=b,f=T2[A+32>>2]+(r<<3)|0,T2[f+4>>2]=T2[t+40>>2],T2[f>>2]=b,f=r+1|0):n1[T2[T2[e>>2]+8>>2]](e,b,t)):T2[b+40>>2]&&(t=T2[b+36>>2],T2[(f=k+i|0)+4>>2]=t,T2[f>>2]=t,t=(f=r<<3)+T2[A+32>>2]|0,c=T2[b+40>>2],T2[t+4>>2]=c,T2[t>>2]=c,t=T2[b+40>>2],f=8+(f+T2[A+32>>2]|0)|0,T2[f>>2]=T2[b+36>>2],T2[f+4>>2]=t,f=r+2|0),!f)break;}}}function d4(A,f,r,e,i,a,n,o,b){var t,c,u,k,l,s=0,v=0,d=0,B=0,Q=0,g=z2(0),w=0,G=z2(0),C=z2(0),E=0;if(L2=Q=L2-32|0,A){if((0|(s=T2[o+4>>2]))<=127){if(T2[o+8>>2]<=127){if(T2[5498]=T2[5498]+1,(d=K2(531))&&(T2[(v=d+19&-16)-4>>2]=d),1<=(0|s))for(d=s;T2[v+B>>2]=T2[T2[o+12>>2]+B>>2],B=B+4|0,d=d-1|0;);(d=T2[o+12>>2])&&S2[o+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[d-4>>2])),T2[o+12>>2]=v,p2[o+16|0]=1,T2[o+8>>2]=128;}for(B=s<<2,d=s-128|0;B=B+4|(T2[T2[o+12>>2]+B>>2]=0),(s=d)>>>0<=(d=s+1|0)>>>0;);}for(T2[o+4>>2]=128,T2[T2[o+12>>2]>>2]=A,A=126,d=1;;){T2[12+Q>>2]=0,w=T2[o+12>>2],B=T2[w+(k=(s=d-1|0)<<2)>>2],j2[8+Q>>2]=j2[B+8>>2]-j2[n+8>>2],j2[4+Q>>2]=j2[B+4>>2]-j2[n+4>>2],j2[Q>>2]=j2[B>>2]-j2[n>>2],G=j2[B+24>>2],C=j2[B+16>>2],g=j2[a+8>>2],t=j2[a>>2],j2[20+Q>>2]=j2[B+20>>2]-j2[a+4>>2],j2[16+Q>>2]=C-t,j2[24+Q>>2]=G-g,v=T2[e+4>>2],t=j2[f+4>>2],c=j2[r+4>>2],G=z2(z2(j2[4+((v<<4)+Q|0)>>2]-t)*c),g=j2[r>>2],E=T2[e>>2],u=j2[f>>2],C=z2(g*z2(j2[(1-E<<4)+Q>>2]-u));A:if(!(C<G||(g=z2(z2(j2[(E<<4)+Q>>2]-u)*g),(t=z2(c*z2(j2[4+((1-v<<4)+Q|0)>>2]-t)))<g||(v=T2[e+8>>2],u=j2[f+8>>2],l=j2[r+8>>2],(C=t<C?t:C)<(c=z2(z2(j2[8+((v<<4)+Q|0)>>2]-u)*l))||(G=g<G?G:g,!(!((g=z2(l*z2(j2[8+((1-v<<4)+Q|0)>>2]-u)))<G)&&(G<c?c:G)<i&&(g<C?g:C)>z2(0))))))){if(T2[B+40>>2]){if((0|A)<(0|s)){if((0|(s=T2[o+4>>2]))<(0|(E=s<<1))){if((0|E)>T2[o+8>>2]){if(w=0,s&&(T2[5498]=T2[5498]+1,(A=K2(19+(s<<3)|0))&&(T2[(w=A+19&-16)-4>>2]=A),!((0|s)<1)))for(v=0,A=s;T2[v+w>>2]=T2[T2[o+12>>2]+v>>2],v=v+4|0,A=A-1|0;);(A=T2[o+12>>2])&&S2[o+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[o+12>>2]=w,p2[o+16|0]=1,T2[o+8>>2]=E;}if(((T2[(v=s<<2)+w>>2]=0)|E)!=(s+1|0))for(A=s-1|0,v=v+4|0;v=v+4|(T2[T2[o+12>>2]+v>>2]=0),A=A-1|0;);w=T2[o+12>>2];}A=(T2[o+4>>2]=E)-2|0;}T2[w+k>>2]=T2[B+36>>2],T2[T2[o+12>>2]+(d<<2)>>2]=T2[B+40>>2],s=d+1|0;break A;}n1[T2[T2[b>>2]+12>>2]](b,B);}if(!(d=s))break;}}L2=32+Q|0;}function B4(A){return T2[(A|=0)+96>>2];}function Q4(A){}function g4(A,f){A=T2[(A|=0)+4>>2],n1[T2[T2[A>>2]+8>>2]](A,T2[(f|=0)+36>>2]);}function w4(A,f){var r,e,i,a,n,o,b,t,c,u,k,l,s,v=0,d=0,B=0,Q=z2(0),g=0,w=z2(0),G=z2(0),C=(z2(0));L2=g=L2-16|0,T2[A+372>>2]=0,T2[A+376>>2]=0,T2[A+252>>2]=2,T2[A+604>>2]=1065353216,T2[A+608>>2]=1065353216,T2[A+408>>2]=1065353216,T2[A+412>>2]=1065353216,T2[A+472>>2]=0,T2[A+476>>2]=0,T2[(v=A+380|0)>>2]=0,T2[v+4>>2]=0,T2[(v=A+388|0)>>2]=0,T2[v+4>>2]=0,T2[(v=A+396|0)>>2]=0,T2[v+4>>2]=0,T2[(v=A+612|0)>>2]=1065353216,T2[v+4>>2]=0,T2[(v=A+420|0)>>2]=0,T2[v+4>>2]=0,T2[A+416>>2]=1065353216,T2[(v=A+428|0)>>2]=0,T2[v+4>>2]=0,T2[(v=A+436|0)>>2]=0,T2[v+4>>2]=0,T2[(v=A+444|0)>>2]=0,T2[v+4>>2]=0,T2[A+452>>2]=0,T2[(v=A+480|0)>>2]=0,T2[v+4>>2]=0,T2[(v=A+488|0)>>2]=0,T2[v+4>>2]=0,T2[(v=A+496|0)>>2]=0,T2[v+4>>2]=0,w=j2[f+96>>2],Q=j2[f+92>>2],j2[12+g>>2]=Q,j2[8+g>>2]=w,T2[4+g>>2]=0,T2[g>>2]=1065353216,j2[A+504>>2]=j2[(Q<z2(0)?4+g|0:Q>z2(1)?g:12+g|0)>>2],T2[4+g>>2]=0,T2[g>>2]=1065353216,j2[A+508>>2]=j2[(w<z2(0)?4+g|0:w>z2(1)?g:8+g|0)>>2],T2[A+668>>2]=0,T2[A+672>>2]=0,v=T2[f+120>>2],T2[A+532>>2]=T2[f+116>>2],T2[A+536>>2]=v,d=T2[f+4>>2],T2[A+540>>2]=d,p2[A+512|0]=S2[f+124|0],v=T2[f+132>>2],T2[A+516>>2]=T2[f+128>>2],T2[A+520>>2]=v,v=T2[f+140>>2],T2[A+524>>2]=T2[f+136>>2],T2[A+528>>2]=v,d?n1[T2[T2[d>>2]+8>>2]](d,v=A+4|0):(v=T2[f+12>>2],T2[A+4>>2]=T2[f+8>>2],T2[A+8>>2]=v,B=T2[(d=f+16|0)+4>>2],T2[(v=A+12|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=f+32|0)+4>>2],T2[(v=A+28|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=f+24|0)+4>>2],T2[(v=A+20|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=f+40|0)+4>>2],T2[(v=A+36|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=f+48|0)+4>>2],T2[(v=A+44|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=f- -64|0)+4>>2],T2[(v=A+60|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=f+56|0)+4>>2],T2[(v=A+52|0)>>2]=T2[d>>2],T2[v+4>>2]=B,v=A+4|0),T2[A+132>>2]=0,T2[A+136>>2]=0,d=T2[v+4>>2],T2[A+68>>2]=T2[v>>2],T2[A+72>>2]=d,T2[(d=A+156|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+148|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+140|0)>>2]=0,T2[d+4>>2]=0,s=T2[(B=A+20|0)+4>>2],T2[(d=A+84|0)>>2]=T2[B>>2],T2[d+4>>2]=s,B=T2[(v=v+8|0)+4>>2],T2[(d=A+76|0)>>2]=T2[v>>2],T2[d+4>>2]=B,B=T2[(d=A+28|0)+4>>2],T2[(v=A+92|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=A+36|0)+4>>2],T2[(v=A+100|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=A+44|0)+4>>2],T2[(v=A+108|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=A+52|0)+4>>2],T2[(v=A+116|0)>>2]=T2[d>>2],T2[v+4>>2]=B,B=T2[(d=A+60|0)+4>>2],T2[(v=A+124|0)>>2]=T2[d>>2],T2[v+4>>2]=B,j2[A+228>>2]=j2[f+100>>2],j2[A+236>>2]=j2[f+104>>2],j2[A+240>>2]=j2[f+108>>2],j2[A+232>>2]=j2[f+112>>2],n1[T2[T2[A>>2]+8>>2]](A,T2[f+72>>2]),v=T2[5866],T2[A+568>>2]=v,T2[5866]=v+1,w=z2(0),v=T2[A+204>>2],(Q=j2[f>>2])!=z2(0)?(T2[A+204>>2]=-2&v,w=z2(z2(1)/Q)):T2[A+204>>2]=1|v,j2[A+404>>2]=w,T2[A+436>>2]=0,j2[A+424>>2]=Q*j2[A+440>>2],j2[A+432>>2]=Q*j2[A+448>>2],j2[A+428>>2]=Q*j2[A+444>>2],Q=j2[f+84>>2],G=j2[f+80>>2],C=j2[f+76>>2],T2[A+468>>2]=0,b=C!=z2(0)?z2(z2(1)/C):z2(0),j2[A+456>>2]=b,t=G!=z2(0)?z2(z2(1)/G):z2(0),j2[A+460>>2]=t,c=Q!=z2(0)?z2(z2(1)/Q):z2(0),j2[A+464>>2]=c,T2[A+368>>2]=0,T2[A+352>>2]=0,T2[A+336>>2]=0,Q=j2[A+44>>2],G=j2[A+36>>2],C=j2[A+40>>2],u=j2[A+28>>2],k=j2[A+20>>2],l=j2[A+24>>2],a=j2[A+12>>2],n=j2[A+8>>2],o=j2[A+4>>2],T2[A+564>>2]=8,r=z2(b*o),e=z2(t*n),i=z2(c*a),j2[A+324>>2]=z2(z2(o*r)+z2(n*e))+z2(a*i),j2[A+328>>2]=z2(z2(r*k)+z2(e*l))+z2(i*u),j2[A+332>>2]=z2(z2(r*G)+z2(e*C))+z2(i*Q),r=z2(b*k),e=z2(t*l),i=z2(c*u),j2[A+340>>2]=z2(z2(o*r)+z2(n*e))+z2(a*i),j2[A+344>>2]=z2(z2(k*r)+z2(l*e))+z2(u*i),j2[A+348>>2]=z2(z2(r*G)+z2(e*C))+z2(i*Q),r=o,o=z2(b*G),e=n,n=z2(t*C),i=a,a=z2(c*Q),j2[A+356>>2]=z2(z2(r*o)+z2(e*n))+z2(i*a),j2[A+360>>2]=z2(z2(k*o)+z2(l*n))+z2(u*a),j2[A+364>>2]=z2(z2(G*o)+z2(C*n))+z2(Q*a),T2[(f=A+596|0)>>2]=0,T2[f+4>>2]=0,T2[(f=A+588|0)>>2]=0,T2[f+4>>2]=0,T2[(f=A+580|0)>>2]=0,T2[f+4>>2]=0,T2[A+572>>2]=0,T2[A+576>>2]=0,Q=j2[A+408>>2],G=j2[A+412>>2],j2[A+628>>2]=w*j2[A+416>>2],j2[A+624>>2]=w*G,j2[A+620>>2]=w*Q,T2[A+664>>2]=0,T2[(f=A+656|0)>>2]=0,T2[f+4>>2]=0,T2[(f=A+648|0)>>2]=0,T2[f+4>>2]=0,T2[(f=A+640|0)>>2]=0,T2[f+4>>2]=0,T2[(A=A+632|0)>>2]=0,T2[A+4>>2]=0,L2=16+g|0;}function G4(A,f,r,e){var i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h=z2(0),Z=z2(0),Y=(0);L2=Y=L2+-64|0,k=j2[f+24>>2],l=j2[f+20>>2],s=j2[f+40>>2],v=j2[f+36>>2],n=j2[A+40>>2],o=j2[A+20>>2],b=j2[A+36>>2],t=j2[A+24>>2],d=j2[f+8>>2],B=j2[f>>2],Q=j2[f+4>>2],g=j2[f+16>>2],w=j2[f+32>>2],Z=j2[A+8>>2],i=j2[A+4>>2],u=j2[A+32>>2],c=j2[A+16>>2],a=j2[A>>2],T2[60+Y>>2]=0,T2[44+Y>>2]=0,C=z2(z2(o*n)-z2(t*b)),E=z2(z2(t*u)-z2(n*c)),D=z2(z2(b*c)-z2(o*u)),h=z2(z2(1)/z2(z2(z2(a*C)+z2(i*E))+z2(Z*D))),G=z2(z2(z2(t*i)-z2(o*Z))*h),t=z2(z2(z2(c*Z)-z2(t*a))*h),o=z2(z2(z2(o*a)-z2(c*i))*h),j2[56+Y>>2]=z2(z2(w*G)+z2(v*t))+z2(s*o),c=z2(z2(z2(b*Z)-z2(n*i))*h),Z=z2(z2(z2(n*a)-z2(u*Z))*h),i=z2(z2(z2(u*i)-z2(b*a))*h),j2[52+Y>>2]=z2(z2(w*c)+z2(v*Z))+z2(s*i),j2[40+Y>>2]=z2(z2(G*g)+z2(t*l))+z2(o*k),j2[36+Y>>2]=z2(z2(c*g)+z2(Z*l))+z2(i*k),T2[28+Y>>2]=0,a=z2(C*h),n=z2(E*h),h=z2(D*h),j2[48+Y>>2]=z2(z2(w*a)+z2(v*n))+z2(s*h),j2[32+Y>>2]=z2(z2(a*g)+z2(n*l))+z2(h*k),j2[24+Y>>2]=z2(d*o)+z2(z2(B*G)+z2(Q*t)),j2[20+Y>>2]=z2(d*i)+z2(z2(B*c)+z2(Q*Z)),j2[16+Y>>2]=z2(h*d)+z2(z2(B*a)+z2(Q*n)),C4(16+Y|0,Y),a=j2[Y>>2],n=j2[4+Y>>2],o=j2[8+Y>>2],h=j2[12+Y>>2],i=z2(z2(1)/z2(_2(z2(z2(z2(z2(a*a)+z2(n*n))+z2(o*o))+z2(h*h))))),v1(Z=z2(F2(z2(H2(z2(h*i),z2(-1))),z2(1))));A:if(1065353216<=(A=2147483647&(f=u1[2]))>>>0)h=z2((0|f)<0?3.141592502593994:0),1065353216!=(0|A)&&(h=z2(z2(0)/z2(Z-Z)));else f:{if(A>>>0<=1056964607){if(h=z2(1.570796251296997),A>>>0<847249409)break f;h=z2(Z*Z),h=z2(z2(z2(z2(7.549789415861596e-8)-z2(z2(z2(h*z2(z2(h*z2(z2(h*z2(-.008656363002955914))+z2(-.04274342209100723)))+z2(.16666586697101593)))/z2(z2(h*z2(-.7066296339035034))+z2(1)))*Z))-Z)+z2(1.570796251296997));break A;}if((0|f)<=-1){h=z2(z2(Z+z2(1))*z2(.5)),Z=z2(_2(h)),h=z2(z2(1.570796251296997)-z2(Z+z2(z2(Z*z2(z2(h*z2(z2(h*z2(z2(h*z2(-.008656363002955914))+z2(-.04274342209100723)))+z2(.16666586697101593)))/z2(z2(h*z2(-.7066296339035034))+z2(1))))+z2(-7.549789415861596e-8)))),h=z2(h+h);break A;}h=z2(z2(z2(1)-Z)*z2(.5)),k1(2,-4096&(v1(b=z2(_2(h))),u1[2])),Z=d1(),h=z2(z2(z2(b*z2(z2(h*z2(z2(h*z2(z2(h*z2(-.008656363002955914))+z2(-.04274342209100723)))+z2(.16666586697101593)))/z2(z2(h*z2(-.7066296339035034))+z2(1))))+z2(z2(h-z2(Z*Z))/z2(b+Z)))+Z),h=z2(h+h);}j2[e>>2]=h+h,T2[r+12>>2]=0,h=z2(a*i),Z=z2(n*i),i=z2(o*i),(a=z2(z2(z2(h*h)+z2(Z*Z))+z2(i*i)))<z2(14210854715202004e-30)?(T2[r+8>>2]=0,T2[r+12>>2]=0,T2[r>>2]=1065353216,T2[r+4>>2]=0):(n=i,i=z2(z2(1)/z2(_2(a))),j2[r+8>>2]=n*i,j2[r+4>>2]=Z*i,j2[r>>2]=h*i),L2=Y+64|0;}function C4(A,f){var r,e,i,a,n=z2(0),o=z2(0),b=0,t=z2(0),c=z2(0),u=L2-16|0,n=j2[A>>2],t=j2[A+20>>2],c=j2[A+40>>2];n=(o=z2(z2(n+t)+c))>z2(0)?(o=z2(_2(z2(o+z2(1)))),n=z2(z2(.5)/o),t=z2(n*z2(j2[A+16>>2]-j2[A+4>>2])),c=z2(n*z2(j2[A+8>>2]-j2[A+32>>2])),o=z2(o*z2(.5)),z2(n*z2(j2[A+36>>2]-j2[A+24>>2]))):(e=(r=n<t?t<c?2:1:(n<c)<<1)<<2,i=(r<<4)+A|0,a=((b=(1+r>>>0)%3|0)<<4)+A|0,r=A+((A=(2+r>>>0)%3|0)<<4)|0,A<<=2,n=z2(_2(z2(z2(z2(j2[i+e>>2]-j2[a+(b<<=2)>>2])-j2[r+A>>2])+z2(1)))),j2[(e|u)>>2]=n*z2(.5),n=z2(z2(.5)/n),j2[12+u>>2]=z2(j2[r+b>>2]-j2[A+a>>2])*n,j2[(u|b)>>2]=n*z2(j2[e+a>>2]+j2[b+i>>2]),j2[(A|u)>>2]=n*z2(j2[r+e>>2]+j2[A+i>>2]),o=j2[12+u>>2],t=j2[8+u>>2],c=j2[4+u>>2],j2[u>>2]),j2[f+12>>2]=o,j2[f+8>>2]=t,j2[f+4>>2]=c,j2[f>>2]=n;}function E4(A,f){var r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C=0,E=0,D=0;2&S2[A+204|0]?(C=T2[A+8>>2],T2[A+68>>2]=T2[A+4>>2],T2[A+72>>2]=C,D=T2[(E=A+12|0)+4>>2],T2[(C=A+76|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=A+20|0)+4>>2],T2[(C=A+84|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=A+28|0)+4>>2],T2[(C=A+92|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=A+36|0)+4>>2],T2[(C=A+100|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=A+44|0)+4>>2],T2[(C=A+108|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=A+52|0)+4>>2],T2[(C=A+116|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=A+60|0)+4>>2],T2[(C=A+124|0)>>2]=T2[E>>2],T2[C+4>>2]=D):(C=T2[f+4>>2],T2[A+68>>2]=T2[f>>2],T2[A+72>>2]=C,D=T2[(E=f+8|0)+4>>2],T2[(C=A+76|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=f+24|0)+4>>2],T2[(C=A+92|0)>>2]=T2[E>>2],T2[C+4>>2]=D,E=T2[f+20>>2],T2[(C=A+84|0)>>2]=T2[f+16>>2],T2[C+4>>2]=E,E=T2[f+36>>2],T2[(C=A+100|0)>>2]=T2[f+32>>2],T2[C+4>>2]=E,D=T2[(E=f+40|0)+4>>2],T2[(C=A+108|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=f+56|0)+4>>2],T2[(C=A+124|0)>>2]=T2[E>>2],T2[C+4>>2]=D,E=T2[f+52>>2],T2[(C=A+116|0)>>2]=T2[f+48>>2],T2[C+4>>2]=E),C=T2[A+392>>2],T2[A+148>>2]=T2[A+388>>2],T2[A+152>>2]=C,C=T2[A+376>>2],T2[A+132>>2]=T2[A+372>>2],T2[A+136>>2]=C,D=T2[(E=A+396|0)+4>>2],T2[(C=A+156|0)>>2]=T2[E>>2],T2[C+4>>2]=D,D=T2[(E=A+380|0)+4>>2],T2[(C=A+140|0)>>2]=T2[E>>2],T2[C+4>>2]=D,u=T2[(D=f+8|0)+4>>2],T2[(C=A+12|0)>>2]=T2[D>>2],T2[C+4>>2]=u,E=T2[f+4>>2],T2[A+4>>2]=T2[f>>2],T2[A+8>>2]=E,e=T2[4+(u=f+24|0)>>2],T2[(E=A+28|0)>>2]=T2[u>>2],T2[E+4>>2]=e,e=T2[f+20>>2],T2[(D=A+20|0)>>2]=T2[f+16>>2],T2[D+4>>2]=e,o=T2[4+(r=f+40|0)>>2],T2[(e=u=A+44|0)>>2]=T2[r>>2],T2[4+e>>2]=o,o=T2[f+36>>2],T2[(r=e=A+36|0)>>2]=T2[f+32>>2],T2[4+r>>2]=o,G=T2[4+(o=f+56|0)>>2],T2[(r=A+60|0)>>2]=T2[o>>2],T2[4+r>>2]=G,o=T2[f+52>>2],T2[(r=A+52|0)>>2]=T2[f+48>>2],T2[4+r>>2]=o,k=j2[A+8>>2],l=j2[C>>2],s=j2[E>>2],v=j2[D>>2],d=j2[A+24>>2],b=j2[u>>2],Q=j2[A+464>>2],t=j2[e>>2],c=j2[A+40>>2],g=j2[A+460>>2],B=j2[A+4>>2],w=j2[A+456>>2],T2[A+368>>2]=0,T2[A+352>>2]=0,T2[A+336>>2]=0,i=z2(w*t),a=z2(g*c),n=z2(Q*b),j2[A+364>>2]=z2(z2(t*i)+z2(c*a))+z2(b*n),j2[A+360>>2]=z2(z2(v*i)+z2(d*a))+z2(s*n),j2[A+356>>2]=z2(z2(B*i)+z2(k*a))+z2(l*n),i=z2(w*v),a=z2(g*d),n=z2(Q*s),j2[A+348>>2]=z2(z2(t*i)+z2(c*a))+z2(b*n),j2[A+344>>2]=z2(z2(v*i)+z2(d*a))+z2(s*n),j2[A+340>>2]=z2(z2(B*i)+z2(k*a))+z2(l*n),i=t,t=z2(B*w),a=c,c=z2(k*g),n=b,b=z2(l*Q),j2[A+332>>2]=z2(z2(i*t)+z2(a*c))+z2(n*b),j2[A+328>>2]=z2(z2(t*v)+z2(c*d))+z2(b*s),j2[A+324>>2]=z2(z2(B*t)+z2(k*c))+z2(l*b);}function D4(A,f){var r=0,e=0,i=0,a=0,n=0;A:{f:if(!((0|(e=T2[A+548>>2]))<1)){for(i=T2[A+556>>2],r=e;T2[i>>2]!=(0|f);)if(i=i+4|0,!(r=r-1|0))break f;if(r)break A;}if(T2[A+552>>2]==(0|e)&&!((0|(a=e?e<<1:1))<=(0|e))){if(a&&(T2[5498]=T2[5498]+1,(r=K2(19+(a<<2)|0))&&(T2[(n=r+19&-16)-4>>2]=r)),1<=(0|e))for(i=0,r=e;T2[i+n>>2]=T2[T2[A+556>>2]+i>>2],i=i+4|0,r=r-1|0;);(r=T2[A+556>>2])&&S2[A+560|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),e=T2[A+548>>2]),T2[A+556>>2]=n,T2[A+552>>2]=a,p2[A+560|0]=1;}if(T2[T2[A+556>>2]+(e<<2)>>2]=f,T2[A+548>>2]=e+1,r=T2[f+32>>2],(0|(n=T2[f+28>>2]))!=(0|A)){if((0|(f=T2[r+288>>2]))==T2[r+292>>2]&&!((0|(a=f?f<<1:1))<=(0|f))){if(e=0,a&&(T2[5498]=T2[5498]+1,(A=K2(19+(a<<2)|0))&&(T2[(e=A+19&-16)-4>>2]=A)),1<=(0|f))for(i=0,A=f;T2[e+i>>2]=T2[T2[r+296>>2]+i>>2],i=i+4|0,A=A-1|0;);(A=T2[r+296>>2])&&S2[r+300|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2]),f=T2[r+288>>2]),T2[r+296>>2]=e,T2[r+292>>2]=a,p2[r+300|0]=1;}A=r,r=n;}else if((0|(f=T2[A+288>>2]))==T2[A+292>>2]&&!((0|(a=f?f<<1:1))<=(0|f))){if(n=0,a&&(T2[5498]=T2[5498]+1,(e=K2(19+(a<<2)|0))&&(T2[(n=e+19&-16)-4>>2]=e)),1<=(0|f))for(i=0,e=f;T2[i+n>>2]=T2[T2[A+296>>2]+i>>2],i=i+4|0,e=e-1|0;);(e=T2[A+296>>2])&&S2[A+300|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]),f=T2[A+288>>2]),T2[A+296>>2]=n,T2[A+292>>2]=a,p2[A+300|0]=1;}T2[A+288>>2]=f+1,T2[A+280>>2]=(-1^f)>>>31,T2[T2[A+296>>2]+(f<<2)>>2]=r;}}function h4(A,f){var r=0,e=0,i=0,a=0;A:if(!((0|(a=T2[A+548>>2]))<1)){for(e=i=T2[A+556>>2];T2[e>>2]!=(0|f);)if(e=e+4|0,(0|a)==(0|(r=r+1|0)))break A;if(!((0|a)<=(0|r))){r=0,e=i;f:{for(;T2[e>>2]!=(0|f);)if(e=e+4|0,(0|a)==(0|(r=r+1|0)))break f;(0|a)<=(0|r)||(T2[e>>2]=T2[(r=i)+(i=(e=a-1|0)<<2)>>2],T2[A+548>>2]=e,T2[i+T2[A+556>>2]>>2]=f);}if(a=T2[f+32>>2],(0|(i=T2[f+28>>2]))==(0|A)){f:if(!((0|(f=T2[A+288>>2]))<1)){for(r=0,e=i=T2[A+296>>2];T2[e>>2]!=(0|a);)if(e=e+4|0,(0|(r=r+1|0))==(0|f))break f;(0|f)<=(0|r)||(T2[e>>2]=T2[(r=i)+(i=(f=f-1|0)<<2)>>2],T2[A+288>>2]=f,T2[i+T2[A+296>>2]>>2]=a);}return void(T2[A+280>>2]=0<(0|f));}f:if(!((0|(f=T2[a+288>>2]))<1)){for(r=0,e=A=T2[a+296>>2];(0|i)!=T2[e>>2];)if(e=e+4|0,(0|(r=r+1|0))==(0|f))break f;(0|f)<=(0|r)||(T2[e>>2]=T2[(r=A)+(A=(f=f-1|0)<<2)>>2],T2[a+288>>2]=f,T2[A+T2[a+296>>2]>>2]=i);}T2[a+280>>2]=0<(0|f);}}}function Z4(A){var f=0;return T2[(A|=0)>>2]=17208,(f=T2[A+204>>2])&&S2[A+208|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+204>>2]=0,p2[A+208|0]=1,T2[(f=A+196|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+176>>2])&&S2[A+180|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+176>>2]=0,p2[A+180|0]=1,T2[(f=A+168|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+156>>2])&&S2[A+160|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+156>>2]=0,p2[A+160|0]=1,T2[(f=A+148|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+136>>2])&&S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+136>>2]=0,p2[A+140|0]=1,T2[(f=A+128|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+116>>2])&&S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+116>>2]=0,p2[A+120|0]=1,T2[(f=A+108|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+96>>2]=0,p2[A+100|0]=1,T2[(f=A+88|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+76>>2])&&S2[A+80|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+76>>2]=0,p2[A+80|0]=1,T2[(f=A+68|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+56>>2]=0,p2[A+60|0]=1,T2[(f=A+48|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+36>>2]=0,p2[A+40|0]=1,T2[(f=A+28|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+16>>2]=0,p2[A+20|0]=1,T2[(f=A+8|0)>>2]=0,(T2[f+4>>2]=0)|A;}function Y4(A,f,r){var e,i,a,n,o,b,t,c,u,k,l,s,v,d=0,B=(0),Q=(0);return L2=Q=L2-256|0,-1<(0|(B=T2[f+212>>2]))||(2&(d=T2[f+252>>2])&&(2&S2[(d=d<<30>>31&f)+204|0]||j2[d+404>>2]!=z2(0))?(B=T2[A+8>>2],d2(8+Q|0,0,244),A=m4(A+4|0,8+Q|0),d=T2[f+252>>2],T2[(e=A+88|0)>>2]=0,T2[4+e>>2]=0,T2[(e=A+80|0)>>2]=0,T2[4+e>>2]=0,T2[(e=A+72|0)>>2]=0,T2[4+e>>2]=0,T2[A+64>>2]=0,T2[A+68>>2]=0,T2[A+144>>2]=0,T2[A+148>>2]=0,T2[(e=A+152|0)>>2]=0,T2[4+e>>2]=0,T2[(e=A+160|0)>>2]=0,T2[4+e>>2]=0,T2[(e=A+168|0)>>2]=0,T2[4+e>>2]=0,2&d?(e=T2[(d=d<<30>>31&f)+8>>2],T2[A>>2]=T2[d+4>>2],T2[A+4>>2]=e,a=T2[4+(i=d+12|0)>>2],T2[(e=A+8|0)>>2]=T2[i>>2],T2[4+e>>2]=a,a=T2[4+(i=d+28|0)>>2],T2[(e=A+24|0)>>2]=T2[i>>2],T2[4+e>>2]=a,i=T2[4+(e=d+20|0)>>2],T2[A+16>>2]=T2[e>>2],T2[A+20>>2]=i,a=T2[4+(i=d+44|0)>>2],T2[(e=A+40|0)>>2]=T2[i>>2],T2[4+e>>2]=a,i=T2[4+(e=d+36|0)>>2],T2[A+32>>2]=T2[e>>2],T2[A+36>>2]=i,i=T2[4+(e=d+52|0)>>2],T2[A+48>>2]=T2[e>>2],T2[A+52>>2]=i,a=T2[4+(i=d+60|0)>>2],T2[(e=A+56|0)>>2]=T2[i>>2],T2[4+e>>2]=a,o=j2[d+412>>2],b=j2[(e=d+416|0)>>2],t=j2[d+408>>2],n=j2[d+404>>2],T2[A+140>>2]=0,j2[A+136>>2]=n*b,j2[A+132>>2]=n*o,j2[A+128>>2]=n*t,T2[A+240>>2]=d,c=T2[4+(a=d+612|0)>>2],T2[(i=A+104|0)>>2]=T2[a>>2],T2[4+i>>2]=c,i=T2[d+608>>2],T2[A+96>>2]=T2[d+604>>2],T2[A+100>>2]=i,a=T2[4+e>>2],T2[(i=A+120|0)>>2]=T2[e>>2],T2[4+i>>2]=a,e=T2[d+412>>2],T2[A+112>>2]=T2[d+408>>2],T2[A+116>>2]=e,a=T2[4+(i=d+380|0)>>2],T2[(e=A+184|0)>>2]=T2[i>>2],T2[4+e>>2]=a,e=T2[d+376>>2],T2[A+176>>2]=T2[d+372>>2],T2[A+180>>2]=e,e=T2[d+392>>2],T2[A+192>>2]=T2[d+388>>2],T2[A+196>>2]=e,a=T2[4+(i=d+396|0)>>2],T2[(e=A+200|0)>>2]=T2[i>>2],T2[4+e>>2]=a,o=j2[d+476>>2],b=j2[d+480>>2],t=j2[d+472>>2],n=j2[d+404>>2],T2[A+220>>2]=0,j2[A+216>>2]=z2(n*b)*r,j2[A+212>>2]=z2(n*o)*r,j2[A+208>>2]=z2(n*t)*r,t=j2[d+340>>2],u=j2[d+356>>2],k=j2[d+328>>2],l=j2[d+344>>2],s=j2[d+360>>2],v=j2[d+324>>2],n=j2[d+488>>2],o=j2[d+492>>2],b=j2[d+496>>2],j2[A+232>>2]=z2(z2(z2(n*j2[d+332>>2])+z2(o*j2[d+348>>2]))+z2(b*j2[d+364>>2]))*r,j2[A+228>>2]=z2(z2(z2(n*k)+z2(o*l))+z2(b*s))*r,j2[A+224>>2]=z2(z2(z2(v*n)+z2(t*o))+z2(u*b))*r):(T2[A+4>>2]=0,T2[A+8>>2]=0,T2[A>>2]=1065353216,T2[A+240>>2]=0,T2[A+128>>2]=0,T2[A+132>>2]=0,T2[A+112>>2]=1065353216,T2[A+116>>2]=1065353216,T2[A+96>>2]=1065353216,T2[A+100>>2]=1065353216,T2[A+176>>2]=0,T2[A+180>>2]=0,T2[(d=A+12|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+24|0)>>2]=0,T2[d+4>>2]=0,T2[A+20>>2]=1065353216,T2[(d=A+32|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+44|0)>>2]=0,T2[d+4>>2]=0,T2[A+40>>2]=1065353216,T2[(d=A+52|0)>>2]=0,T2[d+4>>2]=0,T2[A+60>>2]=0,T2[(d=A+136|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+120|0)>>2]=1065353216,T2[d+4>>2]=0,T2[(d=A+104|0)>>2]=1065353216,T2[d+4>>2]=0,T2[A+232>>2]=0,T2[(d=A+224|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+216|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+208|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+200|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+192|0)>>2]=0,T2[d+4>>2]=0,T2[(d=A+184|0)>>2]=0,T2[d+4>>2]=0),T2[A+236>>2]=0,T2[f+212>>2]=B):-1<(0|(B=T2[A+188>>2]))||(T2[A+188>>2]=T2[A+8>>2],d2(8+Q|0,0,244),f=m4(A+4|0,8+Q|0),T2[(d=f+88|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+80|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+72|0)>>2]=0,T2[d+4>>2]=0,T2[f+64>>2]=0,T2[f+68>>2]=0,T2[f+144>>2]=0,T2[f+148>>2]=0,T2[(d=f+152|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+160|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+168|0)>>2]=0,T2[d+4>>2]=0,T2[f+4>>2]=0,T2[f+8>>2]=0,T2[f>>2]=1065353216,T2[(d=f+12|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+24|0)>>2]=0,T2[d+4>>2]=0,T2[f+20>>2]=1065353216,T2[(d=f+32|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+44|0)>>2]=0,T2[d+4>>2]=0,T2[f+40>>2]=1065353216,T2[(d=f+52|0)>>2]=0,T2[d+4>>2]=0,T2[f+60>>2]=0,T2[(d=f+136|0)>>2]=0,T2[d+4>>2]=0,T2[f+128>>2]=0,T2[f+132>>2]=0,T2[(d=f+120|0)>>2]=1065353216,T2[d+4>>2]=0,T2[f+112>>2]=1065353216,T2[f+116>>2]=1065353216,T2[(d=f+104|0)>>2]=1065353216,T2[d+4>>2]=0,T2[f+96>>2]=1065353216,T2[f+100>>2]=1065353216,T2[(d=f+232|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+224|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+216|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+208|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+200|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+192|0)>>2]=0,T2[d+4>>2]=0,T2[(d=f+184|0)>>2]=0,T2[d+4>>2]=0,T2[f+176>>2]=0,T2[f+180>>2]=0,T2[f+240>>2]=0,B=T2[A+188>>2])),L2=256+Q|0,B;}function R4(A,f,r,e,i,a){var n,o,b,t,c=0,u=0,k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=z2(0),B=0,Q=(0),g=0,w=z2(0),G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=(z2(0)),Y=z2(0),R=z2(0),F=z2(0),c=Q=T2[A+88>>2];if((0|c)==T2[A+92>>2]&&!((0|(B=(c=Q)?c<<1:1))<=(0|c))){if(B&&(T2[5498]=T2[5498]+1,(c=K2(P2(B,152)+19|0))&&(T2[(g=c+19&-16)-4>>2]=c)),1<=(0|Q))for(c=0,u=Q;$2(c+g|0,T2[A+96>>2]+c|0,152),c=c+152|0,u=u-1|0;);(c=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[c-4>>2])),T2[A+96>>2]=g,T2[A+92>>2]=B,p2[A+100|0]=1,c=T2[A+88>>2];}T2[A+88>>2]=c+1,c=(B=T2[A+96>>2])+P2(Q,152)|0,T2[c+16>>2]=0,T2[c+20>>2]=0,T2[c+48>>2]=-2147483648,T2[c+52>>2]=-2147483648,T2[(u=c+24|0)>>2]=0,T2[u+4>>2]=0,T2[(u=c+56|0)>>2]=-2147483648,T2[u+4>>2]=0,j2[c+104>>2]=a,T2[c+96>>2]=0,T2[c+100>>2]=0,g=T2[A+16>>2],A=T2[240+(g+P2(r,244)|0)>>2],u=T2[240+(g+P2(e,244)|0)>>2],T2[c+132>>2]=0,T2[c+140>>2]=i,T2[c+148>>2]=e,T2[c+144>>2]=r,n=j2[f+8>>2],b=j2[f+4>>2],l=j2[f>>2],T2[c+12>>2]=0,t=z2(-l),j2[c>>2]=t,s=z2(-b),j2[c+4>>2]=s,j2[c+8>>2]=-n,i=c,k=A?(v=z2(z2(z2(z2(j2[A+360>>2]*s)-z2(l*j2[A+356>>2]))-z2(n*j2[A+364>>2]))*j2[A+612>>2]),d=z2(z2(z2(z2(j2[A+344>>2]*s)-z2(l*j2[A+340>>2]))-z2(n*j2[A+348>>2]))*j2[A+608>>2]),z2(z2(z2(z2(j2[A+328>>2]*s)-z2(l*j2[A+324>>2]))-z2(n*j2[A+332>>2]))*j2[A+604>>2])):z2(0),j2[i+64>>2]=k,T2[c+76>>2]=0,j2[c+72>>2]=v,j2[c+68>>2]=d,o=j2[f>>2],v=j2[f+4>>2],d=j2[f+8>>2],j2[c+44>>2]=j2[f+12>>2],j2[c+40>>2]=d,j2[c+36>>2]=v,j2[c+32>>2]=o,i=f=B+P2(Q,152)|0,k=u?(C=z2(z2(z2(z2(o*j2[u+356>>2])+z2(v*j2[u+360>>2]))+z2(d*j2[u+364>>2]))*j2[u+612>>2]),w=z2(z2(z2(z2(o*j2[u+340>>2])+z2(v*j2[u+344>>2]))+z2(d*j2[u+348>>2]))*j2[u+608>>2]),z2(z2(z2(z2(o*j2[u+324>>2])+z2(v*j2[u+328>>2]))+z2(d*j2[u+332>>2]))*j2[u+604>>2])):z2(0),j2[i+80>>2]=k,T2[f+92>>2]=0,j2[f+88>>2]=C,j2[f+84>>2]=w,w=z2(0),C=z2(0),f=B+P2(Q,152)|0,k=A?(E=z2(z2(z2(j2[A+360>>2]*s)-z2(l*j2[A+356>>2]))-z2(n*j2[A+364>>2])),w=z2(z2(z2(j2[A+328>>2]*s)-z2(l*j2[A+324>>2]))-z2(n*j2[A+332>>2])),z2(z2(z2(j2[A+344>>2]*s)-z2(l*j2[A+340>>2]))-z2(n*j2[A+348>>2]))):z2(0),k=z2(z2(z2(z2(k*s)-z2(l*w))-z2(n*E))+z2(0)),G=u?(D=z2(z2(z2(o*j2[u+356>>2])+z2(v*j2[u+360>>2]))+z2(d*j2[u+364>>2])),h=z2(z2(z2(o*j2[u+340>>2])+z2(v*j2[u+344>>2]))+z2(d*j2[u+348>>2])),z2(z2(z2(j2[u+324>>2]*o)+z2(j2[u+328>>2]*v))+z2(j2[u+332>>2]*d))):z2(0),G=z2(z2(1)/z2(k+z2(z2(z2(G*o)+z2(h*v))+z2(D*d)))),j2[f+108>>2]=G,l=z2(0),s=z2(0),w=z2(0),E=z2(0),A&&(A=g+P2(r,244)|0,l=z2(z2(j2[A+176>>2]+j2[A+208>>2])*z2(0)),E=j2[A+192>>2],w=j2[A+200>>2],C=j2[A+196>>2],Z=z2(z2(j2[A+184>>2]+j2[A+216>>2])*z2(0)),s=z2(z2(j2[A+180>>2]+j2[A+212>>2])*z2(0))),h=u?(A=g+P2(e,244)|0,D=z2(z2(j2[A+176>>2]+j2[A+208>>2])*z2(-0)),Y=j2[A+192>>2],R=j2[A+200>>2],F=j2[A+196>>2],k=z2(z2(j2[A+180>>2]+j2[A+212>>2])*z2(-0)),z2(z2(j2[A+184>>2]+j2[A+216>>2])*z2(-0))):(D=z2(-0),k=z2(-0),z2(-0)),A=B+P2(Q,152)|0,j2[A+124>>2]=a,j2[A+120>>2]=-a,T2[A+116>>2]=0,j2[A+112>>2]=G*z2(z2(0)-z2(z2(z2(z2(l+s)+Z)+z2(z2(z2(E*t)-z2(b*C))-z2(n*w)))+z2(z2(z2(D+k)+h)+z2(z2(d*R)+z2(z2(v*F)+z2(o*Y))))));}function F4(A,f,r,e,i,a,n,o,b,t,c,u){var k,l,s,v,d,B=0,Q=0,g=z2(0),w=z2(0),G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=z2(0),Y=z2(0),R=0,F=0,W=0,m=z2(0),N=z2(0),V=z2(0),J=z2(0),M=z2(0),I=z2(0),x=z2(0),y=z2(0),U=z2(0),X=z2(0),p=z2(0),T=(z2(0)),S=z2(0),j=z2(0),P=z2(0),z=z2(0),B=(R=T2[A+68>>2]);if((0|B)==T2[A+72>>2]&&!((0|(F=(B=R)?B<<1:1))<=(0|B))){if(F&&(T2[5498]=T2[5498]+1,(B=K2(P2(F,152)+19|0))&&(T2[(Q=B+19&-16)-4>>2]=B)),1<=(0|R))for(B=0,W=R;$2(B+Q|0,T2[A+76>>2]+B|0,152),B=B+152|0,W=W-1|0;);(B=T2[A+76>>2])&&S2[A+80|0]&&(T2[5499]=T2[5499]+1,q2(T2[B-4>>2])),T2[A+76>>2]=Q,T2[A+72>>2]=F,p2[A+80|0]=1,B=T2[A+68>>2];}T2[A+68>>2]=B+1,B=(W=T2[A+76>>2])+P2(R,152)|0,T2[B+140>>2]=i,T2[B+148>>2]=e,T2[B+144>>2]=r,k=j2[a+84>>2],j2[B+104>>2]=k,T2[B+96>>2]=0,T2[B+100>>2]=0,F=T2[A+16>>2],A=T2[240+(F+P2(r,244)|0)>>2],i=T2[240+(F+P2(e,244)|0)>>2],T2[B+132>>2]=0,A?(Q=T2[f+4>>2],T2[B+16>>2]=T2[f>>2],T2[B+20>>2]=Q,s=T2[4+(l=f+8|0)>>2],T2[(Q=B+24|0)>>2]=T2[l>>2],T2[Q+4>>2]=s,G=j2[n>>2],g=j2[n+4>>2],w=j2[n+8>>2],T2[B+12>>2]=0,T=j2[Q>>2],S=j2[B+20>>2],I=z2(z2(g*T)-z2(w*S)),j2[B>>2]=I,j=j2[B+16>>2],x=z2(z2(S*G)-z2(g*j)),j2[B+8>>2]=x,y=z2(z2(w*j)-z2(T*G)),j2[B+4>>2]=y,G=j2[A+332>>2],g=j2[A+328>>2],w=j2[A+608>>2],C=j2[A+348>>2],D=j2[A+340>>2],Y=j2[A+344>>2],E=j2[A+612>>2],m=j2[A+364>>2],h=j2[A+356>>2],Z=j2[A+360>>2],U=j2[A+604>>2],J=j2[A+324>>2],T2[B+76>>2]=0,E=z2(E*z2(z2(z2(I*h)+z2(y*Z))+z2(x*m))),j2[B+72>>2]=E,D=z2(w*z2(z2(z2(I*D)+z2(y*Y))+z2(x*C))),j2[B+68>>2]=D,Y=z2(U*z2(z2(z2(I*J)+z2(y*g))+z2(x*G))),j2[B+64>>2]=Y):(T2[B>>2]=0,T2[B+4>>2]=0,T2[(Q=B+8|0)>>2]=0,T2[Q+4>>2]=0,T2[(Q=B+16|0)>>2]=0,T2[Q+4>>2]=0,T2[(Q=B+24|0)>>2]=0,T2[Q+4>>2]=0,T2[B+64>>2]=0,T2[B+68>>2]=0,T2[(B=B+72|0)>>2]=0,T2[B+4>>2]=0),i?(G=j2[f+4>>2],g=j2[f+8>>2],B=W+P2(R,152)|0,w=j2[f>>2],U=z2(-w),j2[B+48>>2]=U,T2[B+60>>2]=0,P=z2(-g),j2[B+56>>2]=P,z=z2(-G),j2[B+52>>2]=z,C=j2[o+8>>2],Z=j2[o+4>>2],h=j2[o>>2],T2[B+44>>2]=0,m=z2(z2(w*Z)-z2(G*h)),j2[B+40>>2]=m,h=z2(z2(g*h)-z2(w*C)),j2[B+36>>2]=h,Z=z2(z2(G*C)-z2(g*Z)),j2[B+32>>2]=Z,G=j2[i+332>>2],C=j2[i+328>>2],w=j2[i+608>>2],J=j2[i+348>>2],V=j2[i+340>>2],N=j2[i+344>>2],g=j2[i+612>>2],M=j2[i+364>>2],X=j2[i+356>>2],p=j2[i+360>>2],v=j2[i+604>>2],d=j2[i+324>>2],T2[B+92>>2]=0,g=z2(g*z2(z2(z2(Z*X)+z2(h*p))+z2(m*M))),j2[B+88>>2]=g,w=z2(w*z2(z2(z2(Z*V)+z2(h*N))+z2(m*J))),j2[B+84>>2]=w,C=z2(v*z2(z2(z2(Z*d)+z2(h*C))+z2(m*G))),j2[B+80>>2]=C):(B=W+P2(R,152)|0,T2[B+80>>2]=0,T2[B+84>>2]=0,T2[B+32>>2]=0,T2[B+36>>2]=0,T2[(Q=B+88|0)>>2]=0,T2[Q+4>>2]=0,T2[(Q=B+40|0)>>2]=0,T2[Q+4>>2]=0,T2[(Q=B+48|0)>>2]=0,T2[Q+4>>2]=0,T2[(B=B+56|0)>>2]=0,T2[B+4>>2]=0,m=z2(0),h=z2(0),Z=z2(0),U=z2(0),g=z2(0),w=z2(0),C=z2(0)),J=z2(0),B=W+P2(R,152)|0,G=b,b=A?(b=j2[n+8>>2],V=j2[n+4>>2],M=z2(z2(z2(D*b)-z2(E*V))*j2[f>>2]),N=E,E=j2[n>>2],z2(j2[A+404>>2]+z2(z2(M+z2(z2(z2(N*E)-z2(b*Y))*j2[f+4>>2]))+z2(z2(z2(V*Y)-z2(D*E))*j2[f+8>>2])))):z2(0),g=i?(E=j2[o+4>>2],D=j2[o+8>>2],Y=z2(z2(z2(g*E)-z2(w*D))*j2[f>>2]),N=g,g=j2[o>>2],z2(j2[i+404>>2]+z2(z2(Y+z2(z2(z2(C*D)-z2(N*g))*j2[f+4>>2]))+z2(z2(z2(w*g)-z2(C*E))*j2[f+8>>2])))):z2(0),G=z2(G/z2(b+g)),j2[B+108>>2]=G,V=z2(0),E=z2(0),D=z2(0),Y=z2(0),g=z2(0),w=z2(0),A&&(A=F+P2(r,244)|0,D=z2(j2[A+176>>2]+j2[A+208>>2]),V=z2(j2[A+184>>2]+j2[A+216>>2]),Y=j2[A+192>>2],w=j2[A+200>>2],E=z2(j2[A+180>>2]+j2[A+212>>2]),g=j2[A+196>>2]),C=z2(0),b=z2(0),N=z2(0),M=z2(0),X=z2(0),i&&(A=F+P2(e,244)|0,J=z2(j2[A+176>>2]+j2[A+208>>2]),C=z2(j2[A+180>>2]+j2[A+212>>2]),X=j2[A+192>>2],N=j2[A+200>>2],M=j2[A+196>>2],b=z2(j2[A+184>>2]+j2[A+216>>2])),p=z2(0),16&S2[a+128|0]&&(p=z2(G*z2(z2(j2[t+44>>2]*z2(-z2(z2(z2(z2(j2[a+48>>2]-j2[a+32>>2])*j2[f>>2])+z2(z2(j2[a+52>>2]-j2[a+36>>2])*j2[f+4>>2]))+z2(z2(j2[a+56>>2]-j2[a+40>>2])*j2[f+8>>2]))))/j2[t+12>>2]))),A=W+P2(R,152)|0,T2[A+128>>2]=0,j2[A+124>>2]=k,j2[A+120>>2]=-k,j2[A+116>>2]=u,j2[A+112>>2]=z2(G*z2(c-z2(z2(z2(z2(z2(D*j)+z2(E*S))+z2(V*T))+z2(z2(z2(Y*I)+z2(g*y))+z2(w*x)))+z2(z2(z2(z2(J*U)+z2(C*z))+z2(b*P))+z2(z2(z2(X*Z)+z2(M*h))+z2(N*m))))))+p;}function W4(A,f,r,e,i,a,n){var o,b,t,c,u,k,l,s,v=z2(0),d=(0);L2=d=L2-16|0,v=j2[A+52>>2],o=j2[A+56>>2],b=j2[A+48>>2],T2[n+60>>2]=0,j2[n+48>>2]=b+z2(f*a),j2[n+56>>2]=o+z2(e*a),j2[n+52>>2]=v+z2(r*a),e=j2[i>>2],t=j2[i+4>>2],c=j2[i+8>>2],f=(f=z2(z2(z2(e*e)+z2(t*t))+z2(c*c)))>z2(1.1920928955078125e-7)?z2(_2(f)):z2(0),f=(r=z2(f*a)>z2(.7853981852531433)?z2(z2(.7853981852531433)/a):f)<z2(.0010000000474974513)?z2(z2(a*z2(.5))+z2(r*z2(z2(z2(z2(a*a)*a)*z2(-.02083333395421505))*r))):z2(W2(z2(z2(r*z2(.5))*a))/r),C4(A,d),v=j2[4+d>>2],o=j2[12+d>>2],r=m2(z2(z2(r*a)*z2(.5))),b=z2(e*f),u=j2[d>>2],t=z2(t*f),c=z2(c*f),k=j2[8+d>>2],e=z2(z2(z2(z2(o*r)-z2(b*u))-z2(v*t))-z2(c*k)),f=z2(z2(z2(z2(c*o)+z2(r*k))+z2(b*v))-z2(t*u)),a=z2(z2(z2(z2(r*u)+z2(b*o))+z2(t*k))-z2(c*v)),r=z2(z2(z2(c*u)+z2(z2(t*o)+z2(r*v)))-z2(b*k)),(v=z2(z2(e*e)+z2(z2(f*f)+z2(z2(a*a)+z2(r*r)))))>z2(1.1920928955078125e-7)&&(v=z2(z2(1)/z2(_2(v))),e=z2(e*v),f=z2(f*v),r=z2(r*v),a=z2(a*v),v=z2(z2(e*e)+z2(z2(f*f)+z2(z2(r*r)+z2(a*a))))),v>z2(1.1920928955078125e-7)?(T2[n+12>>2]=0,T2[n+44>>2]=0,T2[n+28>>2]=0,o=z2(z2(2)/v),v=z2(f*o),b=z2(r*v),u=z2(a*o),t=z2(e*u),j2[n+36>>2]=b+t,c=z2(a*v),o=z2(r*o),k=z2(e*o),j2[n+32>>2]=c-k,j2[n+24>>2]=b-t,b=z2(a*o),e=z2(e*v),j2[n+16>>2]=b+e,j2[n+8>>2]=c+k,j2[n+4>>2]=b-e,e=z2(a*u),r=z2(r*o),j2[n+40>>2]=z2(1)-z2(e+r),f=z2(f*v),j2[n+20>>2]=z2(1)-z2(e+f),j2[n>>2]=z2(1)-z2(r+f)):(i=T2[A+4>>2],T2[n>>2]=T2[A>>2],T2[n+4>>2]=i,s=T2[4+(l=A+8|0)>>2],T2[(i=n+8|0)>>2]=T2[l>>2],T2[i+4>>2]=s,i=T2[A+20>>2],T2[n+16>>2]=T2[A+16>>2],T2[n+20>>2]=i,s=T2[4+(l=A+24|0)>>2],T2[(i=n+24|0)>>2]=T2[l>>2],T2[i+4>>2]=s,i=T2[A+36>>2],T2[n+32>>2]=T2[A+32>>2],T2[n+36>>2]=i,i=n+40|0,n=T2[(A=A+40|0)+4>>2],T2[i>>2]=T2[A>>2],T2[i+4>>2]=n),L2=16+d|0;}function m4(A,f){var r,e,i,a,n,o,b=0,t=0,c=0,u=0,k=0,l=0,c=t=T2[A+4>>2];if((0|t)==T2[A+8>>2]&&!((0|(n=(c=t)?t<<1:1))<=(0|t))){if(n&&(T2[5498]=T2[5498]+1,(c=K2(P2(n,244)+19|0))&&(T2[(l=c+19&-16)-4>>2]=c)),1<=(0|t))for(b=64,c=t;k=T2[A+12>>2]+b|0,a=T2[4+(e=k+-64|0)>>2],T2[(r=(u=b+l|0)+-64|0)>>2]=T2[e>>2],T2[4+r>>2]=a,i=T2[4+(e=8+e|0)>>2],T2[(r=8+r|0)>>2]=T2[e>>2],T2[4+r>>2]=i,o=T2[4+(a=8+(r=k-48|0)|0)>>2],T2[(i=8+(e=u-48|0)|0)>>2]=T2[a>>2],T2[4+i>>2]=o,i=T2[4+r>>2],T2[e>>2]=T2[r>>2],T2[4+e>>2]=i,o=T2[4+(a=8+(r=k-32|0)|0)>>2],T2[(i=8+(e=u-32|0)|0)>>2]=T2[a>>2],T2[4+i>>2]=o,i=T2[4+r>>2],T2[e>>2]=T2[r>>2],T2[4+e>>2]=i,a=T2[4+(e=k-16|0)>>2],T2[(r=u-16|0)>>2]=T2[e>>2],T2[4+r>>2]=a,i=T2[4+(e=8+e|0)>>2],T2[(r=8+r|0)>>2]=T2[e>>2],T2[4+r>>2]=i,$2(u,k,180),b=b+244|0,c=c-1|0;);(c=T2[A+12>>2])&&S2[A+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[c-4>>2])),T2[A+12>>2]=l,p2[A+16|0]=1,T2[A+8>>2]=n,c=T2[A+4>>2];}return T2[A+4>>2]=c+1,k=T2[(u=f+8|0)+4>>2],t=(c=P2(t,244))+T2[A+12>>2]|0,T2[(b=t+8|0)>>2]=T2[u>>2],T2[b+4>>2]=k,b=T2[f+4>>2],T2[t>>2]=T2[f>>2],T2[t+4>>2]=b,k=T2[(u=f+24|0)+4>>2],T2[(b=t+24|0)>>2]=T2[u>>2],T2[b+4>>2]=k,b=T2[f+20>>2],T2[t+16>>2]=T2[f+16>>2],T2[t+20>>2]=b,b=T2[f+36>>2],T2[t+32>>2]=T2[f+32>>2],T2[t+36>>2]=b,k=T2[(u=f+40|0)+4>>2],T2[(b=t+40|0)>>2]=T2[u>>2],T2[b+4>>2]=k,b=T2[f+52>>2],T2[t+48>>2]=T2[f+48>>2],T2[t+52>>2]=b,k=T2[(u=f+56|0)+4>>2],T2[(b=t+56|0)>>2]=T2[u>>2],T2[b+4>>2]=k,$2(t- -64|0,f- -64|0,180),c+T2[A+12>>2]|0;}function N4(A,f,r,e,i,a){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0;var n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E=0,D=z2(0),h=0,Z=z2(0),Y=(z2(0)),R=z2(0),F=z2(0),W=z2(0);L2=E=L2-272|0,R=j2[f+52>>2],F=j2[r+52>>2],W=j2[f+56>>2],c=j2[r+56>>2],u=j2[f+48>>2],k=j2[r+48>>2],G4(f,r,112+E|0,48+E|0),T2[268+E>>2]=r=0,D=j2[48+E>>2],Z=z2(D*j2[120+E>>2]),j2[264+E>>2]=Z,o=z2(D*j2[116+E>>2]),j2[260+E>>2]=o,D=z2(D*j2[112+E>>2]),j2[256+E>>2]=D,l=j2[e+52>>2],s=j2[i+52>>2],Q=j2[e+56>>2],g=j2[i+56>>2],v=j2[e+48>>2],w=j2[i+48>>2],G4(e,i,112+E|0,48+E|0),T2[252+E>>2]=0,n=j2[48+E>>2],b=z2(n*j2[120+E>>2]),j2[248+E>>2]=b,Y=z2(n*j2[116+E>>2]),j2[244+E>>2]=Y,n=z2(n*j2[112+E>>2]),j2[240+E>>2]=n,i=T2[A+12>>2],D=z2(z2(n1[T2[T2[i>>2]+16>>2]](i))*z2(_2(z2(z2(z2(D*D)+z2(o*o))+z2(Z*Z))))),i=T2[A+16>>2],Z=z2(i?n1[T2[T2[i>>2]+16>>2]](i):0),d=z2(D+z2(Z*z2(_2(z2(z2(z2(n*n)+z2(Y*Y))+z2(b*b)))))),v=z2(w-v),u=z2(k-u),o=z2(v-u),k=z2(s-l),l=z2(F-R),n=z2(k-l),s=z2(g-Q),c=z2(c-W),b=z2(s-c);A:if(z2(d+z2(_2(z2(z2(z2(o*o)+z2(n*n))+z2(b*b)))))!=z2(0)&&(p2[216+E|0]=0,T2[212+E>>2]=1566444395,T2[176+E>>2]=12428,V4(A,f,e,176+E|0),h=T2[4+(t=204+E|0)>>2],T2[(i=232+E|0)>>2]=T2[t>>2],T2[i+4>>2]=h,i=T2[200+E>>2],T2[224+E>>2]=T2[196+E>>2],T2[228+E>>2]=i,S2[216+E|0]&&(Y=j2[180+E>>2],R=j2[184+E>>2],F=j2[188+E>>2],!(z2(d+z2(z2(z2(o*Y)+z2(n*R))+z2(b*F)))<=z2(1.1920928955078125e-7))))){r=1;f:{if((W=z2(j2[212+E>>2]+j2[a+172>>2]))>z2(.0010000000474974513)){for(t=20+E|0,G=160+E|0,Z=z2(i=0);;){if((h=T2[a+168>>2])&&(T2[120+E>>2]=1065353216,T2[124+E>>2]=0,T2[112+E>>2]=1065353216,T2[116+E>>2]=1065353216,n1[T2[T2[h>>2]+28>>2]](h,224+E|0,z2(.20000000298023224),112+E|0)),(D=z2(d+z2(z2(z2(o*Y)+z2(n*R))+z2(b*F))))<=z2(1.1920928955078125e-7)){r=0;break A;}if((D=z2(Z+z2(W/D)))<=Z){r=0;break A;}if(D>z2(1)){r=0;break A;}if(D<z2(0)){r=0;break A;}if(W4(f,u,l,c,256+E|0,D,112+E|0),W4(e,v,k,s,240+E|0,D,48+E|0),(h=T2[a+168>>2])&&(T2[8+E>>2]=0,T2[12+E>>2]=0,T2[E>>2]=1065353216,T2[4+E>>2]=0,n1[T2[T2[h>>2]+28>>2]](h,G,z2(.20000000298023224),E)),n1[T2[T2[a>>2]>>2]](a,D),p2[40+E|0]=0,T2[36+E>>2]=1566444395,T2[E>>2]=12428,V4(A,112+E|0,48+E|0,E),!S2[40+E|0])break f;if(C=T2[4+(B=8+t|0)>>2],T2[(h=232+E|0)>>2]=T2[B>>2],T2[h+4>>2]=C,h=T2[4+t>>2],T2[224+E>>2]=T2[t>>2],T2[228+E>>2]=h,64==(0|i)){n1[T2[T2[a>>2]+8>>2]](a,-2,65),r=0;break A;}if(i=i+1|0,Y=j2[4+E>>2],R=j2[8+E>>2],F=j2[12+E>>2],Z=D,!((W=z2(j2[36+E>>2]+j2[a+172>>2]))>z2(.0010000000474974513)))break;}Z=j2[16+E>>2];}else D=z2(0),Z=j2[192+E>>2];j2[a+132>>2]=Y,j2[a+164>>2]=D,A=T2[228+E>>2],T2[a+148>>2]=T2[224+E>>2],T2[a+152>>2]=A,j2[a+144>>2]=Z,j2[a+140>>2]=F,j2[a+136>>2]=R,e=T2[(f=232+E|0)+4>>2],T2[(A=a+156|0)>>2]=T2[f>>2],T2[A+4>>2]=e;break A;}n1[T2[T2[a>>2]+8>>2]](a,-1,i),r=0;}return L2=272+E|0,0|r;}function V4(A,f,r,e){var i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I,x,y=0,U=0,X=0,p=(z2(0)),T=(z2(0)),S=(0),j=(0),P=(0);L2=y=L2-240|0,T2[A+16>>2]?(U=T2[A+4>>2],p2[U+312|0]=0,p2[U+356|0]=1,T2[U>>2]=0,T2[U+292>>2]=1566444395,T2[U+296>>2]=1566444395,T2[(X=U+336|0)>>2]=0,T2[X+4>>2]=0,T2[(X=U+300|0)>>2]=1566444395,T2[X+4>>2]=0,T2[(X=U+344|0)>>2]=0,T2[X+4>>2]=0,p2[U+352|0]=0,p2[0|(U=U+332|0)]=240&S2[0|U],U=T2[A+12>>2],X=T2[U+4>>2],j=T2[A+16>>2],P=T2[j+4>>2],T=z2(n1[T2[T2[U>>2]+48>>2]](U)),S=T2[A+16>>2],p=z2(n1[T2[T2[S>>2]+48>>2]](S)),T2[(S=172+y|0)>>2]=0,T2[S+4>>2]=0,T2[232+y>>2]=1,T2[236+y>>2]=1,T2[220+y>>2]=-1,p2[212+y|0]=0,j2[208+y>>2]=p,j2[204+y>>2]=T,T2[200+y>>2]=P,T2[196+y>>2]=X,T2[192+y>>2]=j,T2[188+y>>2]=U,T2[164+y>>2]=0,T2[168+y>>2]=1065353216,T2[160+y>>2]=12272,z=T2[A+4>>2],T2[180+y>>2]=T2[A+8>>2],T2[184+y>>2]=z,U=T2[(A=f+8|0)+4>>2],T2[(X=32+y|0)>>2]=T2[A>>2],T2[X+4>>2]=U,U=T2[(A=f+24|0)+4>>2],T2[(X=48+y|0)>>2]=T2[A>>2],T2[X+4>>2]=U,U=T2[(A=f+40|0)+4>>2],T2[(X=y+64|0)>>2]=T2[A>>2],T2[X+4>>2]=U,U=T2[(A=f+56|0)+4>>2],T2[(X=80+y|0)>>2]=T2[A>>2],T2[X+4>>2]=U,U=T2[(A=r+8|0)+4>>2],T2[(X=96+y|0)>>2]=T2[A>>2],T2[X+4>>2]=U,T2[152+y>>2]=1566444395,A=T2[f+4>>2],T2[24+y>>2]=T2[f>>2],T2[28+y>>2]=A,A=T2[f+20>>2],T2[40+y>>2]=T2[f+16>>2],T2[44+y>>2]=A,A=T2[f+36>>2],T2[56+y>>2]=T2[f+32>>2],T2[60+y>>2]=A,A=T2[f+52>>2],T2[72+y>>2]=T2[f+48>>2],T2[76+y>>2]=A,A=T2[r+4>>2],T2[88+y>>2]=T2[r>>2],T2[92+y>>2]=A,f=T2[(A=r+24|0)+4>>2],T2[(U=112+y|0)>>2]=T2[A>>2],T2[U+4>>2]=f,A=T2[r+20>>2],T2[(f=104+y|0)>>2]=T2[r+16>>2],T2[f+4>>2]=A,A=T2[r+36>>2],T2[(f=120+y|0)>>2]=T2[r+32>>2],T2[f+4>>2]=A,f=T2[(A=r+40|0)+4>>2],T2[(U=128+y|0)>>2]=T2[A>>2],T2[U+4>>2]=f,A=T2[r+52>>2],T2[(f=136+y|0)>>2]=T2[r+48>>2],T2[f+4>>2]=A,f=T2[(A=r+56|0)+4>>2],T2[(r=144+y|0)>>2]=T2[A>>2],T2[r+4>>2]=f,J0(160+y|0,24+y|0,e,0,0)):(I=j2[(X=r+52|0)>>2],Q=j2[(j=r+56|0)>>2],g=j2[f+52>>2],h=j2[f+56>>2],t=j2[f+20>>2],c=j2[f+36>>2],T=j2[(P=r+20|0)>>2],p=j2[(S=r+36|0)>>2],i=j2[(R=r+24|0)>>2],a=j2[f+24>>2],n=j2[(F=r+40|0)>>2],s=j2[f+40>>2],Z=j2[r+48>>2],Y=j2[f+48>>2],U=T2[A+12>>2],v=j2[f+32>>2],d=j2[f>>2],w=j2[f+16>>2],G=j2[f+4>>2],b=j2[r+32>>2],o=j2[r+16>>2],u=j2[r>>2],k=j2[r+4>>2],A=T2[A+20>>2],l=j2[r+8>>2],C=j2[f+8>>2],T2[172+y>>2]=0,W=z2(z2(z2(C*k)+z2(a*T))+z2(s*p)),E=z2(-j2[(f=A+60|0)>>2]),m=z2(z2(z2(C*u)+z2(a*o))+z2(s*b)),D=j2[A+56>>2],C=z2(z2(z2(C*l)+z2(a*i))+z2(s*n)),a=j2[(N=A- -64|0)>>2],j2[168+y>>2]=z2(z2(W*E)-z2(m*D))-z2(C*a),V=z2(z2(z2(G*k)+z2(t*T))+z2(c*p)),J=z2(z2(z2(G*u)+z2(t*o))+z2(c*b)),G=z2(z2(z2(G*l)+z2(t*i))+z2(c*n)),j2[164+y>>2]=z2(z2(V*E)-z2(D*J))-z2(a*G),M=z2(z2(z2(d*k)+z2(w*T))+z2(v*p)),B=z2(M*E),E=z2(z2(z2(d*u)+z2(w*o))+z2(v*b)),w=z2(z2(z2(d*l)+z2(w*i))+z2(v*n)),j2[160+y>>2]=z2(B-z2(D*E))-z2(a*w),n1[T2[T2[U>>2]+64>>2]](24+y|0,U,160+y|0),t=j2[f>>2],c=j2[N>>2],D=j2[A+72>>2],a=j2[A+56>>2],s=j2[24+y>>2],v=j2[28+y>>2],d=j2[32+y>>2],T2[172+y>>2]=0,x=z2(z2(z2(Y*u)+z2(g*o))+z2(h*b)),B=o,o=z2(-I),b=z2(z2(x+z2(z2(z2(B*o)-z2(u*Z))-z2(b*Q)))+z2(z2(z2(E*s)+z2(J*v))+z2(m*d))),n=z2(z2(z2(z2(z2(Y*l)+z2(g*i))+z2(h*n))+z2(z2(z2(i*o)-z2(l*Z))-z2(n*Q)))+z2(z2(z2(w*s)+z2(G*v))+z2(C*d))),i=z2(z2(z2(z2(z2(Y*k)+z2(g*T))+z2(h*p))+z2(z2(z2(T*o)-z2(k*Z))-z2(p*Q)))+z2(z2(z2(M*s)+z2(V*v))+z2(W*d))),T=z2(z2(z2(c*n)+z2(z2(a*b)+z2(t*i)))-D),p=z2(b-z2(a*T)),b=j2[r+32>>2],i=z2(i-z2(t*T)),o=j2[S>>2],n=z2(n-z2(c*T)),u=j2[F>>2],j2[168+y>>2]=z2(z2(z2(p*b)+z2(i*o))+z2(n*u))+j2[j>>2],k=j2[r+16>>2],l=j2[P>>2],Q=j2[R>>2],j2[164+y>>2]=z2(z2(z2(p*k)+z2(i*l))+z2(n*Q))+j2[X>>2],g=j2[r>>2],B=z2(g*p),p=j2[r+4>>2],B=z2(B+z2(i*p)),i=j2[r+8>>2],j2[160+y>>2]=z2(B+z2(n*i))+j2[r+48>>2],T2[20+y>>2]=0,j2[16+y>>2]=z2(z2(a*b)+z2(t*o))+z2(c*u),j2[12+y>>2]=z2(z2(a*k)+z2(t*l))+z2(c*Q),j2[8+y>>2]=z2(z2(a*g)+z2(t*p))+z2(c*i),n1[T2[T2[e>>2]+16>>2]](e,8+y|0,160+y|0,T)),L2=240+y|0;}function J4(A){var f,r,e=0,i=0,a=0;if(T2[(A|=0)>>2]=17524,1<=(0|(e=T2[A+8>>2])))for(;r=T2[T2[A+16>>2]+i>>2],(f=T2[r+188>>2])&&(e=T2[A+68>>2],e=0|n1[T2[T2[e>>2]+36>>2]](e),n1[T2[T2[e>>2]+40>>2]](e,f,T2[A+24>>2]),e=T2[A+68>>2],n1[T2[T2[e>>2]+12>>2]](e,f,T2[A+24>>2]),T2[r+188>>2]=0,e=T2[A+8>>2]),i=i+4|0,(0|(a=a+1|0))<(0|e););return (e=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+16>>2]=0,T2[A+8>>2]=0,T2[A+12>>2]=0,p2[A+20|0]=1,0|A;}function M4(A){A|=0;var f,r,e,i,a,n,o=0,b=0,t=0,c=0,u=0,k=0,l=z2(0),s=0,v=0,d=0,B=0,Q=(0);if(L2=o=L2-192|0,0|n1[T2[T2[A>>2]+20>>2]](A)){if(t=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[t>>2]+100>>2]](t),t=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[t>>2]+8>>2]](80+o|0,t),t=0|n1[T2[T2[A>>2]+20>>2]](A),8&n1[T2[T2[t>>2]+56>>2]](t)&&(t=T2[A+24>>2])&&!((0|(v=0|n1[T2[T2[t>>2]+36>>2]](t)))<1))for(B=176+o|0,t=0;;){if(u=T2[A+24>>2],u=0|n1[T2[T2[u>>2]+40>>2]](u,t),1<=(0|(s=T2[u+844>>2])))for(u=u+168|0;d=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[d>>2]+40>>2]](d,u-132|0,u-100|0,j2[u-84>>2],T2[u>>2],B),u=u+208|0,s=s-1|0;);if((0|v)==(0|(t=t+1|0)))break;}if(t=0|n1[T2[T2[A>>2]+20>>2]](A),3&n1[T2[T2[t>>2]+56>>2]](t)&&!(T2[A+8>>2]<1))for(s=160+o|0,v=96+o|0,B=112+o|0,d=128+o|0,f=144+o|0,u=0;;){if(t=T2[T2[A+16>>2]+u>>2],!(32&S2[t+204|0])){if(0|n1[T2[T2[A>>2]+20>>2]](A)&&(b=0|n1[T2[T2[A>>2]+20>>2]](A),1&n1[T2[T2[b>>2]+56>>2]](b))){A:{f:switch(T2[t+220>>2]-1|0){case 0:k=T2[(c=88+o|0)+4>>2],T2[(b=72+o|0)>>2]=T2[c>>2],T2[b+4>>2]=k,b=T2[84+o>>2],T2[64+o>>2]=T2[80+o>>2],T2[68+o>>2]=b;break A;case 1:k=T2[(c=v+8|0)+4>>2],T2[(b=72+o|0)>>2]=T2[c>>2],T2[b+4>>2]=k,b=T2[v+4>>2],T2[64+o>>2]=T2[v>>2],T2[68+o>>2]=b;break A;case 2:k=T2[(c=B+8|0)+4>>2],T2[(b=72+o|0)>>2]=T2[c>>2],T2[b+4>>2]=k,b=T2[B+4>>2],T2[64+o>>2]=T2[B>>2],T2[68+o>>2]=b;break A;case 3:k=T2[(c=d+8|0)+4>>2],T2[(b=72+o|0)>>2]=T2[c>>2],T2[b+4>>2]=k,b=T2[d+4>>2],T2[64+o>>2]=T2[d>>2],T2[68+o>>2]=b;break A;case 4:k=T2[(c=8+f|0)+4>>2],T2[(b=72+o|0)>>2]=T2[c>>2],T2[b+4>>2]=k,b=T2[4+f>>2],T2[64+o>>2]=T2[f>>2],T2[68+o>>2]=b;break A;default:break f;}T2[72+o>>2]=1050253722,T2[76+o>>2]=0,T2[64+o>>2]=1050253722,T2[68+o>>2]=1050253722;}1&p2[t+205|0]&&(k=T2[(c=t+316|0)+4>>2],T2[(b=72+o|0)>>2]=T2[c>>2],T2[b+4>>2]=k,b=T2[t+312>>2],T2[64+o>>2]=T2[t+308>>2],T2[68+o>>2]=b),n1[T2[T2[A>>2]+28>>2]](A,t+4|0,T2[t+192>>2],o+64|0);}(b=T2[A+72>>2])&&2&n1[T2[T2[b>>2]+56>>2]](b)&&(k=T2[(c=s+8|0)+4>>2],T2[(b=40+o|0)>>2]=T2[c>>2],T2[b+4>>2]=k,b=T2[s+4>>2],T2[32+o>>2]=T2[s>>2],T2[36+o>>2]=b,b=T2[t+192>>2],n1[T2[T2[b>>2]+8>>2]](b,t+4|0,o+64|0,48+o|0),j2[64+o>>2]=j2[64+o>>2]+z2(-.019999999552965164),j2[68+o>>2]=j2[68+o>>2]+z2(-.019999999552965164),j2[72+o>>2]=j2[72+o>>2]+z2(-.019999999552965164),j2[48+o>>2]=j2[48+o>>2]+z2(.019999999552965164),j2[52+o>>2]=j2[52+o>>2]+z2(.019999999552965164),j2[56+o>>2]=j2[56+o>>2]+z2(.019999999552965164),S2[A+44|0]&&2==T2[t+252>>2]&&(3&S2[t+204|0]||(b=T2[t+192>>2],n1[T2[T2[b>>2]+8>>2]](b,t+68|0,16+o|0,o),l=z2(j2[16+o>>2]+z2(-.019999999552965164)),j2[16+o>>2]=l,r=z2(j2[20+o>>2]+z2(-.019999999552965164)),j2[20+o>>2]=r,e=z2(j2[24+o>>2]+z2(-.019999999552965164)),j2[24+o>>2]=e,i=z2(j2[o>>2]+z2(.019999999552965164)),j2[o>>2]=i,a=z2(j2[4+o>>2]+z2(.019999999552965164)),j2[4+o>>2]=a,n=z2(j2[8+o>>2]+z2(.019999999552965164)),j2[8+o>>2]=n,l<j2[64+o>>2]&&(j2[64+o>>2]=l),j2[68+o>>2]>r&&(j2[68+o>>2]=r),j2[72+o>>2]>e&&(j2[72+o>>2]=e),(l=j2[28+o>>2])<j2[76+o>>2]&&(j2[76+o>>2]=l),j2[48+o>>2]<i&&(j2[48+o>>2]=i),j2[52+o>>2]<a&&(j2[52+o>>2]=a),j2[56+o>>2]<n&&(j2[56+o>>2]=n),(l=j2[12+o>>2])>j2[60+o>>2]&&(j2[60+o>>2]=l))),t=T2[A+72>>2],n1[T2[T2[t>>2]+60>>2]](t,o+64|0,48+o|0,32+o|0));}if(u=u+4|0,!((0|(Q=Q+1|0))<T2[A+8>>2]))break;}}L2=192+o|0;}function I4(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n=0,o=0,b=0,t=0,c=0,u=L2-96|0;if(L2=u,n=T2[A+8>>2],T2[f+216>>2]=n,T2[A+12>>2]==(0|n)&&!((0|(b=n?n<<1:1))<=(0|n))){if(b&&(T2[5498]=T2[5498]+1,(o=K2(19+(b<<2)|0))&&(T2[(t=o+19&-16)-4>>2]=o)),1<=(0|n))for(o=n;T2[c+t>>2]=T2[T2[A+16>>2]+c>>2],c=c+4|0,o=o-1|0;);(o=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[o-4>>2]),n=T2[A+8>>2]),T2[A+16>>2]=t,T2[A+12>>2]=b,p2[A+20|0]=1;}T2[A+8>>2]=n+1,T2[T2[A+16>>2]+(n<<2)>>2]=f,b=T2[(o=f+12|0)+4>>2],T2[(n=40+u|0)>>2]=T2[o>>2],T2[n+4>>2]=b,b=T2[(o=f+28|0)+4>>2],T2[(n=56+u|0)>>2]=T2[o>>2],T2[n+4>>2]=b,b=T2[(o=f+44|0)+4>>2],T2[(n=72+u|0)>>2]=T2[o>>2],T2[n+4>>2]=b,b=T2[(o=f+60|0)+4>>2],T2[(n=88+u|0)>>2]=T2[o>>2],T2[n+4>>2]=b,n=T2[f+8>>2],T2[32+u>>2]=T2[f+4>>2],T2[36+u>>2]=n,o=T2[(n=f+20|0)+4>>2],T2[48+u>>2]=T2[n>>2],T2[52+u>>2]=o,o=T2[(n=f+36|0)+4>>2],T2[64+u>>2]=T2[n>>2],T2[68+u>>2]=o,o=T2[(n=f+52|0)+4>>2],T2[80+u>>2]=T2[n>>2],T2[84+u>>2]=o,n=T2[f+192>>2],n1[T2[T2[n>>2]+8>>2]](n,32+u|0,16+u|0,u),n=T2[A+68>>2],a=0|n1[T2[T2[n>>2]+8>>2]](n,16+u|0,u,T2[T2[(i=f)+192>>2]+4>>2],f,r,e,T2[A+24>>2]),T2[i+188>>2]=a,L2=96+u|0;}function x4(A,f){A|=0;var r,e,i=0,a=0,n=0,o=0,b=0;(a=T2[(f|=0)+188>>2])&&(i=T2[A+68>>2],i=0|n1[T2[T2[i>>2]+36>>2]](i),n1[T2[T2[i>>2]+40>>2]](i,a,T2[A+24>>2]),i=T2[A+68>>2],n1[T2[T2[i>>2]+12>>2]](i,a,T2[A+24>>2]),T2[f+188>>2]=0),a=T2[A+8>>2];A:if((0|(i=T2[f+216>>2]))<0||(0|a)<=(0|i)){if(!((0|a)<1)){for(i=b=T2[A+16>>2];T2[i>>2]!=(0|f);)if(i=i+4|0,(0|a)==(0|(o=o+1|0)))break A;(0|a)<=(0|o)||(T2[(n=i)>>2]=T2[(i=(a=a-1|0)<<2)+b>>2],T2[A+8>>2]=a,T2[i+T2[A+16>>2]>>2]=f);}}else n=T2[(b=A+16|0)>>2],e=T2[(r=(o=i<<2)+n|0)>>2],T2[r>>2]=T2[n+(n=(a=a-1|0)<<2)>>2],T2[A+8>>2]=a,T2[n+T2[b>>2]>>2]=e,(0|a)<=(0|i)||(T2[T2[T2[A+16>>2]+o>>2]+216>>2]=i);T2[f+216>>2]=-1;}function y4(A,f){var r,e,i,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0,l=0,s=0,v=0,d=0,B=0,Q=0,g=0,w=0,G=0,C=0,E=0,D=0;if(!((0|(n=T2[A+8>>2]))<1)){for(;;){r=T2[T2[T2[A+16>>2]+(C<<2)>>2]+192>>2],a=P2((a=r+(r<<15^-1)|0)>>>10^a,9),a=d>>>0<=(u=(e=(a=((a^=a>>>6)<<11^-1)+a|0)>>>16^a)&k-1)>>>0;A:{f:if(!a&&-1!=(0|(o=T2[(u<<2)+s>>2]))){for(;T2[(o<<3)+b>>2]!=(0|r);)if(-1==(0|(o=T2[(o<<2)+t>>2])))break f;if(l)break A;}f:{r:{if(!a&&-1!=(0|(o=T2[(u<<2)+s>>2])))for(;;){if(T2[(o<<3)+b>>2]==(0|r))break r;if(-1==(0|(o=T2[(o<<2)+t>>2])))break;}if((0|k)==(0|G)){e:if((0|(a=k?k<<1:1))<=(0|k))a=k,Q=l;else {if(Q=0,a&&(T2[5498]=T2[5498]+1,(n=K2(19+(a<<2)|0))&&(T2[(Q=n+19&-16)-4>>2]=n)),1<=(0|k))for(o=Q,n=l,c=k;T2[o>>2]=T2[n>>2],o=o+4|0,n=n+4|0,c=c-1|0;);else if(!l)break e;T2[5499]=T2[5499]+1,q2(T2[l-4>>2]);}n=k;}else a=k,Q=l,n=G;T2[((l=n)<<2)+Q>>2]=r;e:if((0|v)==(0|g)){if((0|(g=v?v<<1:1))<=(0|v))g=v,B=b;else {if(B=0,g&&(T2[5498]=T2[5498]+1,(n=K2(19+(g<<3)|0))&&(T2[(B=n+19&-16)-4>>2]=n)),1<=(0|v))for(o=B,n=b,c=v;i=T2[n+4>>2],T2[o>>2]=T2[n>>2],T2[o+4>>2]=i,o=o+8|0,n=n+8|0,c=c-1|0;);else if(!b)break e;T2[5499]=T2[5499]+1,q2(T2[b-4>>2]);}}else B=b;if(T2[(v<<3)+B>>2]=r,(0|k)<(0|a)){if((0|d)<(0|a)){if((0|a)<=(0|E))c=s;else {c=0,a&&(T2[5498]=T2[5498]+1,(b=K2(19+(a<<2)|0))&&(T2[(c=b+19&-16)-4>>2]=b));e:{if(1<=(0|d))for(o=c,n=s,b=d;T2[o>>2]=T2[n>>2],o=o+4|0,n=n+4|0,b=b-1|0;);else if(!s)break e;T2[5499]=T2[5499]+1,q2(T2[s-4>>2]);}E=a;}if(d2((d<<2)+c|0,0,a-d<<2),k=a<<2,(0|a)<=(0|w))u=t;else {if((0|a)<=(0|D))u=t;else {u=0,a&&(T2[5498]=T2[5498]+1,(b=K2(16+(3|k)|0))&&(T2[(u=b+19&-16)-4>>2]=b));e:{if(1<=(0|w))for(o=u,n=t,b=w;T2[o>>2]=T2[n>>2],o=o+4|0,n=n+4|0,b=b-1|0;);else if(!t)break e;T2[5499]=T2[5499]+1,q2(T2[t-4>>2]);}D=a;}d2((w<<2)+u|0,0,a-w<<2);}if(1<=(0|a)&&(d2(c,255,k),d2(u,255,k)),1<=(0|d))for(k=a-1|0,o=0,n=B,b=u;t=T2[n>>2],t=P2((t=(t<<15^-1)+t|0)>>>10^t,9),t^=t>>>6,T2[b>>2]=T2[(t=((k&((t=(t<<11^-1)+t|0)>>>16^t))<<2)+c|0)>>2],n=n+8|0,b=b+4|0,(0|d)!=(0|(o=(T2[t>>2]=o)+1|0)););s=c,d=w=a,t=u;}u=a-1&e;}v=v+1|0,T2[(G<<2)+t>>2]=T2[(b=(u<<2)+s|0)>>2],T2[b>>2]=G,k=a,G=l+1|0,l=Q,b=B;break f;}T2[(o<<2)+l>>2]=r;}n1[T2[T2[r>>2]+60>>2]](r,f),n=T2[A+8>>2];}if(!((0|(C=C+1|0))<(0|n)))break;}if(1<=(0|n))for(c=o=0;a=T2[T2[A+16>>2]+o>>2],1!=(0|(u=T2[a+252>>2]))&&64!=(0|u)||(n1[T2[T2[a>>2]+24>>2]](a,f),n=T2[A+8>>2]),o=o+4|0,(0|(c=c+1|0))<(0|n););b&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2])),l&&(T2[5499]=T2[5499]+1,q2(T2[l-4>>2])),t&&(T2[5499]=T2[5499]+1,q2(T2[t-4>>2])),s&&(T2[5499]=T2[5499]+1,q2(T2[s-4>>2]));}}function U4(A,f,r,e){var i,a,n,o,b,t,c,u,k,l,s,v=0,d=0,B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=0,C=0,E=z2(0),D=z2(0),h=z2(0),Z=z2(0),Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=0,N=z2(0),V=z2(0),J=z2(0),M=z2(0),I=0,x=z2(0),y=z2(0),U=z2(0),X=z2(0),p=0,T=z2(0),S=(0);T2[(d=264+(L2=v=L2-832|0)|0)>>2]=0,T2[d+4>>2]=0,T2[(d=272+v|0)>>2]=0,T2[d+4>>2]=0,T2[(d=280+v|0)>>2]=0,T2[d+4>>2]=0,T2[288+v>>2]=0,T2[260+v>>2]=1065353216,T2[252+v>>2]=1065353216,T2[256+v>>2]=1065353216,T2[236+v>>2]=8,T2[240+v>>2]=0,T2[244+v>>2]=0,T2[248+v>>2]=0,T2[232+v>>2]=11936,d=T2[r+12>>2];A:if(C=T2[r+4>>2],(0|(G=T2[C+4>>2]))<=19)T2[216+v>>2]=0,T2[220+v>>2]=0,T2[48+v>>2]=12640,j2[212+v>>2]=j2[e+4>>2],p2[652+v|0]=0,T2[628+v>>2]=953267991,T2[308+v>>2]=C,T2[296+v>>2]=13256,T2[304+v>>2]=232+v,T2[300+v>>2]=320+v,T2[32+v>>2]=12396,T2[44+v>>2]=C,G=8&T2[e+16>>2]?32+v|0:296+v|0,C=T2[G>>2],T2[40+v>>2]=232+v,C=T2[C+8>>2],T2[36+v>>2]=320+v,0|n1[0|C](G,A,f,d,d,48+v|0)&&(g=j2[180+v>>2],B=j2[184+v>>2],Q=j2[188+v>>2],(h=z2(z2(z2(g*g)+z2(B*B))+z2(Q*Q)))>z2(9999999747378752e-20)&&(E=j2[212+v>>2])<j2[e+4>>2]&&(x=Q,Q=z2(z2(1)/z2(_2(h))),j2[188+v>>2]=x*Q,j2[184+v>>2]=B*Q,j2[180+v>>2]=g*Q,G=T2[(d=(A=180+v|0)+8|0)+4>>2],T2[(f=16+v|0)>>2]=T2[d>>2],T2[f+4>>2]=G,j2[24+v>>2]=E,f=T2[A+4>>2],T2[8+v>>2]=T2[A>>2],T2[12+v>>2]=f,T2[4+v>>2]=0,T2[v>>2]=T2[r+8>>2],z2(n1[T2[T2[e>>2]+12>>2]](e,v,1))));else if(G-21>>>0<=8)B=j2[d+20>>2],Q=j2[d+36>>2],g=j2[(G=d+24|0)>>2],h=j2[d+52>>2],w=j2[(I=d+56|0)>>2],D=j2[(m=d+40|0)>>2],Z=j2[d+32>>2],W=j2[d+16>>2],N=j2[d>>2],V=j2[d+4>>2],R=j2[d+48>>2],Y=j2[d+8>>2],T2[308+v>>2]=0,F=z2(-h),U=z2(z2(z2(g*F)-z2(Y*R))-z2(D*w)),M=j2[A+48>>2],J=j2[A+52>>2],y=j2[A+56>>2],h=z2(U+z2(z2(z2(Y*M)+z2(g*J))+z2(D*y))),j2[304+v>>2]=h,X=z2(z2(z2(B*F)-z2(V*R))-z2(Q*w)),E=z2(X+z2(z2(z2(V*M)+z2(B*J))+z2(Q*y))),j2[300+v>>2]=E,F=z2(z2(z2(W*F)-z2(N*R))-z2(Z*w)),w=z2(F+z2(z2(z2(N*M)+z2(W*J))+z2(Z*y))),j2[296+v>>2]=w,R=j2[f+48>>2],J=z2(Y*R),Y=j2[f+52>>2],x=D,D=j2[f+56>>2],g=z2(U+z2(z2(J+z2(g*Y))+z2(x*D))),B=z2(X+z2(z2(z2(V*R)+z2(B*Y))+z2(Q*D))),Q=z2(F+z2(z2(z2(N*R)+z2(W*Y))+z2(Z*D))),21!=T2[C+4>>2]?(T2[352+v>>2]=0,j2[348+v>>2]=g,j2[344+v>>2]=B,T2[336+v>>2]=0,j2[332+v>>2]=h,j2[328+v>>2]=E,T2[360+v>>2]=1065353216,j2[324+v>>2]=w,T2[372+v>>2]=C,T2[320+v>>2]=17624,T2[368+v>>2]=T2[r+8>>2],T2[364+v>>2]=e,T2[356+v>>2]=T2[e+16>>2],j2[340+v>>2]=Q,r=T2[(f=d+8|0)+4>>2],T2[(A=384+v|0)>>2]=T2[f>>2],T2[A+4>>2]=r,A=T2[d+4>>2],T2[376+v>>2]=T2[d>>2],T2[380+v>>2]=A,f=T2[G+4>>2],T2[(A=400+v|0)>>2]=T2[G>>2],T2[A+4>>2]=f,f=T2[d+20>>2],T2[(A=392+v|0)>>2]=T2[d+16>>2],T2[A+4>>2]=f,f=T2[d+36>>2],T2[(A=408+v|0)>>2]=T2[d+32>>2],T2[A+4>>2]=f,f=T2[m+4>>2],T2[(A=416+v|0)>>2]=T2[m>>2],T2[A+4>>2]=f,f=T2[d+52>>2],T2[(A=424+v|0)>>2]=T2[d+48>>2],T2[A+4>>2]=f,f=T2[I+4>>2],T2[(A=432+v|0)>>2]=T2[I>>2],T2[A+4>>2]=f,j2[360+v>>2]=j2[e+4>>2],T2[60+v>>2]=0,j2[56+v>>2]=h,j2[52+v>>2]=E,Q<(j2[48+v>>2]=w)&&(j2[48+v>>2]=Q),B<E&&(j2[52+v>>2]=B),g<h&&(j2[56+v>>2]=g),T2[12+v>>2]=0,j2[8+v>>2]=h,j2[4+v>>2]=E,(j2[v>>2]=w)<Q&&(j2[v>>2]=Q),E<B&&(j2[4+v>>2]=B),h<g&&(j2[8+v>>2]=g),n1[T2[T2[C>>2]+64>>2]](C,320+v|0,48+v|0,v)):(T2[352+v>>2]=0,j2[348+v>>2]=g,j2[344+v>>2]=B,p=T2[(f=304+v|0)+4>>2],T2[(A=332+v|0)>>2]=T2[f>>2],T2[A+4>>2]=p,A=T2[300+v>>2],T2[324+v>>2]=T2[296+v>>2],T2[328+v>>2]=A,T2[360+v>>2]=1065353216,j2[340+v>>2]=Q,T2[320+v>>2]=17624,T2[368+v>>2]=T2[r+8>>2],T2[364+v>>2]=e,T2[356+v>>2]=T2[e+16>>2],T2[372+v>>2]=C,r=T2[(f=d+8|0)+4>>2],T2[(A=384+v|0)>>2]=T2[f>>2],T2[A+4>>2]=r,A=T2[d+4>>2],T2[376+v>>2]=T2[d>>2],T2[380+v>>2]=A,f=T2[G+4>>2],T2[(A=400+v|0)>>2]=T2[G>>2],T2[A+4>>2]=f,f=T2[d+20>>2],T2[(A=392+v|0)>>2]=T2[d+16>>2],T2[A+4>>2]=f,f=T2[d+36>>2],T2[(A=408+v|0)>>2]=T2[d+32>>2],T2[A+4>>2]=f,f=T2[m+4>>2],T2[(A=416+v|0)>>2]=T2[m>>2],T2[A+4>>2]=f,f=T2[d+52>>2],T2[(A=424+v|0)>>2]=T2[d+48>>2],T2[A+4>>2]=f,f=T2[I+4>>2],T2[(A=432+v|0)>>2]=T2[I>>2],T2[A+4>>2]=f,j2[360+v>>2]=j2[e+4>>2],T2[32+v>>2]=10956,T2[36+v>>2]=T2[C+56>>2],T2[40+v>>2]=320+v,A=T2[C+60>>2],T2[(f=56+v|0)>>2]=0,T2[f+4>>2]=0,T2[48+v>>2]=0,T2[52+v>>2]=0,T2[(f=8+v|0)>>2]=0,T2[f+4>>2]=0,T2[v>>2]=0,T2[4+v>>2]=0,S2[A+60|0]?g0(A,32+v|0,296+v|0,Q,B,g,48+v|0,v,T2[A+56>>2]):Q0(A,32+v|0,296+v|0,Q,B,g,48+v|0,v));else if(31==(0|G))if(G=T2[C+72>>2],T2[24+v>>2]=e,T2[20+v>>2]=f,T2[16+v>>2]=A,T2[12+v>>2]=d,T2[8+v>>2]=C,T2[v>>2]=17648,T2[4+v>>2]=T2[r+8>>2],G){if(r=T2[G>>2]){for(g=j2[d+56>>2],J=j2[A+56>>2],B=j2[d+40>>2],Q=j2[d+52>>2],y=j2[A+52>>2],h=j2[d+24>>2],E=j2[d+48>>2],U=j2[A+48>>2],w=j2[d+8>>2],D=j2[d+36>>2],Z=j2[d+20>>2],W=j2[d+4>>2],N=j2[d+32>>2],V=j2[d+16>>2],R=j2[d>>2],Y=j2[f+56>>2],F=j2[f+52>>2],M=j2[f+48>>2],T2[320+v>>2]=r,Y=z2(Y-g),F=z2(F-Q),M=z2(M-E),T=z2(z2(B*Y)+z2(z2(h*F)+z2(w*M))),E=z2(U-E),Q=z2(y-Q),x=B,B=z2(J-g),h=z2(z2(z2(w*E)+z2(h*Q))+z2(x*B)),J=w=z2(T-h),x=z2(z2(N*Y)+z2(z2(V*F)+z2(M*R))),N=z2(z2(z2(E*R)+z2(Q*V))+z2(B*N)),g=z2(x-N),E=z2(z2(z2(E*W)+z2(Q*Z))+z2(B*D)),B=z2(z2(z2(D*Y)+z2(z2(Z*F)+z2(M*W)))-E),w=z2(z2(1)/z2(_2(z2(z2(z2(g*g)+z2(B*B))+z2(w*w))))),Q=z2(J*w),g=z2((D=g)*w),B=z2((x=B)*w),R=z2(z2(J*Q)+z2(z2(D*g)+z2(x*B))),o=(48+v|0)+((A=(Q=Q==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/Q))<z2(0))<<4)|8,b=(48+v|0)+((f=(B=B==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/B))<z2(0))<<4)|4,t=(48+v|0)+(!A<<4)|8,c=(48+v|0)+(!f<<4)|4,u=(48+v|0)+((A=(g=g==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/g))<z2(0))<<4)|0,k=(48+v|0)+(!A<<4)|0,p=v+64|0,I=126,A=320+v|0,f=r=128,C=1;;){if(m=T2[(n=(e=C-1|0)<<2)+A>>2],G=T2[(d=m)+20>>2],T2[p>>2]=T2[d+16>>2],T2[p+4>>2]=G,l=T2[(d=d+24|0)+4>>2],T2[(G=p+8|0)>>2]=T2[d>>2],T2[G+4>>2]=l,d=T2[m+4>>2],T2[48+v>>2]=T2[m>>2],T2[52+v>>2]=d,G=T2[(d=m+8|0)+4>>2],T2[56+v>>2]=T2[d>>2],T2[60+v>>2]=G,w=z2(B*z2(j2[b>>2]-E)),!((D=z2(g*z2(j2[k>>2]-N)))<w||(Z=z2(g*z2(j2[u>>2]-N)),(W=z2(B*z2(j2[c>>2]-E)))<Z||(D=W<D?W:D)<(V=z2(Q*z2(j2[o>>2]-h)))||(w=Z<w?w:Z,!(!((Z=z2(Q*z2(j2[t>>2]-h)))<w)&&(w<V?V:w)<R&&(Z<D?Z:D)>z2(0))))))if(T2[m+40>>2]){if((0|I)<(0|e)){if((0|f)<(0|(d=f<<1))){if((0|r)<(0|d)){if(G=0,f&&(T2[5498]=T2[5498]+1,(r=K2(19+(f<<3)|0))&&(T2[(G=r+19&-16)-4>>2]=r),!((0|f)<1)))for(e=G,I=A,r=f;T2[e>>2]=T2[I>>2],e=e+4|0,I=I+4|0,r=r-1|0;);S&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),S=1,r=d,A=G;}d2((f<<=2)+A|0,0,f);}I=d-2|0,f=d;}T2[A+n>>2]=T2[m+36>>2],T2[(C<<2)+A>>2]=T2[m+40>>2],e=C+1|0;}else n1[T2[T2[v>>2]+12>>2]](v,m);if(!(C=e))break;}S&&A&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2]));}}else if(!((0|(A=T2[C+24>>2]))<1))for(G=A-1|0,A=32,r=0;;){if(f=T2[C+32>>2]+A|0,e=T2[f+32>>2],s=j2[d+52>>2],T=j2[d+56>>2],N=j2[f+16>>2],V=j2[f+20>>2],R=j2[f+24>>2],g=j2[d+20>>2],B=j2[d+24>>2],Y=j2[f-32>>2],F=j2[f-16>>2],M=j2[f>>2],J=j2[f-28>>2],y=j2[f-12>>2],U=j2[f+4>>2],X=j2[f-24>>2],Q=j2[d+36>>2],i=j2[f-8>>2],h=j2[d+40>>2],a=j2[f+8>>2],x=j2[d+48>>2],E=j2[d+8>>2],w=j2[d>>2],D=j2[d+4>>2],Z=j2[d+16>>2],W=j2[d+32>>2],T2[380+v>>2]=0,T2[364+v>>2]=0,T2[348+v>>2]=0,T2[332+v>>2]=0,j2[360+v>>2]=z2(z2(X*W)+z2(i*Q))+z2(a*h),j2[356+v>>2]=z2(z2(J*W)+z2(y*Q))+z2(U*h),j2[352+v>>2]=z2(z2(Y*W)+z2(F*Q))+z2(M*h),j2[344+v>>2]=z2(z2(X*Z)+z2(i*g))+z2(a*B),j2[340+v>>2]=z2(z2(J*Z)+z2(y*g))+z2(U*B),j2[336+v>>2]=z2(z2(Y*Z)+z2(F*g))+z2(M*B),j2[328+v>>2]=z2(z2(w*X)+z2(D*i))+z2(E*a),j2[324+v>>2]=z2(z2(w*J)+z2(D*y))+z2(E*U),j2[320+v>>2]=z2(z2(Y*w)+z2(F*D))+z2(M*E),j2[376+v>>2]=T+z2(z2(z2(W*N)+z2(Q*V))+z2(h*R)),j2[372+v>>2]=s+z2(z2(z2(Z*N)+z2(g*V))+z2(B*R)),j2[368+v>>2]=x+z2(z2(z2(w*N)+z2(D*V))+z2(E*R)),T2[316+v>>2]=r,T2[312+v>>2]=-1,T2[304+v>>2]=T2[4+v>>2],T2[300+v>>2]=e,T2[296+v>>2]=0,T2[308+v>>2]=320+v,T2[52+v>>2]=1065353216,T2[56+v>>2]=0,T2[64+v>>2]=0,T2[76+v>>2]=r,T2[68+v>>2]=e,T2[48+v>>2]=17684,f=T2[24+v>>2],T2[72+v>>2]=f,j2[52+v>>2]=j2[f+4>>2],T2[64+v>>2]=T2[f+16>>2],U4(T2[16+v>>2],T2[20+v>>2],296+v|0,48+v|0),(0|r)==(0|G))break A;r=r+1|0,A=A+80|0,d=T2[12+v>>2],C=T2[8+v>>2];}L2=832+v|0;}function X4(A,f,r,e,i,a){var n,o,b,t,c,u,k,l=0,s=0,v=z2(0),d=0,B=z2(0),Q=z2(0),g=z2(0),w=0,G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=z2(0),Y=z2(0),R=z2(0),F=z2(0),W=0,m=0,N=z2(0),V=z2(0),J=z2(0),M=z2(0),I=z2(0),x=z2(0),y=z2(0),U=z2(0),X=z2(0),p=0,T=z2(0),S=z2(0),j=0,P=0,z=0,O=0,H=0,_=0,L=0;L2=l=L2-672|0,s=T2[e+12>>2],n=T2[e+4>>2];A:if((0|(p=T2[n+4>>2]))<=19)j2[644+l>>2]=a,T2[640+l>>2]=0,T2[472+l>>2]=12640,j2[636+l>>2]=j2[i+4>>2],p2[444+l|0]=0,T2[420+l>>2]=953267991,T2[32+l>>2]=14688,T2[668+l>>2]=0,T2[664+l>>2]=n,T2[660+l>>2]=A,T2[648+l>>2]=17352,T2[656+l>>2]=32+l,T2[652+l>>2]=112+l,N4(648+l|0,f,r,s,s,472+l|0)&&(a=j2[604+l>>2],v=j2[608+l>>2],B=j2[612+l>>2],(Q=z2(z2(z2(a*a)+z2(v*v))+z2(B*B)))>z2(9999999747378752e-20)&&(G=j2[636+l>>2])<j2[i+4>>2]&&(g=B,B=z2(z2(1)/z2(_2(Q))),j2[612+l>>2]=g*B,j2[608+l>>2]=v*B,j2[604+l>>2]=a*B,T2[56+l>>2]=n,r=T2[(f=628+l|0)+4>>2],T2[(A=96+l|0)>>2]=T2[f>>2],T2[A+4>>2]=r,s=T2[(r=(A=604+l|0)+8|0)+4>>2],T2[(f=80+l|0)>>2]=T2[r>>2],T2[f+4>>2]=s,f=T2[624+l>>2],T2[88+l>>2]=T2[620+l>>2],T2[92+l>>2]=f,j2[104+l>>2]=G,f=T2[A+4>>2],T2[72+l>>2]=T2[A>>2],T2[76+l>>2]=f,T2[64+l>>2]=T2[e+8>>2],T2[68+l>>2]=48+l,z2(n1[T2[T2[i>>2]+12>>2]](i,l+64|0,1))));else if((P=p-21|0)>>>0<=8){f:switch(0|P){case 0:if(v=j2[s+20>>2],B=j2[s+36>>2],Q=j2[(p=s+8|0)>>2],G=j2[(P=s+24|0)>>2],R=j2[s+52>>2],Z=j2[(W=s+56|0)>>2],h=j2[(z=s+40|0)>>2],E=j2[s+32>>2],D=j2[s+16>>2],C=j2[s>>2],g=j2[s+4>>2],Y=j2[s+48>>2],T2[76+l>>2]=0,R=z2(-R),T=z2(z2(z2(G*R)-z2(Q*Y))-z2(h*Z)),F=j2[f+48>>2],N=j2[f+52>>2],V=j2[(m=f+56|0)>>2],j2[72+l>>2]=T+z2(z2(z2(Q*F)+z2(G*N))+z2(h*V)),S=z2(z2(z2(v*R)-z2(g*Y))-z2(B*Z)),j2[68+l>>2]=S+z2(z2(z2(g*F)+z2(v*N))+z2(B*V)),M=z2(z2(z2(D*R)-z2(C*Y))-z2(E*Z)),j2[64+l>>2]=M+z2(z2(z2(C*F)+z2(D*N))+z2(E*V)),Z=j2[r+52>>2],Y=j2[(O=r+56|0)>>2],R=j2[r+48>>2],T2[500+l>>2]=0,F=j2[(H=r+8|0)>>2],N=j2[(_=r+24|0)>>2],V=j2[(L=r+40|0)>>2],j2[512+l>>2]=z2(z2(Q*F)+z2(G*N))+z2(h*V),I=j2[r+4>>2],x=j2[r+20>>2],J=j2[r+36>>2],j2[508+l>>2]=z2(z2(Q*I)+z2(G*x))+z2(h*J),j2[496+l>>2]=z2(z2(g*F)+z2(v*N))+z2(B*V),j2[492+l>>2]=z2(z2(g*I)+z2(v*x))+z2(B*J),T2[484+l>>2]=0,y=j2[r>>2],U=j2[r+16>>2],X=j2[r+32>>2],j2[504+l>>2]=z2(z2(Q*y)+z2(G*U))+z2(h*X),j2[488+l>>2]=z2(z2(g*y)+z2(v*U))+z2(B*X),j2[480+l>>2]=z2(z2(C*F)+z2(D*N))+z2(E*V),j2[476+l>>2]=z2(z2(C*I)+z2(D*x))+z2(E*J),j2[472+l>>2]=z2(z2(C*y)+z2(D*U))+z2(E*X),T2[532+l>>2]=0,T2[(d=524+l|0)>>2]=0,T2[d+4>>2]=0,T2[(d=516+l|0)>>2]=0,T2[d+4>>2]=0,e=T2[e+8>>2],F=z2(n1[T2[T2[n>>2]+48>>2]](n)),j=T2[(w=f+8|0)+4>>2],T2[(d=128+l|0)>>2]=T2[w>>2],T2[d+4>>2]=j,w=T2[f+20>>2],T2[(d=136+l|0)>>2]=T2[f+16>>2],T2[d+4>>2]=w,j=T2[(w=f+24|0)+4>>2],T2[(d=144+l|0)>>2]=T2[w>>2],T2[d+4>>2]=j,w=T2[f+36>>2],T2[(d=152+l|0)>>2]=T2[f+32>>2],T2[d+4>>2]=w,j=T2[(w=f+40|0)+4>>2],T2[(d=160+l|0)>>2]=T2[w>>2],T2[d+4>>2]=j,w=T2[f+52>>2],T2[(d=168+l|0)>>2]=T2[f+48>>2],T2[d+4>>2]=w,w=T2[m+4>>2],T2[(d=176+l|0)>>2]=T2[m>>2],T2[d+4>>2]=w,d=T2[H+4>>2],T2[(m=192+l|0)>>2]=T2[H>>2],T2[m+4>>2]=d,T2[116+l>>2]=A,T2[112+l>>2]=17456,m=T2[f+4>>2],T2[120+l>>2]=T2[f>>2],T2[124+l>>2]=m,f=T2[r+4>>2],T2[184+l>>2]=T2[r>>2],T2[188+l>>2]=f,m=T2[r+36>>2],T2[(f=216+l|0)>>2]=T2[r+32>>2],T2[f+4>>2]=m,m=T2[_+4>>2],T2[(f=208+l|0)>>2]=T2[_>>2],T2[f+4>>2]=m,m=T2[r+20>>2],T2[(f=200+l|0)>>2]=T2[r+16>>2],T2[f+4>>2]=m,m=T2[L+4>>2],T2[(f=224+l|0)>>2]=T2[L>>2],T2[f+4>>2]=m,m=T2[r+52>>2],T2[(f=232+l|0)>>2]=T2[r+48>>2],T2[f+4>>2]=m,r=T2[O+4>>2],T2[(f=240+l|0)>>2]=T2[O>>2],T2[f+4>>2]=r,r=T2[p+4>>2],T2[(f=256+l|0)>>2]=T2[p>>2],T2[f+4>>2]=r,f=T2[s+4>>2],T2[248+l>>2]=T2[s>>2],T2[252+l>>2]=f,r=T2[P+4>>2],T2[(f=272+l|0)>>2]=T2[P>>2],T2[f+4>>2]=r,r=T2[s+20>>2],T2[(f=264+l|0)>>2]=T2[s+16>>2],T2[f+4>>2]=r,r=T2[z+4>>2],T2[(f=288+l|0)>>2]=T2[z>>2],T2[f+4>>2]=r,r=T2[s+36>>2],T2[(f=280+l|0)>>2]=T2[s+32>>2],T2[f+4>>2]=r,r=T2[W+4>>2],T2[(f=304+l|0)>>2]=T2[W>>2],T2[f+4>>2]=r,r=T2[s+52>>2],T2[(f=296+l|0)>>2]=T2[s+48>>2],T2[f+4>>2]=r,j2[316+l>>2]=F,T2[328+l>>2]=e,T2[332+l>>2]=n,T2[112+l>>2]=18564,j2[320+l>>2]=a,T2[324+l>>2]=i,j2[312+l>>2]=j2[i+4>>2],n1[T2[T2[A>>2]+8>>2]](A,472+l|0,648+l|0,48+l|0),T2[32+l>>2]=11092,T2[36+l>>2]=T2[n+56>>2],a=z2(T+z2(z2(z2(Q*R)+z2(G*Z))+z2(h*Y))),v=z2(S+z2(z2(z2(g*R)+z2(v*Z))+z2(B*Y))),B=z2(M+z2(z2(z2(C*R)+z2(D*Z))+z2(E*Y))),T2[40+l>>2]=112+l,A=T2[n+60>>2],S2[A+60|0]){g0(A,32+l|0,l+64|0,B,v,a,648+l|0,48+l|0,T2[A+56>>2]);break A;}Q0(A,32+l|0,l+64|0,B,v,a,648+l|0,48+l|0);break A;case 7:if(j2[284+l>>2]=a,T2[280+l>>2]=0,T2[112+l>>2]=12640,j2[276+l>>2]=j2[i+4>>2],T2[84+l>>2]=n,T2[80+l>>2]=0,T2[76+l>>2]=A,T2[68+l>>2]=0,T2[72+l>>2]=0,T2[64+l>>2]=17352,!N4(l+64|0,f,r,s,s,112+l|0))break A;if(a=j2[244+l>>2],v=j2[248+l>>2],B=j2[252+l>>2],!((Q=z2(z2(z2(a*a)+z2(v*v))+z2(B*B)))>z2(9999999747378752e-20)))break A;if(!((G=j2[276+l>>2])<j2[i+4>>2]))break A;g=B,B=z2(z2(1)/z2(_2(Q))),j2[252+l>>2]=g*B,j2[248+l>>2]=v*B,j2[244+l>>2]=a*B,T2[656+l>>2]=n,r=T2[(f=268+l|0)+4>>2],T2[(A=504+l|0)>>2]=T2[f>>2],T2[A+4>>2]=r,s=T2[(r=(A=244+l|0)+8|0)+4>>2],T2[(f=488+l|0)>>2]=T2[r>>2],T2[f+4>>2]=s,f=T2[264+l>>2],T2[496+l>>2]=T2[260+l>>2],T2[500+l>>2]=f,j2[512+l>>2]=G,f=T2[A+4>>2],T2[480+l>>2]=T2[A>>2],T2[484+l>>2]=f,T2[472+l>>2]=T2[e+8>>2],T2[476+l>>2]=648+l,z2(n1[T2[T2[i>>2]+12>>2]](i,472+l|0,1));break A;default:break f;}Z=j2[(p=r+56|0)>>2],Y=j2[r+52>>2],R=j2[(P=s+56|0)>>2],k=j2[s+52>>2],F=j2[(W=f+56|0)>>2],N=j2[f+52>>2],v=j2[s+20>>2],B=j2[s+36>>2],Q=j2[(z=s+40|0)>>2],G=j2[(m=s+8|0)>>2],h=j2[(O=s+24|0)>>2],V=j2[r+48>>2],I=j2[s+48>>2],x=j2[f+48>>2],E=j2[s+32>>2],D=j2[s>>2],C=j2[s+16>>2],g=j2[s+4>>2],T2[500+l>>2]=0,J=j2[(H=r+8|0)>>2],y=j2[(_=r+24|0)>>2],U=j2[(L=r+40|0)>>2],j2[512+l>>2]=z2(z2(G*J)+z2(h*y))+z2(Q*U),X=j2[r+4>>2],T=j2[r+20>>2],S=j2[r+36>>2],j2[508+l>>2]=z2(z2(G*X)+z2(h*T))+z2(Q*S),j2[496+l>>2]=z2(z2(g*J)+z2(v*y))+z2(B*U),j2[492+l>>2]=z2(z2(g*X)+z2(v*T))+z2(B*S),T2[484+l>>2]=0,M=j2[r>>2],o=j2[r+16>>2],b=j2[r+32>>2],j2[504+l>>2]=z2(z2(G*M)+z2(h*o))+z2(Q*b),j2[488+l>>2]=z2(z2(g*M)+z2(v*o))+z2(B*b),j2[480+l>>2]=z2(z2(D*J)+z2(C*y))+z2(E*U),j2[476+l>>2]=z2(z2(D*X)+z2(C*T))+z2(E*S),j2[472+l>>2]=z2(z2(D*M)+z2(C*o))+z2(E*b),T2[532+l>>2]=0,T2[(d=524+l|0)>>2]=0,T2[d+4>>2]=0,T2[(d=516+l|0)>>2]=0,T2[d+4>>2]=0,e=T2[e+8>>2],J=z2(n1[T2[T2[n>>2]+48>>2]](n)),j=T2[(w=f+8|0)+4>>2],T2[(d=128+l|0)>>2]=T2[w>>2],T2[d+4>>2]=j,w=T2[f+20>>2],T2[(d=136+l|0)>>2]=T2[f+16>>2],T2[d+4>>2]=w,j=T2[(w=f+24|0)+4>>2],T2[(d=144+l|0)>>2]=T2[w>>2],T2[d+4>>2]=j,w=T2[f+36>>2],T2[(d=152+l|0)>>2]=T2[f+32>>2],T2[d+4>>2]=w,j=T2[(w=f+40|0)+4>>2],T2[(d=160+l|0)>>2]=T2[w>>2],T2[d+4>>2]=j,w=T2[f+52>>2],T2[(d=168+l|0)>>2]=T2[f+48>>2],T2[d+4>>2]=w,w=T2[W+4>>2],T2[(d=176+l|0)>>2]=T2[W>>2],T2[d+4>>2]=w,d=T2[H+4>>2],T2[(W=192+l|0)>>2]=T2[H>>2],T2[W+4>>2]=d,T2[116+l>>2]=A,T2[112+l>>2]=17456,W=T2[f+4>>2],T2[120+l>>2]=T2[f>>2],T2[124+l>>2]=W,f=T2[r+4>>2],T2[184+l>>2]=T2[r>>2],T2[188+l>>2]=f,W=T2[r+36>>2],T2[(f=216+l|0)>>2]=T2[r+32>>2],T2[f+4>>2]=W,W=T2[_+4>>2],T2[(f=208+l|0)>>2]=T2[_>>2],T2[f+4>>2]=W,W=T2[r+20>>2],T2[(f=200+l|0)>>2]=T2[r+16>>2],T2[f+4>>2]=W,W=T2[L+4>>2],T2[(f=224+l|0)>>2]=T2[L>>2],T2[f+4>>2]=W,W=T2[r+52>>2],T2[(f=232+l|0)>>2]=T2[r+48>>2],T2[f+4>>2]=W,r=T2[p+4>>2],T2[(f=240+l|0)>>2]=T2[p>>2],T2[f+4>>2]=r,r=T2[m+4>>2],T2[(f=256+l|0)>>2]=T2[m>>2],T2[f+4>>2]=r,f=T2[s+4>>2],T2[248+l>>2]=T2[s>>2],T2[252+l>>2]=f,r=T2[O+4>>2],T2[(f=272+l|0)>>2]=T2[O>>2],T2[f+4>>2]=r,r=T2[s+20>>2],T2[(f=264+l|0)>>2]=T2[s+16>>2],T2[f+4>>2]=r,r=T2[z+4>>2],T2[(f=288+l|0)>>2]=T2[z>>2],T2[f+4>>2]=r,r=T2[s+36>>2],T2[(f=280+l|0)>>2]=T2[s+32>>2],T2[f+4>>2]=r,r=T2[P+4>>2],T2[(f=304+l|0)>>2]=T2[P>>2],T2[f+4>>2]=r,r=T2[s+52>>2],T2[(f=296+l|0)>>2]=T2[s+48>>2],T2[f+4>>2]=r,j2[316+l>>2]=J,T2[328+l>>2]=e,T2[332+l>>2]=n,T2[112+l>>2]=18588,j2[320+l>>2]=a,T2[324+l>>2]=i,j2[312+l>>2]=j2[i+4>>2],n1[T2[T2[A>>2]+8>>2]](A,472+l|0,l+64|0,648+l|0),T2[60+l>>2]=0,T2[44+l>>2]=0,J=z2(-k),y=z2(z2(z2(C*J)-z2(D*I))-z2(E*R)),a=z2(y+z2(z2(z2(D*V)+z2(C*Y))+z2(E*Z))),E=z2(y+z2(z2(z2(D*x)+z2(C*N))+z2(E*F))),j2[48+l>>2]=j2[64+l>>2]+(a<E?a:E),C=z2(z2(z2(v*J)-z2(g*I))-z2(B*R)),D=z2(C+z2(z2(z2(g*V)+z2(v*Y))+z2(B*Z))),v=z2(C+z2(z2(z2(g*x)+z2(v*N))+z2(B*F))),j2[52+l>>2]=j2[68+l>>2]+(D<v?D:v),C=z2(z2(z2(h*J)-z2(G*I))-z2(Q*R)),B=z2(C+z2(z2(z2(G*V)+z2(h*Y))+z2(Q*Z))),Q=z2(C+z2(z2(z2(G*x)+z2(h*N))+z2(Q*F))),j2[56+l>>2]=j2[72+l>>2]+(B<Q?B:Q),j2[32+l>>2]=j2[648+l>>2]+(E<a?a:E),j2[36+l>>2]=j2[652+l>>2]+(v<D?D:v),j2[40+l>>2]=j2[656+l>>2]+(Q<B?B:Q),n1[T2[T2[n>>2]+64>>2]](n,112+l|0,48+l|0,32+l|0);}else if(31==(0|p)){if(M=j2[(p=s+52|0)>>2],Z=j2[(P=s+56|0)>>2],Y=j2[f+52>>2],R=j2[f+56>>2],v=j2[(W=s+20|0)>>2],B=j2[(z=s+36|0)>>2],F=j2[f+20>>2],N=j2[f+36>>2],V=j2[f+24>>2],Q=j2[(m=s+24|0)>>2],I=j2[f+40>>2],G=j2[(O=s+40|0)>>2],h=j2[s+32>>2],E=j2[s>>2],D=j2[s+16>>2],x=j2[f+32>>2],J=j2[f>>2],y=j2[f+16>>2],U=j2[s+48>>2],X=j2[f+48>>2],C=j2[s+4>>2],T=j2[f+4>>2],S=j2[f+8>>2],g=j2[s+8>>2],T2[(H=172+l|0)>>2]=0,T2[(_=156+l|0)>>2]=0,T2[(L=140+l|0)>>2]=0,j2[(d=152+l|0)>>2]=z2(z2(g*S)+z2(Q*V))+z2(G*I),j2[(w=148+l|0)>>2]=z2(z2(g*T)+z2(Q*F))+z2(G*N),j2[(j=136+l|0)>>2]=z2(z2(C*S)+z2(v*V))+z2(B*I),j2[(t=132+l|0)>>2]=z2(z2(C*T)+z2(v*F))+z2(B*N),c=168+l|0,M=z2(-M),j2[c>>2]=z2(z2(z2(Q*M)-z2(g*U))-z2(G*Z))+z2(z2(z2(g*X)+z2(Q*Y))+z2(G*R)),j2[(u=164+l|0)>>2]=z2(z2(z2(v*M)-z2(C*U))-z2(B*Z))+z2(z2(z2(C*X)+z2(v*Y))+z2(B*R)),T2[124+l>>2]=0,j2[144+l>>2]=z2(z2(g*J)+z2(Q*y))+z2(G*x),j2[128+l>>2]=z2(z2(C*J)+z2(v*y))+z2(B*x),j2[120+l>>2]=z2(z2(E*S)+z2(D*V))+z2(h*I),j2[160+l>>2]=z2(z2(z2(D*M)-z2(E*U))-z2(h*Z))+z2(z2(z2(E*X)+z2(D*Y))+z2(h*R)),j2[116+l>>2]=z2(z2(E*T)+z2(D*F))+z2(h*N),j2[112+l>>2]=z2(z2(E*J)+z2(D*y))+z2(h*x),n1[T2[T2[A>>2]+8>>2]](A,112+l|0,48+l|0,32+l|0),M=j2[p>>2],Z=j2[P>>2],Y=j2[r+52>>2],R=j2[r+56>>2],v=j2[W>>2],B=j2[z>>2],F=j2[r+20>>2],N=j2[r+36>>2],V=j2[r+24>>2],Q=j2[m>>2],I=j2[r+40>>2],G=j2[O>>2],h=j2[s+32>>2],E=j2[s>>2],D=j2[s+16>>2],x=j2[r+32>>2],J=j2[r>>2],y=j2[r+16>>2],U=j2[s+48>>2],X=j2[r+48>>2],C=j2[s+4>>2],T=j2[r+4>>2],S=j2[r+8>>2],g=j2[s+8>>2],T2[H>>2]=0,T2[_>>2]=0,T2[L>>2]=0,j2[d>>2]=z2(z2(g*S)+z2(Q*V))+z2(G*I),j2[w>>2]=z2(z2(g*T)+z2(Q*F))+z2(G*N),j2[j>>2]=z2(z2(C*S)+z2(v*V))+z2(B*I),j2[t>>2]=z2(z2(C*T)+z2(v*F))+z2(B*N),M=z2(-M),j2[c>>2]=z2(z2(z2(Q*M)-z2(g*U))-z2(G*Z))+z2(z2(z2(g*X)+z2(Q*Y))+z2(G*R)),j2[u>>2]=z2(z2(z2(v*M)-z2(C*U))-z2(B*Z))+z2(z2(z2(C*X)+z2(v*Y))+z2(B*R)),T2[124+l>>2]=0,j2[144+l>>2]=z2(z2(g*J)+z2(Q*y))+z2(G*x),j2[128+l>>2]=z2(z2(C*J)+z2(v*y))+z2(B*x),j2[120+l>>2]=z2(z2(E*S)+z2(D*V))+z2(h*I),j2[160+l>>2]=z2(z2(z2(D*M)-z2(E*U))-z2(h*Z))+z2(z2(z2(E*X)+z2(D*Y))+z2(h*R)),j2[116+l>>2]=z2(z2(E*T)+z2(D*F))+z2(h*N),j2[112+l>>2]=z2(z2(E*J)+z2(D*y))+z2(h*x),n1[T2[T2[A>>2]+8>>2]](A,112+l|0,16+l|0,l),(v=j2[16+l>>2])<j2[48+l>>2]&&(j2[48+l>>2]=v),(v=j2[20+l>>2])<j2[52+l>>2]&&(j2[52+l>>2]=v),(v=j2[24+l>>2])<j2[56+l>>2]&&(j2[56+l>>2]=v),(v=j2[28+l>>2])<j2[60+l>>2]&&(j2[60+l>>2]=v),(v=j2[l>>2])>j2[32+l>>2]&&(j2[32+l>>2]=v),(v=j2[4+l>>2])>j2[36+l>>2]&&(j2[36+l>>2]=v),(v=j2[8+l>>2])>j2[40+l>>2]&&(j2[40+l>>2]=v),(v=j2[12+l>>2])>j2[44+l>>2]&&(j2[44+l>>2]=v),T2[504+l>>2]=i,T2[500+l>>2]=s,j2[492+l>>2]=a,T2[488+l>>2]=r,T2[484+l>>2]=f,T2[480+l>>2]=A,T2[476+l>>2]=e,T2[472+l>>2]=18612,T2[496+l>>2]=n,!(A=T2[n+72>>2])){if(T2[n+24>>2]<1)break A;for(A=32,f=1;;){if(r=T2[n+32>>2]+A|0,e=T2[r+32>>2],a=j2[r+16>>2],v=j2[r+20>>2],B=j2[r+24>>2],Q=j2[r-32>>2],G=j2[r-16>>2],h=j2[r>>2],E=j2[r-28>>2],D=j2[r-12>>2],C=j2[r+4>>2],g=j2[r-24>>2],Z=j2[r-8>>2],Y=j2[r+8>>2],T2[172+l>>2]=0,T2[156+l>>2]=0,T2[140+l>>2]=0,T2[124+l>>2]=0,R=j2[s+32>>2],F=j2[s+36>>2],N=j2[s+40>>2],j2[152+l>>2]=z2(z2(g*R)+z2(Z*F))+z2(Y*N),j2[148+l>>2]=z2(z2(E*R)+z2(D*F))+z2(C*N),j2[144+l>>2]=z2(z2(Q*R)+z2(G*F))+z2(h*N),V=j2[s+16>>2],I=j2[s+20>>2],x=j2[s+24>>2],j2[136+l>>2]=z2(z2(g*V)+z2(Z*I))+z2(Y*x),j2[132+l>>2]=z2(z2(E*V)+z2(D*I))+z2(C*x),j2[128+l>>2]=z2(z2(Q*V)+z2(G*I))+z2(h*x),J=g,g=j2[s>>2],M=Z,Z=j2[s+4>>2],y=Y,Y=j2[s+8>>2],j2[120+l>>2]=z2(z2(J*g)+z2(M*Z))+z2(y*Y),j2[116+l>>2]=z2(z2(E*g)+z2(D*Z))+z2(C*Y),j2[112+l>>2]=z2(z2(Q*g)+z2(G*Z))+z2(h*Y),j2[168+l>>2]=z2(z2(z2(a*R)+z2(v*F))+z2(B*N))+j2[s+56>>2],j2[164+l>>2]=z2(z2(z2(a*V)+z2(v*I))+z2(B*x))+j2[s+52>>2],j2[160+l>>2]=z2(z2(z2(a*g)+z2(v*Z))+z2(B*Y))+j2[s+48>>2],T2[68+l>>2]=1065353216,T2[72+l>>2]=1,T2[76+l>>2]=-1,T2[88+l>>2]=r=f-1|0,i=T2[504+l>>2],T2[84+l>>2]=i,T2[80+l>>2]=e,T2[64+l>>2]=18648,j2[68+l>>2]=j2[i+4>>2],T2[668+l>>2]=r,T2[664+l>>2]=-1,T2[652+l>>2]=e,r=T2[476+l>>2],T2[648+l>>2]=r,T2[656+l>>2]=T2[r+8>>2],T2[660+l>>2]=112+l,X4(T2[480+l>>2],T2[484+l>>2],T2[488+l>>2],648+l|0,l+64|0,j2[492+l>>2]),T2[n+24>>2]<=(0|f))break A;A=A+80|0,f=f+1|0,s=T2[500+l>>2];}}e=T2[(r=56+l|0)+4>>2],T2[(f=120+l|0)>>2]=T2[r>>2],T2[f+4>>2]=e,e=T2[(r=40+l|0)+4>>2],T2[(f=136+l|0)>>2]=T2[r>>2],T2[f+4>>2]=e,f=T2[52+l>>2],T2[112+l>>2]=T2[48+l>>2],T2[116+l>>2]=f,f=T2[36+l>>2],T2[128+l>>2]=T2[32+l>>2],T2[132+l>>2]=f,s4(T2[A>>2],112+l|0,472+l|0);}L2=672+l|0;}function p4(A,f,r,e,i,a){A|=0,f|=0,r|=0,e=z2(e),i|=0;var n,o,b=0;return T2[52+(L2=b=L2+-64|0)>>2]=a|=0,T2[48+b>>2]=i,T2[56+b>>2]=T2[A+220>>2],i=T2[A+212>>2],j2[i+4>>2]>=e&&(o=T2[4+(n=r+8|0)>>2],T2[(a=32+b|0)>>2]=T2[n>>2],T2[a+4>>2]=o,o=T2[4+(n=f+8|0)>>2],T2[(a=16+b|0)>>2]=T2[n>>2],T2[a+4>>2]=o,a=T2[r+4>>2],T2[24+b>>2]=T2[r>>2],T2[28+b>>2]=a,r=T2[f+4>>2],T2[8+b>>2]=T2[f>>2],T2[12+b>>2]=r,j2[40+b>>2]=e,T2[b>>2]=T2[A+216>>2],T2[4+b>>2]=48+b,e=z2(n1[T2[T2[i>>2]+12>>2]](i,b,1))),L2=b+64|0,z2(e);}function T4(A,f,r,e,i,a){var n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I,x,y=0;L2=y=L2-368|0,b=T2[4+(v=r+8|0)>>2],T2[(n=312+y|0)>>2]=T2[v>>2],T2[4+n>>2]=b,c=T2[4+(t=r+24|0)>>2],T2[(n=328+y|0)>>2]=T2[t>>2],T2[4+n>>2]=c,E=T2[4+(b=r+40|0)>>2],T2[(n=344+y|0)>>2]=T2[b>>2],T2[4+n>>2]=E,d=T2[4+(c=r+56|0)>>2],T2[(n=360+y|0)>>2]=T2[c>>2],T2[4+n>>2]=d,D=T2[4+(E=e+8|0)>>2],T2[(n=248+y|0)>>2]=T2[E>>2],T2[4+n>>2]=D,n=T2[r+4>>2],T2[304+y>>2]=T2[r>>2],T2[308+y>>2]=n,n=T2[r+20>>2],T2[320+y>>2]=T2[r+16>>2],T2[324+y>>2]=n,n=T2[r+36>>2],T2[336+y>>2]=T2[r+32>>2],T2[340+y>>2]=n,n=T2[r+52>>2],T2[352+y>>2]=T2[r+48>>2],T2[356+y>>2]=n,n=T2[e+4>>2],T2[240+y>>2]=T2[e>>2],T2[244+y>>2]=n,B=T2[4+(d=e+24|0)>>2],T2[(n=264+y|0)>>2]=T2[d>>2],T2[4+n>>2]=B,h=T2[4+(D=e+40|0)>>2],T2[(n=280+y|0)>>2]=T2[D>>2],T2[4+n>>2]=h,Z=T2[4+(B=e+56|0)>>2],T2[(n=296+y|0)>>2]=T2[B>>2],T2[4+n>>2]=Z,n=T2[e+20>>2],T2[256+y>>2]=T2[e+16>>2],T2[260+y>>2]=n,n=T2[e+36>>2],T2[272+y>>2]=T2[e+32>>2],T2[276+y>>2]=n,n=T2[e+52>>2],T2[288+y>>2]=T2[e+48>>2],T2[292+y>>2]=n,G4(304+y|0,240+y|0,8+y|0,224+y|0),M=j2[16+y>>2],I=j2[8+y>>2],x=j2[12+y>>2],Q=j2[224+y>>2],T2[(n=h=20+y|0)>>2]=0,T2[4+n>>2]=0,T2[(n=Z=32+y|0)>>2]=0,T2[4+n>>2]=0,T2[(Y=28+y|0)>>2]=1065353216,T2[(n=W=40+y|0)>>2]=0,T2[4+n>>2]=0,T2[(n=52+y|0)>>2]=0,T2[4+n>>2]=0,T2[(m=48+y|0)>>2]=1065353216,T2[(G=F=60+y|0)>>2]=0,T2[4+G>>2]=0,T2[(G=68+y|0)>>2]=0,T2[12+y>>2]=0,T2[16+y>>2]=0,T2[8+y>>2]=1065353216,C4(304+y|0,224+y|0),T2[n>>2]=0,T2[(N=36+y|0)>>2]=0,T2[h>>2]=0,o=j2[224+y>>2],u=j2[228+y>>2],l=j2[232+y>>2],k=j2[236+y>>2],s=z2(z2(2)/z2(z2(z2(z2(o*o)+z2(u*u))+z2(l*l))+z2(k*k))),g=z2(l*s),w=z2(u*g),R=z2(o*s),C=z2(k*R),j2[44+y>>2]=w+C,V=z2(o*g),s=z2(u*s),J=z2(k*s),j2[W>>2]=V-J,j2[Z>>2]=w-C,w=z2(o*R),u=z2(u*s),j2[m>>2]=z2(1)-z2(w+u),l=z2(l*g),j2[Y>>2]=z2(1)-z2(w+l),o=z2(o*s),k=z2(k*g),j2[24+y>>2]=o+k,j2[16+y>>2]=V+J,j2[12+y>>2]=o-k,j2[8+y>>2]=z2(1)-z2(u+l),n1[T2[T2[f>>2]+8>>2]](f,8+y|0,224+y|0,208+y|0),u=j2[208+y>>2],k=j2[212+y>>2],l=j2[216+y>>2],s=j2[224+y>>2],g=j2[228+y>>2],o=j2[232+y>>2],w=z2(n1[T2[T2[f>>2]+16>>2]](f)),T2[220+y>>2]=0,T2[236+y>>2]=0,R=z2(o+z2(0)),o=z2(I*Q),C=z2(o*o),o=z2(Q*x),C=z2(C+z2(o*o)),o=z2(Q*M),o=z2(w*z2(_2(z2(C+z2(o*o))))),j2[232+y>>2]=R-o,j2[228+y>>2]=z2(g+z2(0))-o,j2[224+y>>2]=z2(s+z2(0))-o,j2[216+y>>2]=o+l,j2[212+y>>2]=o+k,j2[208+y>>2]=o+u,Y=T2[4+v>>2],T2[n>>2]=T2[v>>2],T2[4+n>>2]=Y,n=T2[r+20>>2],T2[F>>2]=T2[r+16>>2],T2[4+F>>2]=n,n=T2[4+t>>2],T2[G>>2]=T2[t>>2],T2[4+G>>2]=n,v=T2[r+36>>2],T2[(n=76+y|0)>>2]=T2[r+32>>2],T2[4+n>>2]=v,v=T2[4+b>>2],T2[(n=84+y|0)>>2]=T2[b>>2],T2[4+n>>2]=v,t=T2[r+52>>2],T2[(n=92+y|0)>>2]=T2[r+48>>2],T2[4+n>>2]=t,b=T2[4+c>>2],T2[(t=v=100+y|0)>>2]=T2[c>>2],T2[4+t>>2]=b,b=T2[4+E>>2],T2[(t=116+y|0)>>2]=T2[E>>2],T2[4+t>>2]=b,T2[8+y>>2]=19520,t=T2[r+4>>2],T2[44+y>>2]=T2[r>>2],T2[48+y>>2]=t,r=T2[e+4>>2],T2[108+y>>2]=T2[e>>2],T2[112+y>>2]=r,b=T2[e+52>>2],T2[(r=156+y|0)>>2]=T2[e+48>>2],T2[r+4>>2]=b,c=T2[4+B>>2],T2[(b=t=164+y|0)>>2]=T2[B>>2],T2[4+b>>2]=c,c=T2[4+d>>2],T2[(b=132+y|0)>>2]=T2[d>>2],T2[4+b>>2]=c,c=T2[e+20>>2],T2[(b=124+y|0)>>2]=T2[e+16>>2],T2[4+b>>2]=c,c=T2[4+D>>2],T2[(b=148+y|0)>>2]=T2[D>>2],T2[4+b>>2]=c,c=T2[e+36>>2],T2[(b=140+y|0)>>2]=T2[e+32>>2],T2[4+b>>2]=c,T2[192+y>>2]=i,j2[196+y>>2]=a,T2[200+y>>2]=f,o=j2[96+y>>2],u=j2[160+y>>2],a=j2[n>>2],k=j2[r>>2],Q=j2[v>>2],l=j2[t>>2],T2[188+y>>2]=A,a=z2(k-a),o=z2(u-o),u=z2(l-Q),k=z2(z2(1)/z2(_2(z2(z2(z2(a*a)+z2(o*o))+z2(u*u))))),s=(Q=z2(u*k))==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/Q),T2[N>>2]=s<z2(0),g=(l=z2(o*k))==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/l),T2[Z>>2]=g<z2(0),j2[h>>2]=s,j2[16+y>>2]=g,a=z2((s=a)*k),j2[40+y>>2]=z2(u*Q)+z2(z2(s*a)+z2(o*l)),a=a==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/a),j2[12+y>>2]=a,T2[28+y>>2]=a<z2(0),A=T2[A+68>>2],n1[T2[T2[A>>2]+24>>2]](A,352+y|0,288+y|0,8+y|0,224+y|0,208+y|0),L2=368+y|0;}function S4(A,f,r){var e,i=0,a=0,a=f|=0,n=0|n1[T2[T2[(r|=0)>>2]+28>>2]](r,T2[(A|=0)+28>>2]);if(T2[a>>2]=n,a=f,n=0|n1[T2[T2[r>>2]+28>>2]](r,T2[A+32>>2]),T2[a+4>>2]=n,i=0|n1[T2[T2[r>>2]+40>>2]](r,A),e=0|n1[T2[T2[r>>2]+28>>2]](r,i),(T2[f+8>>2]=e)&&n1[T2[T2[r>>2]+48>>2]](r,i),T2[f+12>>2]=T2[A+4>>2],T2[f+24>>2]=S2[A+21|0],T2[f+40>>2]=T2[A+24>>2],j2[f+44>>2]=j2[A+16>>2],T2[f+48>>2]=S2[A+20|0],r=T2[A+12>>2],i=T2[A+40>>2],T2[f+28>>2]=T2[A+36>>2],T2[f+32>>2]=i,T2[f+20>>2]=r,T2[f+36>>2]=0,T2[f+16>>2]=T2[A+8>>2],r=T2[A+28>>2],!((0|(i=T2[r+548>>2]))<1)&&(r=T2[r+556>>2],T2[r>>2]==(0|A)&&(T2[f+36>>2]=1),1!=(0|i)))for(r=r+4|0,i=i-1|0;T2[r>>2]==(0|A)&&(T2[f+36>>2]=1),r=r+4|0,i=i-1|0;);if(r=T2[A+32>>2],!((0|(i=T2[r+548>>2]))<1)&&(r=T2[r+556>>2],T2[r>>2]==(0|A)&&(T2[f+36>>2]=1),1!=(0|i)))for(r=r+4|0,i=i-1|0;T2[r>>2]==(0|A)&&(T2[f+36>>2]=1),r=r+4|0,i=i-1|0;);return 19704;}function j4(A,f,r,e,i,a,n,o,b,t){var c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W=T2[a+4>>2];T2[A>>2]=T2[a>>2],T2[A+4>>2]=W,Y=T2[(a=a+8|0)+4>>2],T2[(W=A+8|0)>>2]=T2[a>>2],T2[4+W>>2]=Y,G=j2[f+24>>2],B=j2[f+20>>2],l=j2[f+40>>2],u=j2[f+36>>2],Q=j2[f+8>>2],g=j2[f>>2],C=j2[f+4>>2],E=j2[f+16>>2],c=j2[f+32>>2],v=j2[e+4>>2],s=j2[e+8>>2],w=j2[e>>2],T2[A+28>>2]=0,D=c,c=j2[W>>2],k=j2[A+4>>2],d=z2(z2(v*c)-z2(s*k)),h=u,Z=s,s=j2[A>>2],u=z2(z2(Z*s)-z2(c*w)),v=z2(z2(k*w)-z2(v*s)),w=z2(z2(z2(D*d)+z2(h*u))+z2(l*v)),j2[A+24>>2]=w,G=z2(z2(z2(d*E)+z2(u*B))+z2(v*G)),j2[A+20>>2]=G,v=z2(z2(z2(d*g)+z2(C*u))+z2(v*Q)),j2[A+16>>2]=v,Q=j2[r+24>>2],g=j2[r+20>>2],C=j2[r+40>>2],E=j2[r+36>>2],R=j2[r+8>>2],F=j2[r>>2],D=j2[r+4>>2],h=j2[r+16>>2],l=j2[r+32>>2],d=j2[i+4>>2],u=j2[i>>2],B=j2[i+8>>2],T2[A+44>>2]=0,Z=l,l=z2(z2(k*B)-z2(c*d)),c=z2(z2(c*u)-z2(s*B)),k=z2(z2(s*d)-z2(k*u)),s=z2(z2(z2(Z*l)+z2(E*c))+z2(C*k)),j2[A+40>>2]=s,d=z2(z2(z2(l*h)+z2(c*g))+z2(k*Q)),j2[A+36>>2]=d,c=z2(z2(z2(F*l)+z2(D*c))+z2(k*R)),j2[A+32>>2]=c,k=j2[n+8>>2],u=j2[n+4>>2],B=j2[n>>2],T2[A+60>>2]=0,B=z2(B*v),j2[A+48>>2]=B,u=z2(u*G),j2[A+52>>2]=u,k=z2(k*w),j2[A+56>>2]=k,l=j2[b+8>>2],Q=j2[b+4>>2],g=j2[b>>2],T2[A+76>>2]=0,g=z2(g*c),j2[A+64>>2]=g,Q=z2(Q*d),j2[A+68>>2]=Q,l=z2(l*s),j2[A+72>>2]=l,j2[A+80>>2]=z2(z2(z2(z2(z2(v*B)+z2(G*u))+z2(w*k))+o)+t)+z2(z2(z2(c*g)+z2(d*Q))+z2(s*l));}function P4(A){var f=0,r=0,e=0,i=0,e=T2[A+8>>2],a=(r=T2[A+32>>2])?T2[A+40>>2]:0,n=r,o=(f=T2[A+52>>2])?T2[A+60>>2]:0;if(r=f,i=0,(f=T2[A+72>>2])&&(i=T2[A+80>>2]),z2(n1[T2[T2[e>>2]+12>>2]](e,a,n,o,r,i,f,T2[A+4>>2],T2[A+20>>2],T2[A+24>>2])),(0|(f=T2[A+32>>2]))<=-1)for(T2[A+36>>2]<=-1&&((r=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+36>>2]=0,T2[A+40>>2]=0,p2[A+44|0]=1),e=f<<2;e=e+4|(T2[T2[A+40>>2]+e>>2]=0),(r=f)>>>0<=(f=f+1|0)>>>0;);if(((T2[A+32>>2]=0)|(f=T2[A+52>>2]))<=-1)for(T2[A+56>>2]<=-1&&((r=T2[A+60>>2])&&S2[A- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+56>>2]=0,T2[A+60>>2]=0,p2[A- -64|0]=1),e=f<<2;e=e+4|(T2[T2[A+60>>2]+e>>2]=0),(r=f)>>>0<=(f=f+1|0)>>>0;);if(((T2[A+52>>2]=0)|(f=T2[A+72>>2]))<=-1)for(T2[A+76>>2]<=-1&&((r=T2[A+80>>2])&&S2[A+84|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+76>>2]=0,T2[A+80>>2]=0,p2[A+84|0]=1),e=f<<2;e=e+4|(T2[T2[A+80>>2]+e>>2]=0),(r=f)>>>0<=(f=f+1|0)>>>0;);T2[A+72>>2]=0;}function z4(A){var f=0;return T2[(A|=0)>>2]=19784,S2[A+288|0]&&(f=T2[A+220>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+220>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),(f=T2[A+212>>2])&&(n1[T2[T2[f>>2]>>2]](f),(f=T2[A+212>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),S2[A+289|0]&&(f=T2[A+216>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+216>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),(f=T2[A+332>>2])&&S2[A+336|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+332>>2]=0,p2[A+336|0]=1,T2[(f=A+324|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+304>>2])&&S2[A+308|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+304>>2]=0,p2[A+308|0]=1,T2[(f=A+296|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+256>>2])&&S2[A+260|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+256>>2]=0,p2[A+260|0]=1,T2[(f=A+248|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+236>>2])&&S2[A+240|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+236>>2]=0,p2[A+240|0]=1,T2[(f=A+228|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+204>>2])&&S2[A+208|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+204>>2]=0,p2[A+208|0]=1,T2[(f=A+196|0)>>2]=0,T2[f+4>>2]=0,J4(A),0|A;}function O4(A,f){return T2[T2[(A|=0)+236>>2]+((f|=0)<<2)>>2];}function H4(A,f){n1[T2[T2[(A|=0)>>2]+68>>2]](A,f|=0);}function _4(A,f,r){var e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q=z2(0);(Q=j2[A+404>>2])!=z2(0)&&(i=j2[f+8>>2],e=j2[f+4>>2],a=j2[A+408>>2],j2[A+372>>2]=z2(Q*z2(j2[f>>2]*a))+j2[A+372>>2],o=e,e=j2[A+412>>2],j2[(n=A+376|0)>>2]=z2(Q*z2(o*e))+j2[n>>2],o=Q,Q=j2[A+416>>2],j2[(n=A+380|0)>>2]=z2(o*z2(i*Q))+j2[n>>2],c=j2[A+612>>2],u=j2[A+364>>2],k=j2[A+356>>2],l=j2[A+360>>2],s=j2[A+608>>2],v=j2[A+348>>2],d=j2[A+340>>2],B=j2[A+344>>2],t=j2[r+4>>2],i=z2(Q*j2[f+8>>2]),e=z2(e*j2[f+4>>2]),b=j2[r+8>>2],Q=z2(z2(t*i)-z2(e*b)),a=z2(a*j2[f>>2]),o=z2(a*b),b=j2[r>>2],i=z2(o-z2(i*b)),e=z2(z2(e*b)-z2(a*t)),j2[A+388>>2]=z2(z2(z2(z2(j2[A+324>>2]*Q)+z2(j2[A+328>>2]*i))+z2(e*j2[A+332>>2]))*j2[A+604>>2])+j2[A+388>>2],j2[(f=A+392|0)>>2]=z2(s*z2(z2(z2(Q*d)+z2(i*B))+z2(e*v)))+j2[f>>2],j2[(A=A+396|0)>>2]=z2(c*z2(z2(z2(Q*k)+z2(i*l))+z2(e*u)))+j2[A>>2]);}function L4(A){T2[(A|=0)>>2]=19636,T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);}function K4(A,f,r){var e,i,a,n=j2[A+552>>2],o=j2[f>>2],b=j2[A+568>>2],t=j2[f+4>>2],c=j2[A+584>>2],u=j2[f+8>>2],k=j2[A+620>>2],l=j2[A+636>>2],s=j2[A+652>>2],v=z2(z2(z2(k*j2[r>>2])+z2(l*j2[r+4>>2]))+z2(s*j2[r+8>>2])),d=j2[f+16>>2],B=j2[f+20>>2],Q=j2[f+24>>2],g=z2(z2(z2(k*j2[r+16>>2])+z2(l*j2[r+20>>2]))+z2(s*j2[r+24>>2])),w=z2(z2(z2(z2(z2(n*o)+z2(b*t))+z2(c*u))*v)+z2(z2(z2(z2(n*d)+z2(b*B))+z2(c*Q))*g)),G=n;return n=j2[f+32>>2],e=b,b=j2[f+36>>2],i=c,c=j2[f+40>>2],s=z2(z2(z2(k*j2[r+32>>2])+z2(l*j2[r+36>>2]))+z2(s*j2[r+40>>2])),k=o,o=j2[A+556>>2],l=t,t=j2[A+572>>2],a=u,u=j2[A+588>>2],z2(B2(z2(w+z2(z2(z2(z2(G*n)+z2(e*b))+z2(i*c))*s)),z2(z2(z2(z2(z2(z2(k*o)+z2(l*t))+z2(a*u))*v)+z2(z2(z2(z2(d*o)+z2(B*t))+z2(Q*u))*g))+z2(z2(z2(z2(n*o)+z2(b*t))+z2(c*u))*s)))*j2[A+732>>2]);}function q4(A){return z2(j2[(A|=0)>>2]);}function $4(A){(A|=0)&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2]));}function A1(A){return z2(j2[(A|=0)+4>>2]);}function f1(A){return z2(j2[(A|=0)+8>>2]);}function r1(A,f,r,e,i){A|=0,f=z2(f),r=z2(r),e=z2(e),i=z2(i),j2[A+12>>2]=i,j2[A+8>>2]=e,j2[A+4>>2]=r,j2[A>>2]=f;}function e1(A,f,r,e){var i=0,a=0,n=0,o=0,b=0,t=P2(i=r>>>16|0,a=A>>>16|0);return i=(65535&(a=((b=P2(n=65535&r,o=65535&A))>>>16|0)+P2(a,n)|0))+P2(i,o)|0,z=(P2(f,r)+t|0)+P2(A,e)+(a>>>16)+(i>>>16)|0,65535&b|i<<16;}function i1(A,f,r){var e,i,a=0,n=0,o=0,b=0,t=0,c=0,u=0;A:{f:{r:{e:{i:{a:{n:{o:{b:{t:{if(f){if(!r)break t;break b;}A=(A>>>0)/(r>>>0)|0,z=0;break A;}if(!A)break o;break n;}if(!(r-1&r))break a;b=0-(o=(k(r)+33|0)-k(f)|0)|0;break e;}A=(f>>>0)/0|0,z=0;break A;}if((a=32-k(f)|0)>>>0<31)break i;break r;}if(1==(0|r))break f;r=31&(a=r?31-k(r-1^r)|0:32),A=32<=(63&a)>>>0?f>>>r|(a=0):(a=f>>>r|0,((1<<r)-1&f)<<32-r|A>>>r),z=a;break A;}o=a+1|0,b=63-a|0;}if(n=31&(a=63&o),t=32<=a>>>0?f>>>n|(a=0):(a=f>>>n|0,((1<<n)-1&f)<<32-n|A>>>n),n=31&(b&=63),32<=b>>>0?(f=A<<n,A=0):(f=(1<<n)-1&A>>>32-n|f<<n,A<<=n),o)for(b=-1!=(0|(n=r-1|0))?0:-1;c=a<<1|t>>>31,t=(a=t<<1|f>>>31)-(i=r&(e=(t=b-(c+(n>>>0<a>>>0)|0)|0)>>31))|0,a=c-(a>>>0<i>>>0)|0,f=f<<1|A>>>31,A=u|A<<1,u=c=1&e,o=o-1|0;);z=f<<1|A>>>31,A=c|A<<1;break A;}f=A=0;}z=f;}return A;}function a1(A){var f=0;return (-1>>>(f=31&A)&-2)<<f|(-1<<(A=0-A&31)&-2)>>>A;}c1(t1=S2,1024,"OGPtPtoPST9emHs/2g/JP2k3rDFoISIztA8UM2ghojPbD0k/2w9Jv+TLFkDkyxbAAAAAAAAAAIDbD0lA2w9JwFB1cmUgdmlydHVhbCBmdW5jdGlvbiBjYWxsZWQhAAAAUFIAAAAAAAAAAAAAAAAAAAAZEkQ7Aj8sRxQ9MzAKGwZGS0U3D0kOFwNAHTwrNh9KLRwBICUpIQgMFRYiLhA4Pgs0MRgvQQk5ESNDMkI6BQQmKCcNKh41BxpIEyRM/wAAU3VjY2VzcwBJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFF1b3RhIGV4Y2VlZGVkAE11bHRpaG9wIGF0dGVtcHRlZABDYXBhYmlsaXRpZXMgaW5zdWZmaWNpZW50AE5vIGVycm9yIGluZm9ybWF0aW9uAAAtKyAgIDBYMHgAKG51bGwpAAAAAAAAAAAAABkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABGwkLGAAACQYLAAALAAYZAAAAGRkZAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAABkACg0ZGRkADQAAAgAJDgAAAAkADgAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAATAAAAABMAAAAACQwAAAAAAAwAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAADwAAAAQPAAAAAAkQAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAABEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAGhoaAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFwAAAAAXAAAAAAkUAAAAAAAUAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAAAAAAAAAAAAABUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAU3VwcG9ydCBmb3IgZm9ybWF0dGluZyBsb25nIGRvdWJsZSB2YWx1ZXMgaXMgY3VycmVudGx5IGRpc2FibGVkLgpUbyBlbmFibGUgaXQsIGFkZCAtbGMtcHJpbnRzY2FuLWxvbmctZG91YmxlIHRvIHRoZSBsaW5rIGNvbW1hbmQuCgAAAAAAAAAAAAAAAAAAMDEyMzQ1Njc4OUFCQ0RFRi0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4ALgAKAFN0OXR5cGVfaW5mbwAUDgAAlw0AAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAAAAADwOAACsDQAApA0AAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQAAADwOAADcDQAA0A0AAAAAAAAADgAABAAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAAAAAAhA4AAAUAAAAOAAAACAAAAAkAAAAKAAAADwAAABAAAAARAAAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAADwOAABcDgAAAA4AAAAAAADgDgAABgAAABIAAAAIAAAACQAAAAoAAAATAAAAFAAAABUAAABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9FAAAAPA4AALgOAAAADgAAAAAAAAMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAZxEcAzWfDAAno3ABZgyoAi3bEAKYclgBEr90AGVfRAKU+BQAFB/8AM34/AMIy6ACYT94Au30yACY9wwAea+8An/heADUfOgB/8soA8YcdAHyQIQBqJHwA1W76ADAtdwAVO0MAtRTGAMMZnQCtxMIALE1BAAwAXQCGfUYA43EtAJvGmgAzYgAAtNJ8ALSnlwA3VdUA1z72AKMQGABNdvwAZJ0qAHDXqwBjfPgAerBXABcV5wDASVYAO9bZAKeEOAAkI8sA1op3AFpUIwAAH7kA8QobABnO3wCfMf8AZh5qAJlXYQCs+0cAfn/YACJltwAy6IkA5r9gAO/EzQBsNgkAXT/UABbe1wBYO94A3puSANIiKAAohugA4lhNAMbKMgAI4xYA4H3LABfAUADzHacAGOBbAC4TNACDEmIAg0gBAPWOWwCtsH8AHunyAEhKQwAQZ9MAqt3YAK5fQgBqYc4ACiikANOZtAAGpvIAXHd/AKPCgwBhPIgAinN4AK+MWgBv170ALaZjAPS/ywCNge8AJsFnAFXKRQDK2TYAKKjSAMJhjQASyXcABCYUABJGmwDEWcQAyMVEAE2ykQAAF/MA1EOtAClJ5QD91RAAAL78AB6UzABwzu4AEz71AOzxgACz58MAx/goAJMFlADBcT4ALgmzAAtF8wCIEpwAqyB7AC61nwBHksIAezIvAAxVbQByp5AAa+cfADHLlgB5FkoAQXniAPTfiQDolJcA4uaEAJkxlwCI7WsAX182ALv9DgBImrQAZ6RsAHFyQgCNXTIAnxW4ALzlCQCNMSUA93Q5ADAFHAANDAEASwhoACzuWABHqpAAdOcCAL3WJAD3faYAbkhyAJ8W7wCOlKYAtJH2ANFTUQDPCvIAIJgzAPVLfgCyY2gA3T5fAEBdAwCFiX8AVVIpADdkwABt2BAAMkgyAFtMdQBOcdQARVRuAAsJwQAq9WkAFGbVACcHnQBdBFAAtDvbAOp2xQCH+RcASWt9AB0nugCWaSkAxsysAK0UVACQ4moAiNmJACxyUAAEpL4AdweUAPMwcAAA/CcA6nGoAGbCSQBk4D0Al92DAKM/lwBDlP0ADYaMADFB3gCSOZ0A3XCMABe35wAI3zsAFTcrAFyAoABagJMAEBGSAA/o2ABsgK8A2/9LADiQDwBZGHYAYqUVAGHLuwDHibkAEEC9ANLyBABJdScA67b2ANsiuwAKFKoAiSYvAGSDdgAJOzMADpQaAFE6qgAdo8IAr+2uAFwmEgBtwk0ALXqcAMBWlwADP4MACfD2ACtAjABtMZkAObQHAAwgFQDYw1sA9ZLEAMatSwBOyqUApzfNAOapNgCrkpQA3UJoABlj3gB2jO8AaItSAPzbNwCuoasA3xUxAACuoQAM+9oAZE1mAO0FtwApZTAAV1a/AEf/OgBq+bkAdb7zACiT3wCrgDAAZoz2AATLFQD6IgYA2eQdAD2zpABXG48ANs0JAE5C6QATvqQAMyO1APCqGgBPZagA0sGlAAs/DwBbeM0AI/l2AHuLBACJF3IAxqZTAG9u4gDv6wAAm0pYAMTatwCqZroAds/PANECHQCx8S0AjJnBAMOtdwCGSNoA912gAMaA9ACs8C8A3eyaAD9cvADQ3m0AkMcfACrbtgCjJToAAK+aAK1TkwC2VwQAKS20AEuAfgDaB6cAdqoOAHtZoQAWEioA3LctAPrl/QCJ2/4Aib79AOR2bAAGqfwAPoBwAIVuFQD9h/8AKD4HAGFnMwAqGIYATb3qALPnrwCPbW4AlWc5ADG/WwCE10gAMN8WAMctQwAlYTUAyXDOADDLuAC/bP0ApACiAAVs5ABa3aAAIW9HAGIS0gC5XIQAcGFJAGtW4ACZUgEAUFU3AB7VtwAz8cQAE25fAF0w5ACFLqkAHbLDAKEyNgAIt6QA6rHUABb3IQCPaeQAJ/93AAwDgACNQC0AT82gACClmQCzotMAL10KALT5QgAR2ssAfb7QAJvbwQCrF70AyqKBAAhqXAAuVRcAJwBVAH8U8ADhB4YAFAtkAJZBjQCHvt4A2v0qAGsltgB7iTQABfP+ALm/ngBoak8ASiqoAE/EWgAt+LwA11qYAPTHlQANTY0AIDqmAKRXXwAUP7EAgDiVAMwgAQBx3YYAyd62AL9g9QBNZREAAQdrAIywrACywNAAUVVIAB77DgCVcsMAowY7AMBANQAG3HsA4EXMAE4p+gDWysgA6PNBAHxk3gCbZNgA2b4xAKSXwwB3WNQAaePFAPDaEwC6OjwARhhGAFV1XwDSvfUAbpLGAKwuXQAORO0AHD5CAGHEhwAp/ekA59bzACJ8ygBvkTUACODFAP/XjQBuauIAsP3GAJMIwQB8XXQAa62yAM1unQA+cnsAxhFqAPfPqQApc98Atcm6ALcAUQDisg0AdLokAOV9YAB02IoADRUsAIEYDAB+ZpQAASkWAJ96dgD9/b4AVkXvANl+NgDs2RMAi7q5AMSX/AAxqCcA8W7DAJTFNgDYqFYAtKi1AM/MDgASiS0Ab1c0ACxWiQCZzuMA1iC5AGteqgA+KpwAEV/MAP0LSgDh9PsAjjttAOKGLADp1IQA/LSpAO/u0QAuNckALzlhADghRAAb2cgAgfwKAPtKagAvHNgAU7SEAE6ZjABUIswAKlXcAMDG1gALGZYAGnC4AGmVZAAmWmAAP1LuAH8RDwD0tREA/Mv1ADS8LQA0vO4A6F3MAN1eYABnjpsAkjPvAMkXuABhWJsA4Ve8AFGDxgDYPhAA3XFIAC0c3QCvGKEAISxGAFnz1wDZepgAnlTAAE+G+gBWBvwA5XmuAIkiNgA4rSIAZ5PcAFXoqgCCJjgAyuebAFENpACZM7EAqdcOAGkFSABlsvAAf4inAIhMlwD50TYAIZKzAHuCSgCYzyEAQJ/cANxHVQDhdDoAZ+tCAP6d3wBe1F8Ae2ekALqsegBV9qIAK4gjAEG6VQBZbggAISqGADlHgwCJ4+YA5Z7UAEn7QAD/VukAHA/KAMVZigCU+isA08HFAA/FzwDbWq4AR8WGAIVDYgAhhjsALHmUABBhhwAqTHsAgCwaAEO/EgCIJpAAeDyJAKjE5ADl23sAxDrCACb06gD3Z4oADZK/AGWjKwA9k7EAvXwLAKRR3AAn3WMAaeHdAJqUGQCoKZUAaM4oAAnttABEnyAATpjKAHCCYwB+fCMAD7kyAKf1jgAUVucAIfEIALWdKgBvfk0ApRlRALX5qwCC39YAlt1hABY2AgDEOp8Ag6KhAHLtbQA5jXoAgripAGsyXABGJ1sAADTtANIAdwD89FUAAVlNAOBxgAAAAAAAAAAAAAAAAED7Ifk/AAAAAC1EdD4AAACAmEb4PAAAAGBRzHg7AAAAgIMb8DkAAABAICV6OAAAAIAiguM2AAAAAB3zaTW+8/h57GH2PxkwllvG/t6/PYivSu1x9T+k/NQyaAvbv7AQ8PA5lfQ/e7cfCotB17+FA7iwlcnzP3vPbRrpndO/pWSIDBkN8z8xtvLzmx3Qv6COC3siXvI/8Ho7Gx18yb8/NBpKSrvxP588r5Pj+cK/uuWK8Fgj8T9cjXi/y2C5v6cAmUE/lfA/zl9Htp1vqr8AAAAAAADwPwAAAAAAAAAArEea/Yxg7j899SSfyjizP6BqAh+zpOw/upE4VKl2xD/m/GpXNiDrP9LkxEoLhM4/LaqhY9HC6T8cZcbwRQbUP+1BeAPmhug/+J8bLJyO2D9iSFP13GfnP8x7sU6k4Nw/C25JyRZ20j96xnWgaRnXv926p2wKx94/yPa+SEcV578ruCplRxX3PwAAAAAAAPA/dIUV07DZ7z8PiflsWLXvP1FbEtABk+8/e1F9PLhy7z+quWgxh1TvPzhidW56OO8/4d4f9Z0e7z8VtzEK/gbvP8upOjen8e4/IjQSTKbe7j8tiWFgCM7uPycqNtXav+4/gk+dViu07j8pVEjdB6vuP4VVOrB+pO4/zTt/Zp6g7j90X+zodZ/uP4cB63MUoe4/E85MmYml7j/boCpC5azuP+XFzbA3t+4/kPCjgpHE7j9dJT6yA9XuP63TWpmf6O4/R1778nb/7j+cUoXdmxnvP2mQ79wgN+8/h6T73BhY7z9fm3szl3zvP9qQpKKvpO8/QEVuW3bQ7z8AAAAAAADoQpQjkUv4aqw/88T6UM6/zj/WUgz/Qi7mPwAAAAAAADhD/oIrZUcVR0CUI5FL+Gq8PvPE+lDOvy4/1lIM/0Iulj8AAAAA4BwAACAAAAAhAAAAIgAAACMAAAAAAAAAsBwAACAAAAAkAAAAJQAAACYAAAAUDgAAuBwAAE4xNmJ0Q29sbGlzaW9uV29ybGQxN1JheVJlc3VsdENhbGxiYWNrRQA8DgAA7BwAABAdAABOMmNjMjZjY0Nsb3Nlc3RSYXlSZXN1bHRDYWxsYmFja0UAAAA8DgAAHB0AALAcAABOMTZidENvbGxpc2lvbldvcmxkMjRDbG9zZXN0UmF5UmVzdWx0Q2FsbGJhY2tFAAAAAAAAuB0AACcAAAAoAAAAKQAAACoAAAAAAAAAfB0AACsAAAAsAAAAJQAAAC0AAAA8DgAAiB0AALAcAABOMTZidENvbGxpc2lvbldvcmxkMjRBbGxIaXRzUmF5UmVzdWx0Q2FsbGJhY2tFAAA8DgAAxB0AAHwdAABOMmNjMjZjY0FsbEhpdHNSYXlSZXN1bHRDYWxsYmFja0UAAAAAAAAADB4AAC4AAAAvAAAAMAAAADEAAAAyAAAAMwAAADQAAAAUDgAALx4AAGJ0Q29sbGlzaW9uT2JqZWN0RmxvYXREYXRhADE3YnRDb2xsaXNpb25PYmplY3QAYnRDb2xsaXNpb25TaGFwZURhdGEAMTZidENvbGxpc2lvblNoYXBlAAAUDgAAWB4AADwOAACAHgAAbB4AADEzYnRDb252ZXhTaGFwZQA8DgAAnB4AAHQeAAAyMWJ0Q29udmV4SW50ZXJuYWxTaGFwZQAAAAAAxB4AADUAAAA2AAAAFA4AAMweAAAxOGJ0Q29udmV4UG9seWhlZHJvbgAAAAAAAAAAaB8AADcAAAA4AAAAOQAAADoAAAA7AAAAPAAAAD0AAAA+AAAAPwAAACYAAABAAAAAQQAAAEIAAABDAAAARAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAACYAAAAmAAAAJgAAACYAAAAmAAAAJgAAACYAAAA8DgAAdB8AAJAeAAAyM2J0UG9seWhlZHJhbENvbnZleFNoYXBlAAAAPA4AAJwfAABoHwAAMzRidFBvbHloZWRyYWxDb252ZXhBYWJiQ2FjaGluZ1NoYXBlAAAAAAAAAABMIAAANwAAAE4AAABPAAAAOgAAADsAAAA8AAAAUAAAAD4AAABRAAAAUgAAAEAAAABTAAAAQgAAAEMAAABEAAAARQAAAFQAAABVAAAASAAAAFYAAABKAAAAVwAAAFgAAABNAAAAWQAAAFoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAAA8DgAAHiEAAGgfAAAAAAAAAAAAAAEAAAACAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAADAAAABAAAAAUAAAAGAAAABwAAAAUAAAAGAAAABwAAAAcAAAAAAIA/AACAvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgD8AAIC/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAPwAAgL9idENvbnZleEludGVybmFsU2hhcGVEYXRhAEJveAAxMGJ0Qm94U2hhcGUAAAAAAACQIQAAYQAAAGIAAABjAAAAOgAAADsAAAA8AAAAZAAAAD4AAABlAAAAZgAAAGcAAABoAAAAQgAAAGkAAABqAAAARQAAAEYAAABrAAAASAAAAGwAAABKAAAASwAAAEwAAAA8DgAAvCEAAJAeAABidENhcHN1bGVTaGFwZURhdGEAQ2Fwc3VsZVNoYXBlADE0YnRDYXBzdWxlU2hhcGUAAAAAAAAAADgiAABhAAAAbQAAAG4AAAA6AAAAOwAAADwAAABvAAAAPgAAAHAAAABxAAAAcgAAAHMAAABCAAAAdAAAAHUAAABFAAAAdgAAAHcAAABIAAAAeAAAAEoAAABLAAAATAAAAHkAAAA8DgAAYiIAAJAeAABidEN5bGluZGVyU2hhcGVEYXRhAEN5bGluZGVyWQAxNWJ0Q3lsaW5kZXJTaGFwZQAAAAAA2CIAAGEAAAB6AAAAOQAAADoAAAA7AAAAPAAAAHsAAAA+AAAAfAAAAH0AAAB+AAAAQQAAAEIAAAB/AAAAgAAAAEUAAACBAAAAggAAAEgAAACDAAAASgAAAEsAAABMAAAAPA4AAPkiAACQHgAAYnRDb25lU2hhcGVEYXRhAENvbmUAMTFidENvbmVTaGFwZQAAPA4AABQjAABsHgAAMTRidENvbmNhdmVTaGFwZQAAAAAAAAAAdCMAAIQAAACFAAAAhgAAADoAAAA7AAAAPAAAAIcAAACIAAAAiQAAAIoAAABAAAAAiwAAAIwAAACNAAAAjgAAAEUAAACPAAAAPA4AAKMjAAAIIwAAYnRTdGF0aWNQbGFuZVNoYXBlRGF0YQBTVEFUSUNQTEFORQAxOGJ0U3RhdGljUGxhbmVTaGFwZQBONmJ0RGJ2dDhJQ29sbGlkZUUAABQOAAC4IwAAAAAAACQkAACQAAAAkQAAAJIAAAA6AAAAOwAAADwAAACTAAAAlAAAAJUAAACWAAAAQAAAAJcAAACYAAAAmQAAAJoAAABFAAAAmwAAAJwAAAA8DgAAXSQAAGweAABidENvbXBvdW5kU2hhcGVDaGlsZERhdGEAYnRDb21wb3VuZFNoYXBlRGF0YQAxNWJ0Q29tcG91bmRTaGFwZQAxOGJ0VHJpYW5nbGVDYWxsYmFjawAUDgAAbyQAADMxYnRJbnRlcm5hbFRyaWFuZ2xlSW5kZXhDYWxsYmFjawAAABQOAACMJAAAYnRJbnRJbmRleERhdGEAYnRTaG9ydEludEluZGV4VHJpcGxldERhdGEAYnRDaGFySW5kZXhUcmlwbGV0RGF0YQBidFZlY3RvcjNGbG9hdERhdGEAYnRWZWN0b3IzRG91YmxlRGF0YQBidE1lc2hQYXJ0RGF0YQBidFN0cmlkaW5nTWVzaEludGVyZmFjZURhdGEAMjNidFN0cmlkaW5nTWVzaEludGVyZmFjZQAAAAAUDgAASyUAAAAAAAC0JQAAnQAAAJ4AAACfAAAAoAAAAKEAAACiAAAAowAAAKQAAAClAAAApgAAAKcAAACoAAAAqQAAAKoAAACrAAAAPA4AAMAlAABoJQAAMjZidFRyaWFuZ2xlSW5kZXhWZXJ0ZXhBcnJheQAAAAAAAAAAJCYAAKwAAACtAAAAnwAAAKAAAAChAAAAogAAAKMAAACkAAAArgAAAK8AAACnAAAAqAAAAKkAAACqAAAAqwAAADwOAAAwJgAAtCUAADE0YnRUcmlhbmdsZU1lc2gAAAAAAAAAAJgmAACwAAAAsQAAALIAAAA6AAAAOwAAADwAAACzAAAAtAAAALUAAAC2AAAAQAAAAIsAAACMAAAAtwAAALgAAABFAAAAuQAAALoAAAC7AAAAPA4AAG8nAAAIIwAAAAAAALgmAAC8AAAAvQAAAL4AAAA8DgAAxCYAAIQkAAAyMVN1cHBvcnRWZXJ0ZXhDYWxsYmFjawAAAAAA8CYAAL8AAADAAAAAwQAAADwOAAD8JgAAsCQAAFpOSzE5YnRUcmlhbmdsZU1lc2hTaGFwZTE5cHJvY2Vzc0FsbFRyaWFuZ2xlc0VQMThidFRyaWFuZ2xlQ2FsbGJhY2tSSzlidFZlY3RvcjNTNF9FMTZGaWx0ZXJlZENhbGxiYWNrAFRSSUFOR0xFTUVTSAAxOWJ0VHJpYW5nbGVNZXNoU2hhcGUAAAAAAAAAAKwnAADCAAAAwwAAAMQAAADFAAAAxgAAAMcAAADIAAAAFA4AAA8oAABidE9wdGltaXplZEJ2aE5vZGVEYXRhAGJ0UXVhbnRpemVkQnZoTm9kZURhdGEAYnRCdmhTdWJ0cmVlSW5mb0RhdGEAYnRRdWFudGl6ZWRCdmhGbG9hdERhdGEAMTRidFF1YW50aXplZEJ2aAAAAAAASCgAAMkAAADKAAAAxAAAAMUAAADGAAAAxwAAAMgAAADLAAAAPA4AAFQoAACsJwAAMTRidE9wdGltaXplZEJ2aAAAAAAAAAAA+CgAAL8AAADMAAAAzQAAAAAAAACQKAAAvwAAAM4AAADPAAAAPA4AAJwoAACwJAAAWk4xNGJ0T3B0aW1pemVkQnZoNWJ1aWxkRVAyM2J0U3RyaWRpbmdNZXNoSW50ZXJmYWNlYlJLOWJ0VmVjdG9yM1M0X0UyME5vZGVUcmlhbmdsZUNhbGxiYWNrAAA8DgAABCkAALAkAABaTjE0YnRPcHRpbWl6ZWRCdmg1YnVpbGRFUDIzYnRTdHJpZGluZ01lc2hJbnRlcmZhY2ViUks5YnRWZWN0b3IzUzRfRTI5UXVhbnRpemVkTm9kZVRyaWFuZ2xlQ2FsbGJhY2sAAAAAAMQpAADQAAAA0QAAALIAAAA6AAAAOwAAADwAAADSAAAAtAAAALUAAADTAAAAQAAAAIsAAACMAAAA1AAAANUAAABFAAAA1gAAALoAAAC7AAAA1wAAANgAAAA8DgAAqCoAAJgmAAAAAAAA5CkAANkAAADaAAAA2wAAADwOAADwKQAAYCoAAFpOSzIyYnRCdmhUcmlhbmdsZU1lc2hTaGFwZTE5cHJvY2Vzc0FsbFRyaWFuZ2xlc0VQMThidFRyaWFuZ2xlQ2FsbGJhY2tSSzlidFZlY3RvcjNTNF9FMjFNeU5vZGVPdmVybGFwQ2FsbGJhY2sAAAAUDgAAaCoAADIxYnROb2RlT3ZlcmxhcENhbGxiYWNrAGJ0VHJpYW5nbGVNZXNoU2hhcGVEYXRhAEJWSFRSSUFOR0xFTUVTSAAyMmJ0QnZoVHJpYW5nbGVNZXNoU2hhcGUAAAAAAAAAANgqAADZAAAA3AAAAN0AAAA8DgAA5CoAAGAqAABaTjIyYnRCdmhUcmlhbmdsZU1lc2hTaGFwZTE0cGVyZm9ybVJheWNhc3RFUDE4YnRUcmlhbmdsZUNhbGxiYWNrUks5YnRWZWN0b3IzUzRfRTIxTXlOb2RlT3ZlcmxhcENhbGxiYWNrAAAAAABgKwAA2QAAAN4AAADfAAAAPA4AAGwrAABgKgAAWk4yMmJ0QnZoVHJpYW5nbGVNZXNoU2hhcGUxN3BlcmZvcm1Db252ZXhjYXN0RVAxOGJ0VHJpYW5nbGVDYWxsYmFja1JLOWJ0VmVjdG9yM1M0X1M0X1M0X0UyMU15Tm9kZU92ZXJsYXBDYWxsYmFjawAAAAAAAAAAZCwAADcAAADgAAAA4QAAADoAAAA7AAAAPAAAAOIAAADjAAAAPwAAAOQAAABAAAAAQQAAAEIAAABDAAAARAAAAEUAAADlAAAA5gAAAEgAAADnAAAASgAAAEsAAABMAAAATQAAAOgAAADpAAAA6gAAAOsAAADsAAAA7QAAAO4AAAA8DgAAuywAAJAfAAAAAAAAhCwAAL8AAADvAAAA8AAAADwOAACQLAAAsCQAADI2TG9jYWxTdXBwb3J0VmVydGV4Q2FsbGJhY2sAQ29udmV4VHJpbWVzaAAyNWJ0Q29udmV4VHJpYW5nbGVNZXNoU2hhcGUAAAAAAAAkLQAA8QAAAPIAAADzAAAAOgAAADsAAAA8AAAA9AAAAPUAAAD2AAAA9wAAAEAAAACLAAAAjAAAALcAAAC4AAAARQAAAPgAAAA8DgAANi0AAAgjAABFbXB0eQAxMmJ0RW1wdHlTaGFwZQAAAAAAAAAA0C0AADcAAAD5AAAA+gAAADoAAAA7AAAAPAAAAPsAAAA+AAAAPwAAAPwAAABAAAAAQQAAAEIAAABDAAAARAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAP0AAAD+AAAA/wAAAAABAAABAQAAAgEAAAMBAAAEAQAAPA4AAPktAACQHwAAAQAAAAMAAAAGAAAAYnRCVV9TaW1wbGV4MXRvNAAxNmJ0QlVfU2ltcGxleDF0bzQAAAAAAFwuAAAFAQAABgEAAAcBAAA6AAAAOwAAADwAAAAIAQAACQEAAAoBAAALAQAAQAAAAIsAAACMAAAAtwAAALgAAABFAAAADAEAAA0BAAA8DgAAdC4AAAgjAABIRUlHSFRGSUVMRAAyNWJ0SGVpZ2h0ZmllbGRUZXJyYWluU2hhcGUAU1BIRVJFAAAAAAAA/C4AAGEAAAAOAQAADwEAADoAAAA7AAAAPAAAAD0AAAA+AAAAEAEAABEBAABAAAAAEgEAABMBAABDAAAARAAAAEUAAAAUAQAAFQEAAEgAAAAWAQAASgAAAEsAAABMAAAAPA4AAAgvAACQHgAAMTNidFNwaGVyZVNoYXBlAAAAAABoLwAAkAAAABcBAACSAAAAOgAAADsAAAA8AAAAkwAAAJQAAACVAAAAlgAAAEAAAACXAAAAmAAAAJkAAACaAAAARQAAAJsAAACcAAAAPA4AAH0vAAAkJAAAQ29tcG91bmQATjJjYzE1Y2NDb21wb3VuZFNoYXBlRQA8DgAAoC8AAMQvAAAzMGJ0QWN0aXZhdGluZ0NvbGxpc2lvbkFsZ29yaXRobQAAAAAUDgAAzC8AADIwYnRDb2xsaXNpb25BbGdvcml0aG0AAArXozwAAAAA/C8AABgBAAAZAQAAGgEAADwOAAAIMAAAHDAAADE3YnRHamtQYWlyRGV0ZWN0b3IAFA4AACQwAAAzNmJ0RGlzY3JldGVDb2xsaXNpb25EZXRlY3RvckludGVyZmFjZQAxMmJ0Q29udmV4Q2FzdAAAABQOAABLMAAAAAAAAHgwAAAbAQAAHAEAAB0BAAA8DgAAvzAAAFwwAAAAAAAAoDAAAB4BAAAfAQAAIAEAACEBAAAiAQAAPA4AAKwwAAC0MgAAMTZidFBvaW50Q29sbGVjdG9yADE1YnRHamtDb252ZXhDYXN0AAAAAAAAAADwMAAAHgEAACMBAAAkAQAAJQEAACYBAAA8DgAA/DAAALQyAAAxNmJ0TWFuaWZvbGRSZXN1bHQAAAAAAAAkMQAAJwEAACgBAAApAQAAPA4AAJczAAAEPAAAAAAAAEwxAAAqAQAAKwEAACwBAAAtAQAALgEAADwOAAB9MwAAlC8AAAAAAAB0MQAALwEAADABAAAxAQAAMgEAADMBAAAUDgAAfDEAAE4xMmJ0Q29udmV4Q2FzdDEwQ2FzdFJlc3VsdEUAAAAAAAAAAOwyAAAeAQAANAEAADUBAAA2AQAANwEAAAAAAAAYMgAAHgEAADgBAAA5AQAAOgEAADsBAAAAAAAA8DEAAB4BAAA8AQAAJAEAACUBAAA9AQAAPA4AAPwxAADwMAAAMjRidFBlcnR1cmJlZENvbnRhY3RSZXN1bHQAADwOAAAkMgAAtDIAAFpOMjNidENvbnZleENvbnZleEFsZ29yaXRobTE2cHJvY2Vzc0NvbGxpc2lvbkVQSzI0YnRDb2xsaXNpb25PYmplY3RXcmFwcGVyUzJfUksxNmJ0RGlzcGF0Y2hlckluZm9QMTZidE1hbmlmb2xkUmVzdWx0RTIxYnRXaXRob3V0TWFyZ2luUmVzdWx0AAAAABQOAAC8MgAATjM2YnREaXNjcmV0ZUNvbGxpc2lvbkRldGVjdG9ySW50ZXJmYWNlNlJlc3VsdEUAPA4AAPgyAAC0MgAAWk4yM2J0Q29udmV4Q29udmV4QWxnb3JpdGhtMTZwcm9jZXNzQ29sbGlzaW9uRVBLMjRidENvbGxpc2lvbk9iamVjdFdyYXBwZXJTMl9SSzE2YnREaXNwYXRjaGVySW5mb1AxNmJ0TWFuaWZvbGRSZXN1bHRFMTNidER1bW15UmVzdWx0ADIzYnRDb252ZXhDb252ZXhBbGdvcml0aG0ATjIzYnRDb252ZXhDb252ZXhBbGdvcml0aG0xMENyZWF0ZUZ1bmNFAAAAAAAA1DMAABsBAAA+AQAAPwEAADwOAADgMwAAXDAAADIyYnRTdWJzaW1wbGV4Q29udmV4Q2FzdAAAAAAAAAAABDUAAEABAABBAQAAQgEAAEMBAABEAQAAAAAAACw0AABFAQAARgEAAEcBAAA8DgAA5zQAAIQkAAAAAAAAwDQAADcAAABIAQAASQEAADoAAAA7AAAAPAAAAD0AAAA+AAAASgEAAEsBAABAAAAAQQAAAEIAAABDAAAARAAAAEUAAABGAAAATAEAAEgAAABNAQAASgAAAE4BAABPAQAATQAAAFABAABRAQAAUgEAAFMBAABUAQAAVQEAAFYBAABXAQAAPA4AANU0AABoHwAAVHJpYW5nbGUAMTVidFRyaWFuZ2xlU2hhcGUAMjRidENvbnZleFRyaWFuZ2xlQ2FsbGJhY2sAAAA8DgAAzjUAAJQvAAAAAAAAJDUAALwAAABYAQAAWQEAADwOAAAwNQAAhCQAAFpOMzNidENvbnZleENvbmNhdmVDb2xsaXNpb25BbGdvcml0aG0yMWNhbGN1bGF0ZVRpbWVPZkltcGFjdEVQMTdidENvbGxpc2lvbk9iamVjdFMxX1JLMTZidERpc3BhdGNoZXJJbmZvUDE2YnRNYW5pZm9sZFJlc3VsdEUzMUxvY2FsVHJpYW5nbGVTcGhlcmVDYXN0Q2FsbGJhY2sAMzNidENvbnZleENvbmNhdmVDb2xsaXNpb25BbGdvcml0aG0AAAAAAAAAEDYAAFoBAABbAQAAXAEAAF0BAABeAQAAPA4AAGU2AACULwAAAAAAAEA2AABfAQAAYAEAAGEBAABiAQAAYwEAAGQBAABlAQAAPA4AAEw2AADMIwAAMjJidENvbXBvdW5kTGVhZkNhbGxiYWNrADI4YnRDb21wb3VuZENvbGxpc2lvbkFsZ29yaXRobQAAAAAAoDYAAGYBAABnAQAAaAEAAGkBAABqAQAAFA4AAKg2AAAyM2J0SGFzaGVkU2ltcGxlUGFpckNhY2hlAAAAAAAAAOA2AABrAQAAbAEAAG0BAABuAQAAbwEAADwOAAA9NwAAEDYAAAAAAAAQNwAAXwEAAHABAABxAQAAcgEAAGMBAABkAQAAZQEAADwOAAAcNwAAzCMAADMwYnRDb21wb3VuZENvbXBvdW5kTGVhZkNhbGxiYWNrADM2YnRDb21wb3VuZENvbXBvdW5kQ29sbGlzaW9uQWxnb3JpdGhtAAAAAACANwAAcwEAAHQBAAB1AQAAdgEAAHcBAAA8DgAAjDcAAMQvAAAxNmJ0RW1wdHlBbGdvcml0aG0AAAAAAAC8NwAAeAEAAHkBAAB6AQAAewEAAHwBAAA8DgAAyDcAAJQvAAAzMmJ0U3BoZXJlU3BoZXJlQ29sbGlzaW9uQWxnb3JpdGhtAAAAAAAAADgAABgBAAB9AQAAfgEAADwOAAAMOAAAHDAAADIyU3BoZXJlVHJpYW5nbGVEZXRlY3RvcgAAAAAAAAAARDgAAH8BAACAAQAAgQEAAIIBAACDAQAAPA4AAFA4AACULwAAMzRidFNwaGVyZVRyaWFuZ2xlQ29sbGlzaW9uQWxnb3JpdGhtAAAAAAAAAACMOAAAGAEAAIQBAACFAQAAPA4AAJg4AAAcMAAAMTZidEJveEJveERldGVjdG9yAAAAAAAAyDgAAIYBAACHAQAAiAEAAIkBAACKAQAAPA4AANQ4AACULwAAMjZidEJveEJveENvbGxpc2lvbkFsZ29yaXRobQAAAAAAAAAAEDkAAIsBAACMAQAAjQEAAI4BAACPAQAAPA4AABw5AADELwAAMzFidENvbnZleFBsYW5lQ29sbGlzaW9uQWxnb3JpdGhtAAAAAQAAAAIAAAAAAAAAAgAAAAAAAAABAAAAAAAAAGw5AACQAQAAkQEAAJIBAAA8DgAAeDkAAJw5AAAzMGJ0R2prRXBhUGVuZXRyYXRpb25EZXB0aFNvbHZlcgAAAAAUDgAApDkAADMwYnRDb252ZXhQZW5ldHJhdGlvbkRlcHRoU29sdmVyAAAAAAAAAADkOQAAHgEAAJMBAACUAQAAlQEAAJYBAAA8DgAA8DkAALQyAABaTjMzYnRNaW5rb3dza2lQZW5ldHJhdGlvbkRlcHRoU29sdmVyMTJjYWxjUGVuRGVwdGhFUjIyYnRWb3Jvbm9pU2ltcGxleFNvbHZlclBLMTNidENvbnZleFNoYXBlUzRfUksxMWJ0VHJhbnNmb3JtUzdfUjlidFZlY3RvcjNTOV9TOV9QMTJidElEZWJ1Z0RyYXdFMjBidEludGVybWVkaWF0ZVJlc3VsdAAAAAAAALA6AACQAQAAlwEAAJgBAAA8DgAAvDoAAJw5AAAzM2J0TWlua293c2tpUGVuZXRyYXRpb25EZXB0aFNvbHZlcgAAAAAAYD4AAJkBAACaAQAAmwEAAJwBAACdAQAAngEAAAAAAAAgPgAAnwEAAKABAAChAQAAAAAAANg9AACfAQAAogEAAKMBAAAAAAAAnD0AAJ8BAACkAQAApQEAAAAAAABYPQAAnwEAAKYBAACnAQAAAAAAABg9AACfAQAAqAEAAKkBAAAAAAAA6DwAAJ8BAACqAQAAqwEAAAAAAACoPAAAnwEAAKwBAACtAQAAAAAAAGg8AACfAQAArgEAAK8BAAAAAAAAMDwAAJ8BAACwAQAAsQEAAAAAAADIOwAAnwEAALIBAACzAQAAPA4AANQ7AAAEPAAATjMxYnRDb252ZXhQbGFuZUNvbGxpc2lvbkFsZ29yaXRobTEwQ3JlYXRlRnVuY0UAFA4AAAw8AAAzMGJ0Q29sbGlzaW9uQWxnb3JpdGhtQ3JlYXRlRnVuYwAAAAA8DgAAPDwAAAQ8AABOMjZidEJveEJveENvbGxpc2lvbkFsZ29yaXRobTEwQ3JlYXRlRnVuY0UAADwOAAB0PAAABDwAAE4zNGJ0U3BoZXJlVHJpYW5nbGVDb2xsaXNpb25BbGdvcml0aG0xMENyZWF0ZUZ1bmNFAAA8DgAAtDwAAAQ8AABOMzJidFNwaGVyZVNwaGVyZUNvbGxpc2lvbkFsZ29yaXRobTEwQ3JlYXRlRnVuY0UAAAAAPA4AAPQ8AAAEPAAATjE2YnRFbXB0eUFsZ29yaXRobTEwQ3JlYXRlRnVuY0UAAAAAPA4AACQ9AAAEPAAATjI4YnRDb21wb3VuZENvbGxpc2lvbkFsZ29yaXRobTE3U3dhcHBlZENyZWF0ZUZ1bmNFADwOAABkPQAABDwAAE4zNmJ0Q29tcG91bmRDb21wb3VuZENvbGxpc2lvbkFsZ29yaXRobTEwQ3JlYXRlRnVuY0UAAAAAPA4AAKg9AAAEPAAATjI4YnRDb21wb3VuZENvbGxpc2lvbkFsZ29yaXRobTEwQ3JlYXRlRnVuY0UAAAAAPA4AAOQ9AAAEPAAATjMzYnRDb252ZXhDb25jYXZlQ29sbGlzaW9uQWxnb3JpdGhtMTdTd2FwcGVkQ3JlYXRlRnVuY0UAAAAAPA4AACw+AAAEPAAATjMzYnRDb252ZXhDb25jYXZlQ29sbGlzaW9uQWxnb3JpdGhtMTBDcmVhdGVGdW5jRQAAADwOAABsPgAAkD4AADMxYnREZWZhdWx0Q29sbGlzaW9uQ29uZmlndXJhdGlvbgAAABQOAACYPgAAMjRidENvbGxpc2lvbkNvbmZpZ3VyYXRpb24AMTJidERpc3BhdGNoZXIAAAAUDgAAsz4AAAAAAAAUPwAAtAEAALUBAAC2AQAAtwEAALgBAAC5AQAAugEAALsBAAC8AQAAvQEAAL4BAAC/AQAAwAEAAMEBAADCAQAAwwEAADwOAAB4PwAAxD4AAAAAAAA0PwAAxAEAAMUBAADGAQAAPA4AAEA/AABcPwAAMjNidENvbGxpc2lvblBhaXJDYWxsYmFjawAAABQOAABkPwAAMTdidE92ZXJsYXBDYWxsYmFjawAyMWJ0Q29sbGlzaW9uRGlzcGF0Y2hlcgAAAAAA3D8AAMcBAADIAQAAyQEAAMoBAADLAQAAzAEAAM0BAADOAQAAzwEAANABAADRAQAA0gEAANMBAADUAQAA1QEAANYBAADXAQAAPA4AABlBAAA4QQAAAAAAAPw/AADEAQAA2AEAANkBAAA8DgAACEAAAFw/AABaTjI4YnRIYXNoZWRPdmVybGFwcGluZ1BhaXJDYWNoZTE5Y2xlYW5Qcm94eUZyb21QYWlyc0VQMTdidEJyb2FkcGhhc2VQcm94eVAxMmJ0RGlzcGF0Y2hlckUxN0NsZWFuUGFpckNhbGxiYWNrAAAAAAAAAIxAAADEAQAA2gEAANsBAAA8DgAAmEAAAFw/AABaTjI4YnRIYXNoZWRPdmVybGFwcGluZ1BhaXJDYWNoZTM3cmVtb3ZlT3ZlcmxhcHBpbmdQYWlyc0NvbnRhaW5pbmdQcm94eUVQMTdidEJyb2FkcGhhc2VQcm94eVAxMmJ0RGlzcGF0Y2hlckUxOFJlbW92ZVBhaXJDYWxsYmFjawAyOGJ0SGFzaGVkT3ZlcmxhcHBpbmdQYWlyQ2FjaGUAPA4AAERBAABgQQAAMjJidE92ZXJsYXBwaW5nUGFpckNhY2hlAAAAABQOAABoQQAAMjVidE92ZXJsYXBwaW5nUGFpckNhbGxiYWNrAAAAAADEQQAA3AEAAN0BAADeAQAA3wEAAOABAADhAQAA4gEAAOMBAADkAQAA5QEAAOYBAADnAQAA6AEAAOkBAAA8DgAApkIAALxCAAAAAAAA9EEAAF8BAADqAQAA6wEAAOwBAABjAQAAZAEAAGUBAAA8DgAAAEIAAMwjAAAxOGJ0RGJ2dFRyZWVDb2xsaWRlcgAAAAAAAAAAPEIAAF8BAADtAQAAYQEAAO4BAABjAQAAZAEAAGUBAAA8DgAASEIAAMwjAAAyMEJyb2FkcGhhc2VBYWJiVGVzdGVyAAAAAAAAhEIAAF8BAADvAQAAYQEAAPABAABjAQAAZAEAAGUBAAA8DgAAkEIAAMwjAAAxOUJyb2FkcGhhc2VSYXlUZXN0ZXIAMTZidERidnRCcm9hZHBoYXNlAAAAABQOAADEQgAAMjFidEJyb2FkcGhhc2VJbnRlcmZhY2UAAAAAAABDAADxAQAA8gEAADAAAAAxAAAA8wEAAPQBAAD1AQAAPA4AACFDAAAMHgAAYnRSaWdpZEJvZHlGbG9hdERhdGEAMTFidFJpZ2lkQm9keQAAAAAAAGxDAAD2AQAA9wEAAPgBAAD5AQAA+gEAAPsBAAD8AQAA/QEAAP4BAAD/AQAAAAIAAAECAAACAgAAPA4AAHhDAACgQwAAMzVidFNlcXVlbnRpYWxJbXB1bHNlQ29uc3RyYWludFNvbHZlcgAAABQOAACoQwAAMThidENvbnN0cmFpbnRTb2x2ZXIAAAAAAAAAANRDAAAbAQAAAwIAAAQCAAA8DgAA4EMAAFwwAAAyN2J0Q29udGludW91c0NvbnZleENvbGxpc2lvbgAAADwOAAAMRAAAhCQAADI1YnRUcmlhbmdsZVJheWNhc3RDYWxsYmFjawAAAAAAQEQAALwAAAAFAgAABgIAACYAAAA8DgAATEQAAIQkAAAyOGJ0VHJpYW5nbGVDb252ZXhjYXN0Q2FsbGJhY2sAAAAAAACoRAAABwIAAAgCAAAJAgAACgIAAAsCAAAMAgAADQIAAA4CAAAPAgAAEAIAABECAAASAgAAEwIAABQOAABnSAAAAAAAAMREAAAUAgAAFQIAABYCAAA8DgAA40YAAPxGAAAAAAAAREYAALwAAAAXAgAAGAIAABkCAAAAAAAAuEUAAF8BAAAaAgAAYQEAABsCAABjAQAAZAEAAGUBAAAAAAAAJEUAACAAAAAcAgAAHQIAAB4CAAA8DgAAMEUAALAcAABaTjE2YnRDb2xsaXNpb25Xb3JsZDIxcmF5VGVzdFNpbmdsZUludGVybmFsRVJLMTFidFRyYW5zZm9ybVMyX1BLMjRidENvbGxpc2lvbk9iamVjdFdyYXBwZXJSTlNfMTdSYXlSZXN1bHRDYWxsYmFja0VFMTVMb2NhbEluZm9BZGRlcjIAAAAAPA4AAMRFAADMIwAAWk4xNmJ0Q29sbGlzaW9uV29ybGQyMXJheVRlc3RTaW5nbGVJbnRlcm5hbEVSSzExYnRUcmFuc2Zvcm1TMl9QSzI0YnRDb2xsaXNpb25PYmplY3RXcmFwcGVyUk5TXzE3UmF5UmVzdWx0Q2FsbGJhY2tFRTlSYXlUZXN0ZXIAAAA8DgAAUEYAAABEAABaTjE2YnRDb2xsaXNpb25Xb3JsZDIxcmF5VGVzdFNpbmdsZUludGVybmFsRVJLMTFidFRyYW5zZm9ybVMyX1BLMjRidENvbGxpc2lvbk9iamVjdFdyYXBwZXJSTlNfMTdSYXlSZXN1bHRDYWxsYmFja0VFMjlCcmlkZ2VUcmlhbmdsZVJheWNhc3RDYWxsYmFjawAxOWJ0U2luZ2xlUmF5Q2FsbGJhY2sAAAAAPA4AAAhHAAAkRwAAMjNidEJyb2FkcGhhc2VSYXlDYWxsYmFjawAAABQOAAAsRwAAMjRidEJyb2FkcGhhc2VBYWJiQ2FsbGJhY2sAAAAAAAB0RwAAHwIAACACAAAhAgAAIgIAAPz///90RwAAIwIAACQCAAAlAgAAmA4AAJRHAAAAAAAAAgAAAIQkAAACAAAAsCQAAAIEAAAxN0RlYnVnRHJhd2NhbGxiYWNrAE92ZXJmbG93IGluIEFBQkIsIG9iamVjdCByZW1vdmVkIGZyb20gc2ltdWxhdGlvbgBJZiB5b3UgY2FuIHJlcHJvZHVjZSB0aGlzLCBwbGVhc2UgZW1haWwgYnVnc0Bjb250aW51b3VzcGh5c2ljcy5jb20KAFBsZWFzZSBpbmNsdWRlIGFib3ZlIGluZm9ybWF0aW9uLCB5b3VyIFBsYXRmb3JtLCB2ZXJzaW9uIG9mIE9TLgoAVGhhbmtzLgoAMTZidENvbGxpc2lvbldvcmxkAAAAAAAAAHxLAAC8AAAAJgIAAAYCAAAnAgAAAAAAALxKAAC8AAAAKAIAAAYCAAApAgAAAAAAAAhKAABfAQAAKgIAAGEBAAArAgAAYwEAAGQBAABlAQAAAAAAAOhIAAAsAgAALQIAAC4CAAAvAgAAPA4AAPRIAADUSQAAWlpOMTZidENvbGxpc2lvbldvcmxkMjVvYmplY3RRdWVyeVNpbmdsZUludGVybmFsRVBLMTNidENvbnZleFNoYXBlUksxMWJ0VHJhbnNmb3JtUzVfUEsyNGJ0Q29sbGlzaW9uT2JqZWN0V3JhcHBlclJOU18yMENvbnZleFJlc3VsdENhbGxiYWNrRWZFTjIyYnRDb21wb3VuZExlYWZDYWxsYmFjazEyUHJvY2Vzc0NoaWxkRWlTNV9QSzE2YnRDb2xsaXNpb25TaGFwZUUxNExvY2FsSW5mb0FkZGVyAAAUDgAA3EkAAE4xNmJ0Q29sbGlzaW9uV29ybGQyMENvbnZleFJlc3VsdENhbGxiYWNrRQAAPA4AABRKAADMIwAAWk4xNmJ0Q29sbGlzaW9uV29ybGQyNW9iamVjdFF1ZXJ5U2luZ2xlSW50ZXJuYWxFUEsxM2J0Q29udmV4U2hhcGVSSzExYnRUcmFuc2Zvcm1TNV9QSzI0YnRDb2xsaXNpb25PYmplY3RXcmFwcGVyUk5TXzIwQ29udmV4UmVzdWx0Q2FsbGJhY2tFZkUyMmJ0Q29tcG91bmRMZWFmQ2FsbGJhY2sAAAAAPA4AAMhKAABARAAAWk4xNmJ0Q29sbGlzaW9uV29ybGQyNW9iamVjdFF1ZXJ5U2luZ2xlSW50ZXJuYWxFUEsxM2J0Q29udmV4U2hhcGVSSzExYnRUcmFuc2Zvcm1TNV9QSzI0YnRDb2xsaXNpb25PYmplY3RXcmFwcGVyUk5TXzIwQ29udmV4UmVzdWx0Q2FsbGJhY2tFZkUzMkJyaWRnZVRyaWFuZ2xlQ29udmV4Y2FzdENhbGxiYWNrXzAAAAAAPA4AAIhLAABARAAAWk4xNmJ0Q29sbGlzaW9uV29ybGQyNW9iamVjdFF1ZXJ5U2luZ2xlSW50ZXJuYWxFUEsxM2J0Q29udmV4U2hhcGVSSzExYnRUcmFuc2Zvcm1TNV9QSzI0YnRDb2xsaXNpb25PYmplY3RXcmFwcGVyUk5TXzIwQ29udmV4UmVzdWx0Q2FsbGJhY2tFZkUzMkJyaWRnZVRyaWFuZ2xlQ29udmV4Y2FzdENhbGxiYWNrAAAAAAAATEwAABQCAAAwAgAAMQIAADwOAABYTAAA/EYAADIxYnRTaW5nbGVTd2VlcENhbGxiYWNrAAAAAACITAAAMgIAADMCAAA0AgAANQIAABQOAACQTAAAMjVidFNpbXVsYXRpb25Jc2xhbmRNYW5hZ2VyAAAAAADgTAAANgIAADcCAAA4AgAAOQIAACYAAAAmAAAAOgIAACYAAAAmAAAAOwIAADwCAACYDgAAE00AAAAAAAABAAAAKE0AAAIEAABidFR5cGVkQ29uc3RyYWludEZsb2F0RGF0YQAxN2J0VHlwZWRDb25zdHJhaW50AAAUDgAAME0AADEzYnRUeXBlZE9iamVjdAAAAAAAfE4AAD0CAAA+AgAACQIAAAoCAAALAgAADAIAAD8CAAAOAgAADwIAAEACAABBAgAAEgIAAEICAABDAgAARAIAAEUCAABGAgAARwIAAEgCAABJAgAASgIAAEsCAABMAgAATQIAAE4CAABPAgAAUAIAAFECAABSAgAAUwIAAFQCAABVAgAAVgIAAFcCAABYAgAAWQIAAFoCAABbAgAAXAIAAF0CAABeAgAAXwIAAGACAABhAgAAYgIAAGMCAABkAgAAAAAAABhOAABlAgAAZgIAAGcCAAA8DgAAJE4AAEROAAAyN0lucGxhY2VTb2x2ZXJJc2xhbmRDYWxsYmFjawAAABQOAABMTgAATjI1YnRTaW11bGF0aW9uSXNsYW5kTWFuYWdlcjE0SXNsYW5kQ2FsbGJhY2tFAAAAPA4AAOpOAAAETwAAAAAAAKBOAAAsAgAAaAIAAGkCAABqAgAAPA4AAKxOAACoUAAAMzRidENsb3Nlc3ROb3RNZUNvbnZleFJlc3VsdENhbGxiYWNrAGJ0RHluYW1pY3NXb3JsZEZsb2F0RGF0YQAyM2J0RGlzY3JldGVEeW5hbWljc1dvcmxkADwOAAAQTwAAqEQAADE1YnREeW5hbWljc1dvcmxkAAAAAAAAAExQAABrAgAAbAIAAAkCAAAKAgAACwIAAAwCAAA/AgAADgIAAA8CAABAAgAAQQIAABICAABCAgAAQwIAAEQCAABFAgAARgIAAEcCAABIAgAASQIAAEoCAABLAgAATAIAAE0CAABOAgAATwIAAFACAABRAgAAUgIAAFMCAABUAgAAVQIAAFYCAABXAgAAWAIAAFkCAABaAgAAWwIAAFwCAABdAgAAXgIAAG0CAABgAgAAYQIAAG4CAABjAgAAZAIAAAAAAAD8TwAAbwIAAHACAABxAgAAPA4AAAhQAAAoUAAATjJjYzIzY2NPdmVybGFwRmlsdGVyQ2FsbGJhY2tFAAAUDgAAMFAAADIzYnRPdmVybGFwRmlsdGVyQ2FsbGJhY2sAAAA8DgAA5lAAAHxOAAAAAAAAcFAAACwCAAByAgAAcwIAAHQCAAA8DgAAfFAAAKhQAABOMmNjMzRjY05vdE1lQ2xvc2VzdENvbnZleFJlc3VsdENhbGxiYWNrRQAAADwOAAC0UAAA1EkAAE4xNmJ0Q29sbGlzaW9uV29ybGQyN0Nsb3Nlc3RDb252ZXhSZXN1bHRDYWxsYmFja0UATjJjYzIzY2NEaXNjcmV0ZUR5bmFtaWNzV29ybGRFAAAAAAAAAABAUQAANgIAAHUCAAB2AgAAOQIAAHcCAAB4AgAAOgIAAHkCAAB6AgAAewIAAHwCAAB9AgAAPA4AAGdRAADgTAAAYnRIaW5nZUNvbnN0cmFpbnRGbG9hdERhdGEAMTdidEhpbmdlQ29uc3RyYWludAAAAAAAALRRAAA2AgAAfgIAAH8CAAA5AgAAgAIAAIECAAA6AgAAggIAAIMCAACEAgAAhQIAAIYCAAA8DgAA4VEAAOBMAABidFBvaW50MlBvaW50Q29uc3RyYWludEZsb2F0RGF0YQAyM2J0UG9pbnQyUG9pbnRDb25zdHJhaW50AAAAAAAAFFIAAIcCAACIAgAAiQIAAIoCAAA8DgAAIFIAADhSAABOMmNjMTNjY01vdGlvblN0YXRlRQAAAAAUDgAAQFIAADEzYnRNb3Rpb25TdGF0ZQA="),c1(t1,21072,"BQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAwAAAMxVAAAAAAAAAAAAAAAAAAACAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="),c1(t1,21184,"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=");var n1=[null,function(A){var f=0,f=0;return (A=0|i(T2[(A|=0)+56>>2]))&&(T2[5420]=A,f=-1),0|f;},function(A,f,r){A|=0,f|=0;var e,i=0,a=0,n=0,o=0,b=0;T2[12+(L2=i=L2-16|0)>>2]=r|=0,T2[8+i>>2]=f,f=T2[A+24>>2],T2[i>>2]=f,f=T2[A+20>>2]-f|0,T2[4+i>>2]=f;A:{if((0|(a=s(T2[A+56>>(o=2)],i,2)))!=(0|(b=f+r|0)))for(f=i;;){if((0|a)<=-1){if(T2[A+24>>2]=0,T2[A+16>>2]=0,T2[A+20>>2]=0,T2[A>>2]=32|T2[A>>2],2==((A=0)|o))break A;A=r-T2[f+4>>2]|0;break A;}if(n=T2[f+4>>2],T2[(f=(e=n>>>0<a>>>0)?f+8|0:f)>>2]=(n=a-(e?n:0)|0)+T2[f>>2],T2[f+4>>2]=T2[f+4>>2]-n,(0|(b=b-a|0))==(0|(a=s(T2[A+56>>2],f,o=o-e|0))))break;}f=T2[A+40>>2],T2[A+24>>2]=f,T2[A+20>>2]=f,T2[A+16>>2]=f+T2[A+44>>2],A=r;}return L2=16+i|0,0|A;},function(A,f,r,e){var i=0;return L2=i=L2-16|0,A=(A=0|o(T2[(A|=0)+56>>2],0|(f|=0),0|(r|=0),255&(e|=0),8+i|0))?(T2[5420]=76==(0|A)?70:A,f=-1):(f=T2[12+i>>2],T2[8+i>>2]),L2=16+i|0,z=f,0|A;},g,w,w,function(A){var f=0;T2[12+(L2=f=L2-16|0)>>2]=A|=0,g(A=T2[12+f>>2]),u(A),L2=16+f|0;},Q,Q,function(A,f,r){f|=0,r|=0;var e,i=0;if(T2[72+(L2=i=L2-80|0)>>2]=A|=0,T2[68+i>>2]=f,T2[64+i>>2]=r,1&C(f=T2[72+i>>2],T2[68+i>>2],0))p2[79+i|0]=1;else {if(r=T2[68+(e=i)>>2]){if(T2[(L2=A=L2-96|0)+92>>2]=r,T2[A+88>>2]=3536,T2[A+84>>2]=3584,T2[A+80>>2]=0,T2[A+76>>2]=T2[T2[A+92>>2]>>2],T2[A+72>>2]=T2[T2[A+76>>2]-8>>2],T2[A+68>>2]=T2[A+92>>2]+T2[A+72>>2],T2[A+64>>2]=T2[T2[A+76>>2]-4>>2],T2[A+60>>2]=0,T2[A>>2]=T2[A+84>>2],T2[A+4>>2]=T2[A+92>>2],T2[A+8>>2]=T2[A+88>>2],T2[A+12>>2]=T2[A+80>>2],T2[A+16>>2]=0,T2[A+20>>2]=0,T2[A+24>>2]=0,T2[A+28>>2]=0,T2[A+32>>2]=0,T2[A+36>>2]=0,T2[A+40>>2]=0,T2[A+44>>2]=0,T2[A+48>>2]=0,p2[A+52|0]=0,p2[A+53|0]=0,p2[A+54|0]=0,1&C(T2[A+64>>2],T2[A+84>>2],0))T2[A+48>>2]=1,r=T2[A+64>>2],n1[T2[T2[r>>2]+20>>2]](r,A,T2[A+68>>2],T2[A+68>>2],1,0),1==T2[A+24>>2]&&(T2[A+60>>2]=T2[A+68>>2]);else if(r=T2[A+64>>2],n1[T2[T2[r>>2]+24>>2]](r,A,T2[A+68>>2],1,0),!(1<(r=T2[A+36>>2])>>>0))if(1==(0|r))A:{if(1!=T2[A+24>>2]){if(T2[A+40>>2])break A;if(1!=T2[A+28>>2])break A;if(1!=T2[A+32>>2])break A;}T2[A+60>>2]=T2[A+16>>2];}else 1==T2[A+40>>2]&&1==T2[A+28>>2]&&1==T2[A+32>>2]&&(T2[A+60>>2]=T2[A+20>>2]);L2=A+96|0,A=T2[A+60>>2];}else A=0;T2[60+e>>2]=A,T2[60+i>>2]?(T2[i>>2]=T2[60+i>>2],T2[4+i>>2]=0,T2[8+i>>2]=f,T2[12+i>>2]=-1,T2[16+i>>2]=0,T2[20+i>>2]=0,T2[24+i>>2]=0,T2[28+i>>2]=0,T2[32+i>>2]=0,T2[36+i>>2]=0,T2[40+i>>2]=0,T2[44+i>>2]=0,T2[48+i>>2]=0,p2[52+i|0]=0,p2[53+i|0]=0,p2[54+i|0]=0,T2[48+i>>2]=1,A=T2[60+i>>2],n1[T2[T2[A>>2]+28>>2]](A,i,T2[T2[64+i>>2]>>2],1),1!=T2[24+i>>2]?p2[79+i|0]=0:(T2[T2[64+i>>2]>>2]=T2[16+i>>2],p2[79+i|0]=1)):p2[79+i|0]=0;}return L2=80+i|0,1&p2[79+i|0];},function(A,f,r,e,i,a){f|=0,r|=0,e|=0,i|=0,a|=0;var n=0;T2[28+(L2=n=L2-32|0)>>2]=A|=0,T2[24+n>>2]=f,T2[20+n>>2]=r,T2[16+n>>2]=e,T2[12+n>>2]=i,p2[11+n|0]=a,1&C(A=T2[28+n>>2],T2[T2[24+n>>2]+8>>2],1&p2[11+n|0])&&h(A,T2[24+n>>2],T2[20+n>>2],T2[16+n>>2],T2[12+n>>2]),L2=32+n|0;},function(A,f,r,e,i){f|=0,r|=0,e|=0,i|=0;var a=0;T2[28+(L2=a=L2-32|0)>>2]=A|=0,T2[24+a>>2]=f,T2[20+a>>2]=r,T2[16+a>>2]=e,p2[15+a|0]=i,1&C(A=T2[28+a>>2],T2[T2[24+a>>2]+8>>2],1&p2[15+a|0])?Z(A,T2[24+a>>2],T2[20+a>>2],T2[16+a>>2]):1&C(A,T2[T2[24+a>>2]>>2],1&p2[15+a|0])&&(T2[20+a>>2]!=T2[T2[24+a>>2]+20>>2]&&T2[20+a>>2]!=T2[T2[24+a>>2]+16>>2]?(T2[T2[24+a>>2]+32>>2]=T2[16+a>>2],T2[T2[24+a>>2]+20>>2]=T2[20+a>>2],A=T2[24+a>>2],T2[A+40>>2]=T2[A+40>>2]+1,1==T2[T2[24+a>>2]+36>>2]&&2==T2[T2[24+a>>2]+24>>2]&&(p2[T2[24+a>>2]+54|0]=1),T2[T2[24+a>>2]+44>>2]=4):1==T2[16+a>>2]&&(T2[T2[24+a>>2]+32>>2]=1)),L2=32+a|0;},function(A,f,r,e){f|=0,r|=0,e|=0;var i=0;T2[12+(L2=i=L2-16|0)>>2]=A|=0,T2[8+i>>2]=f,T2[4+i>>2]=r,T2[i>>2]=e,1&C(A=T2[12+i>>2],T2[T2[8+i>>2]+8>>2],0)&&E(A,T2[8+i>>2],T2[4+i>>2],T2[i>>2]),L2=16+i|0;},G,function(A,f,r,e,i,a){f|=0,r|=0,e|=0,i|=0,a|=0;var n=0;T2[28+(L2=n=L2-32|0)>>2]=A|=0,T2[24+n>>2]=f,T2[20+n>>2]=r,T2[16+n>>2]=e,T2[12+n>>2]=i,p2[11+n|0]=a,1&C(A=T2[28+n>>2],T2[T2[24+n>>2]+8>>2],1&p2[11+n|0])?h(A,T2[24+n>>2],T2[20+n>>2],T2[16+n>>2],T2[12+n>>2]):(A=T2[A+8>>2],n1[T2[T2[A>>2]+20>>2]](A,T2[24+n>>2],T2[20+n>>2],T2[16+n>>2],T2[12+n>>2],1&p2[11+n|0])),L2=32+n|0;},function(A,f,r,e,i){f|=0,r|=0,e|=0,i|=0;var a=0;T2[28+(L2=a=L2-32|0)>>2]=A|=0,T2[24+a>>2]=f,T2[20+a>>2]=r,T2[16+a>>2]=e,p2[15+a|0]=i,1&C(A=T2[28+a>>2],T2[T2[24+a>>2]+8>>2],1&p2[15+a|0])?Z(A,T2[24+a>>2],T2[20+a>>2],T2[16+a>>2]):1&C(A,T2[T2[24+a>>2]>>2],1&p2[15+a|0])?T2[20+a>>2]!=T2[T2[24+a>>2]+20>>2]&&T2[20+a>>2]!=T2[T2[24+a>>2]+16>>2]?(T2[T2[24+a>>2]+32>>2]=T2[16+a>>2],p2[14+a|0]=0,4!=T2[T2[24+a>>2]+44>>2]&&(p2[13+a|0]=0,p2[T2[24+a>>2]+52|0]=0,p2[T2[24+a>>2]+53|0]=0,A=T2[A+8>>2],n1[T2[T2[A>>2]+20>>2]](A,T2[24+a>>2],T2[20+a>>2],T2[20+a>>2],1,1&p2[15+a|0]),1&p2[T2[24+a>>2]+53|0]&&(p2[13+a|0]=1)&p2[T2[24+a>>2]+52|0]&&(p2[14+a|0]=1),1&p2[13+a|0]?T2[T2[24+a>>2]+44>>2]=3:T2[T2[24+a>>2]+44>>2]=4),1&p2[14+a|0]||(T2[T2[24+a>>2]+20>>2]=T2[20+a>>2],A=T2[24+a>>2],T2[A+40>>2]=T2[A+40>>2]+1,1==T2[T2[24+a>>2]+36>>2]&&2==T2[T2[24+a>>2]+24>>2]&&(p2[T2[24+a>>2]+54|0]=1))):1==T2[16+a>>2]&&(T2[T2[24+a>>2]+32>>2]=1):(A=T2[A+8>>2],n1[T2[T2[A>>2]+24>>2]](A,T2[24+a>>2],T2[20+a>>2],T2[16+a>>2],1&p2[15+a|0])),L2=32+a|0;},function(A,f,r,e){f|=0,r|=0,e|=0;var i=0;T2[12+(L2=i=L2-16|0)>>2]=A|=0,T2[8+i>>2]=f,T2[4+i>>2]=r,T2[i>>2]=e,1&C(A=T2[12+i>>2],T2[T2[8+i>>2]+8>>2],0)?E(A,T2[8+i>>2],T2[4+i>>2],T2[i>>2]):(A=T2[A+8>>2],n1[T2[T2[A>>2]+28>>2]](A,T2[8+i>>2],T2[4+i>>2],T2[i>>2])),L2=16+i|0;},G,function(A,f,r,e,i,a){f|=0,r|=0,e|=0,i|=0,a|=0;var n=0;if(T2[28+(L2=n=L2-32|0)>>2]=A|=0,T2[24+n>>2]=f,T2[20+n>>2]=r,T2[16+n>>2]=e,T2[12+n>>2]=i,p2[11+n|0]=a,1&C(A=T2[28+n>>2],T2[T2[24+n>>2]+8>>2],1&p2[11+n|0]))h(A,T2[24+n>>2],T2[20+n>>2],T2[16+n>>2],T2[12+n>>2]);else {if(p2[10+n|0]=1&p2[T2[24+n>>2]+52|0],p2[9+n|0]=1&p2[T2[24+n>>2]+53|0],T2[4+n>>2]=(A+16|0)+(T2[A+12>>2]<<3),T2[n>>2]=A+16,p2[T2[24+n>>2]+52|0]=0,p2[T2[24+n>>2]+53|0]=0,Y(T2[n>>2],T2[24+n>>2],T2[20+n>>2],T2[16+n>>2],T2[12+n>>2],1&p2[11+n|0]),p2[10+n|0]=1&p2[T2[24+n>>2]+52|0]|1&p2[10+n|0],p2[9+n|0]=1&p2[T2[24+n>>2]+53|0]|1&p2[9+n|0],f=T2[n>>2]+8|0,(T2[n>>2]=f)>>>0<T[4+n>>2])for(;;){A:if(!(1&p2[T2[24+n>>2]+54|0])){if(1&p2[T2[24+n>>2]+52|0]){if(1==T2[T2[24+n>>2]+24>>2])break A;if(!(2&T2[A+8>>2]))break A;}else if(!(1&T2[A+8>>2])&&1&p2[T2[24+n>>2]+53|0])break A;if(p2[T2[24+n>>2]+52|0]=0,p2[T2[24+n>>2]+53|0]=0,Y(T2[n>>2],T2[24+n>>2],T2[20+n>>2],T2[16+n>>2],T2[12+n>>2],1&p2[11+n|0]),p2[10+n|0]=1&p2[T2[24+n>>2]+52|0]|1&p2[10+n|0],p2[9+n|0]=1&p2[T2[24+n>>2]+53|0]|1&p2[9+n|0],f=T2[n>>2]+8|0,(T2[n>>2]=f)>>>0<T[4+n>>2])continue;}break;}p2[T2[24+n>>2]+52|0]=1&p2[10+n|0],p2[T2[24+n>>2]+53|0]=1&p2[9+n|0];}L2=32+n|0;},function(A,f,r,e,i){f|=0,r|=0,e|=0,i|=0;var a=0;if(T2[44+(L2=a=L2-48|0)>>2]=A|=0,T2[40+a>>2]=f,T2[36+a>>2]=r,T2[32+a>>2]=e,p2[31+a|0]=i,1&C(A=T2[44+a>>2],T2[T2[40+a>>2]+8>>2],1&p2[31+a|0]))Z(A,T2[40+a>>2],T2[36+a>>2],T2[32+a>>2]);else if(1&C(A,T2[T2[40+a>>2]>>2],1&p2[31+a|0])){if(T2[36+a>>2]!=T2[T2[40+a>>2]+20>>2]&&T2[36+a>>2]!=T2[T2[40+a>>2]+16>>2]){if(T2[T2[40+a>>2]+32>>2]=T2[32+a>>2],p2[30+a|0]=0,4!=T2[T2[40+a>>2]+44>>2]){for(p2[29+a|0]=0,T2[24+a>>2]=(A+16|0)+(T2[A+12>>2]<<3),T2[20+a>>2]=A+16;;){A:if(!(T[20+a>>2]>=T[24+a>>2]||(p2[T2[40+a>>2]+52|0]=0,p2[T2[40+a>>2]+53|0]=0,Y(T2[20+a>>2],T2[40+a>>2],T2[36+a>>2],T2[36+a>>2],1,1&p2[31+a|0]),1&p2[T2[40+a>>2]+54|0]))){if(1&p2[T2[40+a>>2]+53|0])if((p2[29+a|0]=1)&p2[T2[40+a>>2]+52|0]){if((p2[30+a|0]=1)==T2[T2[40+a>>2]+24>>2])break A;if(!(2&T2[A+8>>2]))break A;}else if(!(1&T2[A+8>>2]))break A;T2[20+a>>2]=T2[20+a>>2]+8;continue;}break;}1&p2[29+a|0]?T2[T2[40+a>>2]+44>>2]=3:T2[T2[40+a>>2]+44>>2]=4;}1&p2[30+a|0]||(T2[T2[40+a>>2]+20>>2]=T2[36+a>>2],A=T2[40+a>>2],T2[A+40>>2]=T2[A+40>>2]+1,1==T2[T2[40+a>>2]+36>>2]&&2==T2[T2[40+a>>2]+24>>2]&&(p2[T2[40+a>>2]+54|0]=1));}else 1==T2[32+a>>2]&&(T2[T2[40+a>>2]+32>>2]=1);}else if(T2[16+a>>2]=(A+16|0)+(T2[A+12>>2]<<3),T2[12+a>>2]=A+16,F(T2[12+a>>2],T2[40+a>>2],T2[36+a>>2],T2[32+a>>2],1&p2[31+a|0]),f=T2[12+a>>2]+8|0,(T2[12+a>>2]=f)>>>0<T[16+a>>2])if(1==T2[T2[40+a>>2]+36>>2]||2&T2[A+8>>2])for(;!(1&p2[T2[40+a>>2]+54|0])&&(F(T2[12+a>>2],T2[40+a>>2],T2[36+a>>2],T2[32+a>>2],1&p2[31+a|0]),A=T2[12+a>>2]+8|0,(T2[12+a>>2]=A)>>>0<T[16+a>>2]););else if(1&T2[A+8>>2])for(;!(1&p2[T2[40+a>>2]+54|0]||1==T2[T2[40+a>>2]+36>>2]&&1==T2[T2[40+a>>2]+24>>2])&&(F(T2[12+a>>2],T2[40+a>>2],T2[36+a>>2],T2[32+a>>2],1&p2[31+a|0]),A=T2[12+a>>2]+8|0,(T2[12+a>>2]=A)>>>0<T[16+a>>2]););else for(;!(1&p2[T2[40+a>>2]+54|0]||1==T2[T2[40+a>>2]+36>>2])&&(F(T2[12+a>>2],T2[40+a>>2],T2[36+a>>2],T2[32+a>>2],1&p2[31+a|0]),A=T2[12+a>>2]+8|0,(T2[12+a>>2]=A)>>>0<T[16+a>>2]););L2=48+a|0;},function(A,f,r,e){f|=0,r|=0,e|=0;var i=0;if(T2[28+(L2=i=L2-32|0)>>2]=A|=0,T2[24+i>>2]=f,T2[20+i>>2]=r,T2[16+i>>2]=e,1&C(A=T2[28+i>>2],T2[T2[24+i>>2]+8>>2],0))E(A,T2[24+i>>2],T2[20+i>>2],T2[16+i>>2]);else if(T2[12+i>>2]=(A+16|0)+(T2[A+12>>2]<<3),T2[8+i>>2]=A+16,D(T2[8+i>>2],T2[24+i>>2],T2[20+i>>2],T2[16+i>>2]),A=T2[8+i>>2]+8|0,(T2[8+i>>2]=A)>>>0<T[12+i>>2])for(;D(T2[8+i>>2],T2[24+i>>2],T2[20+i>>2],T2[16+i>>2]),!(1&p2[T2[24+i>>2]+54|0])&&(A=T2[8+i>>2]+8|0,(T2[8+i>>2]=A)>>>0<T[12+i>>2]););L2=32+i|0;},function(A){T2[5501]=7328;},function(A){x(22100);},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o=0,b=z2(0),t=z2(0),c=z2(0);L2=o=L2-32|0,a=T2[4+(i=r+8|0)>>2],T2[(e=n=24+o|0)>>2]=T2[i>>2],T2[4+e>>2]=a,e=T2[r+4>>2],T2[16+o>>2]=T2[r>>2],T2[20+o>>2]=e,b=j2[16+o>>2],c=j2[20+o>>2],t=j2[n>>2],z2(z2(z2(b*b)+z2(c*c))+z2(t*t))<z2(14210854715202004e-30)&&(T2[28+o>>2]=0,t=z2(-1),c=z2(-1),b=z2(-1)),n=t,t=z2(z2(1)/z2(_2(z2(z2(z2(b*b)+z2(c*c))+z2(t*t))))),j2[24+o>>2]=n*t,j2[20+o>>2]=c*t,j2[16+o>>2]=b*t,t2(o,f,16+o|0);A:{f:switch(T2[f+4>>2]){case 8:b=z2(j2[f+36>>2]*j2[f+20>>2]);break A;case 0:case 1:case 13:case 11:case 10:b=j2[f+52>>2];break A;case 4:case 5:b=j2[f+52>>2];break A;default:break f;}b=z2(n1[T2[T2[f>>2]+48>>2]](f));}T2[A+12>>2]=0,j2[A+8>>2]=z2(b*j2[24+o>>2])+j2[8+o>>2],j2[A+4>>2]=z2(b*j2[20+o>>2])+j2[4+o>>2],j2[A>>2]=z2(b*j2[16+o>>2])+j2[o>>2],L2=32+o|0;},t2,function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o=z2(0),b=z2(0),t=z2(0),c=z2(0);return (b=j2[r+128>>2])!=z2(0)&&(T2[5868]=T2[5868]+1,o=j2[r+96>>2],t=z2(b-z2(o*j2[r+116>>2])),c=j2[r+16>>2],e=j2[r+20>>2],i=j2[r+24>>2],b=j2[r+108>>2],b=z2(z2(t-z2(z2(z2(z2(z2(c*j2[A+144>>2])+z2(e*j2[A+148>>2]))+z2(i*j2[A+152>>2]))+z2(z2(z2(j2[r>>2]*j2[A+160>>2])+z2(j2[r+4>>2]*j2[A+164>>2]))+z2(j2[r+8>>2]*j2[A+168>>2])))*b))-z2(b*z2(z2(z2(z2(j2[r+48>>2]*j2[f+144>>2])+z2(j2[r+52>>2]*j2[f+148>>2]))+z2(j2[r+56>>2]*j2[f+152>>2]))+z2(z2(z2(j2[r+32>>2]*j2[f+160>>2])+z2(j2[r+36>>2]*j2[f+164>>2]))+z2(j2[r+40>>2]*j2[f+168>>2]))))),a=z2(o+b),t=j2[r+120>>2],j2[r+96>>2]=(n=a<t)?t:a,o=n?z2(t-o):b,T2[A+240>>2]&&(j2[A+144>>2]=z2(j2[A+112>>2]*z2(o*z2(c*j2[A+128>>2])))+j2[A+144>>2],j2[A+148>>2]=z2(z2(o*z2(e*j2[A+132>>2]))*j2[A+116>>2])+j2[A+148>>2],j2[A+152>>2]=z2(z2(o*z2(i*j2[A+136>>2]))*j2[A+120>>2])+j2[A+152>>2],b=j2[r+72>>2],t=j2[r+68>>2],j2[A+160>>2]=z2(z2(o*j2[A+96>>2])*j2[r+64>>2])+j2[A+160>>2],c=j2[A+104>>2],j2[A+164>>2]=z2(t*z2(o*j2[A+100>>2]))+j2[A+164>>2],j2[A+168>>2]=z2(b*z2(o*c))+j2[A+168>>2]),T2[f+240>>2]&&(b=j2[r+56>>2],t=j2[r+52>>2],j2[f+144>>2]=z2(j2[f+112>>2]*z2(o*z2(j2[r+48>>2]*j2[f+128>>2])))+j2[f+144>>2],j2[f+148>>2]=z2(z2(o*z2(t*j2[f+132>>2]))*j2[f+116>>2])+j2[f+148>>2],j2[f+152>>2]=z2(z2(o*z2(b*j2[f+136>>2]))*j2[f+120>>2])+j2[f+152>>2],b=j2[r+88>>2],t=j2[r+84>>2],j2[f+160>>2]=z2(z2(o*j2[f+96>>2])*j2[r+80>>2])+j2[f+160>>2],c=j2[f+104>>2],j2[f+164>>2]=z2(t*z2(o*j2[f+100>>2]))+j2[f+164>>2],j2[f+168>>2]=z2(b*z2(o*c))+j2[f+168>>2])),z2(o);},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a=z2(0),n=z2(0),o=z2(0),b=z2(0),a=(j2[r+100>>2]),b=j2[r+16>>2],t=j2[r+20>>2],c=j2[r+24>>2],n=j2[r+108>>2];return n=z2(z2(z2(j2[r+112>>2]-z2(a*j2[r+116>>2]))-z2(z2(z2(z2(z2(b*j2[A+64>>2])+z2(t*j2[A+68>>2]))+z2(c*j2[A+72>>2]))+z2(z2(z2(j2[r>>2]*j2[A+80>>2])+z2(j2[r+4>>2]*j2[A+84>>2]))+z2(j2[r+8>>2]*j2[A+88>>2])))*n))-z2(n*z2(z2(z2(z2(j2[r+48>>2]*j2[f+64>>2])+z2(j2[r+52>>2]*j2[f+68>>2]))+z2(j2[r+56>>2]*j2[f+72>>2]))+z2(z2(z2(j2[r+32>>2]*j2[f+80>>2])+z2(j2[r+36>>2]*j2[f+84>>2]))+z2(j2[r+40>>2]*j2[f+88>>2]))))),e=z2(a+n),o=j2[r+120>>2],j2[r+100>>2]=(i=e<o)?o:e,a=i?z2(o-a):n,T2[A+240>>2]&&(j2[A+64>>2]=z2(j2[A+112>>2]*z2(a*z2(b*j2[A+128>>2])))+j2[A+64>>2],j2[A+68>>2]=z2(z2(a*z2(t*j2[A+132>>2]))*j2[A+116>>2])+j2[A+68>>2],j2[A+72>>2]=z2(z2(a*z2(c*j2[A+136>>2]))*j2[A+120>>2])+j2[A+72>>2],n=j2[r+72>>2],o=j2[r+68>>2],j2[A+80>>2]=z2(z2(a*j2[A+96>>2])*j2[r+64>>2])+j2[A+80>>2],b=j2[A+104>>2],j2[A+84>>2]=z2(o*z2(a*j2[A+100>>2]))+j2[A+84>>2],j2[A+88>>2]=z2(n*z2(a*b))+j2[A+88>>2]),T2[f+240>>2]&&(n=j2[r+56>>2],o=j2[r+52>>2],j2[f+64>>2]=z2(j2[f+112>>2]*z2(a*z2(j2[r+48>>2]*j2[f+128>>2])))+j2[f+64>>2],j2[f+68>>2]=z2(z2(a*z2(o*j2[f+132>>2]))*j2[f+116>>2])+j2[f+68>>2],j2[f+72>>2]=z2(z2(a*z2(n*j2[f+136>>2]))*j2[f+120>>2])+j2[f+72>>2],n=j2[r+88>>2],o=j2[r+84>>2],j2[f+80>>2]=z2(z2(a*j2[f+96>>2])*j2[r+80>>2])+j2[f+80>>2],b=j2[f+104>>2],j2[f+84>>2]=z2(o*z2(a*j2[f+100>>2]))+j2[f+84>>2],j2[f+88>>2]=z2(n*z2(a*b))+j2[f+88>>2]),z2(a);},function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0),i=z2(0),a=z2(0),n=z2(0),n=(j2[r+100>>2]),o=j2[r+16>>2],b=j2[r+20>>2],t=j2[r+24>>2],i=j2[r+108>>2],e=z2(z2(z2(j2[r+112>>2]-z2(n*j2[r+116>>2]))-z2(z2(z2(z2(z2(o*j2[A+64>>2])+z2(b*j2[A+68>>2]))+z2(t*j2[A+72>>2]))+z2(z2(z2(j2[r>>2]*j2[A+80>>2])+z2(j2[r+4>>2]*j2[A+84>>2]))+z2(j2[r+8>>2]*j2[A+88>>2])))*i))-z2(i*z2(z2(z2(z2(j2[r+48>>2]*j2[f+64>>2])+z2(j2[r+52>>2]*j2[f+68>>2]))+z2(j2[r+56>>2]*j2[f+72>>2]))+z2(z2(z2(j2[r+32>>2]*j2[f+80>>2])+z2(j2[r+36>>2]*j2[f+84>>2]))+z2(j2[r+40>>2]*j2[f+88>>2])))));return ((i=z2(n+e))<(a=j2[r+120>>2])||(a=j2[r+124>>2])<i)&&(e=z2(a-n),i=a),j2[r+100>>2]=i,T2[A+240>>2]&&(j2[A+64>>2]=z2(j2[A+112>>2]*z2(e*z2(o*j2[A+128>>2])))+j2[A+64>>2],j2[A+68>>2]=z2(z2(e*z2(b*j2[A+132>>2]))*j2[A+116>>2])+j2[A+68>>2],j2[A+72>>2]=z2(z2(e*z2(t*j2[A+136>>2]))*j2[A+120>>2])+j2[A+72>>2],i=j2[r+72>>2],a=j2[r+68>>2],j2[A+80>>2]=z2(z2(e*j2[A+96>>2])*j2[r+64>>2])+j2[A+80>>2],n=j2[A+104>>2],j2[A+84>>2]=z2(a*z2(e*j2[A+100>>2]))+j2[A+84>>2],j2[A+88>>2]=z2(i*z2(e*n))+j2[A+88>>2]),T2[f+240>>2]&&(i=j2[r+56>>2],a=j2[r+52>>2],j2[f+64>>2]=z2(j2[f+112>>2]*z2(e*z2(j2[r+48>>2]*j2[f+128>>2])))+j2[f+64>>2],j2[f+68>>2]=z2(z2(e*z2(a*j2[f+132>>2]))*j2[f+116>>2])+j2[f+68>>2],j2[f+72>>2]=z2(z2(e*z2(i*j2[f+136>>2]))*j2[f+120>>2])+j2[f+72>>2],i=j2[r+88>>2],a=j2[r+84>>2],j2[f+80>>2]=z2(z2(e*j2[f+96>>2])*j2[r+80>>2])+j2[f+80>>2],n=j2[f+104>>2],j2[f+84>>2]=z2(a*z2(e*j2[f+100>>2]))+j2[f+84>>2],j2[f+88>>2]=z2(i*z2(e*n))+j2[f+88>>2]),z2(e);},function(A){t4(24164);},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a=0,n=0;L2=a=L2-96|0,e=T2[T2[A>>2]>>2],i=T2[T2[A+4>>2]>>2],0|n1[T2[T2[f>>2]+24>>2]](f,e,i)&&(T2[88+a>>2]=-1,T2[92+a>>2]=-1,T2[72+a>>2]=0,T2[80+a>>2]=e,T2[84+a>>2]=e+4,T2[76+a>>2]=T2[e+192>>2],T2[64+a>>2]=-1,T2[68+a>>2]=-1,T2[48+a>>2]=0,T2[56+a>>2]=i,T2[60+a>>2]=i+4,T2[52+a>>2]=T2[i+192>>2],((n=T2[A+8>>2])||(n=0|n1[T2[T2[f>>2]+8>>2]](f,72+a|0,48+a|0,0,1),T2[A+8>>2]=n))&&(T2[40+a>>2]=0,T2[12+a>>2]=0,T2[8+a>>2]=12508,A=T2[r+8>>2],T2[20+a>>2]=48+a,T2[16+a>>2]=72+a,1!=(0|A)?(i=z2(n1[T2[T2[n>>2]+12>>2]](n,e,i,r,8+a|0)))<j2[r+12>>2]&&(j2[r+12>>2]=i):n1[T2[T2[n>>2]+8>>2]](n,72+a|0,48+a|0,r,8+a|0))),L2=96+a|0;},function(A){A|=0,T2[5870]=17124,(A=T2[6009])&&S2[24040]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),p2[24040]=1,T2[6007]=0,T2[6008]=0,T2[5870]=7664,T2[6009]=0,(A=T2[5944])&&S2[23780]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),p2[23780]=1,T2[5942]=0,T2[5943]=0,T2[5944]=0;},function(A){return T2[(A|=0)>>2]=7328,0|A;},I,function(A,f){var r=0;return T2[(A|=0)+12>>2]&T2[(f|=0)+4>>2]?(r=1,S2[A+88|0]||(A=T2[f>>2])&&(r=!(4&S2[A+204|0])),0|r):0;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b,t,c=0,u=z2(0),k=z2(0),l=0,c=(T2[f>>2]),l=T2[c+192>>2];return 31==T2[l+4>>2]&&(t=T2[f+4>>2])&&(l=T2[64+(T2[l+32>>2]+P2(T2[t>>2],80)|0)>>2]),T2[A+8>>2]=c,T2[A+84>>2]=T2[l+8>>2],j2[A+4>>2]=j2[f+24>>2],r?(r=T2[f+12>>2],T2[A+52>>2]=T2[f+8>>2],T2[A+56>>2]=r,l=T2[(c=f+16|0)+4>>2],T2[(r=A+60|0)>>2]=T2[c>>2],T2[r+4>>2]=l):(e=j2[c+8>>2],i=j2[c+12>>2],a=j2[c+20>>2],n=j2[c+24>>2],o=j2[c+28>>2],b=j2[c+36>>2],t=j2[c+40>>2],u=j2[f+12>>2],r=j2[c+44>>2],k=j2[f+16>>2],l=j2[c+4>>2],c=j2[f+8>>2],T2[A- -64>>2]=0,j2[A+60>>2]=z2(z2(c*b)+z2(u*t))+z2(k*r),j2[A+56>>2]=z2(z2(c*a)+z2(u*n))+z2(k*o),j2[A+52>>2]=z2(z2(l*c)+z2(e*u))+z2(i*k)),u=j2[f+24>>2],k=z2(z2(1)-u),j2[A+68>>2]=z2(k*j2[A+20>>2])+z2(u*j2[A+36>>2]),j2[A+72>>2]=z2(k*j2[A+24>>2])+z2(u*j2[A+40>>2]),j2[A+76>>2]=z2(k*j2[A+28>>2])+z2(u*j2[A+44>>2]),z2(j2[f+24>>2]);},M,function(A,f){return (A=T2[(A|=0)+12>>2])&T2[(f|=0)+4>>2]?0!=(A&T2[f+8>>2])|0:0;},function(){var A=0;T2[12+(L2=A=L2-16|0)>>2]=1088,T2[8+A>>2]=0,f(T2[280],T2[12+A>>2],T2[8+A>>2]),f(T2[280],3477,T2[12+(L2=A=L2-16|0)>>2]=0),L2=16+A|0,j();},x,function(A){u(x(A|=0));},function(A,f){var r=0;return T2[(A|=0)+12>>2]&T2[(f|=0)+4>>2]?(r=1,S2[A+152|0]||(A=T2[f>>2])&&(r=!(4&S2[A+204|0])),0|r):0;},function(A,f,r){A|=0,r|=0;var e=0,i=0,a=0,n=0,o=0,b=0,t=0,i=T2[T2[(f|=0)>>2]+192>>2];if(31==T2[i+4>>2]&&(a=T2[f+4>>2])){if(t=T2[T2[64+(T2[i+32>>2]+P2(T2[a>>2],80)|0)>>2]+8>>2],(0|(e=T2[A+136>>2]))==T2[A+140>>2]&&!((0|(n=e?e<<1:1))<=(0|e))){n&&(T2[5498]=T2[5498]+1,(i=K2(19+(n<<2)|0))&&(T2[(o=i+19&-16)-4>>2]=i)),b=T2[A+144>>2];A:{if(1<=(0|e))for(i=o,a=b;T2[i>>2]=T2[a>>2],i=i+4|0,a=a+4|0,e=e-1|0;);else if(!b)break A;S2[A+148|0]&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2])),e=T2[A+136>>2];}T2[A+144>>2]=o,T2[A+140>>2]=n,p2[A+148|0]=1;}}else if(t=T2[i+8>>2],(0|(e=T2[A+136>>2]))==T2[A+140>>2]&&!((0|(n=e?e<<1:1))<=(0|e))){n&&(T2[5498]=T2[5498]+1,(i=K2(19+(n<<2)|0))&&(T2[(o=i+19&-16)-4>>2]=i)),b=T2[A+144>>2];A:{if(1<=(0|e))for(i=o,a=b;T2[i>>2]=T2[a>>2],i=i+4|0,a=a+4|0,e=e-1|0;);else if(!b)break A;S2[A+148|0]&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2])),e=T2[A+136>>2];}T2[A+144>>2]=o,T2[A+140>>2]=n,p2[A+148|0]=1;}return T2[T2[A+144>>2]+(e<<2)>>2]=t,T2[A+136>>2]=T2[A+136>>2]+1,z2(y(A,f,r));},function(A){var f=0;return T2[(A|=0)>>2]=7532,(f=T2[A+124>>2])&&S2[A+128|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+124>>2]=0,p2[A+128|0]=1,T2[(f=A+116|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+104>>2])&&S2[A+108|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+104>>2]=0,p2[A+108|0]=1,T2[(f=A+96|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+84>>2])&&S2[A+88|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+84>>2]=0,p2[A+88|0]=1,T2[(f=A+76|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,T2[A>>2]=7328,p2[A+36|0]=1,T2[(f=A+24|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f=0;T2[(A|=0)>>2]=7532,(f=T2[A+124>>2])&&S2[A+128|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+124>>2]=0,p2[A+128|0]=1,T2[(f=A+116|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+104>>2])&&S2[A+108|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+104>>2]=0,p2[A+108|0]=1,T2[(f=A+96|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+84>>2])&&S2[A+88|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+84>>2]=0,p2[A+88|0]=1,T2[(f=A+76|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),u(A);},y,function(A){var f=0;return T2[(A|=0)>>2]=7664,(f=T2[A+296>>2])&&S2[A+300|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+296>>2]=0,p2[A+300|0]=1,T2[(f=A+288|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f=0;T2[(A|=0)>>2]=7664,(f=T2[A+296>>2])&&S2[A+300|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+296>>2]=0,p2[A+300|0]=1,T2[(f=A+288|0)>>2]=0,T2[f+4>>2]=0,T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f){T2[(A|=0)+200>>2]=f|=0,T2[A+192>>2]=f,T2[A+304>>2]=T2[A+304>>2]+1;},function(A,f){f|=0;var r=0,e=0,r=e=T2[(A|=0)+288>>2];A:if(!((0|e)<1)){for(A=T2[A+296>>2],r=0;;){if(T2[A>>2]==(0|f))break A;if(A=A+4|0,(0|e)==(0|(r=r+1|0)))break;}r=e;}return (0|e)<=(0|r)|0;},function(A){return 264;},K,function(A,f){var r=0,e=0,e=f|=0,i=0|n1[T2[T2[(A|=0)>>2]+16>>2]](A),a=T2[T2[f>>2]+16>>2],r=0|n1[a](0|e,0|i,1);e=0|n1[T2[T2[A>>2]+20>>2]](A,T2[8+(i=r)>>2],r=f),a=T2[T2[f>>2]+20>>2],n1[a](0|r,0|i,0|e,1245859651,0|A);},a2,function(A){A=a2(A|=0),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A){var f;return T2[(A|=0)>>2]=7916,(f=T2[A+60>>2])&&(n1[T2[T2[f>>2]>>2]](f),(f=T2[A+60>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),0|A;},M,g2,function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b,t,c=0;T2[(t=44+(L2=c=L2-96|0)|0)>>2]=0,T2[4+t>>2]=0,T2[(t=56+c|0)>>2]=0,T2[4+t>>2]=0,T2[52+c>>2]=1065353216,T2[(t=c+64|0)>>2]=0,T2[4+t>>2]=0,T2[(t=76+c|0)>>2]=0,T2[4+t>>2]=0,T2[72+c>>2]=1065353216,T2[(t=84+c|0)>>2]=0,T2[4+t>>2]=0,T2[92+c>>2]=0,T2[36+c>>2]=0,T2[40+c>>2]=0,T2[32+c>>2]=1065353216,n1[T2[T2[A>>2]+8>>2]](A,32+c|0,16+c|0,c),n=j2[c>>2],o=j2[16+c>>2],e=z2(n-o),a=z2(e*e),e=j2[4+c>>2],b=j2[20+c>>2],i=z2(e-b),t=z2(a+z2(i*i)),i=j2[8+c>>2],a=j2[24+c>>2],A=z2(i-a),j2[r>>2]=z2(_2(z2(t+z2(A*A))))*z2(.5),T2[f+12>>2]=0,j2[f+8>>2]=z2(i+a)*z2(.5),j2[f+4>>2]=z2(e+b)*z2(.5),j2[f>>2]=z2(n+o)*z2(.5),L2=96+c|0;},function(A){A|=0;var f,r=0;return L2=r=L2-32|0,n1[T2[T2[A>>2]+12>>2]](A,16+r|0,12+r|0),L2=32+r|0,f=j2[16+r>>2],A=z2(f*f),f=j2[20+r>>2],A=z2(A+z2(f*f)),f=j2[24+r>>2],z2(z2(j2[12+r>>2]+z2(_2(z2(A+z2(f*f))))));},function(A,f){return A|=0,f=z2(f),z2(z2(z2(n1[T2[T2[A>>2]+16>>2]](A))*f));},function(A,f){A|=0,f|=0,z2(0);var r=j2[f>>2],e=j2[f+4>>2],f=j2[f+8>>2];T2[A+32>>2]=0,j2[A+28>>2]=O2(f),j2[A+24>>2]=O2(e),j2[A+20>>2]=O2(r);},function(A){return (A|=0)+20|0;},function(A,f,r){A|=0,f=z2(f),r|=0;var e,i,a=0;L2=a=L2-96|0,e=z2(n1[T2[T2[A>>2]+48>>2]](A)),T2[(i=44+a|0)>>2]=0,T2[4+i>>2]=0,T2[(i=56+a|0)>>2]=0,T2[4+i>>2]=0,T2[52+a>>2]=1065353216,T2[(i=a+64|0)>>2]=0,T2[4+i>>2]=0,T2[(i=76+a|0)>>2]=0,T2[4+i>>2]=0,T2[72+a>>2]=1065353216,T2[(i=84+a|0)>>2]=0,T2[4+i>>2]=0,T2[92+a>>2]=0,T2[36+a>>2]=0,T2[40+a>>2]=0,T2[32+a>>2]=1065353216,n1[T2[T2[A>>2]+8>>2]](A,32+a|0,16+a|0,a),T2[r+12>>2]=0,f=z2(f*z2(.0833333283662796)),i=z2(e+z2(z2(j2[a>>2]-j2[16+a>>2])*z2(.5))),i=z2(i+i),i=z2(i*i),A=z2(e+z2(z2(j2[4+a>>2]-j2[20+a>>2])*z2(.5))),A=z2(A+A),A=z2(A*A),j2[r+8>>2]=f*z2(i+A),e=z2(e+z2(z2(j2[8+a>>2]-j2[24+a>>2])*z2(.5))),e=z2(e+e),e=z2(e*e),j2[r+4>>2]=f*z2(i+e),j2[r>>2]=f*z2(A+e),L2=96+a|0;},function(A,f){T2[(A|=0)+8>>2]=1065353216,T2[A+12>>2]=0,T2[A>>2]=1065353216,T2[A+4>>2]=1065353216;},w2,function(A){return z2(j2[(A|=0)+52>>2]);},J2,function(A,f,r){f|=0;var e=0|n1[T2[T2[(r|=0)>>2]+40>>2]](r,A|=0),i=0|n1[T2[T2[r>>2]+28>>2]](r,e);return (T2[f>>2]=i)&&n1[T2[T2[r>>2]+48>>2]](r,e),r=T2[A+4>>2],T2[f+8>>2]=0,j2[f+28>>2]=j2[A+36>>2],j2[f+32>>2]=j2[A+40>>2],j2[f+36>>2]=j2[A+44>>2],j2[f+40>>2]=j2[A+48>>2],j2[f+12>>2]=j2[A+20>>2],j2[f+16>>2]=j2[A+24>>2],j2[f+20>>2]=j2[A+28>>2],j2[f+24>>2]=j2[A+32>>2],T2[f+4>>2]=r,j2[f+44>>2]=j2[A+52>>2],T2[f+48>>2]=0,8448;},function(A,f){var r=0,e=0,e=f|=0,i=0|n1[T2[T2[(A|=0)>>2]+52>>2]](A),a=T2[T2[f>>2]+16>>2],r=0|n1[a](0|e,0|i,1);e=0|n1[T2[T2[A>>2]+56>>2]](A,T2[8+(i=r)>>2],r=f),a=T2[T2[f>>2]+20>>2],n1[a](0|r,0|i,0|e,1346455635,0|A);},i2,function(A,f,r){A|=0,f|=0,r|=0;var e=0,i=z2(0),a=z2(0),n=0,o=z2(0),b=z2(0),t=0,c=0,u=0,k=0,l=z2(0),s=z2(0),v=z2(0);if(L2=t=L2-2048|0,T2[A>>2]=0,T2[A+4>>2]=0,T2[(e=A+8|0)>>2]=0,T2[e+4>>2]=0,o=j2[r>>2],i=j2[r+4>>2],b=j2[r+8>>2],a=z2(z2(z2(o*o)+z2(i*i))+z2(b*b)),l=z2(1),a<z2(9999999747378752e-20)||(a=z2(z2(1)/z2(_2(a))),s=z2(b*a),v=z2(i*a),l=z2(o*a)),a=l,1<=(0|n1[T2[T2[f>>2]+96>>2]](f)))for(b=z2(-0xde0b6b000000000);;){if(c=128,127<((0|n1[T2[T2[f>>2]+96>>2]](f))-u|0)||1<=(0|(c=(0|n1[T2[T2[f>>2]+96>>2]](f))-u|0))){for(r=0,e=t;n1[T2[T2[f>>2]+108>>2]](f,r,e),e=e+16|0,(0|c)!=(0|(r=r+1|0)););for(e=0,k=-1,i=z2(-34028234663852886e22),r=t;i=(n=i<(o=z2(z2(z2(a*j2[r>>2])+z2(v*j2[r+4>>2]))+z2(s*j2[r+8>>2]))))?o:i,k=n?e:k,r=r+16|0,(0|c)!=(0|(e=e+1|0)););}else i=z2(-34028234663852886e22),k=-1;if(b<i&&(r=T2[(n=(k<<4)+t|0)+12>>2],T2[(e=A+8|0)>>2]=T2[n+8>>2],T2[e+4>>2]=r,r=T2[n+4>>2],T2[A>>2]=T2[n>>2],T2[A+4>>2]=r,b=i),u=u+128|0,!((0|n1[T2[T2[f>>2]+96>>2]](f))>(0|u)))break;}L2=2048+t|0;},function(A,f,r,e,i,a,n){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,n|=0;var o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M=0;T2[44+(L2=M=L2-48|0)>>2]=0,o=j2[r>>2],b=j2[r+4>>2],t=j2[r+8>>2],j2[32+M>>2]=z2(z2(j2[f>>2]*o)+z2(j2[f+16>>2]*b))+z2(j2[f+32>>2]*t),k=f+24|0,N=f+40|0,j2[40+M>>2]=z2(z2(o*j2[f+8>>2])+z2(b*j2[k>>2]))+z2(t*j2[N>>2]),l=f+20|0,V=f+36|0,j2[36+M>>2]=z2(z2(o*j2[f+4>>2])+z2(b*j2[l>>2]))+z2(t*j2[V>>2]),n1[T2[T2[A>>2]+64>>2]](16+M|0,A,32+M|0),s=j2[(m=f+56|0)>>2],v=j2[N>>2],d=j2[V>>2],c=j2[(J=f+52|0)>>2],B=j2[k>>2],Q=j2[l>>2],g=j2[f+32>>2],u=j2[f+48>>2],w=j2[f+8>>2],G=j2[f>>2],C=j2[f+4>>2],E=j2[f+16>>2],o=j2[24+M>>2],b=j2[16+M>>2],t=j2[20+M>>2],T2[12+M>>2]=0,j2[8+M>>2]=-j2[40+M>>2],j2[4+M>>2]=-j2[36+M>>2],j2[M>>2]=-j2[32+M>>2],n1[T2[T2[A>>2]+64>>2]](16+M|0,A,M),D=j2[m>>2],h=j2[N>>2],Z=j2[V>>2],Y=j2[J>>2],R=j2[k>>2],F=j2[l>>2],W=j2[f+32>>2],A=j2[f+48>>2],m=j2[f+8>>2],N=j2[f>>2],V=j2[f+4>>2],J=j2[f+16>>2],k=j2[24+M>>2],l=j2[16+M>>2],f=j2[20+M>>2],u=z2(u+z2(z2(z2(b*G)+z2(t*C))+z2(o*w))),c=z2(c+z2(z2(z2(b*E)+z2(t*Q))+z2(o*B))),o=z2(s+z2(z2(z2(b*g)+z2(t*d))+z2(o*v))),j2[e>>2]=z2(z2(u*j2[r>>2])+z2(c*j2[r+4>>2]))+z2(o*j2[r+8>>2]),b=z2(A+z2(z2(z2(l*N)+z2(f*V))+z2(k*m))),t=z2(Y+z2(z2(z2(l*J)+z2(f*F))+z2(k*R))),k=z2(D+z2(z2(z2(l*W)+z2(f*Z))+z2(k*h))),j2[i>>2]=z2(z2(b*j2[r>>2])+z2(t*j2[r+4>>2]))+z2(k*j2[r+8>>2]),T2[n+12>>2]=0,j2[n+8>>2]=k,j2[n+4>>2]=t,j2[n>>2]=b,T2[a+12>>2]=0,j2[a+8>>2]=o,j2[a+4>>2]=c,j2[a>>2]=u,l=j2[e>>2],(f=j2[i>>2])<l&&(j2[e>>2]=f,j2[i>>2]=l,T2[n+12>>2]=0,j2[n+8>>2]=o,j2[n+4>>2]=c,j2[n>>2]=u,T2[a+12>>2]=0,j2[a+8>>2]=k,j2[a+4>>2]=t,j2[a>>2]=b),L2=48+M|0;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u,k,l,s=0,v=0,d=z2(0),B=0,Q=0,g=0,w=0,G=0;if(L2=Q=L2-2048|0,1<=(0|e)){for(v=r+12|0,s=e;T2[v>>2]=-581039253,v=v+16|0,s=s-1|0;);for(;;){if(1<=(0|n1[T2[T2[A>>2]+96>>2]](A)))for(n=12+(i=(s=G<<4)+r|0)|0,t=8+(a=f+s|0)|0,c=4+a|0,g=0;;){if(w=128,127<((0|n1[T2[T2[A>>2]+96>>2]](A))-g|0)||1<=(0|(w=(0|n1[T2[T2[A>>2]+96>>2]](A))-g|0))){for(v=0,s=Q;n1[T2[T2[A>>2]+108>>2]](A,v,s),s=s+16|0,(0|w)!=(0|(v=v+1|0)););for(u=j2[t>>2],k=j2[c>>2],l=j2[a>>2],s=0,B=-1,d=z2(-34028234663852886e22),v=Q;d=(b=d<(o=z2(z2(z2(l*j2[v>>2])+z2(k*j2[v+4>>2]))+z2(u*j2[v+8>>2]))))?o:d,B=b?s:B,v=v+16|0,(0|w)!=(0|(s=s+1|0)););}else d=z2(-34028234663852886e22),B=-1;if(j2[n>>2]<d&&(B=T2[(s=(B<<4)+Q|0)+12>>2],T2[(v=8+i|0)>>2]=T2[s+8>>2],T2[v+4>>2]=B,v=T2[s+4>>2],T2[i>>2]=T2[s>>2],T2[4+i>>2]=v,j2[n>>2]=d),g=g+128|0,!((0|n1[T2[T2[A>>2]+96>>2]](A))>(0|g)))break;}if((0|(G=G+1|0))==(0|e))break;}}L2=2048+Q|0;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c=0,u=(0);for(L2=c=L2-80|0,t=z2(n1[T2[T2[A>>2]+48>>2]](A)),b=72+c|0;T2[b>>2]=0,T2[4+b>>2]=0,T2[64+c>>2]=0,T2[68+c>>2]=0,T2[(o=(c+64|0)+u|0)>>2]=1065353216,T2[44+c>>2]=0,i=j2[64+c>>2],a=j2[68+c>>2],n=j2[b>>2],j2[40+c>>2]=z2(z2(i*j2[f+8>>2])+z2(a*j2[f+24>>2]))+z2(n*j2[f+40>>2]),j2[36+c>>2]=z2(z2(i*j2[f+4>>2])+z2(a*j2[f+20>>2]))+z2(n*j2[f+36>>2]),j2[32+c>>2]=z2(z2(i*j2[f>>2])+z2(a*j2[f+16>>2]))+z2(n*j2[f+32>>2]),n1[T2[T2[A>>2]+64>>2]](48+c|0,A,32+c|0),T2[44+c>>2]=0,i=j2[48+c>>2],a=j2[52+c>>2],n=j2[56+c>>2],j2[40+c>>2]=z2(z2(z2(i*j2[f+32>>2])+z2(a*j2[f+36>>2]))+z2(n*j2[f+40>>2]))+j2[f+56>>2],j2[36+c>>2]=z2(z2(z2(i*j2[f+16>>2])+z2(a*j2[f+20>>2]))+z2(n*j2[f+24>>2]))+j2[f+52>>2],j2[32+c>>2]=z2(z2(z2(i*j2[f>>2])+z2(a*j2[f+4>>2]))+z2(n*j2[f+8>>2]))+j2[f+48>>2],T2[o>>2]=-1082130432,j2[e+u>>2]=t+j2[(o=(32+c|0)+u|0)>>2],T2[12+c>>2]=0,i=j2[64+c>>2],a=j2[68+c>>2],n=j2[b>>2],j2[8+c>>2]=z2(z2(i*j2[f+8>>2])+z2(a*j2[f+24>>2]))+z2(n*j2[f+40>>2]),j2[4+c>>2]=z2(z2(i*j2[f+4>>2])+z2(a*j2[f+20>>2]))+z2(n*j2[f+36>>2]),j2[c>>2]=z2(z2(i*j2[f>>2])+z2(a*j2[f+16>>2]))+z2(n*j2[f+32>>2]),n1[T2[T2[A>>2]+64>>2]](16+c|0,A,c),T2[44+c>>2]=0,i=j2[16+c>>2],a=j2[20+c>>2],n=j2[24+c>>2],j2[40+c>>2]=z2(z2(z2(i*j2[f+32>>2])+z2(a*j2[f+36>>2]))+z2(n*j2[f+40>>2]))+j2[f+56>>2],j2[36+c>>2]=z2(z2(z2(i*j2[f+16>>2])+z2(a*j2[f+20>>2]))+z2(n*j2[f+24>>2]))+j2[f+52>>2],j2[32+c>>2]=z2(z2(z2(i*j2[f>>2])+z2(a*j2[f+4>>2]))+z2(n*j2[f+8>>2]))+j2[f+48>>2],j2[r+u>>2]=j2[o>>2]-t,12!=(0|(u=u+4|0)););L2=80+c|0;},G2,C2,function(A,f){A|=0,f|=0;var r,e,i,a,n,o=0,b=0,t=0,c=0,u=0,k=0,l=0,s=z2(0),v=0,d=z2(0),B=0,Q=z2(0),g=z2(0),w=0,G=0,C=0,E=z2(0),D=0,h=0,Z=0,Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=0,N=0,V=0,J=0,M=0,I=0,x=z2(0),y=z2(0),U=0,X=z2(0),p=z2(0),T=0,S=0;if(L2=c=L2-208|0,(b=T2[A+60>>2])&&(n1[T2[T2[b>>2]>>2]](b),(b=T2[A+60>>2])&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2]))),T2[5498]=T2[5498]+1,(b=K2(151))&&(T2[(o=b+19&-16)-4>>2]=b),T2[o>>2]=7868,p2[o+20|0]=1,T2[o+16>>2]=0,p2[o+40|0]=1,T2[o+8>>2]=0,T2[o+12>>2]=0,T2[o+36>>2]=0,p2[o+60|0]=1,T2[o+28>>2]=0,T2[o+32>>2]=0,T2[o+56>>2]=0,T2[o+48>>2]=0,T2[o+52>>2]=0,T2[A+60>>2]=o,!(((o=0)|n1[T2[T2[A>>2]+96>>2]](A))<1)){for(;;){if((0|u)==(0|Z)&&!((0|(b=u?u<<1:1))<=(0|u))){k=0,b&&(T2[5498]=T2[5498]+1,(o=K2(19+(b<<4)|0))&&(T2[(k=o+19&-16)-4>>2]=o));A:{if(1<=(0|u))for(o=k,t=J;v=T2[t+4>>2],T2[o>>2]=T2[t>>2],T2[o+4>>2]=v,m=T2[(D=t+8|0)+4>>2],T2[(v=o+8|0)>>2]=T2[D>>2],T2[v+4>>2]=m,o=o+16|0,t=t+16|0,u=u-1|0;);else if(!J)break A;T2[5499]=T2[5499]+1,q2(T2[J-4>>2]);}u=b,J=k;}if(k=T2[108+c>>2],T2[(o=(Z<<4)+J|0)>>2]=T2[104+c>>2],T2[o+4>>2]=k,t=T2[(k=112+c|0)+4>>2],T2[(b=o+8|0)>>2]=T2[k>>2],T2[b+4>>2]=t,n1[T2[T2[A>>2]+108>>2]](A,Z,o),Z=Z+1|0,!((0|n1[T2[T2[A>>2]+96>>2]](A))>(0|Z)))break;}o=J;}p2[140+c|0]=1,T2[136+c>>2]=0,p2[160+c|0]=1,T2[(b=128+c|0)>>2]=0,T2[b+4>>2]=0,T2[156+c>>2]=0,T2[(b=148+c|0)>>2]=0,T2[b+4>>2]=0,T2[116+c>>2]=0,p2[120+c|0]=1,T2[108+c>>2]=0,T2[112+c>>2]=0;A:{f:{if(!f){Q2(104+c|0,o,Z);break A;}if(!((0|Z)<1)){for(N=Z-1|0,k=J+24|0;;){if((B=(f=B)+1|0)>>>0<Z>>>0)for(m=(l=(f<<4)+J|0)+8|0,M=l+4|0,v=B;;){if((0|(v=(f=v)+1|0))<(0|Z))for(T=(h=(f<<4)+J|0)+8|0,I=h+4|0,D=v;;){for(s=j2[l>>2],d=z2(j2[h>>2]-s),Q=j2[M>>2],g=z2(j2[(f=(D<<4)+J|0)+4>>2]-Q),Q=z2(j2[I>>2]-Q),s=z2(j2[f>>2]-s),Y=z2(z2(d*g)-z2(Q*s)),F=j2[m>>2],W=z2(j2[T>>2]-F),E=z2(W*s),s=z2(j2[f+8>>2]-F),F=z2(E-z2(d*s)),W=z2(z2(Q*s)-z2(W*g)),d=z2(1),f=1;;){s=z2(Y*d),Q=z2(W*d),d=z2(F*d);r:if((g=z2(z2(s*s)+z2(z2(Q*Q)+z2(d*d))))>z2(9999999747378752e-20)){g=z2(z2(1)/z2(_2(g))),s=z2(s*g),d=z2(d*g),Q=z2(Q*g);e:if(!(u=(0|w)<1)){if(z2(z2(z2(Q*j2[G>>2])+z2(d*j2[G+4>>2]))+z2(s*j2[G+8>>2]))>z2(.9990000128746033))break r;for(b=w-1|0,o=G+24|0,t=0;;){if((0|b)==(0|t))break e;if(V=o-4|0,U=o-8|0,g=j2[o>>2],o=o+16|0,t=t+1|0,z2(z2(z2(Q*j2[U>>2])+z2(d*j2[V>>2]))+z2(s*g))>z2(.9990000128746033))break;}if((0|t)<(0|w))break r;}if(g=z2(z2(z2(Q*j2[l>>2])+z2(d*j2[M>>2]))+z2(s*j2[m>>2])),!(z2(z2(z2(z2(z2(Q*j2[J>>2])+z2(d*j2[J+4>>2]))+z2(s*j2[J+8>>2]))-g)+z2(-.009999999776482582))>z2(0))){E=z2(-g),t=0,o=k;e:{for(;;){if((0|t)==(0|N))break e;if(b=o-4|0,V=o-8|0,R=j2[o>>2],o=o+16|0,t=t+1|0,z2(z2(z2(z2(z2(Q*j2[V>>2])+z2(d*j2[b>>2]))+z2(s*R))-g)+z2(-.009999999776482582))>z2(0))break;}if((0|t)<(0|Z))break r;}if((0|w)==(0|C))if((0|(C=w?w<<1:1))<=(0|w))C=w;else {b=0,C&&(T2[5498]=T2[5498]+1,(o=K2(19+(C<<4)|0))&&(T2[(b=o+19&-16)-4>>2]=o));e:{if(u){if(!G)break e;}else for(o=b,t=G,u=w;V=T2[t+4>>2],T2[o>>2]=T2[t>>2],T2[o+4>>2]=V,S=T2[(U=t+8|0)+4>>2],T2[(V=o+8|0)>>2]=T2[U>>2],T2[V+4>>2]=S,o=o+16|0,t=t+16|0,u=u-1|0;);T2[5499]=T2[5499]+1,q2(T2[G-4>>2]);}G=b;}j2[(o=(w<<4)+G|0)+12>>2]=E,j2[o+8>>2]=s,j2[o+4>>2]=d,j2[o>>2]=Q,w=w+1|0;}}if(o=1&f,d=z2(-1),f=0,!o)break;}if(!((0|(D=D+1|0))<(0|Z)))break;}if((0|v)==(0|Z))break;}if((0|B)==(0|Z))break;}if((0|w)<1)l=0;else {for(k=f=l=0;;){if(T2[(C=40+c|0)>>2]=T2[(o=(k<<4)+G|0)+8>>2],b=T2[o+4>>2],T2[32+c>>2]=T2[o>>2],T2[36+c>>2]=b,s=z2(j2[o+12>>2]-z2(n1[T2[T2[A>>2]+48>>2]](A))),(0|k)==(0|(b=f))){if((0|(f=b?b<<1:1))<=(0|b))f=b;else {v=0,f&&(T2[5498]=T2[5498]+1,(o=K2(19+(f<<4)|0))&&(T2[(v=o+19&-16)-4>>2]=o));r:{if(1<=(0|b))for(o=v,t=l,u=b;B=T2[t+4>>2],T2[o>>2]=T2[t>>2],T2[o+4>>2]=B,Z=T2[(D=t+8|0)+4>>2],T2[(B=o+8|0)>>2]=T2[D>>2],T2[B+4>>2]=Z,o=o+16|0,t=t+16|0,u=u-1|0;);else if(!l)break r;T2[5499]=T2[5499]+1,q2(T2[l-4>>2]);}l=v;}}else b=k;if(o=(b<<4)+l|0,b=T2[36+c>>2],T2[o>>2]=T2[32+c>>2],T2[o+4>>2]=b,b=T2[C>>2],j2[o+12>>2]=s,T2[o+8>>2]=b,(0|w)==(0|(k=k+1|0)))break;}if(!((0|w)<1)){for(B=D=o=f=0;;){if((B=(b=B)+1|0)>>>0<w>>>0)for(h=(C=(b<<4)+l|0)+12|0,N=C+4|0,T=C+8|0,Z=B;;){if((0|(Z=(b=Z)+1|0))<(0|w))for(I=(M=(b<<4)+l|0)+12|0,V=M+8|0,U=M+4|0,t=Z;;){if(b=o,Q=j2[(o=(t<<4)+l|0)+4>>2],g=j2[M>>2],Y=j2[U>>2],F=j2[o>>2],W=z2(z2(Q*g)-z2(Y*F)),E=j2[o+8>>2],R=j2[V>>2],y=z2(z2(Y*E)-z2(R*Q)),X=z2(z2(R*F)-z2(E*g)),z2(z2(W*W)+z2(z2(y*y)+z2(X*X)))>z2(9999999747378752e-20)){if(s=j2[N>>2],d=j2[C>>2],p=z2(z2(F*s)-z2(Q*d)),x=Q,Q=j2[T>>2],x=z2(z2(x*Q)-z2(E*s)),F=z2(z2(E*d)-z2(F*Q)),z2(z2(p*p)+z2(z2(x*x)+z2(F*F)))>z2(9999999747378752e-20)){if(E=z2(z2(Y*d)-z2(g*s)),Y=z2(z2(R*s)-z2(Y*Q)),g=z2(z2(g*Q)-z2(R*d)),z2(z2(E*E)+z2(z2(Y*Y)+z2(g*g)))>z2(9999999747378752e-20)){if(s=z2(z2(Q*W)+z2(z2(s*X)+z2(y*d))),z2(O2(s))>z2(9.999999974752427e-7)){for(s=z2(z2(-1)/s),d=j2[o+12>>2],Q=j2[h>>2],R=z2(W*Q),W=j2[I>>2],E=z2(s*z2(z2(E*d)+z2(R+z2(p*W)))),g=z2(s*z2(z2(g*d)+z2(z2(X*Q)+z2(F*W)))),s=z2(s*z2(z2(Y*d)+z2(z2(y*Q)+z2(x*W)))),u=0,k=1,o=l;!(z2(z2(j2[o+12>>2]+z2(z2(z2(s*j2[o>>2])+z2(g*j2[o+4>>2]))+z2(E*j2[o+8>>2])))+z2(-.009999999776482582))>z2(0)||(o=o+16|0,k=(u=u+1|0)>>>0<w>>>0,(0|u)==(0|w))););if(1&k)o=b;else {if((0|b)==(0|D)){if((0|(o=b?b<<1:1))<=(0|b))o=b;else {v=0,o&&(T2[5498]=T2[5498]+1,(k=K2(19+(o<<4)|0))&&(T2[(v=k+19&-16)-4>>2]=k));r:{if(1<=(0|b))for(u=v,k=f,m=b;S=T2[k+4>>2],T2[u>>2]=T2[k>>2],T2[u+4>>2]=S,e=T2[4+(r=k+8|0)>>2],T2[(S=u+8|0)>>2]=T2[r>>2],T2[S+4>>2]=e,u=u+16|0,k=k+16|0,m=m-1|0;);else if(!f)break r;T2[5499]=T2[5499]+1,q2(T2[f-4>>2]);}f=v;}}else o=b,b=D;T2[(b=(b<<4)+f|0)+12>>2]=0,j2[b+8>>2]=E,j2[b+4>>2]=g,j2[b>>2]=s,D=D+1|0;}}else o=b;}else o=b;}else o=b;}else o=b;if(!((0|(t=t+1|0))<(0|w)))break;}if((0|w)==(0|Z))break;}if((0|B)==(0|w))break;}if(Q2(104+c|0,f,D),!f)break f;T2[5499]=T2[5499]+1,q2(T2[f-4>>2]);break f;}}}Q2(104+c|0,0,0);}l&&(T2[5499]=T2[5499]+1,q2(T2[l-4>>2])),G&&(T2[5499]=T2[5499]+1,q2(T2[G-4>>2]));}if(1<=((Z=0)|(k=T2[148+c>>2])))for(T2[5498]=T2[5498]+1,(f=K2(19+(k<<4)|0))&&(T2[(Z=f+19&-16)-4>>2]=f),o=Z,t=k;f=T2[36+c>>2],T2[o>>2]=T2[32+c>>2],T2[o+4>>2]=f,u=T2[(b=40+c|0)+4>>2],T2[(f=o+8|0)>>2]=T2[b>>2],T2[f+4>>2]=u,o=o+16|0,t=t-1|0;);if(T2[92+c>>2]=0,p2[96+c|0]=1,T2[84+c>>2]=0,T2[88+c>>2]=0,p2[0|(f=47+c|0)]=0,p2[f+1|0]=0,p2[f+2|0]=0,p2[f+3|0]=0,T2[(f=40+c|0)>>2]=0,T2[f+4>>2]=0,T2[32+c>>2]=0,-1<((T2[36+c>>2]=0)|k)){if(k)for(E2(80+c|0,k),o=T2[92+c>>2]+20|0,f=32+c|3,u=k;T2[(b=v=o-16|0)>>2]=0,T2[b+4>>2]=0,p2[o-4|0]=1,b=S2[f+4|0]|S2[f+5|0]<<8|(S2[f+6|0]<<16|S2[f+7|0]<<24),t=S2[0|f]|S2[f+1|0]<<8|(S2[f+2|0]<<16|S2[f+3|0]<<24),p2[0|o]=t,p2[o+1|0]=t>>>8,p2[o+2|0]=t>>>16,p2[o+3|0]=t>>>24,p2[o+4|0]=b,p2[o+5|0]=b>>>8,p2[o+6|0]=b>>>16,p2[o+7|0]=b>>>24,T2[v+8>>2]=0,v=S2[(t=f+8|0)+4|0]|S2[t+5|0]<<8|(S2[t+6|0]<<16|S2[t+7|0]<<24),t=S2[0|t]|S2[t+1|0]<<8|(S2[t+2|0]<<16|S2[t+3|0]<<24),p2[0|(b=o+8|0)]=t,p2[b+1|0]=t>>>8,p2[b+2|0]=t>>>16,p2[b+3|0]=t>>>24,p2[b+4|0]=v,p2[b+5|0]=v>>>8,p2[b+6|0]=v>>>16,p2[b+7|0]=v>>>24,o=o+36|0,u=u-1|0;);if(T2[84+c>>2]=k,t=T2[108+c>>2],v=T2[A+60>>2],(0|(b=T2[v+8>>2]))<(0|t)){if(T2[v+12>>2]<(0|t)){if(f=0,t&&(T2[5498]=T2[5498]+1,(o=K2(19+(t<<4)|0))&&(T2[(f=o+19&-16)-4>>2]=o)),1<=(0|b))for(o=0,u=b;l=T2[v+16>>2]+o|0,D=T2[l+4>>2],T2[(B=C=f+o|0)>>2]=T2[l>>2],T2[B+4>>2]=D,B=T2[(l=l+8|0)+4>>2],T2[(C=C+8|0)>>2]=T2[l>>2],T2[C+4>>2]=B,o=o+16|0,u=u-1|0;);(o=T2[v+16>>2])&&S2[v+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[o-4>>2])),T2[v+16>>2]=f,T2[v+12>>2]=t,p2[v+20|0]=1;}for(o=b<<4,u=t-b|0;l=T2[36+c>>2],f=T2[v+16>>2]+o|0,T2[f>>2]=T2[32+c>>2],T2[f+4>>2]=l,l=T2[(b=40+c|0)+4>>2],T2[(f=f+8|0)>>2]=T2[b>>2],T2[f+4>>2]=l,o=o+16|0,u=u-1|0;);}if(1<=(0|(T2[v+8>>2]=t)))for(o=0;f=T2[116+c>>2]+o|0,v=T2[f+4>>2],b=T2[T2[A+60>>2]+16>>2]+o|0,T2[b>>2]=T2[f>>2],T2[b+4>>2]=v,u=T2[(f=f+8|0)+4>>2],T2[(b=b+8|0)>>2]=T2[f>>2],T2[b+4>>2]=u,o=o+16|0,t=t-1|0;);if(!((0|k)<1))for(G=0;;){for(f=0,b=h=T2[136+c>>2]+P2(T2[T2[156+c>>2]+(G<<2)>>2],12)|0;;){if(C=(l=(w=P2(G,36))+T2[92+c>>2]|0)+4|0,m=T2[8+(P2(T2[b+4>>2],12)+b|0)>>2],(0|(u=T2[l+4>>2]))==T2[l+8>>2]&&!((0|(D=u?u<<1:1))<=(0|u))){D?(B=0,T2[5498]=T2[5498]+1,(o=K2(19+(D<<2)|0))&&(T2[(B=o+19&-16)-4>>2]=o),u=T2[C>>2]):B=0,N=l+8|0,M=l+12|0,v=T2[l+12>>2];A:{if(1<=(0|u))for(o=B,t=v;T2[o>>2]=T2[t>>2],o=o+4|0,t=t+4|0,u=u-1|0;);else if(!v)break A;S2[l+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[v-4>>2])),T2[M>>2]=0,u=T2[C>>2];}T2[M>>2]=B,T2[N>>2]=D,p2[l+16|0]=1;}if(T2[T2[l+12>>2]+(u<<2)>>2]=m,T2[C>>2]=T2[C>>2]+1,f=(0|f)<=1?(t=T2[116+c>>2],s=j2[(o=t+(m<<4)|0)+4>>2],t=t+(T2[b+8>>2]<<4)|0,Q=j2[t+4>>2],d=j2[o>>2],g=j2[t>>2],Y=j2[o+8>>2],F=j2[t+8>>2],T2[(o=(32+c|0)+(f<<4)|0)+12>>2]=0,d=z2(g-d),Q=z2(Q-s),g=z2(F-Y),s=z2(z2(1)/z2(_2(z2(z2(z2(d*d)+z2(Q*Q))+z2(g*g))))),j2[o+8>>2]=g*s,j2[o+4>>2]=Q*s,j2[o>>2]=d*s,f+1|0):2,o=P2(T2[b+4>>2],12)+b|0,(0|h)==(0|(b=P2(T2[o>>2],12)+o|0)))break;}if(2!=(0|f)?(T2[(f=(G<<4)+Z|0)>>2]=0,T2[f+4>>2]=0,T2[(f=f+8|0)>>2]=0,T2[f+4>>2]=0,t=T2[92+c>>2]):(s=j2[36+c>>2],d=j2[52+c>>2],Q=j2[48+c>>2],g=j2[40+c>>2],Y=j2[32+c>>2],F=j2[56+c>>2],T2[(f=(G<<4)+Z|0)+12>>2]=0,W=z2(z2(d*Y)-z2(s*Q)),d=z2(z2(s*F)-z2(g*d)),Q=z2(z2(g*Q)-z2(F*Y)),s=z2(z2(1)/z2(_2(z2(z2(W*W)+z2(z2(d*d)+z2(Q*Q)))))),j2[f+8>>2]=W*s,j2[f+4>>2]=Q*s,s=z2(d*s),j2[f>>2]=s,t=T2[92+c>>2],j2[(o=w+t|0)+20>>2]=s,j2[o+24>>2]=j2[f+4>>2],j2[o+28>>2]=j2[f+8>>2],T2[o+32>>2]=1900671690),(0|(b=T2[(f=t+w|0)+4>>2]))<1)d=z2(1.0000000150474662e30);else if(v=T2[T2[A+60>>2]+16>>2],u=T2[f+12>>2],o=v+(T2[u>>2]<<4)|0,s=j2[(t=(G<<4)+Z|0)>>2],Q=j2[t+4>>2],g=j2[t+8>>2],d=(d=z2(z2(z2(j2[o>>2]*s)+z2(j2[o+4>>2]*Q))+z2(j2[o+8>>2]*g)))<z2(1.0000000150474662e30)?d:z2(1.0000000150474662e30),1!=(0|b))for(o=u+4|0,u=b-1|0;b=v+(T2[o>>2]<<4)|0,d=(Y=z2(z2(z2(j2[b>>2]*s)+z2(j2[b+4>>2]*Q))+z2(j2[b+8>>2]*g)))<d?Y:d,o=o+4|0,u=u-1|0;);if(j2[f+32>>2]=-d,(0|k)==(0|(G=G+1|0)))break;}}else j();if(1<=T2[84+c>>2]){for(b=v=D=0;;){if((0|b)==(0|v))if((b=v?v<<1:1)>>>0<=v>>>0)b=v;else {k=0,T2[5498]=T2[5498]+1,(f=K2(19+(b<<2)|0))&&(T2[(k=f+19&-16)-4>>2]=f);A:{if(v)for(o=k,t=D,u=v;T2[o>>2]=T2[t>>2],o=o+4|0,t=t+4|0,u=u-1|0;);else if(!D){b=1;break A;}T2[5499]=T2[5499]+1,q2(T2[D-4>>2]);}D=k;}if(!((0|(v=(T2[(v<<2)+D>>2]=v)+1|0))<T2[84+c>>2]))break;}for(M=52+c|0;;){f=T2[((b=v-1|0)<<2)+D>>2],T2[5498]=T2[5498]+1,C=0,(o=K2(23))&&(T2[(C=o+19&-16)-4>>2]=o),T2[C>>2]=f;A:{if((0|v)<2)m=1,v=b;else {for(f=(t=T2[92+c>>2])+P2(f,36)|0,s=j2[f+20>>2],d=j2[f+28>>2],Q=j2[f+24>>2],k=v-2|0,f=C,v=b,m=o=1;;){b=T2[(k<<2)+D>>2],t=P2(b,36)+t|0;f:if(z2(z2(z2(s*j2[t+20>>2])+z2(Q*j2[t+24>>2]))+z2(d*j2[t+28>>2]))>z2(.9990000128746033)){r:if((0|o)!=(0|m)||(0|(l=o?o<<1:1))<=(0|o))C=f,l=o;else {if(C=0,l&&(T2[5498]=T2[5498]+1,(t=K2(19+(l<<2)|0))&&(T2[(C=t+19&-16)-4>>2]=t)),1<=(0|o))for(t=C,u=f;T2[t>>2]=T2[u>>2],t=t+4|0,u=u+4|0,o=o-1|0;);else if(!f)break r;T2[5499]=T2[5499]+1,q2(T2[f-4>>2]);}if(T2[(m<<2)+C>>2]=b,m=m+1|0,!((0|v)<1)){for(t=0,o=D;(0|b)!=T2[o>>2];)if(o=o+4|0,(0|v)==(0|(t=t+1|0)))break f;(0|v)<=(0|t)||(T2[o>>2]=T2[(f=((v=v-1|0)<<2)+D|0)>>2],T2[f>>2]=b);}}else C=f,l=o;if(!(1<=(0|k)))break;k=k-1|0,t=T2[92+c>>2],f=C,o=l;}if((0|m)<=1){if(f=1!=(0|m),m=1,f)break A;}else {for(T2[20+c>>2]=k=0,p2[24+c|0]=1,T2[12+c>>2]=0,T2[16+c>>2]=0,d=z2(0),Q=z2(b=0),g=z2(0),u=0;;){if(o=T2[92+c>>2]+P2(T2[(u<<2)+C>>2],36)|0,s=j2[o+20>>2],Y=j2[o+28>>2],F=j2[o+24>>2],1<=(0|(f=T2[o+4>>2])))for(N=o+4|0,T=o+12|0,l=0;;){w=T2[T2[T>>2]+(l<<2)>>2],o=T2[T2[A+60>>2]+16>>2]+(w<<4)|0,h=T2[(G=o+8|0)+4>>2],T2[(t=B=176+c|0)>>2]=T2[G>>2],T2[t+4>>2]=h,t=T2[o+4>>2],T2[168+c>>2]=T2[o>>2],T2[172+c>>2]=t;f:{if(1<=(0|b)){for(t=1<(0|k)?k:1,o=T2[20+c>>2]+20|0;;){if((0|w)==T2[o>>2])break f;if(o=o+24|0,!(t=t-1|0))break;}b=k;}if(o=T2[B+4>>2],T2[(f=h=40+c|0)>>2]=T2[B>>2],T2[f+4>>2]=o,f=T2[172+c>>2],T2[32+c>>2]=T2[168+c>>2],T2[36+c>>2]=f,T2[16+c>>2]==(0|b)){if((0|(G=b?b<<1:1))<=(0|b))k=b;else {if(B=0,G&&(T2[5498]=T2[5498]+1,(f=K2(P2(G,24)+19|0))&&(T2[(B=f+19&-16)-4>>2]=f),b=k),f=T2[20+c>>2],1<=(0|b))for(o=B,t=f;I=T2[t+4>>2],T2[o>>2]=T2[t>>2],T2[o+4>>2]=I,U=T2[(V=t+16|0)+4>>2],T2[(I=o+16|0)>>2]=T2[V>>2],T2[I+4>>2]=U,U=T2[(V=t+8|0)+4>>2],T2[(I=o+8|0)>>2]=T2[V>>2],T2[I+4>>2]=U,o=o+24|0,t=t+24|0,b=b-1|0;);f&&S2[24+c|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]),k=T2[12+c>>2]),T2[20+c>>2]=B,p2[24+c|0]=1,T2[16+c>>2]=G;}}else k=b;b=T2[36+c>>2],o=T2[20+c>>2]+P2(k,24)|0,T2[o>>2]=T2[32+c>>2],T2[o+4>>2]=b,T2[o+20>>2]=w,T2[o+16>>2]=T2[48+c>>2],f=o+8|0,o=T2[h+4>>2],T2[f>>2]=T2[h>>2],T2[f+4>>2]=o,k=T2[12+c>>2]+1|0,T2[12+c>>2]=k,f=T2[N>>2];}if(b=k,!((0|(l=l+1|0))<(0|f)))break;}if(g=z2(s+g),d=z2(Y+d),Q=z2(F+Q),(0|(u=u+1|0))==(0|m))break;}T2[36+c>>2]=0,T2[40+c>>2]=0,f=T2[92+c>>2]+P2(T2[C>>2],36)|0,j2[52+c>>2]=j2[f+20>>2],j2[56+c>>2]=j2[f+24>>2],j2[60+c>>2]=j2[f+28>>2],T2[44+c>>2]=0,j2[64+c>>2]=j2[f+32>>2],s=z2(z2(1)/z2(_2(z2(z2(z2(g*g)+z2(Q*Q))+z2(d*d))))),Y=z2(Q*s),F=z2(g*s),p2[48+c|0]=1,W=z2(d*s),s=z2(O2(W))>z2(.7071067690849304)?(d=z2(z2(W*W)+z2(Y*Y)),s=z2(z2(1)/z2(_2(d))),X=z2(d*s),d=z2(s*z2(-W)),p=z2(F*d),g=z2(0),Q=z2(Y*s),z2(Q*z2(-F))):(d=z2(z2(F*F)+z2(Y*Y)),s=z2(z2(1)/z2(_2(d))),p=z2(d*s),d=z2(F*s),X=z2(d*z2(-W)),Q=z2(0),g=z2(s*z2(-Y)),z2(W*g));f:{r:{e:{i:if(2<=(0|k)){for(u=0,o=b=T2[20+c>>2];f=o+8|0,z2(z2(z2(g*j2[o>>2])+z2(d*j2[o+4>>2]))+z2(Q*j2[f>>2]))<z2(z2(z2(g*j2[b>>2])+z2(d*j2[b+4>>2]))+z2(Q*j2[b+8>>2]))&&(B=T2[b>>2],G=T2[b+4>>2],t=T2[o+4>>2],T2[b>>2]=T2[o>>2],T2[b+4>>2]=t,w=T2[(t=b+16|0)>>2],h=T2[t+4>>2],N=T2[(l=o+16|0)+4>>2],T2[t>>2]=T2[l>>2],T2[t+4>>2]=N,N=T2[(t=b+8|0)>>2],T=T2[t+4>>2],I=T2[f+4>>2],T2[t>>2]=T2[f>>2],T2[t+4>>2]=I,T2[o>>2]=B,T2[o+4>>2]=G,T2[l>>2]=w,T2[l+4>>2]=h,T2[f>>2]=N,T2[f+4>>2]=T),o=o+24|0,(0|(u=u+1|0))<(0|k););if(T2[b+16>>2]=-246811958,2<=(0|k))for(o=b+40|0,u=k-1|0,i=j2[b+8>>2],a=j2[b+4>>2],n=j2[b>>2];E=z2(j2[(f=o)-16>>2]-n),R=z2(j2[o-12>>2]-a),x=z2(j2[o-8>>2]-i),y=z2(z2(z2(X*E)+z2(s*R))+z2(p*x)),E=z2(z2(z2(g*E)+z2(d*R))+z2(Q*x)),E=z2(z2(y*y)+z2(E*E))<z2(1.1920928955078125e-7)?z2(0):(R=z2(O2(y)),E=E>=z2(0)?(x=z2(.7853981852531433),z2(z2(E-R)/z2(E+R))):(x=z2(2.356194496154785),z2(z2(E+R)/z2(R-E))),E=z2(x+z2(E*z2(-.7853981852531433))),y<z2(0)?z2(-E):E),j2[f>>2]=E,o=o+24|0,u=u-1|0;);if(t=T2[(o=b+8|0)+4>>2],T2[(f=176+c|0)>>2]=T2[o>>2],T2[f+4>>2]=t,f=T2[b+4>>2],T2[168+c>>2]=T2[b>>2],T2[172+c>>2]=f,function A(f,r,e,i){var a=z2(0),n=0,o=0,b=0,t=z2(0),c=0,u=0,k=0,l=0,s=0,v=z2(0),d=0,B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=0,C=0,E=0,D=0,h=z2(0),Z=z2(0),Y=z2(0),R=0;k=L2-32|0;L2=k;c=T2[f+12>>2];o=c+P2((e+i|0)/2|0,24)|0;D=T2[o+20>>2];B=j2[o+16>>2];h=j2[o+8>>2];Z=j2[o+4>>2];Y=j2[o>>2];o=e;u=i;for(;;){for(Q=j2[r>>2],t=z2(Y-Q),a=z2(t*t),g=j2[r+4>>2],t=z2(Z-g),a=z2(a+z2(t*t)),w=j2[r+8>>2],t=z2(h-w),t=z2(a+z2(t*t)),n=20+(P2(o,24)+c|0)|0;;){a:{n:{if((a=j2[n-4>>2])!=B){if(a<B)break n;break a;}if(a=z2(j2[n-20>>2]-Q),v=z2(a*a),a=z2(j2[n-16>>2]-g),v=z2(v+z2(a*a)),a=z2(j2[n-12>>2]-w),1!=(0|((a=z2(v+z2(a*a)))!=t?a<t:T2[n>>2]<(0|D))))break a;}n=n+24|0,o=o+1|0;continue;}break;}for(l=P2(u,24);;){a:{n:{if((a=j2[(G=(b=l+c|0)+16|0)>>2])!=B){if(B<a)break n;break a;}if(a=z2(j2[b>>2]-Q),v=z2(a*a),a=z2(j2[b+4>>2]-g),v=z2(v+z2(a*a)),a=z2(j2[b+8>>2]-w),1!=(0|((a=z2(v+z2(a*a)))!=t?t<a:T2[b+20>>2]>(0|D))))break a;}l=l-24|0,u=u-1|0;continue;}break;}if((0|o)<=(0|u)&&(s=T2[4+(C=(n=n-20|0)+16|0)>>2],T2[(c=24+k|0)>>2]=T2[(d=C)>>2],T2[c+4>>2]=s,R=T2[4+(d=n+8|0)>>2],T2[(s=E=16+k|0)>>2]=T2[d>>2],T2[4+s>>2]=R,s=T2[n+4>>2],T2[8+k>>2]=T2[n>>2],T2[12+k>>2]=s,s=T2[b+4>>2],T2[n>>2]=T2[b>>2],T2[n+4>>2]=s,b=T2[(n=b+8|0)+4>>2],T2[d>>2]=T2[n>>2],T2[4+d>>2]=b,n=T2[G+4>>2],T2[C>>2]=T2[G>>2],T2[4+C>>2]=n,n=T2[f+12>>2]+l|0,l=T2[12+k>>2],T2[n>>2]=T2[8+k>>2],T2[n+4>>2]=l,l=T2[c+4>>2],T2[(b=n+16|0)>>2]=T2[c>>2],T2[b+4>>2]=l,b=T2[4+E>>2],T2[(n=n+8|0)>>2]=T2[E>>2],T2[n+4>>2]=b,u=u-1|0,o=o+1|0),!((0|o)<=(0|u)))break;c=T2[f+12>>2];}(0|e)<(0|u)&&A(f,r,e,u);(0|o)<(0|i)&&A(f,r,o,i);L2=32+k|0;}(8+c|0,168+c|0,1,k-1|0),l=0,T2[5498]=T2[5498]+1,f=T2[20+c>>2],o=0,(b=K2(43))&&(T2[(o=b+19&-16)-4>>2]=b),t=T2[20+c>>2],b=T2[f+4>>2],T2[o>>2]=T2[f>>2],T2[o+4>>2]=b,B=T2[(u=f+16|0)+4>>2],T2[(b=o+16|0)>>2]=T2[u>>2],T2[b+4>>2]=B,B=T2[(f=f+8|0)+4>>2],T2[(u=k=o+8|0)>>2]=T2[f>>2],T2[u+4>>2]=B,T2[5498]=T2[5498]+1,(f=K2(67))&&(T2[(l=f+19&-16)-4>>2]=f),f=T2[o+4>>2],T2[l>>2]=T2[o>>2],T2[l+4>>2]=f,u=T2[b+4>>2],T2[(f=l+16|0)>>2]=T2[b>>2],T2[f+4>>2]=u,b=T2[k+4>>2],T2[(f=l+8|0)>>2]=T2[k>>2],T2[f+4>>2]=b,T2[5499]=T2[5499]+1,q2(T2[o-4>>2]),k=T2[(b=(f=t+24|0)+16|0)+4>>2],T2[(o=l+40|0)>>2]=T2[b>>2],T2[o+4>>2]=k,k=T2[(b=f+8|0)+4>>2],T2[(o=l+32|0)>>2]=T2[b>>2],T2[o+4>>2]=k,o=T2[f+4>>2],T2[l+24>>2]=T2[f>>2],T2[l+28>>2]=o,2!=T2[12+c>>2]){for(G=t=k=b=2;;){a:{n:{o:if(!((0|t)<2)){for(u=t<<1,o=(P2(t,24)+l|0)-48|0,f=T2[20+c>>2]+P2(G,24)|0,s=j2[f+8>>2],d=j2[f+4>>2],Q=j2[f>>2];;){if(g=j2[o>>2],E=z2(g-j2[o+24>>2]),R=j2[o+4>>2],y=z2(R-d),R=z2(R-j2[o+28>>2]),g=z2(g-Q),p=z2(z2(z2(E*y)-z2(R*g))*W),x=R,R=j2[o+8>>2],X=z2(R-s),R=z2(R-j2[o+32>>2]),z2(p+z2(z2(F*z2(z2(x*X)-z2(R*y)))+z2(Y*z2(z2(R*g)-z2(E*X)))))>z2(0)){if(!((0|u)<=(0|t))&&(0|b)==(0|t)){if(w=0,T2[5498]=T2[5498]+1,(o=K2(P2(b,48)+19|0))&&(T2[(w=o+19&-16)-4>>2]=o),1<=(0|k))for(o=w,t=l,b=k;B=T2[t+4>>2],T2[o>>2]=T2[t>>2],T2[o+4>>2]=B,N=T2[(h=t+16|0)+4>>2],T2[(B=o+16|0)>>2]=T2[h>>2],T2[B+4>>2]=N,N=T2[(h=t+8|0)+4>>2],T2[(B=o+8|0)>>2]=T2[h>>2],T2[B+4>>2]=N,o=o+24|0,t=t+24|0,b=b-1|0;);T2[5499]=T2[5499]+1,q2(T2[l-4>>2]),b=u,l=w,t=k;}u=T2[f+4>>2],o=P2(t,24)+l|0,T2[o>>2]=T2[f>>2],T2[o+4>>2]=u,B=T2[(u=f+16|0)+4>>2],T2[(t=o+16|0)>>2]=T2[u>>2],T2[t+4>>2]=B,t=T2[(f=f+8|0)+4>>2],T2[(o=o+8|0)>>2]=T2[f>>2],T2[o+4>>2]=t,t=k=k+1|0;break o;}if(o=o-24|0,u=u-2|0,!(2<((t=k=t-1|0)+1|0)))break;}k=1;break n;}if(1!=(0|t))break a;}if(t=T2[20+c>>2]+P2(G,24)|0,1==(0|b)){f=0,T2[5498]=T2[5498]+1,(o=K2(67))&&(T2[(f=o+19&-16)-4>>2]=o);n:{if(1<=(0|k))for(o=0,b=k;N=T2[(B=h=o+l|0)+4>>2],T2[(u=f+o|0)>>2]=T2[B>>2],T2[u+4>>2]=N,N=T2[(B=B+16|0)+4>>2],T2[(w=u+16|0)>>2]=T2[B>>2],T2[w+4>>2]=N,w=T2[(B=h+8|0)+4>>2],T2[(u=u+8|0)>>2]=T2[B>>2],T2[u+4>>2]=w,o=o+24|0,b=b-1|0;);else if(!l)break n;T2[5499]=T2[5499]+1,q2(T2[l-4>>2]);}b=2,l=f,f=k;}else f=1;u=T2[t+4>>2],f=P2(f,24)+l|0,T2[(o=f)>>2]=T2[t>>2],T2[o+4>>2]=u,B=T2[(u=t+16|0)+4>>2],T2[(o=o+16|0)>>2]=T2[u>>2],T2[o+4>>2]=B,t=T2[(o=t+8|0)+4>>2],T2[(f=f+8|0)>>2]=T2[o>>2],T2[f+4>>2]=t,t=k=k+1|0;}if((0|(G=G+1|0))==T2[12+c>>2])break;}if(0<(0|k))break i;break e;}k=2;}else {if(1!=((l=0)|k))break r;T2[5498]=T2[5498]+1,f=T2[20+c>>2],(o=K2(43))&&(T2[(l=o+19&-16)-4>>2]=o),o=T2[f+4>>2],T2[l>>2]=T2[f>>2],T2[l+4>>2]=o,k=T2[(b=f+16|0)+4>>2],T2[(o=l+16|0)>>2]=T2[b>>2],T2[o+4>>2]=k,b=T2[(f=f+8|0)+4>>2],T2[(o=l+8|0)>>2]=T2[f>>2],T2[o+4>>2]=b,k=1;}for(u=T2[40+c>>2],B=S2[48+c|(w=0)],f=T2[36+c>>2];;){if(h=20+(P2(w,24)+l|0)|0,(0|f)==(0|u))if((0|(b=u?u<<1:1))<=(0|u))f=u;else {G=0,b&&(T2[5498]=T2[5498]+1,(f=K2(19+(b<<2)|0))&&(T2[(G=f+19&-16)-4>>2]=f)),f=T2[44+c>>2];i:{if(1<=(0|u))for(o=G,t=f;T2[o>>2]=T2[t>>2],o=o+4|0,t=t+4|0,u=u-1|0;);else if(!f)break i;B&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),u=T2[36+c>>2];}f=u,T2[40+c>>2]=b,T2[44+c>>2]=G,B=1,u=b;}T2[T2[44+c>>2]+(f<<2)>>2]=T2[h>>2],T2[36+c>>2]=f=f+1|0;i:if(!(b=(0|(G=T2[12+c>>2]))<1)){for(o=T2[20+c>>2]+20|0,h=T2[h>>2],t=G;(0|h)!=T2[o>>2];)if(o=o+24|0,!(t=t-1|0))break i;T2[o>>2]=-1;}if((0|(w=w+1|0))==(0|k))break;}if(p2[48+c|0]=B,b)break r;}if(!((0|(k=T2[84+c>>2]))<1))for(B=T2[92+c>>2],w=T2[20+c>>2],G=1<(0|G)?G:1,f=0;;){if(-1!=(0|(h=T2[20+(w+P2(f,24)|0)>>2])))for(u=0;;){o=C,t=m;e:{for(;;){if(T2[o>>2]==(0|u))break e;if(o=o+4|0,!(t=t-1|0))break;}if(o=B+P2(u,36)|0,!((0|(t=T2[o+4>>2]))<1))for(o=T2[o+12>>2];;){if(b=1,(0|h)==T2[o>>2])break f;if(o=o+4|0,!(t=t-1|0))break;}}if((0|k)==(0|(u=u+1|0)))break;}if((0|G)==(0|(f=f+1|0)))break;}}D2(T2[A+60>>2]+24|0,32+c|0),b=0;}if(l&&(T2[5499]=T2[5499]+1,q2(T2[l-4>>2])),(f=T2[44+c>>2])&&S2[48+c|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),(f=T2[20+c>>2])&&S2[24+c|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),!b)break A;}}for(k=0;;){if(T2[44+c>>2]=0,f=T2[(k<<2)+C>>2],T2[40+c>>2]=0,b=T2[92+c>>2]+P2(f,36)|0,u=T2[b+4>>2],(p2[48+c|0]=1)<=(0|u)){for(o=0,T2[5498]=T2[5498]+1,(f=K2((t=u<<2)+19|0))&&(T2[(o=f+19&-16)-4>>2]=f,(f=T2[44+c>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),T2[44+c>>2]=o,p2[48+c|0]=1,T2[40+c>>2]=u,d2(o,0,t),T2[36+c>>2]=u,t=T2[b+12>>2];T2[o>>2]=T2[t>>2],o=o+4|0,t=t+4|0,u=u-1|0;);t=S2[48+c|0],f=T2[44+c>>2];}else T2[36+c>>2]=u,t=1,f=0;if(o=T2[b+24>>2],T2[M>>2]=T2[b+20>>2],T2[M+4>>2]=o,u=T2[(b=b+28|0)+4>>2],T2[(o=M+8|0)>>2]=T2[b>>2],T2[o+4>>2]=u,D2(T2[A+60>>2]+24|0,32+c|0),f&&255&t&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),(0|m)==(0|(k=k+1|0)))break;}}if(C&&(T2[5499]=T2[5499]+1,q2(T2[C-4>>2])),!v)break;}if(b2(T2[A+60>>2]),D&&(T2[5499]=T2[5499]+1,q2(T2[D-4>>2])),!((0|(t=T2[84+c>>2]))<1))for(o=T2[92+c>>2]+8|0;(f=T2[(A=o+4|0)>>2])&&S2[o+8|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A>>2]=0,p2[o+8|0]=1,T2[(A=o-4|0)>>2]=0,o=o+36|(T2[A+4>>2]=0),t=t-1|0;);}else b2(T2[A+60>>2]);return (A=T2[92+c>>2])&&S2[96+c|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),Z&&(T2[5499]=T2[5499]+1,q2(T2[Z-4>>2])),(A=T2[156+c>>2])&&S2[160+c|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[156+c>>2]=0,p2[160+c|0]=1,T2[148+c>>2]=0,T2[152+c>>2]=0,(A=T2[136+c>>2])&&S2[140+c|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[136+c>>2]=0,p2[140+c|0]=1,T2[128+c>>2]=0,T2[132+c>>2]=0,(A=T2[116+c>>2])&&S2[120+c|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),J&&(T2[5499]=T2[5499]+1,q2(T2[J-4>>2])),L2=208+c|0,1;},Y2,R2,V2,function(A,f,r){A|=0,f=z2(f),r|=0,z2(0);var e=j2[A+44>>2],i=j2[A+40>>2],a=j2[A+36>>2],n=z2(n1[T2[T2[A>>2]+48>>2]](A)),o=z2(n1[T2[T2[A>>2]+48>>2]](A)),A=z2(n1[T2[T2[A>>2]+48>>2]](A));T2[r+12>>2]=0,f=z2(f/z2(12)),a=z2(a+n),a=z2(a+a),a=z2(a*a),i=z2(i+o),i=z2(i+i),i=z2(i*i),j2[r+8>>2]=f*z2(a+i),e=z2(e+A),e=z2(e+e),e=z2(e*e),j2[r+4>>2]=f*z2(a+e),j2[r>>2]=f*z2(i+e);},function(A){return 8474;},Z2,function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0),e=(j2[f+40>>2]),i=j2[f+44>>2],a=j2[f+36>>2],n=z2(n1[T2[T2[f>>2]+48>>2]](f)),o=z2(n1[T2[T2[f>>2]+48>>2]](f)),f=z2(n1[T2[T2[f>>2]+48>>2]](f));T2[A+12>>2]=0,i=z2(i+f),j2[A+8>>2]=j2[r+8>>2]>=z2(0)?i:z2(-i),e=z2(e+o),j2[A+4>>2]=j2[r+4>>2]>=z2(0)?e:z2(-e),e=z2(a+n),j2[A>>2]=j2[r>>2]>=z2(0)?e:z2(-e);},function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0);T2[A+12>>2]=0,e=j2[f+36>>2],j2[A>>2]=j2[r>>2]>=z2(0)?e:z2(-e),e=j2[f+44>>2],j2[A+8>>2]=j2[r+8>>2]>=z2(0)?e:z2(-e),e=j2[f+40>>2],j2[A+4>>2]=j2[r+4>>2]>=z2(0)?e:z2(-e);},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u=0;if(1<=(0|e))for(;b=j2[4+(i=f+u|0)>>2],t=j2[8+i>>2],c=j2[i>>2],a=j2[A+40>>2],n=j2[A+44>>2],o=j2[A+36>>2],T2[12+(i=r+u|0)>>2]=0,j2[i>>2]=c>=z2(0)?o:z2(-o),j2[8+i>>2]=t>=z2(0)?n:z2(-n),j2[4+i>>2]=b>=z2(0)?a:z2(-a),u=u+16|0,e=e-1|0;);},M2,function(A,f,r){A|=0,r|=0,(f|=0)>>>0<=5&&(T2[r+12>>2]=0,j2[r+8>>2]=j2[(A=f<<2)+8424>>2],j2[r+4>>2]=j2[A+8400>>2],j2[r>>2]=j2[A+8376>>2]);},function(A){return 8;},e2,function(A,f,r,e){e|=0;var i=0;f=(f|=0)>>>0<=11?(i=T2[(f<<=2)+8328>>2],T2[f+8280>>2]):0,n1[T2[T2[(A|=0)>>2]+108>>2]](A,f,r|=0),n1[T2[T2[A>>2]+108>>2]](A,i,e);},function(A,f,r){A|=0,f|=0,r|=0,z2(0);var e=j2[A+44>>2],i=j2[A+40>>2],a=j2[A+36>>2],n=z2(n1[T2[T2[A>>2]+48>>2]](A)),o=z2(n1[T2[T2[A>>2]+48>>2]](A)),b=z2(n1[T2[T2[A>>2]+48>>2]](A));T2[r+12>>2]=0,i=z2(i+o),j2[r+4>>2]=z2(i*z2(0|!(A=f>>>1&1)))-z2(i*z2(0|A)),i=z2(a+n),j2[r>>2]=z2(i*z2(0|!(A=1&f)))-z2(i*z2(0|A)),e=z2(e+b),j2[r+8>>2]=z2(e*z2(0|!(A=f>>>2&1)))-z2(e*z2(0|A));},M2,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o=0;L2=o=L2-48|0,n1[T2[T2[A>>2]+124>>2]](A,32+o|0,e),T2[f+12>>2]=0,i=j2[40+o>>2],j2[f+8>>2]=i,a=j2[36+o>>2],j2[f+4>>2]=a,n=j2[32+o>>2],j2[f>>2]=n,T2[12+o>>2]=0,j2[8+o>>2]=-i,j2[4+o>>2]=-a,j2[o>>2]=-n,n1[T2[T2[A>>2]+64>>2]](16+o|0,A,o),e=T2[(f=24+o|0)+4>>2],T2[(A=r+8|0)>>2]=T2[f>>2],T2[A+4>>2]=e,A=T2[20+o>>2],T2[r>>2]=T2[16+o>>2],T2[r+4>>2]=A,L2=48+o|0;},function(A,f,r){A|=0,f|=0,r=z2(r),z2(0);var e=0,i=j2[f>>2],a=j2[A+36>>2];return i<=z2(a+r)&&i>=z2(z2(-a)-r)&&(i=j2[f+4>>2],a=j2[A+40>>2],i<=z2(a+r)&&i>=z2(z2(-a)-r)&&(i=j2[f+8>>2],a=j2[A+44>>2],i<=z2(a+r)&&(e=i>=z2(z2(-a)-r)))),0|e;},function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0),i=z2(0),a=z2(0),n=(z2(0)),o=j2[A+44>>2],b=j2[A+40>>2],e=j2[A+36>>2],i=z2(1);A:{f:{r:{e:{i:switch(0|r){case 1:i=z2(-1);break f;case 2:a=z2(1);break r;case 3:a=z2(-1);break r;case 4:e=z2(1);break e;case 0:break f;case 5:break i;default:break A;}e=z2(-1);}n=e,i=z2(0),e=o;break f;}i=z2(0),e=b;}j2[f+8>>2]=n,j2[f+4>>2]=a,j2[f>>2]=i,j2[f+12>>2]=-e;}},_,I2,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0,z2(0);var i,a,n,o,b,t,c,u,k,l,s,v,d=0,B=(A+36|0);A=T2[A+60>>2],a=j2[B+((A+2|0)%3<<2)>>2],j2[8+(d=L2-16|0)>>2]=a,j2[4+d>>2]=a,j2[d>>2]=a,j2[(A<<=2)+d>>2]=a+j2[A+B>>2],a=j2[f+56>>2],u=j2[f+40>>2],k=j2[f+36>>2],t=j2[f+52>>2],b=j2[f+24>>2],l=j2[f+20>>2],s=j2[f+32>>2],v=j2[f+16>>2],c=j2[f+48>>2],n=j2[f+8>>2],i=j2[f>>2],o=j2[f+4>>2],T2[r+12>>2]=0,A=z2(O2(i)),i=j2[d>>2],B=z2(O2(o)),o=j2[4+d>>2],f=z2(O2(n)),n=j2[8+d>>2],A=z2(z2(z2(A*i)+z2(B*o))+z2(f*n)),j2[r>>2]=c-A,b=z2(z2(z2(i*z2(O2(v)))+z2(o*z2(O2(l))))+z2(n*z2(O2(b)))),j2[r+4>>2]=t-b,i=z2(z2(z2(i*z2(O2(s)))+z2(o*z2(O2(k))))+z2(n*z2(O2(u)))),j2[r+8>>2]=a-i,j2[e>>2]=c+A,j2[e+4>>2]=t+b,j2[e+8>>2]=a+i,T2[e+12>>2]=0;},function(A,f){A|=0,f|=0,z2(0);var r,e,i,a=j2[f>>2],n=j2[f+4>>2],o=j2[f+8>>2];T2[A+32>>2]=0,r=j2[(i=A+28|0)>>2],j2[i>>2]=O2(o),o=j2[(i=A+24|0)>>2],j2[i>>2]=O2(n),n=j2[A+20>>2],j2[A+20>>2]=O2(a),a=j2[f+8>>2],e=j2[f+4>>2],i=j2[f>>2],T2[A+48>>2]=0,j2[A+36>>2]=i*z2(j2[A+36>>2]/n),j2[(f=A+40|0)>>2]=e*z2(j2[f>>2]/o),j2[(f=A+44|0)>>2]=a*z2(j2[f>>2]/r),j2[A+52>>2]=j2[(A+36|0)+((T2[A+60>>2]+2|0)%3<<2)>>2];},function(A,f,r){A|=0,f=z2(f),r|=0,z2(0);var e,i=0,a=0,i=(T2[A+60>>2]),n=j2[(a=A+36|0)+((i+2|0)%3<<2)>>2];T2[(A=L2-16|0)+12>>2]=0,j2[A+8>>2]=n,j2[A+4>>2]=n,j2[A>>2]=n,j2[(e=(i<<=2)+A|0)>>2]=j2[i+a>>2]+j2[e>>2],f=z2(f*z2(.0833333283662796)),n=j2[A>>2],n=z2(n+n),n=z2(n*n),a=j2[A+4>>2],a=z2(a+a),a=z2(a*a),j2[r+8>>2]=f*z2(n+a),e=n,n=j2[A+8>>2],n=z2(n+n),n=z2(n*n),j2[r+4>>2]=f*z2(e+n),j2[r>>2]=f*z2(a+n);},function(A){return 8623;},x2,y2,U2,function(A,f,r){f|=0;var e=0|n1[T2[T2[(r|=0)>>2]+40>>2]](r,A|=0),i=0|n1[T2[T2[r>>2]+28>>2]](r,e);return (T2[f>>2]=i)&&n1[T2[T2[r>>2]+48>>2]](r,e),r=T2[A+4>>2],T2[f+8>>2]=0,j2[f+28>>2]=j2[A+36>>2],j2[f+32>>2]=j2[A+40>>2],j2[f+36>>2]=j2[A+44>>2],j2[f+40>>2]=j2[A+48>>2],j2[f+12>>2]=j2[A+20>>2],j2[f+16>>2]=j2[A+24>>2],j2[f+20>>2]=j2[A+28>>2],j2[f+24>>2]=j2[A+32>>2],T2[f+4>>2]=r,j2[f+44>>2]=j2[A+52>>2],T2[f+48>>2]=0,A=T2[A+60>>2],T2[f+56>>2]=0,T2[f+52>>2]=A,8604;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n=z2(0),o=z2(0),b=z2(0),t=z2(0),c=z2(0),u=z2(0),k=z2(0),l=(L2-16|0);T2[A>>2]=0,T2[A+4>>2]=0,T2[(a=A+8|0)>>2]=0,T2[4+a>>2]=0,o=j2[r>>2],b=j2[r+4>>2],n=j2[r+8>>2],o=(t=z2(z2(z2(o*o)+z2(b*b))+z2(n*n)))<z2(9999999747378752e-20)?(t=z2(0),z2(1)):(c=n,n=z2(z2(1)/z2(_2(t))),k=z2(c*n),t=z2(b*n),z2(o*n)),T2[(r=8+l|0)>>2]=0,T2[r+4>>2]=0,T2[l>>2]=0,T2[4+l>>2]=0,a=T2[f+60>>2]<<2,c=j2[36+(f+a|0)>>2],j2[(e=l+a|0)>>2]=c,b=z2(-0xde0b6b000000000),u=j2[l>>2],i=j2[4+l>>2],a=j2[r>>2],(n=z2(z2(z2(o*u)+z2(t*i))+z2(k*a)))>z2(-0xde0b6b000000000)&&(j2[A+12>>2]=j2[12+l>>2],j2[A+8>>2]=a,j2[A+4>>2]=i,j2[A>>2]=u,b=n),T2[(r=f=8+l|0)>>2]=0,T2[r+4>>2]=0,T2[l>>2]=0,T2[4+l>>2]=0,j2[e>>2]=-c,c=b,u=o,o=j2[l>>2],b=j2[4+l>>2],n=j2[r>>2],c<z2(z2(z2(u*o)+z2(t*b))+z2(k*n))&&(j2[A+12>>2]=j2[12+l>>2],j2[A+8>>2]=n,j2[A+4>>2]=b,j2[A>>2]=o);},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c=0,u=z2(0),k=z2(0),l=z2(0),s=z2(0),v=0,d=z2(0),B=z2(0),Q=z2(0),g=(L2-16|0);if(1<=(0|e))for(;T2[(i=8+g|0)>>2]=0,T2[4+i>>2]=0,T2[g>>2]=0,T2[4+g>>2]=0,c=T2[A+60>>2],u=j2[36+((a=c<<2)+A|0)>>2],j2[g+a>>2]=u,k=z2(-0xde0b6b000000000),s=j2[g>>2],d=j2[(a=f+v|0)>>2],n=j2[4+g>>2],B=j2[(o=4+a|0)>>2],b=j2[i>>2],Q=j2[(t=8+a|0)>>2],(l=z2(z2(z2(s*d)+z2(n*B))+z2(b*Q)))>z2(-0xde0b6b000000000)&&(j2[(c=r+v|0)>>2]=s,j2[c+12>>2]=j2[12+g>>2],j2[c+8>>2]=b,j2[c+4>>2]=n,Q=j2[t>>2],B=j2[o>>2],c=T2[A+60>>2],u=j2[36+((c<<2)+A|0)>>2],d=j2[a>>2],k=l),T2[i>>2]=0,T2[4+i>>2]=0,T2[g>>2]=0,T2[4+g>>2]=0,j2[(c<<2)+g>>2]=-u,s=k,k=j2[g>>2],l=j2[4+g>>2],u=j2[i>>2],s<z2(z2(z2(k*d)+z2(l*B))+z2(u*Q))&&(j2[(i=r+v|0)>>2]=k,j2[12+i>>2]=j2[12+g>>2],j2[8+i>>2]=u,j2[4+i>>2]=l),v=v+16|0,e=e-1|0;);},I2,R2,V2,function(A,f,r){A|=0,f=z2(f),r|=0;var e,i,a,n=z2(0),o=z2(0),b=z2(0),b=(j2[A+44>>2]),n=j2[A+40>>2],t=j2[A+36>>2],c=z2(n1[T2[T2[A>>2]+48>>2]](A));n=z2(n+z2(n1[T2[T2[A>>2]+48>>2]](A))),a=z2(n1[T2[T2[A>>2]+48>>2]](A)),o=z2(f*z2(.5)),e=z2(f*z2(.25)),i=z2(f/z2(12)),f=z2(c+t);A:{f:switch(T2[A+60>>2]){case 0:b=o,o=z2(n*n),n=z2(b*o),o=f=z2(z2(e*o)+z2(i*z2(f*z2(f*z2(4)))));break A;case 2:f=z2(f*f),o=z2(o*f),n=z2(e*f),f=z2(a+b),f=n=z2(n+z2(i*z2(f*z2(f*z2(4)))));break A;default:break f;}b=o,o=z2(f*f),f=z2(b*o),o=n=z2(z2(e*o)+z2(i*z2(n*z2(n*z2(4)))));}T2[r+12>>2]=0,j2[r+8>>2]=o,j2[r+4>>2]=f,j2[r>>2]=n;},function(A){return 8792;},x2,Z2,U2,function(A,f,r){f|=0;var e=0|n1[T2[T2[(r|=0)>>2]+40>>2]](r,A|=0),i=0|n1[T2[T2[r>>2]+28>>2]](r,e);return (T2[f>>2]=i)&&n1[T2[T2[r>>2]+48>>2]](r,e),r=T2[A+4>>2],T2[f+8>>2]=0,j2[f+28>>2]=j2[A+36>>2],j2[f+32>>2]=j2[A+40>>2],j2[f+36>>2]=j2[A+44>>2],j2[f+40>>2]=j2[A+48>>2],j2[f+12>>2]=j2[A+20>>2],j2[f+16>>2]=j2[A+24>>2],j2[f+20>>2]=j2[A+28>>2],j2[f+24>>2]=j2[A+32>>2],T2[f+4>>2]=r,j2[f+44>>2]=j2[A+52>>2],T2[f+48>>2]=0,A=T2[A+60>>2],T2[f+56>>2]=0,T2[f+52>>2]=A,8772;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n=z2(0),o=z2(0),b=z2(0),t=0;L2=t=L2-16|0,n1[T2[T2[f>>2]+68>>2]](t,f,r),a=T2[4+(i=8+t|0)>>2],T2[(e=A+8|0)>>2]=T2[i>>2],T2[4+e>>2]=a,e=T2[4+t>>2],T2[A>>2]=T2[t>>2],T2[A+4>>2]=e,z2(n1[T2[T2[f>>2]+48>>2]](f))!=z2(0)&&(o=j2[r+4>>2],n=j2[r>>2],b=j2[r+8>>2],e=z2(n1[T2[T2[f>>2]+48>>2]](f)),r=n=(f=z2(z2(z2(n*n)+z2(o*o))+z2(b*b))<z2(14210854715202004e-30))?z2(-1):n,b=f?z2(-1):b,o=f?z2(-1):o,n=z2(z2(1)/z2(_2(z2(z2(b*b)+z2(z2(n*n)+z2(o*o)))))),j2[A>>2]=j2[A>>2]+z2(e*z2(r*n)),j2[A+4>>2]=j2[A+4>>2]+z2(e*z2(o*n)),j2[A+8>>2]=j2[A+8>>2]+z2(e*z2(b*n))),L2=16+t|0;},function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0),i=z2(0),a=(z2(0)),n=z2(0),e=j2[f+40>>2],i=j2[f+36>>2],o=j2[r>>2],f=j2[r+8>>2];e=((a=z2(_2(z2(z2(o*o)+z2(f*f)))))==z2(0)||(i=z2(i/a),n=z2(f*i),i=z2(o*i)),j2[r+4>>2]<z2(0)?z2(-e):e),j2[A+8>>2]=n,j2[A+4>>2]=e,j2[A>>2]=i;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n=z2(0),o=z2(0),b=z2(0);if(1<=(0|e))for(;n=j2[A+40>>2],o=j2[A+36>>2],i=j2[f>>2],b=j2[f+8>>2],n=((a=z2(_2(z2(z2(i*i)+z2(b*b)))))==z2(0)?b=z2(0):(o=z2(o/a),b=z2(b*o),o=z2(i*o)),j2[f+4>>2]<z2(0)?z2(-n):n),j2[r>>2]=o,j2[r+8>>2]=b,j2[r+4>>2]=n,f=f+16|0,r=r+16|0,e=e-1|0;);},function(A){A|=0,z2(0);var f=j2[A+36>>2],r=z2(n1[T2[T2[A>>2]+48>>2]](A));return z2(n1[T2[T2[A>>2]+48>>2]](A)),z2(n1[T2[T2[A>>2]+48>>2]](A)),z2(z2(f+r));},I2,function(A,f){A|=0,f|=0;var r=0,e=(T2[A+76>>2]<<2),i=j2[e+f>>2],a=z2(j2[A+68>>2]*z2(i/j2[(r=e)+(e=A+20|0)>>2]));j2[A+68>>2]=a,r=T2[A+72>>2]<<2,i=z2(j2[r+f>>2]/j2[e+r>>2]),r=T2[A+80>>2]<<2,r=z2(j2[A+64>>2]*z2(z2(i+z2(j2[r+f>>2]/j2[e+r>>2]))*z2(.5))),j2[A+64>>2]=r,j2[A+60>>2]=r/z2(_2(z2(z2(a*a)+z2(r*r)))),r=j2[f+8>>2],a=j2[f+4>>2],i=j2[f>>2],T2[A+32>>2]=0,j2[A+20>>2]=O2(i),j2[A+24>>2]=O2(a),j2[A+28>>2]=O2(r);},function(A,f,r){A|=0,f=z2(f),r|=0;var e,i,a,n,o,b,t=0;T2[(b=44+(L2=t=L2-96|0)|0)>>2]=0,T2[4+b>>2]=0,T2[(b=56+t|0)>>2]=0,T2[4+b>>2]=0,T2[52+t>>2]=1065353216,T2[(b=t+64|0)>>2]=0,T2[4+b>>2]=0,T2[(b=76+t|0)>>2]=0,T2[4+b>>2]=0,T2[72+t>>2]=1065353216,T2[(b=84+t|0)>>2]=0,T2[4+b>>2]=0,T2[92+t>>2]=0,T2[36+t>>2]=0,T2[40+t>>2]=0,T2[32+t>>2]=1065353216,n1[T2[T2[A>>2]+8>>2]](A,32+t|0,16+t|0,t),a=j2[24+t>>2],n=j2[8+t>>2],e=j2[16+t>>2],i=j2[t>>2],o=j2[20+t>>2],b=j2[4+t>>2],A=z2(n1[T2[T2[A>>2]+48>>2]](A)),T2[r+12>>2]=0,f=z2(f*z2(.0833333283662796)),e=z2(A+z2(z2(i-e)*z2(.5))),e=z2(e+e),e=z2(e*e),i=z2(A+z2(z2(b-o)*z2(.5))),i=z2(i+i),i=z2(i*i),j2[r+8>>2]=f*z2(e+i),A=z2(A+z2(z2(n-a)*z2(.5))),A=z2(A+A),A=z2(A*A),j2[r+4>>2]=f*z2(e+A),j2[r>>2]=f*z2(i+A),L2=96+t|0;},function(A){return 8948;},function(A,f){T2[(A|=0)+8>>2]=0,T2[A+12>>2]=0,T2[A>>2]=0,T2[A+4>>2]=1065353216;},U2,function(A,f,r){A|=0,f|=0,r|=0,z2(0);var e=0|n1[T2[T2[r>>2]+40>>2]](r,A),i=0|n1[T2[T2[r>>2]+28>>2]](r,e);return (T2[f>>2]=i)&&n1[T2[T2[r>>2]+48>>2]](r,e),r=T2[A+4>>2],T2[f+8>>2]=0,j2[f+28>>2]=j2[A+36>>2],j2[f+32>>2]=j2[A+40>>2],j2[f+36>>2]=j2[A+44>>2],j2[f+40>>2]=j2[A+48>>2],j2[f+12>>2]=j2[A+20>>2],j2[f+16>>2]=j2[A+24>>2],j2[f+20>>2]=j2[A+28>>2],j2[f+24>>2]=j2[A+32>>2],T2[f+4>>2]=r,r=j2[A+52>>2],T2[f+48>>2]=0,j2[f+44>>2]=r,A=T2[A+76>>2],T2[f+56>>2]=0,T2[f+52>>2]=A,8932;},function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0),i=z2(0),a=z2(0),n=z2(0),o=0,b=z2(0),t=0,i=z2(j2[f+68>>2]*z2(.5)),c=T2[f+72>>2],o=(t=T2[f+76>>2])<<2,e=j2[r>>2],n=z2(e*e);e=j2[r+4>>2],n=z2(n+z2(e*e)),e=j2[r+8>>2];A:{if(j2[o+r>>2]>z2(j2[f+60>>2]*z2(_2(z2(n+z2(e*e))))))T2[(c<<2)+A>>2]=0,j2[A+o>>2]=i,o=T2[f+80>>2];else {if(e=j2[(c<<2)+r>>2],o=T2[f+80>>2],a=j2[(o<<2)+r>>2],(b=z2(_2(z2(z2(e*e)+z2(a*a)))))>z2(1.1920928955078125e-7)){n=e,e=z2(j2[f+64>>2]/b),j2[(c<<2)+A>>2]=n*e,j2[(t<<2)+A>>2]=-i,i=z2(a*e);break A;}T2[(c<<2)+A>>2]=0,j2[(t<<2)+A>>2]=-i;}i=z2(0);}j2[(o<<2)+A>>2]=i,z2(n1[T2[T2[f>>2]+48>>2]](f))!=z2(0)&&(i=j2[r+4>>2],e=j2[r>>2],a=j2[r+8>>2],b=z2(n1[T2[T2[f>>2]+48>>2]](f)),n=e=(f=z2(z2(z2(e*e)+z2(i*i))+z2(a*a))<z2(14210854715202004e-30))?z2(-1):e,a=f?z2(-1):a,i=f?z2(-1):i,e=z2(z2(1)/z2(_2(z2(z2(a*a)+z2(z2(e*e)+z2(i*i)))))),j2[A>>2]=j2[A>>2]+z2(b*z2(n*e)),j2[A+4>>2]=j2[A+4>>2]+z2(b*z2(i*e)),j2[A+8>>2]=j2[A+8>>2]+z2(b*z2(a*e)));},function(A,f,r){A|=0,f|=0,r|=0,z2(0);var e,i,a=z2(0),n=z2(0),o=0,b=0,a=(z2(j2[f+68>>2]*z2(.5))),t=T2[f+72>>2],o=(b=T2[f+76>>2])<<2,c=j2[r>>2],n=z2(c*c);c=j2[r+4>>2],n=z2(n+z2(c*c)),c=j2[r+8>>2];A:{if(j2[o+r>>2]>z2(j2[f+60>>2]*z2(_2(z2(n+z2(c*c))))))T2[(t<<2)+A>>2]=0,j2[A+o>>2]=a,r=T2[f+80>>2];else {if(c=j2[(t<<2)+r>>2],o=r,r=T2[f+80>>2],e=j2[o+(r<<2)>>2],(i=z2(_2(z2(z2(c*c)+z2(e*e)))))>z2(1.1920928955078125e-7)){n=c,c=z2(j2[f+64>>2]/i),j2[(t<<2)+A>>2]=n*c,j2[(b<<2)+A>>2]=-a,a=z2(e*c);break A;}T2[(t<<2)+A>>2]=0,j2[(b<<2)+A>>2]=-a;}a=z2(0);}j2[(r<<2)+A>>2]=a;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0,z2(0);var i,a,n,o=0,b=0,t=z2(0),c=z2(0),u=0,k=(L2-16|0);if(1<=(0|e))for(;;){t=z2(j2[A+68>>2]*z2(.5)),o=T2[A+72>>2],b=T2[A+76>>2]<<2,i=j2[f>>2],c=z2(i*i),i=j2[f+4>>2],c=z2(c+z2(i*i)),i=j2[f+8>>2];A:{if(j2[b+f>>2]>z2(j2[A+60>>2]*z2(_2(z2(c+z2(i*i))))))T2[(o<<2)+k>>2]=0,j2[k+b>>2]=t,o=T2[A+80>>2];else {if(i=j2[(u=o<<2)+f>>2],o=T2[A+80>>2],a=j2[(o<<2)+f>>2],(n=z2(_2(z2(z2(i*i)+z2(a*a)))))>z2(1.1920928955078125e-7)){c=i,i=z2(j2[A+64>>2]/n),j2[k+u>>2]=c*i,j2[k+b>>2]=-t,t=z2(a*i);break A;}T2[k+u>>2]=0,j2[k+b>>2]=-t;}t=z2(0);}if(j2[(o<<2)+k>>2]=t,b=T2[4+k>>2],T2[r>>2]=T2[k>>2],T2[r+4>>2]=b,u=T2[(o=8+k|0)+4>>2],T2[(b=r+8|0)>>2]=T2[o>>2],T2[b+4>>2]=u,f=f+16|0,r=r+16|0,!(e=e-1|0))break;}},_,I2,function(A,f,r,e){e|=0,T2[(r|=0)+8>>2]=-581039253,T2[r+12>>2]=0,T2[r>>2]=-581039253,T2[r+4>>2]=-581039253,T2[e+8>>2]=1566444395,T2[e+12>>2]=0,T2[e>>2]=1566444395,T2[e+4>>2]=1566444395;},function(A,f){var r=T2[(f|=0)+4>>2];T2[(A|=0)+76>>2]=T2[f>>2],T2[A+80>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+84|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},function(A){return (A|=0)+76|0;},X2,function(A){return 9111;},function(A,f){A|=0,f=z2(f),j2[A+20>>2]=f;},function(A){return z2(j2[(A|=0)+20>>2]);},J2,function(A,f,r){A|=0,f|=0,r|=0,z2(0);var e=0|n1[T2[T2[r>>2]+40>>2]](r,A),i=0|n1[T2[T2[r>>2]+28>>2]](r,e);return (T2[f>>2]=i)&&n1[T2[T2[r>>2]+48>>2]](r,e),r=T2[A+4>>2],T2[f+8>>2]=0,j2[f+12>>2]=j2[A+76>>2],j2[f+16>>2]=j2[A+80>>2],j2[f+20>>2]=j2[A+84>>2],j2[f+24>>2]=j2[A+88>>2],j2[f+28>>2]=j2[A+56>>2],j2[f+32>>2]=j2[A+60>>2],j2[f+36>>2]=j2[A- -64>>2],j2[f+40>>2]=j2[A+68>>2],T2[f+4>>2]=r,A=j2[A+72>>2],T2[f+48>>2]=0,j2[f+44>>2]=A,9088;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u,k,l=z2(0),s=z2(0),v=0,d=(z2(0)),B=(z2(0)),Q=(z2(0)),g=(z2(0)),w=z2(0),G=z2(0),C=(z2(0));L2=v=L2-48|0,B=j2[e>>2],d=j2[r>>2],i=z2(z2(B-d)*z2(.5)),a=z2(i*i),s=j2[e+4>>2],l=j2[r+4>>2],i=z2(z2(s-l)*z2(.5)),o=z2(a+z2(i*i)),a=j2[e+8>>2],n=j2[r+8>>2],i=z2(z2(a-n)*z2(.5)),i=z2(_2(z2(o+z2(i*i)))),a=z2(z2(a+n)*z2(.5)),n=z2(z2(s+l)*z2(.5)),b=z2(z2(B+d)*z2(.5)),B=j2[A- -64>>2],z2(O2(B))>z2(.7071067690849304)?(d=j2[A+60>>2],s=z2(z2(B*B)+z2(d*d)),l=z2(z2(1)/z2(_2(s))),g=z2(s*l),Q=z2(d*l),s=j2[A+56>>2],w=z2(Q*z2(-s)),l=z2(l*z2(-B)),G=z2(s*l)):(s=j2[A+56>>2],d=j2[A+60>>2],g=z2(z2(s*s)+z2(d*d)),l=z2(z2(1)/z2(_2(g))),G=z2(g*l),C=z2(l*z2(-d)),w=z2(B*C),l=z2(s*l),g=z2(l*z2(-B))),k=j2[A+72>>2],T2[(A=44+v|0)>>2]=0,e=40+v|(T2[(r=28+v|0)>>2]=0),a=z2(z2(z2(B*(o=a))+z2(z2(b*s)+z2(n*d)))-k),k=z2(o-z2(B*a)),Q=z2(i*Q),o=z2(k-Q),B=z2(i*G),G=z2(o-B),j2[e>>2]=G,t=36+v|0,n=z2(n-z2(d*a)),l=z2(i*l),c=z2(n-l),d=z2(i*w),w=z2(c-d),j2[t>>2]=w,u=24+v|0,Q=z2(Q+k),j2[u>>2]=Q-B,k=20+v|0,l=z2(l+n),j2[k>>2]=l-d,T2[12+v>>2]=0,s=z2(b-z2(s*a)),a=z2(i*C),n=z2(s-a),i=z2(i*g),b=z2(n-i),j2[32+v>>2]=b,s=z2(a+s),j2[16+v>>2]=s-i,a=z2(B+Q),j2[8+v>>2]=a,l=z2(d+l),j2[4+v>>2]=l,s=z2(i+s),j2[v>>2]=s,n1[T2[T2[f>>2]+8>>2]](f,v,0,0),T2[A>>2]=0,j2[e>>2]=a,j2[t>>2]=l,T2[r>>2]=0,j2[u>>2]=B+o,j2[k>>2]=d+c,j2[32+v>>2]=s,j2[16+v>>2]=i+n,T2[12+v>>2]=0,j2[8+v>>2]=G,j2[4+v>>2]=w,j2[v>>2]=b,n1[T2[T2[f>>2]+8>>2]](f,v,0,1),L2=48+v|0;},o0,function(A){var f=0;T2[(A|=0)>>2]=9180,(f=T2[A+72>>2])&&(A0(f),(f=T2[A+72>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,p2[A+36|0]=1,T2[(f=A+24|0)>>2]=0,T2[f+4>>2]=0,T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i=z2(0),a=z2(0),n=z2(0),o=z2(0),b=z2(0),t=(z2(0)),c=(z2(0)),u=(z2(0)),i=(T2[A+24>>2]?(n=j2[A- -64>>2],i=j2[A+48>>2],o=z2(z2(n+i)*z2(.5)),a=j2[A+60>>2],t=j2[A+44>>2],b=z2(z2(a+t)*z2(.5)),c=z2(z2(n-i)*z2(.5)),u=z2(z2(a-t)*z2(.5)),i=j2[A+56>>2],a=j2[A+40>>2],n=z2(z2(i+a)*z2(.5)),z2(z2(i-a)*z2(.5))):z2(0)),k=z2(n1[T2[T2[A>>2]+48>>2]](A)),l=z2(n1[T2[T2[A>>2]+48>>2]](A)),s=z2(n1[T2[T2[A>>2]+48>>2]](A)),v=j2[f+52>>2],a=j2[f+20>>2],t=j2[f+24>>2],d=j2[f+56>>2],B=j2[f+36>>2],Q=j2[f+40>>2],g=j2[f+48>>2],w=j2[f+8>>2],G=j2[f>>2],C=j2[f+4>>2],A=j2[f+16>>2],f=j2[f+32>>2];T2[r+12>>2]=0,d=z2(d+z2(z2(z2(n*f)+z2(b*B))+z2(o*Q))),i=z2(i+k),k=z2(i*z2(O2(f))),f=z2(u+l),k=z2(k+z2(f*z2(O2(B)))),B=z2(c+s),Q=z2(k+z2(B*z2(O2(Q)))),j2[r+8>>2]=d-Q,c=z2(v+z2(z2(z2(n*A)+z2(b*a))+z2(o*t))),a=z2(z2(z2(i*z2(O2(A)))+z2(f*z2(O2(a))))+z2(B*z2(O2(t)))),j2[r+4>>2]=c-a,o=z2(g+z2(z2(z2(n*G)+z2(b*C))+z2(o*w))),b=z2(z2(z2(i*z2(O2(G)))+z2(f*z2(O2(C))))+z2(B*z2(O2(w)))),j2[r>>2]=o-b,T2[e+12>>2]=0,j2[e+8>>2]=Q+d,j2[e+4>>2]=a+c,j2[e>>2]=b+o;},function(A,f){f|=0;var r,e,i,a,n,o,b,t,c,u,k=0,l=0,s=0,v=0,d=0;if(L2=l=L2-144|0,1<=T2[(A|=0)+24>>2])for(o=96+l|0,b=l+64|0,t=48+l|0,c=32+l|0;;){if(k=(v=P2(d,80))+T2[A+32>>2]|0,a=T2[(s=k+8|0)+4>>2],T2[(r=24+l|0)>>2]=T2[s>>2],T2[4+r>>2]=a,i=T2[k+4>>2],T2[16+l>>2]=T2[k>>2],T2[20+l>>2]=i,e=T2[4+(a=k+24|0)>>2],T2[(s=i=8+c|0)>>2]=T2[a>>2],T2[s+4>>2]=e,s=T2[k+20>>2],T2[c>>2]=T2[k+16>>2],T2[4+c>>2]=s,n=T2[4+(e=k+40|0)>>2],T2[(s=8+t|0)>>2]=T2[e>>2],T2[s+4>>2]=n,a=T2[k+36>>2],T2[t>>2]=T2[k+32>>2],T2[4+t>>2]=a,u=T2[4+(n=k+56|0)>>2],T2[(e=a=8+b|0)>>2]=T2[n>>2],T2[4+e>>2]=u,e=T2[k+52>>2],T2[b>>2]=T2[k+48>>2],T2[4+b>>2]=e,k=T2[k+64>>2],k=0|n1[T2[T2[k>>2]+28>>2]](k),n=T2[4+(u=k+8|0)>>2],T2[(e=8+l|0)>>2]=T2[u>>2],T2[4+e>>2]=n,n=T2[k+4>>2],k=T2[k>>2],j2[e>>2]=z2(j2[e>>2]*j2[f+8>>2])/j2[A+92>>2],T2[l>>2]=k,T2[4+l>>2]=n,T2[12+l>>2]=0,j2[l>>2]=z2(j2[l>>2]*j2[f>>2])/j2[A+84>>2],j2[4+l>>2]=z2(j2[4+l>>2]*j2[f+4>>2])/j2[A+88>>2],k=T2[64+(v+T2[A+32>>2]|0)>>2],n1[T2[T2[k>>2]+24>>2]](k,l),T2[76+l>>2]=0,j2[72+l>>2]=z2(j2[72+l>>2]*j2[f+8>>2])/j2[A+92>>2],j2[68+l>>2]=z2(j2[68+l>>2]*j2[f+4>>2])/j2[A+88>>2],j2[64+l>>2]=z2(j2[64+l>>2]*j2[f>>2])/j2[A+84>>2],n=T2[4+r>>2],k=v+T2[A+32>>2]|0,T2[(e=k+8|0)>>2]=T2[r>>2],T2[4+e>>2]=n,r=T2[20+l>>2],T2[k>>2]=T2[16+l>>2],T2[k+4>>2]=r,e=T2[4+i>>2],T2[(r=k+24|0)>>2]=T2[i>>2],T2[4+r>>2]=e,r=T2[4+c>>2],T2[k+16>>2]=T2[c>>2],T2[k+20>>2]=r,i=T2[s+4>>2],T2[(r=k+40|0)>>2]=T2[s>>2],T2[4+r>>2]=i,r=T2[4+t>>2],T2[k+32>>2]=T2[t>>2],T2[k+36>>2]=r,r=T2[4+b>>2],T2[k+48>>2]=T2[b>>2],T2[k+52>>2]=r,r=T2[4+a>>2],T2[(k=k+56|0)>>2]=T2[a>>2],T2[k+4>>2]=r,T2[A+72>>2]){k=T2[64+(v+T2[A+32>>2]|0)>>2],n1[T2[T2[k>>2]+8>>2]](k,16+l|0,128+l|0,112+l|0),i=T2[4+(r=136+l|0)>>2],T2[(k=a=88+l|0)>>2]=T2[r>>2],T2[k+4>>2]=i,k=T2[116+l>>2],T2[o>>2]=T2[112+l>>2],T2[4+o>>2]=k,i=T2[4+(r=120+l|0)>>2],T2[(k=8+o|0)>>2]=T2[r>>2],T2[k+4>>2]=i,k=T2[132+l>>2],T2[80+l>>2]=T2[128+l>>2],T2[84+l>>2]=k;A:if(k=i0(i=T2[A+72>>2],r=T2[76+(v+T2[A+32>>2]|0)>>2])){if(0<=(0|(s=T2[i+8>>2]))){if(s)for(;;){if(!(v=T2[k+32>>2]))break A;if(k=v,!(s=s-1|0))break;}}else k=T2[i>>2];}else k=0;v=T2[84+l>>2],T2[r>>2]=T2[80+l>>2],T2[r+4>>2]=v,e=T2[(s=104+l|0)+4>>2],T2[(v=r+24|0)>>2]=T2[s>>2],T2[v+4>>2]=e,s=T2[4+o>>2],T2[(v=r+16|0)>>2]=T2[o>>2],T2[v+4>>2]=s,s=T2[4+a>>2],T2[(v=r+8|0)>>2]=T2[a>>2],T2[v+4>>2]=s,a0(i,k,r);}if(!((0|(d=d+1|0))<T2[A+24>>2]))break;}k=T2[f+4>>2],T2[A+84>>2]=T2[f>>2],T2[A+88>>2]=k,v=T2[(f=f+8|0)+4>>2],T2[(k=A+92|0)>>2]=T2[f>>2],T2[k+4>>2]=v,n1[T2[T2[A>>2]+68>>2]](A),L2=144+l|0;},function(A){return (A|=0)+84|0;},function(A,f,r){A|=0,f=z2(f),r|=0;var e,i,a=0;T2[(i=44+(L2=a=L2-96|0)|0)>>2]=0,T2[4+i>>2]=0,T2[(i=56+a|0)>>2]=0,T2[4+i>>2]=0,T2[52+a>>2]=1065353216,T2[(i=a+64|0)>>2]=0,T2[4+i>>2]=0,T2[(i=76+a|0)>>2]=0,T2[4+i>>2]=0,T2[72+a>>2]=1065353216,T2[(i=84+a|0)>>2]=0,T2[4+i>>2]=0,T2[92+a>>2]=0,T2[36+a>>2]=0,T2[40+a>>2]=0,T2[32+a>>2]=1065353216,n1[T2[T2[A>>2]+8>>2]](A,32+a|0,16+a|0,a),f=z2(f/z2(12)),e=z2(z2(j2[a>>2]-j2[16+a>>2])*z2(.5)),e=z2(e+e),e=z2(e*e),i=z2(z2(j2[4+a>>2]-j2[20+a>>2])*z2(.5)),i=z2(i+i),i=z2(i*i),j2[r+8>>2]=f*z2(e+i),A=e,e=z2(z2(j2[8+a>>2]-j2[24+a>>2])*z2(.5)),e=z2(e+e),e=z2(e*e),j2[r+4>>2]=f*z2(A+e),j2[r>>2]=f*z2(i+e),L2=96+a|0;},function(A){return 12148;},function(A,f){A|=0,f=z2(f),j2[A+80>>2]=f;},function(A){return z2(j2[(A|=0)+80>>2]);},function(A){return 24;},function(A,f,r){f|=0;var e,i,a,n,o,b,t=0,c=0,u=0,k=0,l=0,t=0|n1[T2[T2[(r|=0)>>2]+40>>2]](r,A|=0),c=0|n1[T2[T2[r>>2]+28>>2]](r,t);if((T2[f>>2]=c)&&n1[T2[T2[r>>2]+48>>2]](r,t),t=T2[A+4>>2],T2[f+8>>2]=0,T2[f+12>>2]=0,T2[f+4>>2]=t,j2[f+20>>2]=j2[A+80>>2],t=T2[A+24>>2],T2[f+16>>2]=t){if(e=0|n1[T2[T2[r>>2]+16>>2]](r,76,t),t=T2[8+e>>2],i=f,a=0|n1[T2[T2[r>>2]+28>>2]](r,t),T2[i+12>>2]=a,0<T2[f+16>>2])for(t=t+36|0,k=T2[A+32>>2],u=36;j2[t+36>>2]=j2[(c=u+k|0)+36>>2],i=t+28|0,a=0|n1[T2[T2[r>>2]+28>>2]](r,T2[c+28>>2]),T2[i>>2]=a,0|n1[T2[T2[r>>2]+24>>2]](r,T2[28+(T2[A+32>>2]+u|0)>>2])||(c=T2[28+(T2[A+32>>2]+u|0)>>2],a=r,n=0|n1[T2[T2[c>>2]+52>>2]](c),i=T2[T2[r>>2]+16>>2],c=0|n1[i](0|a,0|n,1),k=T2[28+(T2[A+32>>2]+u|0)>>2],a=0|n1[T2[T2[k>>2]+56>>2]](k,T2[(n=c)+8>>2],o=r),b=T2[28+(T2[A+32>>2]+u|0)>>2],i=T2[T2[r>>2]+20>>2],n1[i](0|o,0|n,0|a,1346455635,0|b)),k=T2[A+32>>2],j2[t-36>>2]=j2[(c=k+u|0)-36>>2],j2[t-32>>2]=j2[c-32>>2],j2[t-28>>2]=j2[c-28>>2],j2[t-24>>2]=j2[c-24>>2],j2[t-20>>2]=j2[c-20>>2],j2[t-16>>2]=j2[c-16>>2],j2[t-12>>2]=j2[c-12>>2],j2[t-8>>2]=j2[c-8>>2],j2[t-4>>2]=j2[c-4>>2],j2[t>>2]=j2[c>>2],j2[t+4>>2]=j2[c+4>>2],j2[t+8>>2]=j2[c+8>>2],j2[t+12>>2]=j2[c+12>>2],j2[t+16>>2]=j2[c+16>>2],j2[t+20>>2]=j2[c+20>>2],T2[t+32>>2]=T2[c+32>>2],j2[t+24>>2]=j2[c+24>>2],u=u+80|0,t=t+76|0,(0|(l=l+1|0))<T2[f+16>>2];);n1[T2[T2[r>>2]+20>>2]](r,e,9264,1497453121,T2[8+e>>2]);}return 9289;},function(A,f){f|=0;var r=0,e=0;if(T2[(A|=0)+76>>2]=T2[A+76>>2]+1,1<=(0|(r=T2[A+24>>2])))for(e=r+1|0,r=P2(r,80)-16|0;T2[T2[A+32>>2]+r>>2]==(0|f)&&b0(A,e-2|0),r=r-80|0,1<(0|(e=e-1|0)););n1[T2[T2[A>>2]+68>>2]](A);},function(A){A|=0;var f,r,e=z2(0),i=0,a=0,n=0;if(L2=i=L2-32|0,T2[A+56>>2]=-581039253,T2[A+60>>2]=-581039253,T2[A+40>>2]=1566444395,T2[A+44>>2]=1566444395,T2[(f=A- -64|0)>>2]=-581039253,T2[4+f>>2]=0,T2[(f=A+48|0)>>2]=1566444395,T2[4+f>>2]=0,1<=T2[A+24>>2])for(;f=T2[A+32>>2]+a|0,r=T2[f+64>>2],n1[T2[T2[r>>2]+8>>2]](r,f,16+i|0,i),(e=j2[16+i>>2])<j2[A+40>>2]&&(j2[A+40>>2]=e),(e=j2[i>>2])>j2[A+56>>2]&&(j2[A+56>>2]=e),(e=j2[20+i>>2])<j2[A+44>>2]&&(j2[A+44>>2]=e),(e=j2[4+i>>2])>j2[A+60>>2]&&(j2[A+60>>2]=e),(e=j2[24+i>>2])<j2[A+48>>2]&&(j2[A+48>>2]=e),(e=j2[8+i>>2])>j2[A+64>>2]&&(j2[A+64>>2]=e),a=a+80|0,(0|(n=n+1|0))<T2[A+24>>2];);L2=32+i|0;},function(A){var f=0;return T2[(A|=0)>>2]=9592,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,p2[A+36|0]=1,T2[(f=A+24|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f=0;T2[(A|=0)>>2]=9592,(f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,p2[A+36|0]=1,T2[(f=A+24|0)>>2]=0,T2[f+4>>2]=0,T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u=0,k=0,l=0,s=0,v=(z2(0)),d=z2(0),B=z2(0),Q=0;if(L2=r=L2-80|0,1<=(0|(o=0|n1[T2[T2[A>>2]+28>>2]](A))))for(i=j2[A+12>>2],a=j2[A+8>>2],n=j2[A+4>>2];;){n1[T2[T2[A>>2]+16>>2]](A,r+76|0,r+52|0,r- -64|0,r+56|0,r+72|0,r+68|0,r+48|0,r+60|0,Q);A:{f:switch(T2[r+64>>2]){case 0:r:switch(T2[r+60>>2]-2|0){case 3:if(T2[r+48>>2]<1)break A;for(e=0;s=T2[r+76>>2],l=T2[r+56>>2],k=T2[r+72>>2]+P2(T2[r+68>>2],e)|0,u=s+P2(l,S2[0|k])|0,v=j2[u>>2],d=j2[u+4>>2],B=j2[u+8>>2],T2[r+12>>2]=0,j2[r+8>>2]=i*B,j2[r+4>>2]=a*d,j2[r>>2]=n*v,u=s+P2(l,S2[k+1|0])|0,v=j2[u>>2],d=j2[u+4>>2],B=j2[u+8>>2],T2[r+28>>2]=0,j2[r+24>>2]=i*B,j2[r+20>>2]=a*d,j2[r+16>>2]=n*v,k=s+P2(l,S2[k+2|0])|0,v=j2[k>>2],d=j2[k+4>>2],B=j2[k+8>>2],T2[r+44>>2]=0,j2[r+40>>2]=i*B,j2[r+36>>2]=a*d,j2[r+32>>2]=n*v,n1[T2[T2[f>>2]+8>>2]](f,r,Q,e),(0|(e=e+1|0))<T2[r+48>>2];);break A;case 1:if(T2[r+48>>2]<1)break A;for(e=0;s=T2[r+76>>2],l=T2[r+56>>2],k=T2[r+72>>2]+P2(T2[r+68>>2],e)|0,u=s+P2(l,A2[k>>1])|0,v=j2[u>>2],d=j2[u+4>>2],B=j2[u+8>>2],T2[r+12>>2]=0,j2[r+8>>2]=i*B,j2[r+4>>2]=a*d,j2[r>>2]=n*v,u=s+P2(l,A2[k+2>>1])|0,v=j2[u>>2],d=j2[u+4>>2],B=j2[u+8>>2],T2[r+28>>2]=0,j2[r+24>>2]=i*B,j2[r+20>>2]=a*d,j2[r+16>>2]=n*v,k=s+P2(l,A2[k+4>>1])|0,v=j2[k+8>>2],d=j2[k+4>>2],B=j2[k>>2],T2[r+44>>2]=0,j2[r+32>>2]=n*B,j2[r+36>>2]=a*d,j2[r+40>>2]=i*v,n1[T2[T2[f>>2]+8>>2]](f,r,Q,e),(0|(e=e+1|0))<T2[r+48>>2];);break A;case 0:break r;default:break A;}if(T2[r+48>>2]<1)break A;for(e=0;s=T2[r+76>>2],l=T2[r+56>>2],k=T2[r+72>>2]+P2(T2[r+68>>2],e)|0,u=s+P2(l,T2[k>>2])|0,v=j2[u>>2],d=j2[u+4>>2],B=j2[u+8>>2],T2[r+12>>2]=0,j2[r+8>>2]=i*B,j2[r+4>>2]=a*d,j2[r>>2]=n*v,u=s+P2(l,T2[k+4>>2])|0,v=j2[u>>2],d=j2[u+4>>2],B=j2[u+8>>2],T2[r+28>>2]=0,j2[r+24>>2]=i*B,j2[r+20>>2]=a*d,j2[r+16>>2]=n*v,k=s+P2(l,T2[k+8>>2])|0,v=j2[k+8>>2],d=j2[k+4>>2],B=j2[k>>2],T2[r+44>>2]=0,j2[r+32>>2]=n*B,j2[r+36>>2]=a*d,j2[r+40>>2]=i*v,n1[T2[T2[f>>2]+8>>2]](f,r,Q,e),(0|(e=e+1|0))<T2[r+48>>2];);break A;case 1:break f;default:break A;}f:switch(T2[r+60>>2]-2|0){case 3:if(T2[r+48>>2]<1)break A;for(e=0;k=T2[r+72>>2]+P2(T2[r+68>>2],e)|0,l=S2[0|k],T2[r+12>>2]=0,s=T2[r+76>>2],u=l,l=T2[r+56>>2],u=s+P2(u,l)|0,j2[r+8>>2]=i*z2(X[u+16>>3]),j2[r+4>>2]=a*z2(X[u+8>>3]),j2[r>>2]=n*z2(X[u>>3]),u=S2[k+1|0],T2[r+28>>2]=0,u=s+P2(u,l)|0,j2[r+24>>2]=i*z2(X[u+16>>3]),j2[r+20>>2]=a*z2(X[u+8>>3]),j2[r+16>>2]=n*z2(X[u>>3]),k=s+P2(l,S2[k+2|0])|0,b=X[k>>3],t=X[k+8>>3],c=X[k+16>>3],T2[r+44>>2]=0,j2[r+40>>2]=i*z2(c),j2[r+36>>2]=a*z2(t),j2[r+32>>2]=n*z2(b),n1[T2[T2[f>>2]+8>>2]](f,r,Q,e),(0|(e=e+1|0))<T2[r+48>>2];);break A;case 1:if(T2[r+48>>2]<1)break A;for(e=0;T2[r+12>>2]=0,T2[r+28>>2]=0,s=T2[r+76>>2],l=T2[r+56>>2],k=T2[r+72>>2]+P2(T2[r+68>>2],e)|0,u=s+P2(l,A2[k>>1])|0,j2[r+8>>2]=i*z2(X[u+16>>3]),j2[r+4>>2]=a*z2(X[u+8>>3]),j2[r>>2]=n*z2(X[u>>3]),u=s+P2(l,A2[k+2>>1])|0,j2[r+24>>2]=i*z2(X[u+16>>3]),j2[r+20>>2]=a*z2(X[u+8>>3]),j2[r+16>>2]=n*z2(X[u>>3]),T2[r+44>>2]=0,k=s+P2(l,A2[k+4>>1])|0,j2[r+32>>2]=n*z2(X[k>>3]),j2[r+36>>2]=a*z2(X[k+8>>3]),j2[r+40>>2]=i*z2(X[k+16>>3]),n1[T2[T2[f>>2]+8>>2]](f,r,Q,e),(0|(e=e+1|0))<T2[r+48>>2];);break A;case 0:break f;default:break A;}if(!(T2[r+48>>2]<1))for(e=0;T2[r+12>>2]=0,T2[r+28>>2]=0,s=T2[r+76>>2],l=T2[r+56>>2],k=T2[r+72>>2]+P2(T2[r+68>>2],e)|0,u=s+P2(l,T2[k>>2])|0,j2[r+8>>2]=i*z2(X[u+16>>3]),j2[r+4>>2]=a*z2(X[u+8>>3]),j2[r>>2]=n*z2(X[u>>3]),u=s+P2(l,T2[k+4>>2])|0,j2[r+24>>2]=i*z2(X[u+16>>3]),j2[r+20>>2]=a*z2(X[u+8>>3]),j2[r+16>>2]=n*z2(X[u>>3]),T2[r+44>>2]=0,k=s+P2(l,T2[k+8>>2])|0,j2[r+32>>2]=n*z2(X[k>>3]),j2[r+36>>2]=a*z2(X[k+8>>3]),j2[r+40>>2]=i*z2(X[k+16>>3]),n1[T2[T2[f>>2]+8>>2]](f,r,Q,e),(0|(e=e+1|0))<T2[r+48>>2];);}if(n1[T2[T2[A>>2]+24>>2]](A,Q),(0|o)==(0|(Q=Q+1|0)))break;}L2=r+80|0;},t0,t0,c0,c0,k0,c0,c0,function(A){return 1==T2[(A|=0)+48>>2]|0;},function(A,f,r){r|=0;var e,i=T2[(f|=0)+4>>2];T2[(A|=0)+52>>2]=T2[f>>2],T2[A+56>>2]=i,e=T2[(f=f+8|0)+4>>2],T2[(i=A+60|0)>>2]=T2[f>>2],T2[4+i>>2]=e,f=T2[r+4>>2],T2[A+68>>2]=T2[r>>2],T2[A+72>>2]=f,i=T2[(r=r+8|0)+4>>2],T2[(f=A+76|0)>>2]=T2[r>>2],T2[f+4>>2]=i,T2[A+48>>2]=1;},function(A,f,r){r|=0;var e,i=T2[(A|=0)+56>>2];T2[(f|=0)>>2]=T2[A+52>>2],T2[f+4>>2]=i,e=T2[4+(i=A+60|0)>>2],T2[(f=f+8|0)>>2]=T2[i>>2],T2[f+4>>2]=e,e=T2[4+(i=A+76|0)>>2],T2[(f=r+8|0)>>2]=T2[i>>2],T2[f+4>>2]=e,f=T2[A+72>>2],T2[r>>2]=T2[A+68>>2],T2[r+4>>2]=f;},function(A){return 28;},function(A,f,r){f|=0,r|=0;var e,i,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0,l=0,s=0;if(L2=n=L2-32|0,a=0|n1[T2[T2[(A|=0)>>2]+28>>2]](A),T2[f>>2]=0,T2[f+20>>2]=a){if(e=0|n1[T2[T2[r>>2]+16>>2]](r,32,a),c=T2[8+e>>2],l=f,s=0|n1[T2[T2[r>>2]+28>>2]](r,c),T2[l>>2]=s,0<(0|(i=0|n1[T2[T2[A>>2]+28>>2]](A))))for(;;){n1[T2[T2[A>>2]+16>>2]](A,28+n|0,4+n|0,16+n|0,8+n|0,24+n|0,20+n|0,n,12+n|0,k),T2[c>>2]=0,T2[c+4>>2]=0,T2[(a=c+8|0)>>2]=0,T2[a+4>>2]=0,T2[(a=c+16|0)>>2]=0,T2[a+4>>2]=0,a=T2[n>>2],T2[c+24>>2]=a,T2[c+28>>2]=T2[4+n>>2];A:{f:switch(T2[12+n>>2]-2|0){case 0:if(!a)break A;if(b=0|n1[T2[T2[r>>2]+16>>2]](r,4,P2(a,3)),a=T2[b+8>>2],l=c,s=0|n1[T2[T2[r>>2]+28>>2]](r,a),T2[l+8>>2]=s,1<=T2[n>>2])for(o=0,u=T2[24+n>>2];t=u+P2(T2[20+n>>2],o)|0,T2[a>>2]=T2[t>>2],T2[a+4>>2]=T2[t+4>>2],T2[a+8>>2]=T2[t+8>>2],a=a+12|0,(0|(o=o+1|0))<T2[n>>2];);n1[T2[T2[r>>2]+20>>2]](r,b,9400,1497453121,T2[b+8>>2]);break A;case 1:if(!a)break A;if(b=0|n1[T2[T2[r>>2]+16>>2]](r,8,a),a=T2[b+8>>2],l=c,s=0|n1[T2[T2[r>>2]+28>>2]](r,a),T2[l+12>>2]=s,1<=T2[n>>2])for(o=0;t=T2[24+n>>2]+P2(T2[20+n>>2],o)|0,$[a>>1]=A2[t>>1],$[a+2>>1]=A2[t+2>>1],t=A2[t+4>>1],$[a+6>>1]=0,$[a+4>>1]=t,a=a+8|0,(0|(o=o+1|0))<T2[n>>2];);n1[T2[T2[r>>2]+20>>2]](r,b,9415,1497453121,T2[b+8>>2]);break A;case 3:break f;default:break A;}if(a){if(b=0|n1[T2[T2[r>>2]+16>>2]](r,4,a),a=T2[b+8>>2],l=c,s=0|n1[T2[T2[r>>2]+28>>2]](r,a),T2[l+16>>2]=s,1<=T2[n>>2])for(o=0;t=T2[24+n>>2]+P2(T2[20+n>>2],o)|0,p2[0|a]=S2[0|t],p2[a+1|0]=S2[t+1|0],p2[a+2|0]=S2[t+2|0],a=a+4|(p2[a+3|0]=0),(0|(o=o+1|0))<T2[n>>2];);n1[T2[T2[r>>2]+20>>2]](r,b,9442,1497453121,T2[b+8>>2]);}}A:{f:switch(T2[16+n>>2]){case 0:if(!(a=T2[4+n>>2]))break A;if(t=0|n1[T2[T2[r>>2]+16>>2]](r,16,a),a=T2[t+8>>2],l=c,s=0|n1[T2[T2[r>>2]+28>>2]](r,a),T2[l>>2]=s,1<=(0|(b=T2[4+n>>2])))for(u=T2[8+n>>2],o=T2[28+n>>2];j2[a>>2]=j2[o>>2],j2[a+4>>2]=j2[o+4>>2],j2[a+8>>2]=j2[o+8>>2],o=o+u|0,a=a+16|0,b=b-1|0;);n1[T2[T2[r>>2]+20>>2]](r,t,9465,1497453121,T2[t+8>>2]);break A;case 1:break f;default:break A;}if(a=T2[4+n>>2]){if(t=0|n1[T2[T2[r>>2]+16>>2]](r,32,a),a=T2[t+8>>2],l=c,s=0|n1[T2[T2[r>>2]+28>>2]](r,a),T2[l+4>>2]=s,1<=(0|(b=T2[4+n>>2])))for(u=T2[8+n>>2],o=T2[28+n>>2];X[a>>3]=X[o>>3],X[a+8>>3]=X[o+8>>3],X[a+16>>3]=X[o+16>>3],o=o+u|0,a=a+32|0,b=b-1|0;);n1[T2[T2[r>>2]+20>>2]](r,t,9484,1497453121,T2[t+8>>2]);}}if(n1[T2[T2[A>>2]+24>>2]](A,k),c=c+32|0,(0|i)==(0|(k=k+1|0)))break;}n1[T2[T2[r>>2]+20>>2]](r,e,9504,1497453121,T2[8+e>>2]);}return T2[f+24>>2]=0,j2[f+4>>2]=j2[A+4>>2],j2[f+8>>2]=j2[A+8>>2],j2[f+12>>2]=j2[A+12>>2],j2[f+16>>2]=j2[A+16>>2],L2=32+n|0,9519;},u0,function(A){A=u0(A|=0),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f){f|=0;var r,e=0,i=0,a=0,n=0,o=0;A:{if(S2[(A|=0)+165|0]){if(T2[A+92>>2]>=(0|f))break A;if(f&&(T2[5498]=T2[5498]+1,(e=K2(19+(f<<4)|0))&&(T2[(a=e+19&-16)-4>>2]=e)),1<=(0|(n=T2[A+88>>2])))for(;i=T2[A+96>>2]+o|0,e=T2[i+4>>2],T2[(r=o+a|0)>>2]=T2[i>>2],T2[4+r>>2]=e,e=T2[(i=i+8|0)+4>>2],T2[(r=8+r|0)>>2]=T2[i>>2],T2[4+r>>2]=e,o=o+16|0,n=n-1|0;);return (e=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+96>>2]=a,T2[A+92>>2]=f,void(p2[A+100|0]=1);}if(!(T2[A+112>>2]>=(0|f))){f&&(T2[5498]=T2[5498]+1,(i=K2(19+(f<<2)|0))&&(T2[(e=i+19&-16)-4>>2]=i)),i=T2[A+116>>2];f:{if(1<=(0|(a=T2[A+108>>2])))for(o=e,n=i;j2[o>>2]=j2[n>>2],o=o+4|0,n=n+4|0,a=a-1|0;);else if(!i)break f;S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2]));}T2[A+116>>2]=e,T2[A+112>>2]=f,p2[A+120|0]=1;}}},function(A,f){f|=0;var r=0,e=0,i=0,a=0,n=0;A:{if(S2[(A|=0)+164|0]){if(T2[A+132>>2]>=(0|f))break A;f&&(T2[5498]=T2[5498]+1,(r=K2(19+(f<<2)|0))&&(T2[(i=r+19&-16)-4>>2]=r)),a=T2[A+136>>2];f:{if(1<=(0|(e=T2[A+128>>2])))for(n=i,r=a;T2[n>>2]=T2[r>>2],n=n+4|0,r=r+4|0,e=e-1|0;);else if(!a)break f;S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2]));}return T2[A+136>>2]=i,T2[A+132>>2]=f,void(p2[A+140|0]=1);}if(!(T2[A+152>>2]>=(0|f))){f&&(T2[5498]=T2[5498]+1,(r=K2(19+(f<<1)|0))&&(T2[(i=r+19&-16)-4>>2]=r)),a=T2[A+156>>2];f:{if(1<=(0|(e=T2[A+148>>2])))for(n=i,r=a;$[n>>1]=A2[r>>1],n=n+2|0,r=r+2|0,e=e-1|0;);else if(!a)break f;S2[A+160|0]&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2]));}T2[A+156>>2]=i,T2[A+152>>2]=f,p2[A+160|0]=1;}}},_,I2,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0,z2(0);var i=0,a=0,n=0,o=0,b=(j2[(i=A+32|0)>>2]),t=j2[(a=A+48|0)>>2],c=j2[(n=A+28|0)>>2],u=j2[(o=A+44|0)>>2],k=j2[A+24>>2],l=j2[A+40>>2],s=z2(n1[T2[T2[A>>2]+48>>2]](A)),v=z2(n1[T2[T2[A>>2]+48>>2]](A)),d=z2(n1[T2[T2[A>>2]+48>>2]](A)),B=j2[f+52>>2],Q=j2[f+24>>2],g=j2[f+20>>2],w=j2[f+56>>2],G=j2[n>>2],C=j2[o>>2],E=j2[i>>2],D=j2[a>>2],h=j2[f+40>>2],Z=j2[f+36>>2],Y=j2[f+48>>2],R=j2[f+8>>2],F=j2[f>>2],n=j2[f+4>>2],o=j2[f+16>>2],i=j2[A+24>>2],a=j2[A+40>>2],A=j2[f+32>>2];T2[r+12>>2]=0,f=w,w=z2(z2(a+i)*z2(.5)),G=z2(z2(C+G)*z2(.5)),C=z2(z2(D+E)*z2(.5)),E=z2(f+z2(z2(z2(A*w)+z2(Z*G))+z2(h*C))),k=z2(s+z2(z2(l-k)*z2(.5))),f=z2(k*z2(O2(A))),A=z2(v+z2(z2(u-c)*z2(.5))),f=z2(f+z2(A*z2(O2(Z)))),Z=z2(d+z2(z2(t-b)*z2(.5))),h=z2(f+z2(Z*z2(O2(h)))),j2[r+8>>2]=E-h,b=z2(B+z2(z2(z2(w*o)+z2(G*g))+z2(C*Q))),Q=z2(z2(z2(k*z2(O2(o)))+z2(A*z2(O2(g))))+z2(Z*z2(O2(Q)))),j2[r+4>>2]=b-Q,g=z2(Y+z2(z2(z2(w*F)+z2(G*n))+z2(C*R))),Z=z2(z2(z2(k*z2(O2(F)))+z2(A*z2(O2(n))))+z2(Z*z2(O2(R)))),j2[r>>2]=g-Z,T2[e+12>>2]=0,j2[e+8>>2]=h+E,j2[e+4>>2]=Q+b,j2[e>>2]=Z+g;},v0,function(A){return T2[(A|=0)+56>>2]+4|0;},X2,function(A){return 10082;},e2,function(A,f,r){f|=0;var e=0|n1[T2[T2[(r|=0)>>2]+40>>2]](r,A|=0),i=0|n1[T2[T2[r>>2]+28>>2]](r,e);return (T2[f>>2]=i)&&n1[T2[T2[r>>2]+48>>2]](r,e),A=T2[A+4>>2],T2[f+8>>2]=0,T2[f+4>>2]=A,7747;},function(A,f,r,e){A|=0,f|=0,e|=0;var i,a,n,o=0;L2=o=L2-48|0,n=T2[4+(a=(r|=0)+8|0)>>2],T2[(i=24+o|0)>>2]=T2[a>>2],T2[4+i>>2]=n,n=T2[4+(a=e+8|0)>>2],T2[(i=40+o|0)>>2]=T2[a>>2],T2[4+i>>2]=n,T2[8+o>>2]=9956,i=T2[r+4>>2],T2[16+o>>2]=T2[r>>2],T2[20+o>>2]=i,i=T2[e+4>>2],T2[32+o>>2]=T2[e>>2],T2[36+o>>2]=i,T2[12+o>>2]=f,A=T2[A+56>>2],n1[T2[T2[A>>2]+8>>2]](A,8+o|0,r,e),L2=48+o|0;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b,t=0;T2[(b=i=52+(L2=t=L2-144|0)|0)>>2]=0,T2[4+b>>2]=0,T2[(b=t+64|0)>>2]=0,T2[4+b>>2]=0,T2[(b=72+t|0)>>2]=0,T2[4+b>>2]=0,T2[(b=84+t|0)>>2]=0,T2[4+b>>2]=0,T2[80+t>>2]=1065353216,T2[(b=92+t|0)>>2]=0,T2[4+b>>2]=0,T2[(b=104+t|0)>>2]=0,T2[4+b>>2]=0,T2[100+t>>2]=1065353216,T2[(b=112+t|0)>>2]=0,T2[4+b>>2]=0,T2[(b=120+t|0)>>2]=0,T2[4+b>>2]=-581039253,T2[140+t>>2]=0,e=j2[r+8>>2],a=j2[r>>2],n=z2(a*z2(0)),o=j2[r+4>>2],b=z2(o*z2(0)),j2[136+t>>2]=e+z2(n+b),e=z2(e*z2(0)),j2[132+t>>2]=z2(o+n)+e,T2[44+t>>2]=0,T2[48+t>>2]=0,T2[40+t>>2]=9900,T2[60+t>>2]=1065353216,j2[128+t>>2]=z2(a+b)+e,T2[32+t>>2]=1566444395,T2[36+t>>2]=0,T2[24+t>>2]=1566444395,T2[28+t>>2]=1566444395,T2[16+t>>2]=-581039253,T2[20+t>>2]=0,T2[8+t>>2]=-581039253,T2[12+t>>2]=-581039253,n1[T2[T2[f>>2]+64>>2]](f,40+t|0,8+t|0,24+t|0),r=T2[4+i>>2],T2[(f=A+8|0)>>2]=T2[i>>2],T2[f+4>>2]=r,f=T2[48+t>>2],T2[A>>2]=T2[44+t>>2],T2[A+4>>2]=f,L2=144+t|0;},function(A,f,r){n1[T2[T2[(f|=0)>>2]+68>>2]](A|=0,f,r|=0);},_,I,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o=z2(0),b=z2(0),t=0,c=(0);r=A+4|0,b=j2[A+84>>2],i=j2[A+88>>2],a=j2[A+92>>2],n=j2[A+96>>2],b<(o=z2(z2(z2(i*j2[f>>2])+z2(a*j2[f+4>>2]))+z2(n*j2[f+8>>2])))&&(j2[A+84>>2]=o,e=T2[f+4>>2],T2[r>>2]=T2[f>>2],T2[r+4>>2]=e,c=T2[(t=f+8|0)+4>>2],T2[(e=r+8|0)>>2]=T2[t>>2],T2[e+4>>2]=c,b=o),b<(o=z2(z2(z2(i*j2[f+16>>2])+z2(a*j2[f+20>>2]))+z2(n*j2[f+24>>2])))?(j2[A+84>>2]=o,t=T2[(e=f+16|0)+4>>2],T2[r>>2]=T2[e>>2],T2[r+4>>2]=t,c=T2[(e=e+8|0)+4>>2],T2[(t=r+8|0)>>2]=T2[e>>2],T2[t+4>>2]=c):o=b,o<(b=z2(z2(z2(i*j2[f+32>>2])+z2(a*j2[f+36>>2]))+z2(n*j2[f+40>>2])))&&(j2[A+84>>2]=b,f=T2[(A=f+32|0)+4>>2],T2[r>>2]=T2[A>>2],T2[r+4>>2]=f,f=r+8|0,r=T2[(A=A+8|0)+4>>2],T2[f>>2]=T2[A>>2],T2[f+4>>2]=r);},_,I,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i=0,a=z2(0),n=z2(0),o=z2(0),b=z2(0),t=0,a=j2[f>>2],n=j2[f+16>>2],o=j2[f+32>>2];j2[A+24>>2]<((b=a<n?a:n)<o?b:o)||j2[(o<j2[f+(i=!(n<a)<<4)>>2]?i:32)+f>>2]<j2[A+8>>2]||(a=j2[f+8>>2],n=j2[(i=f+24|0)>>2],o=j2[(t=f+40|0)>>2],j2[A+32>>2]<((b=a<n?a:n)<o?b:o)||j2[(o<j2[(i=n<a?f+8|0:i)>>2]?i:t)>>2]<j2[A+16>>2]||(a=j2[f+4>>2],n=j2[(i=f+20|0)>>2],o=j2[(t=f+36|0)>>2],j2[A+28>>2]<((b=a<n?a:n)<o?b:o)||j2[(o<j2[(i=n<a?f+4|0:i)>>2]?i:t)>>2]<j2[A+12>>2]||(A=T2[A+4>>2],n1[T2[T2[A>>2]+8>>2]](A,f,r,e))));},d0,function(A){A=d0(A|=0),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},B0,w0,function(A,f,r){r|=0;var e,i,a=0,n=0,o=0,b=0,t=0;if(j2[(f|=0)+16>>2]=j2[(A|=0)+20>>2],j2[f+20>>2]=j2[A+24>>2],j2[f+24>>2]=j2[A+28>>2],j2[f+28>>2]=j2[A+32>>2],j2[f>>2]=j2[A+4>>2],j2[f+4>>2]=j2[A+8>>2],j2[f+8>>2]=j2[A+12>>2],j2[f+12>>2]=j2[A+16>>2],j2[f+32>>2]=j2[A+36>>2],j2[f+36>>2]=j2[A+40>>2],j2[f+40>>2]=j2[A+44>>2],j2[f+44>>2]=j2[A+48>>2],T2[f+48>>2]=T2[A+56>>2],T2[f+52>>2]=S2[A+60|0],a=T2[A+88>>2],T2[f+56>>2]=a){if(a=0|n1[T2[T2[r>>2]+28>>2]](r,T2[A+96>>2]),T2[f+64>>2]=a){if(o=T2[A+88>>2],t=0|n1[T2[T2[r>>2]+16>>2]](r,48,o),1<=(0|o))for(a=T2[t+8>>2]+44|0,b=40;n=T2[A+96>>2]+b|0,j2[a-28>>2]=j2[n-24>>2],j2[a-24>>2]=j2[n-20>>2],j2[a-20>>2]=j2[n-16>>2],j2[a-16>>2]=j2[n-12>>2],j2[a-44>>2]=j2[n-40>>2],j2[a-40>>2]=j2[n-36>>2],j2[a-36>>2]=j2[n-32>>2],j2[a-32>>2]=j2[n-28>>2],T2[a-12>>2]=T2[n-8>>2],T2[a-8>>2]=T2[n-4>>2],n=T2[n>>2],T2[a>>2]=0,T2[a-4>>2]=n,b=b- -64|0,a=a+48|0,o=o-1|0;);n1[T2[T2[r>>2]+20>>2]](r,t,10164,1497453121,T2[A+96>>2]);}}else T2[f+64>>2]=0;if(a=T2[A+128>>2],T2[f+60>>2]=a){if(a=0|n1[T2[T2[r>>2]+28>>2]](r,T2[A+136>>2]),T2[f+68>>2]=a){if(o=T2[A+128>>2],e=(b=0)|n1[T2[T2[r>>2]+16>>2]](r,16,o),(0|o)<=0)t=T2[A+136>>2];else for(t=T2[A+136>>2],i=T2[8+e>>2];$[(a=b+i|0)+6>>1]=A2[(n=b+t|0)+6>>1],$[a+8>>1]=A2[n+8>>1],$[a+10>>1]=A2[n+10>>1],$[a>>1]=A2[n>>1],$[a+2>>1]=A2[n+2>>1],T2[a+12>>2]=T2[n+12>>2],$[a+4>>1]=A2[n+4>>1],b=b+16|0,o=o-1|0;);n1[T2[T2[r>>2]+20>>2]](r,e,10187,1497453121,t);}}else T2[f+68>>2]=0;if(T2[f+76>>2]=T2[A+144>>2],a=T2[A+152>>2],!(T2[f+80>>2]=a))return T2[f+72>>2]=0,10231;if(a=f,f=0|n1[T2[T2[r>>2]+28>>2]](r,T2[A+160>>2]),T2[a+72>>2]=f){if(b=T2[A+152>>2],n=0|n1[T2[T2[r>>2]+16>>2]](r,20,b),(0|b)<=0)A=T2[A+160>>2];else for(a=(A=T2[A+160>>2])+16|0,f=T2[n+8>>2];$[f+14>>1]=A2[a-10>>1],$[f+16>>1]=A2[a-8>>1],$[f+18>>1]=A2[a-6>>1],$[f+8>>1]=A2[a-16>>1],$[f+10>>1]=A2[a-14>>1],t=T2[(o=a-4|0)+4>>2],T2[f>>2]=T2[o>>2],T2[f+4>>2]=t,$[f+12>>1]=A2[a-12>>1],a=a+32|0,f=f+20|0,b=b-1|0;);n1[T2[T2[r>>2]+20>>2]](r,n,10210,1497453121,A);}return 10231;},function(A,f){var r=0,e=0,i=0,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0;if(L2=c=L2+-64|0,j2[(A|=0)+20>>2]=j2[(f|=0)+16>>2],j2[A+24>>2]=j2[f+20>>2],j2[A+28>>2]=j2[f+24>>2],j2[A+32>>2]=j2[f+28>>2],j2[A+4>>2]=j2[f>>2],j2[A+8>>2]=j2[f+4>>2],j2[A+12>>2]=j2[f+8>>2],j2[A+16>>2]=j2[f+12>>2],j2[A+36>>2]=j2[f+32>>2],j2[A+40>>2]=j2[f+36>>2],j2[A+44>>2]=j2[f+40>>2],j2[A+48>>2]=j2[f+44>>2],T2[A+56>>2]=T2[f+48>>2],p2[A+60|0]=0!=T2[f+52>>2],b=T2[f+56>>2],T2[(r=56+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=48+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=40+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=32+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=24+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=16+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=8+c|0)>>2]=0,T2[r+4>>2]=0,T2[c>>2]=0,((T2[4+c>>2]=0)|(i=T2[A+88>>2]))<(0|b)){if(T2[A+92>>2]<(0|b)){if(b&&(T2[5498]=T2[5498]+1,(r=K2(b<<6|19))&&(T2[(a=r+19&-16)-4>>2]=r)),1<=(0|i))for(r=i;o=T2[A+96>>2]+t|0,k=T2[(n=o)+4>>2],T2[(e=a+t|0)>>2]=T2[n>>2],T2[e+4>>2]=k,k=T2[(n=n+56|0)+4>>2],T2[(u=e+56|0)>>2]=T2[n>>2],T2[u+4>>2]=k,k=T2[(u=o+48|0)+4>>2],T2[(n=e+48|0)>>2]=T2[u>>2],T2[n+4>>2]=k,k=T2[(u=o+40|0)+4>>2],T2[(n=e+40|0)>>2]=T2[u>>2],T2[n+4>>2]=k,k=T2[(u=o+32|0)+4>>2],T2[(n=e+32|0)>>2]=T2[u>>2],T2[n+4>>2]=k,k=T2[(u=o+24|0)+4>>2],T2[(n=e+24|0)>>2]=T2[u>>2],T2[n+4>>2]=k,k=T2[(u=o+16|0)+4>>2],T2[(n=e+16|0)>>2]=T2[u>>2],T2[n+4>>2]=k,n=T2[(o=o+8|0)+4>>2],T2[(e=e+8|0)>>2]=T2[o>>2],T2[e+4>>2]=n,t=t- -64|0,r=r-1|0;);(r=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+96>>2]=a,T2[A+92>>2]=b,p2[A+100|0]=1;}for(r=i<<6,t=b-i|0;a=T2[4+c>>2],i=T2[A+96>>2]+r|0,T2[(e=i)>>2]=T2[c>>2],T2[e+4>>2]=a,o=T2[(a=56+c|0)+4>>2],T2[(e=e+56|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=48+c|0)+4>>2],T2[(e=i+48|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=40+c|0)+4>>2],T2[(e=i+40|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=32+c|0)+4>>2],T2[(e=i+32|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=24+c|0)+4>>2],T2[(e=i+24|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=16+c|0)+4>>2],T2[(e=i+16|0)>>2]=T2[a>>2],T2[e+4>>2]=o,a=T2[(e=8+c|0)+4>>2],T2[(i=i+8|0)>>2]=T2[e>>2],T2[i+4>>2]=a,r=r- -64|0,t=t-1|0;);}if(1<=(0|(T2[A+88>>2]=b)))for(e=T2[f+64>>2]+40|0,r=T2[A+96>>2]+40|0;j2[r-24>>2]=j2[e-24>>2],j2[r-20>>2]=j2[e-20>>2],j2[r-16>>2]=j2[e-16>>2],j2[r-12>>2]=j2[e-12>>2],j2[r-40>>2]=j2[e-40>>2],j2[r-36>>2]=j2[e-36>>2],j2[r-32>>2]=j2[e-32>>2],T2[r-8>>2]=T2[e-8>>2],j2[r-28>>2]=j2[e-28>>2],T2[r-4>>2]=T2[e-4>>2],T2[r>>2]=T2[e>>2],r=r- -64|0,e=e+48|0,b=b-1|0;);if(t=T2[f+60>>2],T2[(r=8+c|0)>>2]=0,T2[r+4>>2]=0,T2[c>>2]=0,((T2[4+c>>2]=0)|(i=T2[A+128>>2]))<(0|t)){if(T2[A+132>>2]<(0|t)){if(a=0,t&&(T2[5498]=T2[5498]+1,(r=K2(19+(t<<4)|0))&&(T2[(a=r+19&-16)-4>>2]=r)),1<=(0|i))for(e=0,r=i;b=T2[A+136>>2]+e|0,u=T2[b+4>>2],T2[(n=o=e+a|0)>>2]=T2[b>>2],T2[n+4>>2]=u,n=T2[(b=b+8|0)+4>>2],T2[(o=o+8|0)>>2]=T2[b>>2],T2[o+4>>2]=n,e=e+16|0,r=r-1|0;);(r=T2[A+136>>2])&&S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+136>>2]=a,T2[A+132>>2]=t,p2[A+140|0]=1;}for(e=i<<4,r=t-i|0;a=T2[4+c>>2],i=T2[A+136>>2]+e|0,T2[i>>2]=T2[c>>2],T2[i+4>>2]=a,a=T2[(b=8+c|0)+4>>2],T2[(i=i+8|0)>>2]=T2[b>>2],T2[i+4>>2]=a,e=e+16|0,r=r-1|0;);}if(1<=(0|(T2[A+128>>2]=t)))for(e=T2[A+136>>2],a=T2[f+68>>2],b=0;$[(r=e+b|0)+6>>1]=A2[(i=a+b|0)+6>>1],$[r+8>>1]=A2[i+8>>1],$[r+10>>1]=A2[i+10>>1],$[r>>1]=A2[i>>1],$[r+2>>1]=A2[i+2>>1],T2[r+12>>2]=T2[i+12>>2],$[r+4>>1]=A2[i+4>>1],b=b+16|0,t=t-1|0;);if(T2[A+144>>2]=T2[f+76>>2],b=T2[f+80>>2],(0|(i=T2[A+152>>2]))<(0|b)){if(T2[A+156>>2]<(0|b)){if(a=0,b&&(T2[5498]=T2[5498]+1,(r=K2(b<<5|19))&&(T2[(a=r+19&-16)-4>>2]=r)),1<=(0|i))for(e=0,r=i;o=T2[A+160>>2]+e|0,k=T2[(n=o)+4>>2],T2[(t=e+a|0)>>2]=T2[n>>2],T2[t+4>>2]=k,k=T2[(n=n+24|0)+4>>2],T2[(u=t+24|0)>>2]=T2[n>>2],T2[u+4>>2]=k,k=T2[(u=o+16|0)+4>>2],T2[(n=t+16|0)>>2]=T2[u>>2],T2[n+4>>2]=k,n=T2[(o=o+8|0)+4>>2],T2[(t=t+8|0)>>2]=T2[o>>2],T2[t+4>>2]=n,e=e+32|0,r=r-1|0;);(r=T2[A+160>>2])&&S2[A+164|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+160>>2]=a,T2[A+156>>2]=b,p2[A+164|0]=1;}for(r=i<<5,t=b-i|0;a=T2[4+c>>2],i=T2[A+160>>2]+r|0,T2[(e=i)>>2]=T2[c>>2],T2[e+4>>2]=a,o=T2[(a=24+c|0)+4>>2],T2[(e=e+24|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=16+c|0)+4>>2],T2[(e=i+16|0)>>2]=T2[a>>2],T2[e+4>>2]=o,a=T2[(e=8+c|0)+4>>2],T2[(i=i+8|0)>>2]=T2[e>>2],T2[i+4>>2]=a,r=r+32|0,t=t-1|0;);}if(1<=(0|(T2[A+152>>2]=b)))for(e=T2[A+160>>2]+16|0,r=T2[f+72>>2];$[e-10>>1]=A2[r+14>>1],$[e-8>>1]=A2[r+16>>1],$[e-6>>1]=A2[r+18>>1],$[e-16>>1]=A2[r+8>>1],$[e-14>>1]=A2[r+10>>1],f=T2[r+4>>2],T2[(A=e-4|0)>>2]=T2[r>>2],T2[A+4>>2]=f,$[e-12>>1]=A2[r+12>>1],e=e+32|0,r=r+20|0,b=b-1|0;);L2=c+64|0;},function(A,f){var r=0,e=0,i=0,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0;if(L2=c=L2+-64|0,j2[(A|=0)+20>>2]=X[(f|=0)+32>>3],j2[A+4>>2]=X[f>>3],j2[A+8>>2]=X[f+8>>3],j2[A+12>>2]=X[f+16>>3],j2[A+16>>2]=X[f+24>>3],j2[A+36>>2]=X[f+64>>3],j2[A+24>>2]=X[f+40>>3],j2[A+28>>2]=X[f+48>>3],j2[A+32>>2]=X[f+56>>3],j2[A+40>>2]=X[f+72>>3],T2[A+56>>2]=T2[f+96>>2],j2[A+44>>2]=X[f+80>>3],j2[A+48>>2]=X[f+88>>3],p2[A+60|0]=0!=T2[f+100>>2],b=T2[f+104>>2],T2[(r=56+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=48+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=40+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=32+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=24+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=16+c|0)>>2]=0,T2[r+4>>2]=0,T2[(r=8+c|0)>>2]=0,T2[r+4>>2]=0,T2[c>>2]=0,((T2[4+c>>2]=0)|(i=T2[A+88>>2]))<(0|b)){if(T2[A+92>>2]<(0|b)){if(b&&(T2[5498]=T2[5498]+1,(r=K2(b<<6|19))&&(T2[(a=r+19&-16)-4>>2]=r)),1<=(0|i))for(r=i;o=T2[A+96>>2]+t|0,k=T2[(n=o)+4>>2],T2[(e=a+t|0)>>2]=T2[n>>2],T2[e+4>>2]=k,k=T2[(n=n+56|0)+4>>2],T2[(u=e+56|0)>>2]=T2[n>>2],T2[u+4>>2]=k,k=T2[(u=o+48|0)+4>>2],T2[(n=e+48|0)>>2]=T2[u>>2],T2[n+4>>2]=k,k=T2[(u=o+40|0)+4>>2],T2[(n=e+40|0)>>2]=T2[u>>2],T2[n+4>>2]=k,k=T2[(u=o+32|0)+4>>2],T2[(n=e+32|0)>>2]=T2[u>>2],T2[n+4>>2]=k,k=T2[(u=o+24|0)+4>>2],T2[(n=e+24|0)>>2]=T2[u>>2],T2[n+4>>2]=k,k=T2[(u=o+16|0)+4>>2],T2[(n=e+16|0)>>2]=T2[u>>2],T2[n+4>>2]=k,n=T2[(o=o+8|0)+4>>2],T2[(e=e+8|0)>>2]=T2[o>>2],T2[e+4>>2]=n,t=t- -64|0,r=r-1|0;);(r=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+96>>2]=a,T2[A+92>>2]=b,p2[A+100|0]=1;}for(r=i<<6,t=b-i|0;a=T2[4+c>>2],i=T2[A+96>>2]+r|0,T2[(e=i)>>2]=T2[c>>2],T2[e+4>>2]=a,o=T2[(a=56+c|0)+4>>2],T2[(e=e+56|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=48+c|0)+4>>2],T2[(e=i+48|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=40+c|0)+4>>2],T2[(e=i+40|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=32+c|0)+4>>2],T2[(e=i+32|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=24+c|0)+4>>2],T2[(e=i+24|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=16+c|0)+4>>2],T2[(e=i+16|0)>>2]=T2[a>>2],T2[e+4>>2]=o,a=T2[(e=8+c|0)+4>>2],T2[(i=i+8|0)>>2]=T2[e>>2],T2[i+4>>2]=a,r=r- -64|0,t=t-1|0;);}if(1<=(0|(T2[A+88>>2]=b)))for(e=T2[f+112>>2]+72|0,r=T2[A+96>>2]+40|0;T2[r-8>>2]=T2[e-8>>2],j2[r-24>>2]=X[e-40>>3],j2[r-20>>2]=X[e-32>>3],j2[r-16>>2]=X[e-24>>3],j2[r-12>>2]=X[e-16>>3],j2[r-40>>2]=X[e-72>>3],j2[r-36>>2]=X[e+-64>>3],j2[r-32>>2]=X[e-56>>3],j2[r-28>>2]=X[e-48>>3],T2[r-4>>2]=T2[e-4>>2],T2[r>>2]=T2[e>>2],r=r- -64|0,e=e+80|0,b=b-1|0;);if(t=T2[f+108>>2],T2[(r=8+c|0)>>2]=0,T2[r+4>>2]=0,T2[c>>2]=0,((T2[4+c>>2]=0)|(i=T2[A+128>>2]))<(0|t)){if(T2[A+132>>2]<(0|t)){if(a=0,t&&(T2[5498]=T2[5498]+1,(r=K2(19+(t<<4)|0))&&(T2[(a=r+19&-16)-4>>2]=r)),1<=(0|i))for(e=0,r=i;b=T2[A+136>>2]+e|0,u=T2[b+4>>2],T2[(n=o=e+a|0)>>2]=T2[b>>2],T2[n+4>>2]=u,n=T2[(b=b+8|0)+4>>2],T2[(o=o+8|0)>>2]=T2[b>>2],T2[o+4>>2]=n,e=e+16|0,r=r-1|0;);(r=T2[A+136>>2])&&S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+136>>2]=a,T2[A+132>>2]=t,p2[A+140|0]=1;}for(e=i<<4,r=t-i|0;a=T2[4+c>>2],i=T2[A+136>>2]+e|0,T2[i>>2]=T2[c>>2],T2[i+4>>2]=a,a=T2[(b=8+c|0)+4>>2],T2[(i=i+8|0)>>2]=T2[b>>2],T2[i+4>>2]=a,e=e+16|0,r=r-1|0;);}if(1<=(0|(T2[A+128>>2]=t)))for(e=T2[A+136>>2],a=T2[f+116>>2],b=0;$[(r=e+b|0)+6>>1]=A2[(i=a+b|0)+6>>1],$[r+8>>1]=A2[i+8>>1],$[r+10>>1]=A2[i+10>>1],$[r>>1]=A2[i>>1],$[r+2>>1]=A2[i+2>>1],T2[r+12>>2]=T2[i+12>>2],$[r+4>>1]=A2[i+4>>1],b=b+16|0,t=t-1|0;);if(T2[A+144>>2]=T2[f+120>>2],b=T2[f+124>>2],(0|(i=T2[A+152>>2]))<(0|b)){if(T2[A+156>>2]<(0|b)){if(a=0,b&&(T2[5498]=T2[5498]+1,(r=K2(b<<5|19))&&(T2[(a=r+19&-16)-4>>2]=r)),1<=(0|i))for(e=0,r=i;o=T2[A+160>>2]+e|0,k=T2[(n=o)+4>>2],T2[(t=e+a|0)>>2]=T2[n>>2],T2[t+4>>2]=k,k=T2[(n=n+24|0)+4>>2],T2[(u=t+24|0)>>2]=T2[n>>2],T2[u+4>>2]=k,k=T2[(u=o+16|0)+4>>2],T2[(n=t+16|0)>>2]=T2[u>>2],T2[n+4>>2]=k,n=T2[(o=o+8|0)+4>>2],T2[(t=t+8|0)>>2]=T2[o>>2],T2[t+4>>2]=n,e=e+32|0,r=r-1|0;);(r=T2[A+160>>2])&&S2[A+164|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+160>>2]=a,T2[A+156>>2]=b,p2[A+164|0]=1;}for(r=i<<5,t=b-i|0;a=T2[4+c>>2],i=T2[A+160>>2]+r|0,T2[(e=i)>>2]=T2[c>>2],T2[e+4>>2]=a,o=T2[(a=24+c|0)+4>>2],T2[(e=e+24|0)>>2]=T2[a>>2],T2[e+4>>2]=o,o=T2[(a=16+c|0)+4>>2],T2[(e=i+16|0)>>2]=T2[a>>2],T2[e+4>>2]=o,a=T2[(e=8+c|0)+4>>2],T2[(i=i+8|0)>>2]=T2[e>>2],T2[i+4>>2]=a,r=r+32|0,t=t-1|0;);}if(1<=(0|(T2[A+152>>2]=b)))for(e=T2[A+160>>2]+16|0,r=T2[f+128>>2];$[e-10>>1]=A2[r+14>>1],$[e-8>>1]=A2[r+16>>1],$[e-6>>1]=A2[r+18>>1],$[e-16>>1]=A2[r+8>>1],$[e-14>>1]=A2[r+10>>1],f=T2[r+4>>2],T2[(A=e-4|0)>>2]=T2[r>>2],T2[A+4>>2]=f,$[e-12>>1]=A2[r+12>>1],e=e+32|0,r=r+20|0,b=b-1|0;);L2=c+64|0;},function(A){return d0(A|=0),0|A;},function(A){d0(A|=0),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f,r,e){return B0(A|=0,f|=0,r|=0,e|=0),1;},I,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u,k,l,s=z2(0),v=z2(0),d=z2(0),B=z2(0),Q=0,g=z2(0),w=0,G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=(0),d=(j2[f+40>>2]),s=j2[f+24>>2],Z=(B=(B=(v=j2[f+8>>2])>z2(-0xde0b6b000000000)?v:z2(-0xde0b6b000000000))<s?s:B)<d?d:B;if(v=v<z2(0xde0b6b000000000)?v:z2(0xde0b6b000000000),c=z2(Z-(G=d<(s=s<v?s:v)?d:s)),B=(d=j2[f+36>>2])<(B=(s=j2[f+20>>2])<(B=(v=j2[f+4>>2])<z2(0xde0b6b000000000)?v:z2(0xde0b6b000000000))?s:B)?d:B,d=(s=(v=v>z2(-0xde0b6b000000000)?v:z2(-0xde0b6b000000000))<s?s:v)<d?d:s,u=(s=j2[f+32>>2])<(D=(v=j2[f+16>>2])<(E=(g=j2[f>>2])<z2(0xde0b6b000000000)?g:z2(0xde0b6b000000000))?v:E),k=(C=(g=g>z2(-0xde0b6b000000000)?g:z2(-0xde0b6b000000000))<v?v:g)<s,f=T2[A+8>>2],v=j2[f+44>>2],g=j2[f+40>>2],E=j2[f+12>>2],o=j2[f+8>>2],b=j2[f+36>>2],t=j2[f+4>>2],i=T2[A+4>>2],(0|(A=T2[i+4>>2]))==T2[i+8>>2]&&!((0|(w=A?A<<1:1))<=(0|A))){if(w&&(T2[5498]=T2[5498]+1,(f=K2(19+(w<<4)|0))&&(T2[(h=f+19&-16)-4>>2]=f)),1<=(0|A))for(f=0;a=T2[i+12>>2]+f|0,n=T2[4+a>>2],T2[(Q=f+h|0)>>2]=T2[a>>2],T2[Q+4>>2]=n,n=T2[4+(a=8+a|0)>>2],T2[(Q=Q+8|0)>>2]=T2[a>>2],T2[Q+4>>2]=n,f=f+16|0,A=A-1|0;);(A=T2[i+12>>2])&&S2[i+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[i+12>>2]=h,p2[i+16|0]=1,T2[i+8>>2]=w,A=T2[i+4>>2];}l=z2(d-B),A=T2[i+12>>2]+(A<<4)|0,T2[A+12>>2]=r<<21|e,D=z2((C=k?s:C)-(s=u?s:D)),f=A,r=c<z2(.0020000000949949026),e=(G=z2(z2((r?z2(G+z2(-.0010000000474974513)):G)-E)*v))<z2(4294967296)&G>=z2(0)?~~G>>>0:0,$[f+4>>1]=65534&e,f=A,e=l<z2(.0020000000949949026),w=(B=z2(z2((e?z2(B+z2(-.0010000000474974513)):B)-o)*g))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,$[f+2>>1]=65534&w,f=A,w=D<z2(.0020000000949949026),Q=(s=z2(z2((w?z2(s+z2(-.0010000000474974513)):s)-t)*b))<z2(4294967296)&s>=z2(0)?~~s>>>0:0,$[f>>1]=65534&Q,Q=A+10|0,f=(s=z2(z2(z2((r?z2(Z+z2(.0010000000474974513)):Z)-E)*v)+z2(1)))<z2(4294967296)&s>=z2(0)?~~s>>>0:0,$[Q>>1]=1|f,r=A+8|0,f=(d=z2(z2(z2((e?z2(d+z2(.0010000000474974513)):d)-o)*g)+z2(1)))<z2(4294967296)&d>=z2(0)?~~d>>>0:0,$[r>>1]=1|f,f=(d=z2(z2(z2((w?z2(C+z2(.0010000000474974513)):C)-t)*b)+z2(1)))<z2(4294967296)&d>=z2(0)?~~d>>>0:0,$[A+6>>1]=1|f,T2[i+4>>2]=T2[i+4>>2]+1;},I,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u,k,l,s,v,d,B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=0,C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=(L2-32|0);if(L2=Z,B=j2[f+28>>2],k=(g=(Q=j2[f+12>>2])>z2(0)?Q:z2(0))<B?B:g,g=j2[f+24>>2],l=(w=(C=j2[f+8>>2])>z2(-0xde0b6b000000000)?C:z2(-0xde0b6b000000000))<g?g:w,w=j2[f+20>>2],s=(D=(E=j2[f+4>>2])>z2(-0xde0b6b000000000)?E:z2(-0xde0b6b000000000))<w?w:D,D=j2[f+16>>2],h=(h=(c=j2[f>>2])>z2(-0xde0b6b000000000)?c:z2(-0xde0b6b000000000))<D?D:h,v=B<(Q=Q<z2(0)?Q:z2(0))?B:Q,d=g<(B=C<z2(0xde0b6b000000000)?C:z2(0xde0b6b000000000))?g:B,w=w<(B=E<z2(0xde0b6b000000000)?E:z2(0xde0b6b000000000))?w:B,E=D<(B=c<z2(0xde0b6b000000000)?c:z2(0xde0b6b000000000))?D:B,B=j2[f+44>>2],Q=j2[f+40>>2],g=j2[f+36>>2],C=j2[f+32>>2],o=T2[A+4>>2],(0|(G=T2[o+4>>2]))==T2[o+8>>2]&&!((0|(u=G?G<<1:1))<=(0|G))){if(f=0,u&&(T2[5498]=T2[5498]+1,(A=K2(u<<6|19))&&(T2[(f=A+19&-16)-4>>2]=A)),1<=(0|G))for(A=0;b=T2[o+12>>2]+A|0,n=T2[4+(i=b)>>2],T2[(a=t=A+f|0)>>2]=T2[i>>2],T2[4+a>>2]=n,n=T2[4+(i=56+i|0)>>2],T2[(a=56+a|0)>>2]=T2[i>>2],T2[4+a>>2]=n,n=T2[4+(a=48+b|0)>>2],T2[(i=48+t|0)>>2]=T2[a>>2],T2[4+i>>2]=n,n=T2[4+(a=40+b|0)>>2],T2[(i=40+t|0)>>2]=T2[a>>2],T2[4+i>>2]=n,n=T2[4+(a=32+b|0)>>2],T2[(i=32+t|0)>>2]=T2[a>>2],T2[4+i>>2]=n,n=T2[4+(a=24+b|0)>>2],T2[(i=24+t|0)>>2]=T2[a>>2],T2[4+i>>2]=n,n=T2[4+(a=16+b|0)>>2],T2[(i=16+t|0)>>2]=T2[a>>2],T2[4+i>>2]=n,i=T2[4+(b=8+b|0)>>2],T2[(t=8+t|0)>>2]=T2[b>>2],T2[4+t>>2]=i,A=A- -64|0,G=G-1|0;);(A=T2[o+12>>2])&&S2[o+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2])),T2[o+12>>2]=f,p2[o+16|0]=1,T2[o+8>>2]=u,G=T2[o+4>>2];}A=T2[o+12>>2]+(G<<6)|0,T2[A+40>>2]=e,T2[A+36>>2]=r,T2[A+32>>2]=-1,j2[A+16>>2]=h<C?C:h,j2[A+12>>2]=B<v?B:v,j2[A+8>>2]=Q<d?Q:d,j2[A+4>>2]=g<w?g:w,j2[A>>2]=C<E?C:E,f=T2[16+Z>>2],T2[A+44>>2]=T2[12+Z>>2],T2[A+48>>2]=f,j2[A+28>>2]=k<B?B:k,j2[A+24>>2]=l<Q?Q:l,j2[A+20>>2]=s<g?g:s,e=T2[(r=20+Z|0)+4>>2],T2[(f=A+52|0)>>2]=T2[r>>2],T2[f+4>>2]=e,T2[A+60>>2]=T2[28+Z>>2],T2[o+4>>2]=T2[o+4>>2]+1,L2=32+Z|0;},function(A){var f;return T2[(A|=0)>>2]=10608,S2[A+69|0]&&(f=T2[A+60>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+60>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),0|A;},function(A){var f;T2[(A|=0)>>2]=10608,S2[A+69|0]&&(f=T2[A+60>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+60>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f){A|=0,f|=0,z2(0);var r=0|n1[T2[T2[A>>2]+28>>2]](A),e=z2(j2[r>>2]-j2[f>>2]),i=z2(e*e);e=z2(j2[4+r>>2]-j2[f+4>>2]),i=z2(i+z2(e*e)),e=z2(j2[8+r>>2]-j2[f+8>>2]),z2(i+z2(e*e))>z2(1.1920928955078125e-7)&&(v0(A,f),S2[A+69|0]&&(f=T2[A+60>>2],n1[T2[T2[f>>2]>>2]](f),(f=T2[A+60>>2])&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]))),T2[5498]=T2[5498]+1,f=0,(r=K2(191))&&(T2[(f=r+19&-16)-4>>2]=r),p2[f+80|0]=1,p2[f+60|0]=0,T2[f+52>>2]=287,T2[f+76>>2]=0,p2[f+100|0]=1,T2[f+68>>2]=0,T2[f+72>>2]=0,T2[f+96>>2]=0,p2[f+120|0]=1,T2[f+88>>2]=0,T2[f+92>>2]=0,T2[f+116>>2]=0,p2[f+140|0]=1,T2[f+108>>2]=0,T2[f+112>>2]=0,T2[f+136>>2]=0,p2[f+164|0]=1,T2[f+144>>2]=0,T2[f+128>>2]=0,T2[f+132>>2]=0,T2[f+160>>2]=0,T2[f+152>>2]=0,T2[f+156>>2]=0,T2[f+168>>2]=0,T2[f+28>>2]=2139095039,T2[f+32>>2]=0,T2[f+20>>2]=2139095039,T2[f+24>>2]=2139095039,T2[f+12>>2]=-8388609,T2[f+16>>2]=0,T2[f+4>>2]=-8388609,T2[f+8>>2]=-8388609,T2[f>>2]=10280,G0(T2[A+60>>2]=f,T2[A+56>>2],S2[A+68|0],A+24|0,A+40|0),p2[A+69|0]=1);},function(A){return 10904;},U2,function(A,f,r){f|=0;var e=0,i=0,a=0,n=0,o=0,b=0,t=0,c=0,e=0|n1[T2[T2[(r|=0)>>2]+40>>2]](r,A|=0),i=0|n1[T2[T2[r>>2]+28>>2]](r,e);return (T2[f>>2]=i)&&n1[T2[T2[r>>2]+48>>2]](r,e),e=T2[A+4>>2],T2[f+8>>2]=0,T2[f+4>>2]=e,e=T2[A+56>>2],n1[T2[T2[e>>2]+56>>2]](e,f+12|0,r),j2[f+52>>2]=j2[A+20>>2],!T2[A+60>>2]||1&n1[T2[T2[r>>2]+52>>2]](r)?(T2[f+40>>2]=0,T2[f+44>>2]=0):(e=0|n1[T2[T2[r>>2]+24>>2]](r,T2[A+60>>2]))?(T2[f+44>>2]=0,T2[f+40>>2]=e):(e=0|n1[T2[T2[r>>2]+28>>2]](r,T2[A+60>>2]),T2[f+44>>2]=0,T2[f+40>>2]=e,e=T2[A+60>>2],n=r,o=0|n1[T2[T2[e>>2]+12>>2]](e),a=T2[T2[r>>2]+16>>2],e=0|n1[a](0|n,0|o,0|(b=1)),i=T2[A+60>>2],n=0|n1[T2[T2[i>>2]+16>>2]](i,T2[(o=e)+8>>2],b=r),c=T2[A+60>>2],a=T2[T2[r>>2]+20>>2],n1[a](0|b,0|o,0|n,0|(t=1213612625),0|c)),!T2[A+64>>2]||2&n1[T2[T2[r>>2]+52>>2]](r)?T2[f+48>>2]=0:(e=0|n1[T2[T2[r>>2]+24>>2]](r,T2[A+64>>2]))?T2[f+48>>2]=e:(a=f,c=0|n1[T2[T2[r>>2]+28>>2]](r,T2[A+64>>2]),T2[a+48>>2]=c,e=T2[A+64>>2],c=r,t=0|n1[T2[T2[e>>2]+8>>2]](e),a=T2[T2[r>>2]+16>>2],e=0|n1[a](0|c,0|t,0|(n=1)),i=T2[A+64>>2],c=0|n1[T2[T2[i>>2]+12>>2]](i,T2[(t=e)+8>>2],n=r),b=T2[A+64>>2],a=T2[T2[r>>2]+20>>2],n1[a](0|n,0|t,0|c,0|(o=1346456916),0|b)),T2[f+56>>2]=0,10880;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u=0,k=0,l=z2(0),s=z2(0),v=0,d=0,B=z2(0),Q=z2(0),g=0,w=z2(0),G=0,C=0,E=0,D=0,h=0;T2[60+(L2=v=L2-80|0)>>2]=0,T2[8+v>>2]=f,T2[v>>2]=10712,T2[4+v>>2]=T2[A+56>>2],u=T2[A+60>>2];A:if(S2[u+60|0]){k=A=v,w=j2[u+28>>2],l=j2[u+12>>2],s=j2[r+8>>2],n=j2[u+44>>2],f=(s=z2(z2((w<(s=s<l?l:s)?w:s)-l)*n))<z2(4294967296)&s>=z2(0)?~~s>>>0:0,$[k+78>>1]=f&=65534,g=A,i=j2[u+24>>2],s=j2[u+8>>2],B=j2[r+4>>2],o=j2[u+40>>2],k=(B=z2(z2((i<(B=B<s?s:B)?i:B)-s)*o))<z2(4294967296)&B>=z2(0)?~~B>>>0:0,$[g+76>>1]=k&=65534,g=A,a=j2[u+20>>2],B=j2[u+4>>2],Q=j2[r>>2],b=j2[u+36>>2],r=(Q=z2(z2((a<(Q=Q<B?B:Q)?a:Q)-B)*b))<z2(4294967296)&Q>=z2(0)?~~Q>>>0:0,$[g+74>>1]=G=65534&r,Q=j2[e+8>>2],r=(l=z2(z2(n*z2((w<(Q=Q<l?l:Q)?w:Q)-l))+z2(1)))<z2(4294967296)&l>=z2(0)?~~l>>>0:0,l=j2[e>>2],w=j2[e+4>>2],$[A+72>>1]=e=1|r,r=(s=z2(z2(o*z2((i<(w=w<s?s:w)?i:w)-s))+z2(1)))<z2(4294967296)&s>=z2(0)?~~s>>>0:0,$[A+70>>1]=g=1|r,A=v,r=(l=z2(z2(b*z2((a<(l=l<B?B:l)?a:l)-B))+z2(1)))<z2(4294967296)&l>=z2(0)?~~l>>>0:0,$[A+68>>1]=C=1|r;f:switch(T2[u+144>>2]){case 0:if(1<=(0|(E=T2[u+56>>2])))for(A=T2[u+136>>2],r=0;u=G>>>0<=A2[A+6>>1]&C>>>0>=A2[A>>1]&f>>>0<=A2[A+10>>1]&e>>>0>=A2[A+4>>1]&k>>>0<=A2[A+8>>1]&g>>>0>=A2[A+2>>1],(h=(0|(D=T2[A+12>>2]))<0)||u&&n1[T2[T2[v>>2]+8>>2]](v,D>>>21|0,2097151&D),A=h&(-1^u)?(r=r-(u=T2[A+12>>2])|0,A-(u<<4)|0):(r=r+1|0,A+16|0),d=d+1|0,(0|r)<(0|E););if(T2[5592]>=(0|d))break A;T2[5592]=d;break A;case 1:if(T2[u+152>>2]<1)break A;for(;;){if(A=T2[u+160>>2]+(D<<5)|0,!(G>>>0>A2[A+6>>1]||C>>>0<A2[A>>1]||f>>>0>A2[A+10>>1]||e>>>0<A2[A+4>>1]||k>>>0>A2[A+8>>1]||g>>>0<A2[A+2>>1])){if((0|(d=T2[A+16>>2]))<1)d=0;else for(c=d+(r=T2[A+12>>2])|0,A=T2[u+136>>2]+(r<<4)|0,d=0;E=G>>>0<=A2[A+6>>1]&C>>>0>=A2[A>>1]&f>>>0<=A2[A+10>>1]&e>>>0>=A2[A+4>>1]&k>>>0<=A2[A+8>>1]&g>>>0>=A2[A+2>>1],(t=(0|(h=T2[A+12>>2]))<0)||E&&n1[T2[T2[v>>2]+8>>2]](v,h>>>21|0,2097151&h),A=(-1^E)&t?(r=r-(E=T2[A+12>>2])|0,A-(E<<4)|0):(r=r+1|0,A+16|0),d=d+1|0,(0|r)<(0|c););T2[5592]>=(0|d)||(T2[5592]=d);}if(!((0|(D=D+1|0))<T2[u+152>>2]))break;}break A;case 2:break f;default:break A;}!function A(f,r,e,i){for(var a,n=0;;){f:{if(!(A2[e>>1]>A2[f+6>>1]||A2[i>>1]<A2[f>>1]||A2[e+4>>1]>A2[f+10>>1]||A2[i+4>>1]<A2[f+4>>1]||A2[e+2>>1]>A2[f+8>>1]||A2[i+2>>1]<A2[f+2>>1])){if((0|(n=T2[f+12>>2]))<0)break f;n1[T2[T2[r>>2]+8>>2]](r,n>>>21|0,2097151&n);}return;}A(n=f+16|0,r,e,i),a=f+32|0,f=-1<(0|(f=T2[f+28>>2]))?a:n-(f<<4)|0;}}(T2[u+136>>2],v,74+v|0,68+v|0);}else {if(1<=(0|(g=T2[u+56>>2])))for(A=T2[u+96>>2],f=0;;){k=0,j2[r>>2]>j2[A+16>>2]||(k=0,j2[e>>2]<j2[A>>2]||(k=1)),d=0,j2[r+8>>2]>j2[A+24>>2]||j2[e+8>>2]<j2[A+8>>2]||(d=k);f:{r:{if(j2[e+4>>2]<j2[A+4>>2]||j2[r+4>>2]>j2[A+20>>2])C=-1==(0|(k=T2[A+32>>2])),d=0;else if((C=-1==(0|(k=T2[A+32>>2])))&d){n1[T2[T2[v>>2]+8>>2]](v,T2[A+36>>2],T2[A+40>>2]),g=T2[u+56>>2];break r;}if(!C&&!d){f=f+k|0,A=(k<<6)+A|0;break f;}}f=f+1|0,A=A- -64|0;}if(G=G+1|0,!((0|f)<(0|g)))break;}T2[5592]>=(0|G)||(T2[5592]=G);}L2=80+v|0;},function(A,f){f|=0;var r,e,i,a,n=0;(n=T2[(A|=0)+60>>2])&&(i=f,a=0|n1[T2[T2[n>>2]+12>>2]](n),e=T2[T2[f>>2]+16>>2],n=0|n1[e](0|i,0|a,1),r=T2[A+60>>2],i=0|n1[T2[T2[r>>2]+16>>2]](r,T2[8+(a=n)>>2],n=f),A=T2[A+60>>2],e=T2[T2[f>>2]+20>>2],n1[e](0|n,0|a,0|i,1213612625,0|A));},function(A,f){f|=0;var r,e,i,a,n=0;(n=T2[(A|=0)+64>>2])&&(i=f,a=0|n1[T2[T2[n>>2]+8>>2]](n),e=T2[T2[f>>2]+16>>2],n=0|n1[e](0|i,0|a,1),r=T2[A+64>>2],i=0|n1[T2[T2[r>>2]+12>>2]](r,T2[8+(a=n)>>2],n=f),A=T2[A+64>>2],e=T2[T2[f>>2]+20>>2],n1[e](0|n,0|a,0|i,1346456916,0|A));},_,I,function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b,t=0,c=0,u=z2(0),k=0,l=z2(0),s=z2(0),v=0,d=z2(0),B=0;L2=k=L2-32|0,T2[A+60>>2]=T2[A+60>>2]+1,v=T2[A+4>>2],n1[T2[T2[v>>2]+16>>2]](v,28+k|0,24+k|0,20+k|0,16+k|0,12+k|0,8+k|0,4+k|0,k,f),v=(e=T2[A+4>>2])+12|0,i=T2[12+k>>2]+P2(T2[8+k>>2],r)|0,a=T2[20+k>>2],o=c=T2[28+k>>2],b=n=T2[16+k>>2];A:{f:{r:{e:{i:{a:{n:{if(3!=(0|(B=T2[k>>2]))){if(2!=(0|B))break n;t=T2[8+i>>2];break a;}if(t=P2(A2[4+i>>1],n)+c|0,t=a?(l=z2(j2[e+8>>2]*z2(X[t+8>>3])),s=z2(j2[e+4>>2]*z2(X[t>>3])),u=z2(X[t+16>>3]),v):(l=z2(j2[t+4>>2]*j2[e+8>>2]),s=z2(j2[t>>2]*j2[e+4>>2]),u=j2[e+12>>2],t+8|0),d=j2[t>>2],T2[A+56>>2]=0,j2[A+48>>2]=l,j2[A+44>>2]=s,j2[A+52>>2]=d*u,t=P2(A2[2+i>>1],n)+c|0,!a)break i;l=z2(j2[e+8>>2]*z2(X[t+8>>3])),s=z2(j2[e+4>>2]*z2(X[t>>3])),u=z2(X[t+16>>3]),t=v;break e;}t=S2[2+i|0];}if(t=P2(t,n)+c|0,t=a?(l=z2(j2[e+8>>2]*z2(X[t+8>>3])),s=z2(j2[e+4>>2]*z2(X[t>>3])),u=z2(X[t+16>>3]),v):(l=z2(j2[t+4>>2]*j2[e+8>>2]),s=z2(j2[t>>2]*j2[e+4>>2]),u=j2[e+12>>2],t+8|0),d=j2[t>>2],T2[A+56>>2]=0,j2[A+48>>2]=l,j2[A+44>>2]=s,j2[A+52>>2]=d*u,2==(0|B))break r;t=S2[1+i|0];break f;}l=z2(j2[t+4>>2]*j2[e+8>>2]),s=z2(j2[t>>2]*j2[e+4>>2]),u=j2[e+12>>2],t=t+8|0;}d=j2[t>>2],T2[A+40>>2]=0,j2[A+32>>2]=l,j2[A+28>>2]=s,j2[A+36>>2]=d*u,c=P2(A2[i>>1],n)+c|0,l=a?(s=z2(j2[e+4>>2]*z2(X[c>>3])),u=z2(X[c+16>>3]),z2(j2[e+8>>2]*z2(X[c+8>>3]))):(v=c+8|0,s=z2(j2[c>>2]*j2[e+4>>2]),u=j2[e+12>>2],z2(j2[c+4>>2]*j2[e+8>>2])),u=z2(j2[v>>2]*u);break A;}t=T2[4+i>>2];}t=o+P2(b,t)|0,t=a?(l=z2(j2[e+8>>2]*z2(X[t+8>>3])),s=z2(j2[e+4>>2]*z2(X[t>>3])),u=z2(X[t+16>>3]),v):(l=z2(j2[t+4>>2]*j2[e+8>>2]),s=z2(j2[t>>2]*j2[e+4>>2]),u=j2[e+12>>2],t+8|0),d=j2[t>>2],T2[A+40>>2]=0,j2[A+32>>2]=l,j2[A+28>>2]=s,j2[A+36>>2]=d*u,t=2!=(0|B)?S2[0|i]:T2[i>>2],c=P2(t,n)+c|0,l=a?(s=z2(j2[e+4>>2]*z2(X[c>>3])),u=z2(X[c+16>>3]),z2(j2[e+8>>2]*z2(X[c+8>>3]))):(v=c+8|0,s=z2(j2[c>>2]*j2[e+4>>2]),u=j2[e+12>>2],z2(j2[c+4>>2]*j2[e+8>>2])),u=z2(j2[v>>2]*u);}j2[A+12>>2]=s,T2[A+24>>2]=0,j2[A+20>>2]=u,j2[A+16>>2]=l,v=T2[A+8>>2],n1[T2[T2[v>>2]+8>>2]](v,A+12|0,f,r),A=T2[A+4>>2],n1[T2[T2[A>>2]+24>>2]](A,f),L2=32+k|0;},I,C0,I,C0,Y2,h2,function(A,f){A|=0,f|=0,z2(0);var r,e,i=0;L2=i=L2-96|0,e=T2[f+4>>2],r=T2[A+100>>2],T2[r+4>>2]=T2[f>>2],T2[r+8>>2]=e,e=T2[(f=f+8|0)+4>>2],T2[(r=r+12|0)>>2]=T2[f>>2],T2[4+r>>2]=e,p2[A+96|0]=1,S2[22256]||(T2[5569]=0,T2[5570]=0,T2[5568]=1065353216,T2[5571]=0,T2[5572]=0,T2[5574]=0,T2[5575]=0,T2[5573]=1065353216,T2[5576]=0,T2[5577]=0,T2[5581]=0,T2[5582]=0,T2[5580]=-1082130432,T2[5578]=1065353216,T2[5579]=0,T2[5583]=0,T2[5584]=0,T2[5586]=0,T2[5587]=0,T2[5585]=-1082130432,T2[5588]=0,T2[5589]=0,T2[5590]=-1082130432,T2[5591]=0,p2[22256]=1),f=d2(i,0,96),n1[T2[T2[A>>2]+76>>2]](A,22272,f,6),i=j2[A+52>>2],j2[A+80>>2]=j2[f>>2]+i,j2[A+64>>2]=j2[f+48>>2]-i,j2[A+84>>2]=i+j2[f+20>>2],j2[A+68>>2]=j2[f+68>>2]-i,j2[A+88>>2]=i+j2[f+40>>2],j2[A+72>>2]=j2[f+88>>2]-i,L2=f+96|0;},function(A){return T2[(A|=0)+100>>2]+4|0;},function(A){return 11437;},i2,function(A,f,r){A|=0,f|=0,r|=0;var e=0,i=z2(0),a=z2(0),n=z2(0),o=z2(0);L2=e=L2-80|0,a=j2[r>>2],n=j2[r+4>>2],o=j2[r+8>>2],i=(i=z2(z2(z2(a*a)+z2(n*n))+z2(o*o)))<z2(9999999747378752e-20)?(n=z2(0),a=z2(1),o=z2(0),z2(0)):(i=z2(z2(1)/z2(_2(i))),o=z2(o*i),n=z2(n*i),a=z2(a*i),j2[r+12>>2]),T2[(r=52+e|0)>>2]=0,T2[r+4>>2]=0,j2[76+e>>2]=i,j2[72+e>>2]=o,j2[68+e>>2]=n,T2[44+e>>2]=0,T2[48+e>>2]=0,T2[40+e>>2]=11384,j2[64+e>>2]=a,T2[60+e>>2]=-581039253,T2[32+e>>2]=1566444395,T2[36+e>>2]=0,T2[24+e>>2]=1566444395,T2[28+e>>2]=1566444395,f=T2[f+100>>2],T2[16+e>>2]=-581039253,T2[20+e>>2]=0,T2[8+e>>2]=-581039253,T2[12+e>>2]=-581039253,n1[T2[T2[f>>2]+8>>2]](f,40+e|0,8+e|0,24+e|0),a=T2[r+4>>2],T2[(f=A+8|0)>>2]=T2[r>>2],T2[f+4>>2]=a,f=T2[48+e>>2],T2[A>>2]=T2[44+e>>2],T2[A+4>>2]=f,L2=80+e|0;},function(A,f,r,e){A|=0,f|=0,r|=0;var i,a,n,o,b=0,t=0,c=0;if(L2=b=L2-80|0,1<=(0|(e|=0))){for(c=r+12|0,t=e;T2[c>>2]=-581039253,c=c+16|0,t=t-1|0;);for(t=40+b|4,c=b+64|0;T2[t>>2]=0,T2[t+4>>2]=0,T2[(i=a=t+8|0)>>2]=0,T2[4+i>>2]=0,i=T2[f+4>>2],T2[c>>2]=T2[f>>2],T2[c+4>>2]=i,o=T2[4+(n=f+8|0)>>2],T2[(i=c+8|0)>>2]=T2[n>>2],T2[4+i>>2]=o,T2[40+b>>2]=11384,T2[60+b>>2]=-581039253,T2[32+b>>2]=1566444395,T2[36+b>>2]=0,T2[24+b>>2]=1566444395,T2[28+b>>2]=1566444395,i=T2[A+100>>2],T2[16+b>>2]=-581039253,T2[20+b>>2]=0,T2[8+b>>2]=-581039253,T2[12+b>>2]=-581039253,n1[T2[T2[i>>2]+8>>2]](i,40+b|0,8+b|0,24+b|0),n=T2[4+a>>2],T2[(i=r+8|0)>>2]=T2[a>>2],T2[4+i>>2]=n,a=T2[t+4>>2],T2[r>>2]=T2[t>>2],T2[r+4>>2]=a,f=f+16|0,r=r+16|0,e=e-1|0;);}L2=80+b|0;},G2,G2,E0,C2,G2,E0,D0,I,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o=z2(0),b=z2(0),t=0,c=(0);r=A+4|0,b=j2[A+20>>2],i=j2[A+24>>2],a=j2[A+28>>2],n=j2[A+32>>2],b<(o=z2(z2(z2(i*j2[f>>2])+z2(a*j2[f+4>>2]))+z2(n*j2[f+8>>2])))&&(j2[A+20>>2]=o,e=T2[f+4>>2],T2[r>>2]=T2[f>>2],T2[r+4>>2]=e,c=T2[(t=f+8|0)+4>>2],T2[(e=r+8|0)>>2]=T2[t>>2],T2[e+4>>2]=c,b=o),b<(o=z2(z2(z2(i*j2[f+16>>2])+z2(a*j2[f+20>>2]))+z2(n*j2[f+24>>2])))?(j2[A+20>>2]=o,t=T2[(e=f+16|0)+4>>2],T2[r>>2]=T2[e>>2],T2[r+4>>2]=t,c=T2[(e=e+8|0)+4>>2],T2[(t=r+8|0)>>2]=T2[e>>2],T2[t+4>>2]=c):o=b,o<(b=z2(z2(z2(i*j2[f+32>>2])+z2(a*j2[f+36>>2]))+z2(n*j2[f+40>>2])))&&(j2[A+20>>2]=b,f=T2[(A=f+32|0)+4>>2],T2[r>>2]=T2[A>>2],T2[r+4>>2]=f,f=r+8|0,r=T2[(A=A+8|0)+4>>2],T2[f>>2]=T2[A>>2],T2[f+4>>2]=r);},_,I2,h0,function(A,f){var r=T2[(f|=0)+4>>2];T2[(A|=0)+24>>2]=T2[f>>2],T2[A+28>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+32|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},function(A){return (A|=0)+24|0;},function(A,f,r){},function(A){return 11568;},E0,Y2,function(A,f,r,e){h2(A|=0,f|=0,r|=0,e|=0);},function(A,f){A|=0,f|=0,z2(0);var r,e,i,a=0;L2=a=L2-96|0,p2[A+96|0]=1,r=j2[f>>2],e=j2[f+4>>2],i=j2[f+8>>2],T2[A+32>>2]=0,j2[A+28>>2]=O2(i),j2[A+24>>2]=O2(e),j2[A+20>>2]=O2(r),S2[22256]||(T2[5569]=0,T2[5570]=0,T2[5568]=1065353216,T2[5571]=0,T2[5572]=0,T2[5574]=0,T2[5575]=0,T2[5573]=1065353216,T2[5576]=0,T2[5577]=0,T2[5581]=0,T2[5582]=0,T2[5580]=-1082130432,T2[5578]=1065353216,T2[5579]=0,T2[5583]=0,T2[5584]=0,T2[5586]=0,T2[5587]=0,T2[5585]=-1082130432,T2[5588]=0,T2[5589]=0,T2[5590]=-1082130432,T2[5591]=0,p2[22256]=1),f=d2(a,0,96),n1[T2[T2[A>>2]+76>>2]](A,22272,f,6),r=j2[A+52>>2],j2[A+80>>2]=r+j2[f>>2],j2[A+64>>2]=j2[f+48>>2]-r,j2[A+84>>2]=r+j2[f+20>>2],j2[A+68>>2]=j2[f+68>>2]-r,j2[A+88>>2]=r+j2[f+40>>2],j2[A+72>>2]=j2[f+88>>2]-r,L2=f+96|0;},function(A){return 11752;},function(A){return T2[(A|=0)+100>>2];},function(A){return (A=T2[(A|=0)+100>>2]-2|0)>>>0<=2?T2[11740+(A<<2)>>2]:0;},function(A,f,r,e){f|=0,r|=0,e|=0;var i=0,a=0;A:{f:{r:{e:{i:{a:switch(T2[(A|=0)+100>>2]-2|0){case 1:n:switch(0|f){case 1:break r;case 0:break e;case 2:break n;default:break i;}break f;case 0:break e;case 2:break a;default:break i;}a:switch(0|f){case 3:f=T2[A+108>>2],T2[r>>2]=T2[A+104>>2],T2[r+4>>2]=f,f=r+8|0,i=T2[(r=A+112|0)+4>>2],T2[f>>2]=T2[r>>2],T2[f+4>>2]=i;break A;case 4:a=T2[(i=A+128|0)+4>>2],T2[(f=r+8|0)>>2]=T2[i>>2],T2[f+4>>2]=a,i=T2[(f=A+120|0)+4>>2],T2[r>>2]=T2[f>>2],T2[r+4>>2]=i;break A;case 2:break f;case 1:break r;case 0:break e;case 5:break a;default:break i;}a=T2[(i=A+144|0)+4>>2],T2[(f=r+8|0)>>2]=T2[i>>2],T2[f+4>>2]=a,i=T2[(f=A+136|0)+4>>2],T2[r>>2]=T2[f>>2],T2[r+4>>2]=i,i=T2[(r=A+160|0)+4>>2],T2[(f=e+8|0)>>2]=T2[r>>2],T2[f+4>>2]=i,f=T2[(A=A+152|0)+4>>2],T2[e>>2]=T2[A>>2],T2[e+4>>2]=f;}return;}return f=T2[A+108>>2],T2[r>>2]=T2[A+104>>2],T2[r+4>>2]=f,f=r+8|0,i=T2[(r=A+112|0)+4>>2],T2[f>>2]=T2[r>>2],T2[f+4>>2]=i,i=T2[(r=A+128|0)+4>>2],T2[(f=e+8|0)>>2]=T2[r>>2],T2[f+4>>2]=i,f=T2[(A=A+120|0)+4>>2],T2[e>>2]=T2[A>>2],void(T2[e+4>>2]=f);}return a=T2[(i=A+128|0)+4>>2],T2[(f=r+8|0)>>2]=T2[i>>2],T2[f+4>>2]=a,i=T2[(f=A+120|0)+4>>2],T2[r>>2]=T2[f>>2],T2[r+4>>2]=i,i=T2[(r=A+144|0)+4>>2],T2[(f=e+8|0)>>2]=T2[r>>2],T2[f+4>>2]=i,f=T2[(A=A+136|0)+4>>2],T2[e>>2]=T2[A>>2],void(T2[e+4>>2]=f);}return a=T2[(i=A+144|0)+4>>2],T2[(f=r+8|0)>>2]=T2[i>>2],T2[f+4>>2]=a,i=T2[(f=A+136|0)+4>>2],T2[r>>2]=T2[f>>2],T2[r+4>>2]=i,i=T2[(r=A+112|0)+4>>2],T2[(f=e+8|0)>>2]=T2[r>>2],T2[f+4>>2]=i,f=T2[A+108>>2],T2[e>>2]=T2[A+104>>2],void(T2[e+4>>2]=f);}i=T2[(r=A+160|0)+4>>2],T2[(f=e+8|0)>>2]=T2[r>>2],T2[f+4>>2]=i,f=T2[(A=A+152|0)+4>>2],T2[e>>2]=T2[A>>2],T2[e+4>>2]=f;},function(A,f,r){var e,i=T2[(f=(A=((f|=0)<<4)+(A|=0)|0)+112|0)+4>>2];T2[(e=(r|=0)+8|0)>>2]=T2[f>>2],T2[4+e>>2]=i,f=T2[(A=A+104|0)+4>>2],T2[r>>2]=T2[A>>2],T2[r+4>>2]=f;},function(A){return 0|(4==(0|(A=T2[(A|=0)+100>>2]))?4:(3==(0|A))<<1);},E0,D0,function(A,f){return 0;},function(A){return T2[(A|=0)>>2]=11796,0|A;},function(A){T2[(A|=0)>>2]=11796,T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0,z2(0);var i=j2[f+56>>2],a=j2[f+36>>2],n=j2[f+40>>2],o=j2[f+52>>2],b=j2[f+20>>2],t=j2[A+120>>2],c=j2[A+28>>2],u=j2[A+44>>2],k=j2[f+24>>2],l=j2[A+124>>2],s=j2[A+32>>2],v=j2[A+48>>2],d=j2[f+32>>2],B=j2[f+48>>2],Q=j2[f>>2],g=j2[f+4>>2],w=j2[f+8>>2],G=j2[f+16>>2],C=j2[A+116>>2],E=j2[A+24>>2],D=j2[A+40>>2],h=z2(n1[T2[T2[A>>2]+48>>2]](A)),f=z2(n1[T2[T2[A>>2]+48>>2]](A)),A=z2(n1[T2[T2[A>>2]+48>>2]](A));T2[r+12>>2]=0,C=z2(z2(C*z2(D-E))*z2(.5)),t=z2(z2(t*z2(u-c))*z2(.5)),c=z2(z2(C*z2(O2(G)))+z2(t*z2(O2(b)))),b=z2(z2(l*z2(v-s))*z2(.5)),c=z2(f+z2(c+z2(b*z2(O2(k))))),j2[r+4>>2]=o-c,u=z2(h+z2(z2(z2(C*z2(O2(Q)))+z2(t*z2(O2(g))))+z2(b*z2(O2(w))))),j2[r>>2]=B-u,C=z2(A+z2(z2(z2(C*z2(O2(d)))+z2(t*z2(O2(a))))+z2(b*z2(O2(n))))),j2[r+8>>2]=i-C,T2[e+12>>2]=0,j2[e+8>>2]=i+C,j2[e+4>>2]=o+c,j2[e>>2]=B+u;},function(A,f){var r=T2[(f|=0)+4>>2];T2[(A|=0)+116>>2]=T2[f>>2],T2[A+120>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+124|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},function(A){return (A|=0)+116|0;},X2,function(A){return 11880;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o=z2(0),b=0,t=z2(0),c=z2(0),u=(0),k=0,l=0,s=0,v=0,d=0,B=0,Q=0;L2=b=L2-48|0,t=j2[A+48>>2],c=j2[A+32>>2],i=z2(z2(1)/j2[A+124>>2]),a=j2[A- -64>>2],l=((o=t<(o=(o=z2(z2(i*j2[e+8>>2])+a))<c?c:o)?t:o)<z2(0)?-.5:.5)+ +o,d=(u=O2(l)<2147483648?~~l:-2147483648)+1|0,l=((o=t<(o=(o=z2(z2(i*j2[r+8>>2])+a))<c?c:o)?t:o)<z2(0)?-.5:.5)+ +o,n=(u=O2(l)<2147483648?~~l:-2147483648)-1|0,t=j2[A+44>>2],c=j2[A+28>>2],i=z2(z2(1)/j2[A+120>>2]),a=j2[A+60>>2],l=((o=t<(o=(o=z2(z2(i*j2[e+4>>2])+a))<c?c:o)?t:o)<z2(0)?-.5:.5)+ +o,B=(u=O2(l)<2147483648?~~l:-2147483648)+1|0,l=((o=t<(o=(o=z2(z2(i*j2[r+4>>2])+a))<c?c:o)?t:o)<z2(0)?-.5:.5)+ +o,u=(u=O2(l)<2147483648?~~l:-2147483648)-1|0,t=j2[A+40>>2],c=j2[A+24>>2],i=z2(z2(1)/j2[A+116>>2]),a=j2[A+56>>2],l=((o=t<(o=(o=z2(z2(i*j2[e>>2])+a))<c?c:o)?t:o)<z2(0)?-.5:.5)+ +o,e=(e=O2(l)<2147483648?~~l:-2147483648)+1|0,l=((o=t<(o=(o=z2(z2(i*j2[r>>2])+a))<c?c:o)?t:o)<z2(0)?-.5:.5)+ +o,r=(r=O2(l)<2147483648?~~l:-2147483648)-1|0,s=T2[A+76>>2]-1|0,v=T2[A+72>>2]-1|0;A:{f:switch(T2[A+112>>2]){case 0:s=(0|d)<(0|s)?d:s,k=0<(0|n)?n:0,v=(0|B)<(0|v)?B:v,Q=0<(0|u)?u:0;break A;case 1:s=(0|d)<(0|s)?d:s,k=0<(0|n)?n:0,v=(0|e)<(0|v)?e:v,Q=0<(0|r)?r:0;break A;case 2:break f;default:break A;}s=(0|B)<(0|s)?B:s,k=0<(0|u)?u:0,v=(0|e)<(0|v)?e:v,Q=0<(0|r)?r:0;}if((0|k)<(0|s))for(;;){if(d=s,(0|v)<=(0|Q))r=k+1|0;else {for(B=1&k,i=z2(0|(u=k+1|0)),a=z2(0|k),r=Q;;){A:{f:{if(!S2[A+108|0]&&(r+k&1||!S2[A+109|0])){if(B)break f;if(!S2[A+110|0])break f;}o=z2(n1[T2[T2[A>>2]+68>>2]](A,r,k));r:{e:switch(T2[A+112>>2]){default:t=j2[4+b>>2],c=j2[b>>2],o=j2[8+b>>2];break r;case 0:T2[12+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break r;case 1:T2[12+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break r;case 2:break e;}T2[12+b>>2]=0,t=z2(a-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}j2[b>>2]=c*j2[A+116>>2],j2[4+b>>2]=t*j2[A+120>>2],j2[8+b>>2]=o*j2[A+124>>2],o=z2(n1[T2[T2[A>>2]+68>>2]](A,r,u));r:{e:switch(T2[A+112>>2]){default:t=j2[20+b>>2],c=j2[16+b>>2],o=j2[24+b>>2];break r;case 0:T2[28+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break r;case 1:T2[28+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break r;case 2:break e;}T2[28+b>>2]=0,t=z2(i-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}j2[16+b>>2]=c*j2[A+116>>2],j2[20+b>>2]=t*j2[A+120>>2],j2[24+b>>2]=o*j2[A+124>>2],o=z2(n1[T2[T2[A>>2]+68>>2]](A,e=r+1|0,u));r:{e:switch(T2[A+112>>2]){default:t=j2[36+b>>2],c=j2[32+b>>2],o=j2[40+b>>2];break r;case 0:T2[44+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break r;case 1:T2[44+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break r;case 2:break e;}T2[44+b>>2]=0,t=z2(i-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}j2[32+b>>2]=c*j2[A+116>>2],j2[36+b>>2]=t*j2[A+120>>2],j2[40+b>>2]=o*j2[A+124>>2],n1[T2[T2[f>>2]+8>>2]](f,b,r,k),o=z2(n1[T2[T2[A>>2]+68>>2]](A,e,u));r:{e:switch(T2[A+112>>2]){default:t=j2[20+b>>2],c=j2[16+b>>2],o=j2[24+b>>2];break r;case 0:T2[28+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break r;case 1:T2[28+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break r;case 2:break e;}T2[28+b>>2]=0,t=z2(i-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}j2[16+b>>2]=c*j2[A+116>>2],j2[20+b>>2]=t*j2[A+120>>2],j2[24+b>>2]=o*j2[A+124>>2],o=z2(n1[T2[T2[A>>2]+68>>2]](A,e,k));r:{e:switch(T2[A+112>>2]){default:t=j2[36+b>>2],c=j2[32+b>>2],o=j2[40+b>>2];break r;case 0:T2[44+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break r;case 1:T2[44+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break r;case 2:break e;}T2[44+b>>2]=0,t=z2(a-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}break A;}o=z2(n1[T2[T2[A>>2]+68>>2]](A,r,k));f:{r:switch(T2[A+112>>2]){default:t=j2[4+b>>2],c=j2[b>>2],o=j2[8+b>>2];break f;case 0:T2[12+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break f;case 1:T2[12+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break f;case 2:break r;}T2[12+b>>2]=0,t=z2(a-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}j2[b>>2]=c*j2[A+116>>2],j2[4+b>>2]=t*j2[A+120>>2],j2[8+b>>2]=o*j2[A+124>>2],o=z2(n1[T2[T2[A>>2]+68>>2]](A,r,u));f:{r:switch(T2[A+112>>2]){default:t=j2[20+b>>2],c=j2[16+b>>2],o=j2[24+b>>2];break f;case 0:T2[28+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break f;case 1:T2[28+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break f;case 2:break r;}T2[28+b>>2]=0,t=z2(i-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|r)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}j2[16+b>>2]=c*j2[A+116>>2],j2[20+b>>2]=t*j2[A+120>>2],j2[24+b>>2]=o*j2[A+124>>2],o=z2(n1[T2[T2[A>>2]+68>>2]](A,e=r+1|0,k));f:{r:switch(T2[A+112>>2]){default:t=j2[36+b>>2],c=j2[32+b>>2],o=j2[40+b>>2];break f;case 0:T2[44+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break f;case 1:T2[44+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break f;case 2:break r;}T2[44+b>>2]=0,t=z2(a-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}j2[32+b>>2]=c*j2[A+116>>2],j2[36+b>>2]=t*j2[A+120>>2],j2[40+b>>2]=o*j2[A+124>>2],n1[T2[T2[f>>2]+8>>2]](f,b,r,k),o=z2(n1[T2[T2[A>>2]+68>>2]](A,e,k));f:{r:switch(T2[A+112>>2]){default:t=j2[4+b>>2],c=j2[b>>2],o=j2[8+b>>2];break f;case 0:T2[12+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break f;case 1:T2[12+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(a-z2(j2[A+92>>2]*z2(.5)));break f;case 2:break r;}T2[12+b>>2]=0,t=z2(a-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}j2[b>>2]=c*j2[A+116>>2],j2[4+b>>2]=t*j2[A+120>>2],j2[8+b>>2]=o*j2[A+124>>2],o=z2(n1[T2[T2[A>>2]+68>>2]](A,e,u));f:{r:switch(T2[A+112>>2]){default:t=j2[36+b>>2],c=j2[32+b>>2],o=j2[40+b>>2];break f;case 0:T2[44+b>>2]=0,c=z2(o-j2[A+56>>2]),t=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break f;case 1:T2[44+b>>2]=0,t=z2(o-j2[A+60>>2]),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(i-z2(j2[A+92>>2]*z2(.5)));break f;case 2:break r;}T2[44+b>>2]=0,t=z2(i-z2(j2[A+92>>2]*z2(.5))),c=z2(z2(0|e)-z2(j2[A+88>>2]*z2(.5))),o=z2(o-j2[A+64>>2]);}}if(j2[32+b>>2]=c*j2[A+116>>2],j2[36+b>>2]=t*j2[A+120>>2],j2[40+b>>2]=o*j2[A+124>>2],n1[T2[T2[f>>2]+8>>2]](f,b,r,k),(0|v)==(0|(r=e)))break;}r=u;}if((0|d)==(0|(k=r)))break;}L2=48+b|0;},function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0);A:switch(T2[A+104>>2]){case 0:return z2(j2[T2[A+100>>2]+(P2(T2[A+72>>2],r)+f<<2)>>2]);case 5:return z2(z2(j2[A+96>>2]*z2(S2[T2[A+100>>2]+(P2(T2[A+72>>2],r)+f|0)|0])));case 3:e=z2(j2[A+96>>2]*z2($[T2[A+100>>2]+(P2(T2[A+72>>2],r)+f<<1)>>1]));break;default:break A;}return z2(e);},I2,h0,function(A,f,r){A|=0,f=z2(f),r|=0,z2(0);var e=z2(n1[T2[T2[A>>2]+48>>2]](A)),A=z2(n1[T2[T2[A>>2]+48>>2]](A));T2[r+12>>2]=0,f=z2(A*z2(e*z2(f*z2(.4000000059604645)))),j2[r+8>>2]=f,j2[r+4>>2]=f,j2[r>>2]=f;},function(A){return 11920;},w2,function(A){return z2(z2(j2[(A|=0)+36>>2]*j2[A+20>>2]));},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n=z2(0),o=z2(0),b=z2(0),t=0;L2=t=L2-16|0,n1[T2[T2[f>>2]+68>>2]](t,f,r),i=T2[4+(a=8+t|0)>>2],T2[(e=A+8|0)>>2]=T2[a>>2],T2[4+e>>2]=i,i=T2[4+t>>2],T2[A>>2]=T2[t>>2],T2[A+4>>2]=i,o=j2[r+4>>2],n=j2[r>>2],b=j2[r+8>>2],i=z2(n1[T2[T2[f>>2]+48>>2]](f)),r=n=(f=z2(z2(z2(n*n)+z2(o*o))+z2(b*b))<z2(14210854715202004e-30))?z2(-1):n,b=f?z2(-1):b,o=f?z2(-1):o,n=z2(z2(1)/z2(_2(z2(z2(b*b)+z2(z2(n*n)+z2(o*o)))))),j2[A>>2]=j2[A>>2]+z2(i*z2(r*n)),j2[A+4>>2]=j2[A+4>>2]+z2(i*z2(o*n)),j2[e>>2]=j2[e>>2]+z2(i*z2(b*n)),L2=16+t|0;},function(A,f,r){T2[(A|=0)>>2]=0,T2[A+4>>2]=0,T2[(A=A+8|0)>>2]=0,T2[A+4>>2]=0;},function(A,f,r,e){r|=0,1<=(0|(e|=0))&&d2(r,0,e<<4);},function(A){o0(A|=0),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},_,I,J0,_,I,x0,_,I,C2,C2,function(A,f,r,e){var i,a;A|=0,f|=0,r|=0,e=z2(e),j2[A+36>>2]>e&&(p2[A+40|0]=1,i=T2[f+4>>2],T2[A+4>>2]=T2[f>>2],T2[A+8>>2]=i,a=T2[(f=f+8|0)+4>>2],T2[(i=A+12|0)>>2]=T2[f>>2],T2[4+i>>2]=a,f=T2[r+4>>2],T2[A+20>>2]=T2[r>>2],T2[A+24>>2]=f,i=T2[(r=r+8|0)+4>>2],T2[(f=A+28|0)>>2]=T2[r>>2],T2[f+4>>2]=i,j2[A+36>>2]=e);},I,function(A,f,r){f|=0,T2[(A|=0)+24>>2]=r|=0,T2[A+16>>2]=f;},function(A,f,r){f|=0,T2[(A|=0)+28>>2]=r|=0,T2[A+20>>2]=f;},function(A,f,r,e){A|=0,f|=0,r|=0,e=z2(e);var i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q=0,g=0,w=0,G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=z2(0),Y=z2(0),R=0,F=0,W=0,m=0,N=(z2(0)),V=z2(0);L2=Q=L2-208|0,F=T2[A+4>>2];A:if(!((i=j2[F+848>>2])<e)){if(h=j2[r+8>>2],G=z2(z2(j2[f+8>>2]*e)+h),a=j2[r+4>>2],D=z2(z2(j2[f+4>>2]*e)+a),n=j2[r>>2],Z=z2(z2(j2[f>>2]*e)+n),W=T2[A+8>>2],Y=((m=(0|(g=T2[W+8>>2]))==(0|(w=T2[F+836>>2])))?(Y=z2(Z-j2[w+52>>2]),C=z2(D-j2[w+56>>2]),E=z2(G-j2[w+60>>2]),N=z2(z2(z2(Y*j2[w+12>>2])+z2(C*j2[w+28>>2]))+z2(E*j2[w+44>>2])),V=z2(z2(z2(Y*j2[w+8>>2])+z2(C*j2[w+24>>2]))+z2(E*j2[w+40>>2])),R=T2[A+12>>2],g=T2[R+8>>2]):(R=T2[A+12>>2],w=T2[R+8>>2],Y=z2(Z-j2[w+52>>2]),C=z2(D-j2[w+56>>2]),E=z2(G-j2[w+60>>2]),N=z2(z2(z2(Y*j2[w+12>>2])+z2(C*j2[w+28>>2]))+z2(E*j2[w+44>>2])),V=z2(z2(z2(Y*j2[w+8>>2])+z2(C*j2[w+24>>2]))+z2(E*j2[w+40>>2]))),z2(z2(z2(Y*j2[w+4>>2])+z2(C*j2[w+20>>2]))+z2(E*j2[w+36>>2]))),o=j2[g+20>>2],b=j2[g+36>>2],t=j2[g+40>>2],c=j2[g+8>>2],u=j2[g+24>>2],k=j2[g+44>>2],l=j2[g+60>>2],C=j2[g+12>>2],E=j2[g+52>>2],s=j2[g+28>>2],v=j2[g+56>>2],d=j2[g+4>>2],T2[28+Q>>2]=0,T2[(g=92+Q|0)>>2]=0,T2[g+4>>2]=0,T2[(g=124+Q|0)>>2]=0,T2[g+4>>2]=0,T2[(g=132+Q|0)>>2]=0,T2[g+4>>2]=0,T2[(g=140+Q|0)>>2]=0,T2[g+4>>2]=0,T2[(g=148+Q|0)>>2]=0,T2[g+4>>2]=0,T2[(g=156+Q|0)>>2]=0,T2[g+4>>2]=0,T2[164+Q>>2]=0,B=T2[(w=f+8|0)+4>>2],T2[(g=72+Q|0)>>2]=T2[w>>2],T2[g+4>>2]=B,B=C,C=z2(n-E),E=z2(a-v),h=z2(h-l),j2[24+Q>>2]=z2(z2(B*C)+z2(s*E))+z2(k*h),j2[20+Q>>2]=z2(z2(C*c)+z2(E*u))+z2(h*t),T2[12+Q>>2]=0,j2[8+Q>>2]=N,j2[4+Q>>2]=V,j2[Q>>2]=Y,T2[84+Q>>2]=0,T2[88+Q>>2]=0,j2[80+Q>>2]=e,T2[116+Q>>2]=0,T2[120+Q>>2]=0,g=T2[f+4>>2],T2[64+Q>>2]=T2[f>>2],T2[68+Q>>2]=g,j2[16+Q>>2]=z2(z2(C*d)+z2(E*o))+z2(h*b),T2[60+Q>>2]=0,j2[56+Q>>2]=G,j2[52+Q>>2]=D,w=T2[(g=r+8|0)+4>>2],T2[(f=40+Q|0)>>2]=T2[g>>2],T2[f+4>>2]=w,j2[48+Q>>2]=Z,f=T2[r+4>>2],T2[32+Q>>2]=T2[r>>2],T2[36+Q>>2]=f,A=m?(w=A+28|0,f=A+24|0,r=A+20|0,m=A+16|0,g=(A=T2[W>>2])||W,(A=T2[R>>2])||R):(w=A+24|0,f=A+28|0,r=A+16|0,m=A+20|0,g=(A=T2[R>>2])||R,(A=T2[W>>2])||W),g=T2[g+4>>2],A=T2[A+4>>2],T2[204+Q>>2]=A,w=T2[w>>2],T2[112+Q>>2]=w,f=T2[f>>2],T2[108+Q>>2]=f,T2[104+Q>>2]=T2[r>>2],T2[100+Q>>2]=T2[m>>2],T2[200+Q>>2]=g,31==T2[g+4>>2]&&(g=T2[64+(T2[g+32>>2]+P2(f,80)|0)>>2],T2[200+Q>>2]=g),31==T2[A+4>>2]&&(A=T2[64+(T2[A+32>>2]+P2(w,80)|0)>>2],T2[204+Q>>2]=A),r=Q,e=(f=T2[g+16>>2])&&(A=T2[A+16>>2])?(j2[96+Q>>2]=j2[f>>2]*j2[A>>2],e=j2[f+4>>2],G=j2[A+4>>2],j2[84+Q>>2]=F2(z2(H2(z2(e*G),z2(-10))),z2(10)),j2[88+Q>>2]=F2(z2(H2(z2(z2(G*j2[f+8>>2])+z2(e*j2[A+8>>2])),z2(-10))),z2(10)),z2(F2(z2(H2(z2(z2(G*j2[f+12>>2])+z2(e*j2[A+12>>2])),z2(-10))),z2(10)))):(A=T2[W+8>>2],f=T2[R+8>>2],j2[96+Q>>2]=j2[A+232>>2]*j2[f+232>>2],e=j2[A+228>>2],G=j2[f+228>>2],j2[84+Q>>2]=F2(z2(H2(z2(e*G),z2(-10))),z2(10)),j2[88+Q>>2]=F2(z2(H2(z2(z2(G*j2[A+236>>2])+z2(e*j2[f+236>>2])),z2(-10))),z2(10)),z2(F2(z2(H2(z2(z2(G*j2[A+240>>2])+z2(e*j2[f+240>>2])),z2(-10))),z2(10)))),j2[r+92>>2]=e,e=j2[72+Q>>2],z2(O2(e))>z2(.7071067690849304)?(D=j2[68+Q>>2],Z=z2(z2(e*e)+z2(D*D)),G=z2(z2(1)/z2(_2(Z))),Z=z2(Z*G),h=j2[64+Q>>2],C=z2(G*z2(-e)),E=z2(h*C),e=z2(D*G),D=z2(e*z2(-h)),h=z2(0)):(Z=j2[64+Q>>2],D=j2[68+Q>>2],C=z2(z2(Z*Z)+z2(D*D)),G=z2(z2(1)/z2(_2(C))),E=z2(C*G),h=z2(G*z2(-D)),D=z2(e*h),C=z2(Z*G),Z=z2(C*z2(-e)),e=z2(0)),j2[192+Q>>2]=E,j2[188+Q>>2]=D,j2[176+Q>>2]=e,j2[172+Q>>2]=C,j2[184+Q>>2]=Z,j2[168+Q>>2]=h,!((0|(r=T2[F+844>>2]))<1)){for(g=F+12|0,e=z2(i*i),A=0,w=-1;G=z2(j2[g-8>>2]-Y),C=z2(G*G),G=z2(j2[g-4>>2]-V),C=z2(C+z2(G*G)),G=z2(j2[g>>2]-N),e=(f=(G=z2(C+z2(G*G)))<e)?G:e,w=f?A:w,g=g+208|0,(0|r)!=(0|(A=A+1|0)););if(!((0|w)<0)){A=F+P2(w,208)|0,g=T2[(r=A+120|0)>>2],w=T2[(f=A+136|0)+4>>2],R=T2[f>>2],e=j2[(F=A+144|0)>>2],m=T2[(W=A+168|0)>>2],$2(A+4|0,Q,208),T2[W>>2]=m,j2[F>>2]=e,T2[f>>2]=R,T2[f+4>>2]=w,T2[r>>2]=g;break A;}}W0(F,Q);}L2=208+Q|0;},_,I,function(A,f,r,e){var i;return A|=0,r|=0,e|=0,r=T2[(f|=0)>>2],r=0|n1[T2[T2[r>>2]+56>>2]](r,72),p2[r+60|0]=0,p2[r+52|0]=0,T2[r+36>>2]=0,T2[r+40>>2]=0,e=T2[A+12>>2],i=T2[A+16>>2],T2[r+4>>2]=T2[f>>2],p2[r+28|0]=1,T2[r+8>>2]=T2[A+8>>2],T2[r>>2]=12600,T2[r+24>>2]=0,p2[r+48|0]=1,T2[r+16>>2]=0,T2[r+20>>2]=0,T2[r+44>>2]=0,T2[r+64>>2]=e,T2[r+68>>2]=i,T2[r+56>>2]=T2[f+4>>2],0|r;},function(A){var f,r=0;return T2[(A|=0)>>2]=12600,S2[A+52|0]&&(r=T2[A+56>>2])&&(f=T2[A+4>>2],n1[T2[T2[f>>2]+16>>2]](f,r)),(r=T2[A+44>>2])&&S2[A+48|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+44>>2]=0,p2[A+48|0]=1,T2[(r=A+36|0)>>2]=0,T2[r+4>>2]=0,(r=T2[A+24>>2])&&S2[A+28|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+24>>2]=0,p2[A+28|0]=1,T2[(r=A+16|0)>>2]=0,(T2[r+4>>2]=0)|A;},function(A){var f,r=0;T2[(A|=0)>>2]=12600,S2[A+52|0]&&(r=T2[A+56>>2])&&(f=T2[A+4>>2],n1[T2[T2[f>>2]+16>>2]](f,r)),(r=T2[A+44>>2])&&S2[A+48|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+44>>2]=0,p2[A+48|0]=1,T2[(r=A+36|0)>>2]=0,T2[r+4>>2]=0,(r=T2[A+24>>2])&&S2[A+28|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),u(A);},function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W=0,m=0,N=z2(0),V=0,J=z2(0),M=z2(0),I=0,x=z2(0),y=0,U=0,X=0,p=0,T=z2(0),S=0,j=z2(0),P=z2(0),z=z2(0),O=z2(0),H=0,_=0,L=0,K=0,q=z2(0),$=z2(0),A2=z2(0),f2=0,r2=z2(0),e2=z2(0),i2=z2(0),a2=z2(0),n2=z2(0),o2=z2(0),b2=z2(0),t2=z2(0),c2=z2(0),u2=0,k2=z2(0),l2=z2(0),s2=z2(0),v2=0,d2=z2(0),B2=z2(0),Q2=z2(0),g2=z2(0),w2=z2(0),G2=z2(0),C2=z2(0),E2=z2(0),D2=z2(0),h2=z2(0),Z2=(z2(0)),Y2=z2(0),R2=(z2(0));L2=W=L2-976|0,(I=T2[A+56>>2])||(m=T2[A+4>>2],I=0|n1[T2[T2[m>>2]+12>>2]](m,T2[f+8>>2],T2[r+8>>2]),p2[A+52|0]=1,T2[A+56>>2]=I),T2[i+4>>2]=I,X=T2[r+4>>2];A:{f:{r:{e:switch(H=T2[f+4>>2],T2[H+4>>2]-8|0){case 0:break r;case 2:break e;default:break f;}e:switch(T2[X+4>>2]-8|0){case 2:if(A=T2[H+60>>2],N=j2[(e=H+36|0)+(A<<2)>>2],M=j2[e+((A+2|0)%3<<2)>>2],e=T2[X+60>>2],J=j2[I+848>>2],(N=y0(400+W|0,8+W|0,N,M,j2[(m=X+36|0)+(e<<2)>>2],j2[m+((e+2|0)%3<<2)>>2],A,e,T2[f+12>>2],T2[r+12>>2],J))<J&&n1[T2[T2[i>>2]+16>>2]](i,400+W|0,8+W|0,N),A=T2[i+4>>2],!T2[A+844>>2])break A;if((0|(f=T2[A+836>>2]))!=(0|(r=T2[T2[i+8>>2]+8>>2]))){m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0);break A;}m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0);break A;case 0:break e;default:break f;}if(A=T2[H+60>>2],J=j2[I+848>>2],(N=y0(400+W|0,8+W|0,j2[(e=H+36|0)+(A<<2)>>2],j2[e+((A+2|0)%3<<2)>>2],z2(0),z2(j2[X+36>>2]*j2[X+20>>2]),A,1,T2[f+12>>2],T2[r+12>>2],J))<J&&n1[T2[T2[i>>2]+16>>2]](i,400+W|0,8+W|0,N),A=T2[i+4>>2],!T2[A+844>>2])break A;if((0|(f=T2[A+836>>2]))!=(0|(r=T2[T2[i+8>>2]+8>>2]))){m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0);break A;}m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0);break A;}if(10==T2[X+4>>2]){if(e=X+36|0,A=T2[X+60>>2],J=j2[I+848>>2],(N=y0(400+W|0,8+W|0,z2(0),z2(j2[H+36>>2]*j2[H+20>>2]),j2[e+(A<<2)>>2],j2[e+((A+2|0)%3<<2)>>2],1,A,T2[f+12>>2],T2[r+12>>2],J))<J&&n1[T2[T2[i>>2]+16>>2]](i,400+W|0,8+W|0,N),A=T2[i+4>>2],!T2[A+844>>2])break A;if((0|(f=T2[A+836>>2]))!=(0|(r=T2[T2[i+8>>2]+8>>2]))){m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0);break A;}m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0);break A;}}T2[888+W>>2]=1566444395,p2[732+W|0]=0,T2[708+W>>2]=953267991,T2[(m=332+W|0)>>2]=0,T2[m+4>>2]=0,T2[320+W>>2]=12272,T2[352+W>>2]=X,T2[348+W>>2]=H,T2[324+W>>2]=0,T2[328+W>>2]=1065353216,T2[340+W>>2]=T2[A+8>>2],T2[356+W>>2]=T2[H+4>>2],T2[360+W>>2]=T2[X+4>>2],T2[344+W>>2]=400+W,R=W,F=z2(n1[T2[T2[H>>2]+48>>2]](H)),j2[364+R>>2]=F,N=z2(n1[T2[T2[X>>2]+48>>2]](X)),T2[392+W>>2]=1,T2[396+W>>2]=1,T2[380+W>>2]=-1,p2[372+W|0]=0,j2[368+W>>2]=N,T2[352+W>>2]=X,T2[348+W>>2]=H,N=z2(z2(z2(z2(n1[T2[T2[H>>2]+48>>2]](H))+z2(n1[T2[T2[X>>2]+48>>2]](X)))+j2[T2[A+56>>2]+848>>2])+j2[i+32>>2]),j2[888+W>>2]=N*N,m=T2[f+12>>2],y=T2[(I=m+8|0)>>2],I=T2[I+4>>2],V=T2[m>>2],U=T2[m+4>>2],L=T2[(_=m+24|0)+4>>2],T2[(S=784+W|0)>>2]=T2[_>>2],T2[S+4>>2]=L,T2[(S=768+W|0)>>2]=y,T2[S+4>>2]=I,I=T2[m+16>>2],y=T2[m+20>>2],L=T2[(_=m+40|0)+4>>2],T2[(S=800+W|0)>>2]=T2[_>>2],T2[S+4>>2]=L,S=T2[m+32>>2],_=T2[m+36>>2],u2=T2[(K=m+56|0)+4>>2],T2[(L=816+W|0)>>2]=T2[K>>2],T2[L+4>>2]=u2,T2[776+W>>2]=I,T2[780+W>>2]=y,T2[760+W>>2]=V,T2[764+W>>2]=U,T2[792+W>>2]=S,T2[796+W>>2]=_,I=T2[m+52>>2],T2[808+W>>2]=T2[m+48>>2],T2[812+W>>2]=I,m=T2[r+12>>2],V=T2[(y=m+8|0)+4>>2],T2[(I=832+W|0)>>2]=T2[y>>2],T2[I+4>>2]=V,I=T2[m+4>>2],T2[824+W>>2]=T2[m>>2],T2[828+W>>2]=I,y=T2[m+20>>2],T2[(I=U=840+W|0)>>2]=T2[m+16>>2],T2[I+4>>2]=y,V=T2[(y=m+24|0)+4>>2],T2[(I=848+W|0)>>2]=T2[y>>2],T2[I+4>>2]=V,y=T2[m+36>>2],T2[(I=S=856+W|0)>>2]=T2[m+32>>2],T2[I+4>>2]=y,V=T2[(y=m+40|0)+4>>2],T2[(I=864+W|0)>>2]=T2[y>>2],T2[I+4>>2]=V,y=T2[m+52>>2],T2[(I=_=872+W|0)>>2]=T2[m+48>>2],T2[I+4>>2]=y,y=T2[(m=m+56|0)+4>>2],T2[(I=880+W|0)>>2]=T2[m>>2],T2[I+4>>2]=y;f:{r:{e:{if(!(6<(0|(I=T2[H+4>>2])))&&!(6<(0|(m=T2[X+4>>2])))&&(T2[312+W>>2]=12708,N=z2(0),I&&(J=z2(n1[T2[T2[H>>2]+48>>2]](H)),m=T2[X+4>>2]),m&&(N=z2(n1[T2[T2[X>>2]+48>>2]](X))),p2[44+W|0]=0,j2[36+W>>2]=N,j2[32+W>>2]=J,T2[12+W>>2]=i,T2[8+W>>2]=12736,L=T2[H+60>>2])){if(K=T2[X+60>>2]){if(R2=j2[T2[A+56>>2]+848>>2],S2[e+24|0]){if(T2[5606]=T2[5606]+1,M=j2[L+64>>2],V=T2[f+12>>2],N=j2[V+32>>2],T=j2[L+68>>2],J=j2[V+36>>2],z=j2[L+72>>2],x=j2[V+40>>2],j=j2[K+64>>2],U=T2[r+12>>2],q=j2[K+68>>2],P=j2[K+72>>2],G2=z2(z2(z2(z2(z2(M*N)+z2(T*J))+z2(z*x))+j2[V+56>>2])-z2(z2(z2(z2(j*j2[U+32>>2])+z2(q*j2[U+36>>2]))+z2(P*j2[U+40>>2]))+j2[U+56>>2])),O=j2[V+16>>2],b2=j2[V+20>>2],t2=j2[V+24>>2],C2=z2(z2(z2(z2(z2(M*O)+z2(T*b2))+z2(z*t2))+j2[V+52>>2])-z2(z2(z2(z2(j*j2[U+16>>2])+z2(q*j2[U+20>>2]))+z2(P*j2[U+24>>2]))+j2[U+52>>2])),c2=j2[V+4>>2],$=j2[V+8>>2],E2=z2(z2(z2(z2(z2(M*j2[V>>2])+z2(T*c2))+z2(z*$))+j2[V+48>>2])-z2(z2(z2(z2(j*j2[U>>2])+z2(q*j2[U+4>>2]))+z2(P*j2[U+8>>2]))+j2[U+48>>2])),(0|(e=T2[L+28>>2]))<1){T=z2(34028234663852886e22);break e;}for(e=e-1|0,T=z2(34028234663852886e22),_=28;;){if(m=T2[L+36>>2]+_|0,M=j2[m>>2],z=j2[m-8>>2],j=j2[m-4>>2],T2[908+W>>2]=0,N=z2(z2(z2(z*N)+z2(j*J))+z2(M*x)),j2[904+W>>2]=N,J=z2(z2(z2(z*O)+z2(j*b2))+z2(M*t2)),j2[900+W>>2]=J,M=z2(z2(z2(z*j2[V>>2])+z2(j*c2))+z2(M*$)),j2[896+W>>2]=M,z2(z2(z2(M*E2)+z2(J*C2))+z2(N*G2))<z2(0)&&(N=z2(-N),j2[904+W>>2]=N,J=z2(-J),j2[900+W>>2]=J,M=z2(-M),j2[896+W>>2]=M),T2[5607]=T2[5607]+1,M0(V,U,E2,C2,G2,M,J,N,L,K,T)){if(S=0,T2[5608]=T2[5608]+1,N2(L,V,896+W|0,972+W|0,968+W|0,248+W|0,944+W|0),N2(K,U,896+W|0,964+W|0,960+W|0,928+W|0,912+W|0),(O=j2[968+W>>2])<(z=j2[964+W>>2])||(x=j2[960+W>>2])<(j=j2[972+W>>2])||(S=1,P=z2(x-j),(O=z2(O-z))<P&&(P=O)),!S)break f;P<T&&(A2=N,r2=J,i2=M,T=P);}if(!e)break e;_=_+36|0,e=e-1|0,c2=j2[V+4>>2],x=j2[V+40>>2],J=j2[V+36>>2],N=j2[V+32>>2],t2=j2[V+24>>2],b2=j2[V+20>>2],O=j2[V+16>>2],$=j2[V+8>>2];}}if(J0(320+W|0,760+W|0,8+W|0,T2[e+20>>2],0),!((J=j2[40+W>>2])<z2(0)))break f;if(!S2[44+W|0])break f;N=j2[28+W>>2],A2=j2[24+W>>2],r2=j2[20+W>>2],i2=j2[16+W>>2];break r;}if(1==T2[X+4>>2]){if(T2[252+W>>2]=0,m=T2[r+12>>2],x=j2[m+52>>2],T=j2[m+20>>2],P=j2[m+24>>2],A2=j2[m+56>>2],N=j2[X- -64>>2],J=j2[X+68>>2],r2=j2[m+36>>2],M=j2[X+72>>2],i2=j2[m+40>>2],a2=j2[m+48>>2],O=j2[m+8>>2],z=j2[m>>2],j=j2[m+4>>2],q=j2[m+16>>2],b2=j2[m+32>>2],T2[5498]=T2[5498]+1,I=0,(m=K2(35))&&(T2[(I=m+19&-16)-4>>2]=m),T2[256+W>>2]=1,T2[260+W>>2]=I,p2[264+W|0]=1,j2[I+4>>2]=x+z2(z2(z2(N*q)+z2(J*T))+z2(M*P)),j2[I>>2]=a2+z2(z2(z2(N*z)+z2(J*j))+z2(M*O)),T2[I+12>>2]=0,j2[I+8>>2]=A2+z2(z2(z2(N*b2)+z2(J*r2))+z2(M*i2)),I=T2[252+W>>2],T2[252+W>>2]=y=I+1|0,N=j2[X+80>>2],m=T2[r+12>>2],J=j2[X+84>>2],M=j2[X+88>>2],x=z2(z2(z2(z2(N*j2[m>>2])+z2(J*j2[m+4>>2]))+z2(M*j2[m+8>>2]))+j2[m+48>>2]),T=z2(z2(z2(z2(N*j2[m+32>>2])+z2(J*j2[m+36>>2]))+z2(M*j2[m+40>>2]))+j2[m+56>>2]),N=z2(z2(z2(z2(N*j2[m+16>>2])+z2(J*j2[m+20>>2]))+z2(M*j2[m+24>>2]))+j2[m+52>>2]),(0|y)==(0|(m=T2[256+W>>2]))&&!((0|(V=(m=y)?m<<1:1))<=(0|m))){if(S=0,V&&(T2[5498]=T2[5498]+1,(m=K2(19+(V<<4)|0))&&(T2[(S=m+19&-16)-4>>2]=m)),0<=(0|I))for(m=I+1|0,I=0;y=T2[260+W>>2]+I|0,L=T2[y+4>>2],T2[(U=I+S|0)>>2]=T2[y>>2],T2[U+4>>2]=L,_=T2[(y=y+8|0)+4>>2],T2[(U=U+8|0)>>2]=T2[y>>2],T2[U+4>>2]=_,I=I+16|0,m=m-1|0;);(m=T2[260+W>>2])&&S2[264+W|0]&&(T2[5499]=T2[5499]+1,q2(T2[m-4>>2])),T2[260+W>>2]=S,p2[264+W|0]=1,T2[256+W>>2]=V,y=T2[252+W>>2],m=V;}if(U=T2[260+W>>2],T2[(I=U+(y<<4)|0)+12>>2]=0,j2[I+8>>2]=T,j2[I+4>>2]=N,j2[I>>2]=x,T2[252+W>>2]=y=y+1|0,N=j2[X+96>>2],r=T2[r+12>>2],J=j2[X+100>>2],M=j2[X+104>>2],x=z2(z2(z2(z2(N*j2[r>>2])+z2(J*j2[r+4>>2]))+z2(M*j2[r+8>>2]))+j2[r+48>>2]),T=z2(z2(z2(z2(N*j2[r+32>>2])+z2(J*j2[r+36>>2]))+z2(M*j2[r+40>>2]))+j2[r+56>>2]),N=z2(z2(z2(z2(N*j2[r+16>>2])+z2(J*j2[r+20>>2]))+z2(M*j2[r+24>>2]))+j2[r+52>>2]),(0|m)==(0|y))if((0|(r=m?m<<1:1))<=(0|m))y=m;else {if(U=0,r&&(T2[5498]=T2[5498]+1,(I=K2(19+(r<<4)|0))&&(T2[(U=I+19&-16)-4>>2]=I)),1<=(0|m))for(I=0;y=T2[260+W>>2]+I|0,_=T2[y+4>>2],T2[(V=I+U|0)>>2]=T2[y>>2],T2[V+4>>2]=_,S=T2[(y=y+8|0)+4>>2],T2[(V=V+8|0)>>2]=T2[y>>2],T2[V+4>>2]=S,I=I+16|0,m=m-1|0;);(m=T2[260+W>>2])&&S2[264+W|0]&&(T2[5499]=T2[5499]+1,q2(T2[m-4>>2])),T2[260+W>>2]=U,p2[264+W|0]=1,T2[256+W>>2]=r,y=T2[252+W>>2];}if(T2[(r=(y<<4)+U|0)+12>>2]=0,j2[r+8>>2]=T,j2[r+4>>2]=N,j2[r>>2]=x,T2[252+W>>2]=T2[252+W>>2]+1,N=j2[T2[A+56>>2]+848>>2],J0(320+W|0,760+W|0,312+W|0,T2[e+20>>2],0),J=j2[324+W>>2],M=j2[328+W>>2],x=j2[332+W>>2],(T=z2(z2(z2(J*J)+z2(M*M))+z2(x*x)))>z2(1.1920928955078125e-7)){if(T2[956+W>>2]=0,P=x,x=z2(z2(1)/T),j2[952+W>>2]=P*x,j2[948+W>>2]=M*x,j2[944+W>>2]=J*x,J=z2(z2(j2[376+W>>2]-z2(n1[T2[T2[H>>2]+48>>2]](H)))-z2(n1[T2[T2[X>>2]+48>>2]](X))),(0|(I=T2[A+36>>2]))<=-1)for(T2[A+40>>2]<=-1&&((r=T2[A+44>>2])&&S2[A+48|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+40>>2]=0,T2[A+44>>2]=0,p2[A+48|0]=1),V=I<<4;m=T2[932+W>>2],r=T2[A+44>>2]+V|0,T2[r>>2]=T2[928+W>>2],T2[r+4>>2]=m,m=T2[(e=936+W|0)+4>>2],T2[(r=r+8|0)>>2]=T2[e>>2],T2[r+4>>2]=m,V=V+16|0,(r=I)>>>0<=(I=I+1|0)>>>0;);I0(944+W|(T2[A+36>>2]=0),T2[H+60>>2],T2[f+12>>2],248+W|0,A+32|0,z2(J-N),N,i);}if(S2[A+52|0]&&(A=T2[i+4>>2],T2[A+844>>2]&&((0|(f=T2[A+836>>2]))==(0|(r=T2[T2[i+8>>2]+8>>2]))?m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0):m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0))),!(A=T2[260+W>>2]))break A;if(!S2[264+W|0])break A;T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);break A;}}if(J0(320+W|0,760+W|0,i,T2[e+20>>2],0),T2[A+64>>2]&&!(T2[T2[i+4>>2]+844>>2]>=T2[A+68>>2])&&(N=j2[324+W>>2],J=j2[328+W>>2],M=j2[332+W>>2],(x=z2(z2(z2(N*N)+z2(J*J))+z2(M*M)))>z2(1.1920928955078125e-7)&&(P=J,J=z2(z2(1)/x),P=z2(P*J),a2=z2(N*J),O=z2(M*J),z2(O2(O))>z2(.7071067690849304)?(J=z2(z2(1)/z2(_2(z2(z2(O*O)+z2(P*P))))),N=z2(P*J),J=z2(J*z2(-O)),M=z2(0)):(N=z2(z2(1)/z2(_2(z2(z2(a2*a2)+z2(P*P))))),J=z2(a2*N),M=z2(N*z2(-P)),N=z2(0)),v2=824+W|0,L=808+W|0,K=792+W|0,u2=776+W|0,n=272+W|0,m=(c=(x=z2(n1[T2[T2[H>>2]+16>>2]](H)))<(T=z2(n1[T2[T2[X>>2]+16>>2]](X))))?(y=T2[(I=768+W|0)+4>>2],T2[(m=256+W|0)>>2]=T2[I>>2],T2[m+4>>2]=y,m=T2[764+W>>2],T2[248+W>>2]=T2[760+W>>2],T2[252+W>>2]=m,T=z2(F2(z2(z2(.019999999552965164)/x),z2(.39269909262657166))),y=248+W|0,V=K,I=u2,L):(y=T2[(I=v2+8|0)+4>>2],T2[(m=256+W|0)>>2]=T2[I>>2],T2[m+4>>2]=y,m=T2[v2+4>>2],T2[248+W>>2]=T2[v2>>2],T2[252+W>>2]=m,T=z2(F2(z2(z2(.019999999552965164)/T),z2(.39269909262657166))),y=248+W|0,V=S,I=U,_),H=T2[(X=I+8|0)+4>>2],T2[n>>2]=T2[X>>2],T2[4+n>>2]=H,n=T2[(H=V+8|0)+4>>2],T2[(X=288+W|0)>>2]=T2[H>>2],T2[X+4>>2]=n,n=T2[(H=m+8|0)+4>>2],T2[(X=304+W|0)>>2]=T2[H>>2],T2[X+4>>2]=n,X=T2[I+4>>2],T2[264+W>>2]=T2[I>>2],T2[268+W>>2]=X,I=T2[V+4>>2],T2[280+W>>2]=T2[V>>2],T2[284+W>>2]=I,I=T2[m+4>>2],T2[296+W>>2]=T2[m>>2],T2[300+W>>2]=I,!((0|(V=T2[A+64>>2]))<1))))for(X=296+W|0,H=280+W|0,n=264+W|0,A2=N,x=z2(T*z2(.5)),Z2=z2(z2(z2(M*M)+z2(J*J))+z2(N*N)),N=z2(W2(x)/z2(_2(Z2))),T=z2(A2*N),A2=z2(J*N),r2=z2(M*N),Y2=z2(_2(z2(z2(O*O)+z2(z2(a2*a2)+z2(P*P))))),u=224+W|0,k=208+W|0,l=192+W|0,s=176+W|0,v=160+W|0,d=144+W|0,B=128+W|0,Q=112+W|0,g=96+W|0,w=80+W|0,G=W+64|0,C=48+W|0,i2=m2(x),I=0;Z2>z2(1.1920928955078125e-7)&&(x=z2(z2(z2(z2(6.2831854820251465)/z2(0|V))*z2(0|I))*z2(.5)),M=z2(W2(x)/Y2),N=z2(O*M),J=z2(P*M),M=z2(a2*M),x=m2(x),c?(m=T2[f+12>>2],q=j2[m>>2],b2=j2[m+4>>2],t2=j2[m+8>>2],T2[772+W>>2]=0,c2=j2[m+36>>2],d2=j2[m+20>>2],B2=j2[m+40>>2],Q2=j2[m+24>>2],g2=j2[m+32>>2],w2=j2[m+16>>2],T2[804+W>>2]=0,T2[788+W>>2]=0,n2=z2(z2(T*M)+z2(z2(z2(A2*x)-z2(i2*J))-z2(r2*N))),$=z2(z2(T*N)+z2(z2(A2*J)+z2(z2(i2*x)+z2(r2*M)))),o2=z2(z2(A2*N)+z2(z2(z2(r2*x)-z2(i2*M))-z2(T*J))),e2=z2(z2(r2*J)+z2(z2(z2(T*x)-z2(i2*N))-z2(A2*M))),z=z2(z2(z2(N*n2)+z2(z2(M*$)+z2(x*o2)))-z2(J*e2)),j=z2(z2(z2(z2(x*$)-z2(M*o2))-z2(J*n2))-z2(N*e2)),l2=z2(z2(z2(J*o2)+z2(z2(N*$)+z2(x*e2)))-z2(M*n2)),N=z2(z2(z2(M*e2)+z2(z2(x*n2)+z2(J*$)))-z2(N*o2)),J=z2(z2(2)/z2(z2(j*j)+z2(z2(l2*l2)+z2(z2(z*z)+z2(N*N))))),M=z2(l2*J),$=z2(z*M),x=z2(N*J),o2=z2(j*x),n2=z2($-o2),e2=z2(N*M),k2=z2(z*J),D2=z2(j*k2),J=z2(e2+D2),k2=z2(z*k2),h2=z2(N*x),N=z2(z2(1)-z2(k2+h2)),j2[800+W>>2]=z2(z2(t2*n2)+z2(Q2*J))+z2(B2*N),j2[796+W>>2]=z2(z2(n2*b2)+z2(J*d2))+z2(N*c2),j2[792+W>>2]=z2(z2(n2*q)+z2(J*w2))+z2(N*g2),x=z2(z*x),z=z2(j*M),N=z2(x+z),j=z2(l2*M),J=z2(z2(1)-z2(k2+j)),M=z2(e2-D2),j2[784+W>>2]=z2(z2(t2*N)+z2(Q2*J))+z2(B2*M),j2[780+W>>2]=z2(z2(N*b2)+z2(J*d2))+z2(M*c2),j2[776+W>>2]=z2(z2(N*q)+z2(J*w2))+z2(M*g2),N=z2(z2(1)-z2(h2+j)),J=z2(x-z),M=z2($+o2),j2[768+W>>2]=z2(z2(t2*N)+z2(Q2*J))+z2(B2*M),j2[764+W>>2]=z2(z2(N*b2)+z2(J*d2))+z2(M*c2),j2[760+W>>2]=z2(z2(N*q)+z2(J*w2))+z2(M*g2),m=T2[r+12>>2],p=T2[m+4>>2],T2[v2>>2]=T2[m>>2],T2[v2+4>>2]=p,f2=T2[(V=m+8|0)+4>>2],T2[(p=v2+8|0)>>2]=T2[V>>2],T2[p+4>>2]=f2,f2=T2[(p=m+24|0)+4>>2],T2[(V=U+8|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[m+20>>2],T2[U>>2]=T2[m+16>>2],T2[U+4>>2]=V,f2=T2[(p=m+40|0)+4>>2],T2[(V=S+8|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[m+36>>2],T2[S>>2]=T2[m+32>>2],T2[S+4>>2]=V,f2=T2[(p=m+56|0)+4>>2],T2[(V=_+8|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[m+52>>2],T2[_>>2]=T2[m+48>>2],T2[_+4>>2]=V):(m=T2[f+12>>2],p=T2[(V=m+8|0)>>2],V=T2[V+4>>2],f2=T2[m>>2],D=T2[m+4>>2],a=T2[m+20>>2],T2[u2>>2]=T2[m+16>>2],T2[u2+4>>2]=a,h=T2[4+(E=m+24|0)>>2],T2[(a=u2+8|0)>>2]=T2[E>>2],T2[4+a>>2]=h,T2[(a=768+W|0)>>2]=p,T2[4+a>>2]=V,V=T2[m+36>>2],T2[K>>2]=T2[m+32>>2],T2[K+4>>2]=V,a=T2[(p=m+40|0)+4>>2],T2[(V=K+8|0)>>2]=T2[p>>2],T2[V+4>>2]=a,a=T2[(p=m+56|0)+4>>2],T2[(V=L+8|0)>>2]=T2[p>>2],T2[V+4>>2]=a,V=T2[m+52>>2],T2[L>>2]=T2[m+48>>2],T2[L+4>>2]=V,T2[760+W>>2]=f2,T2[764+W>>2]=D,m=T2[r+12>>2],q=j2[m+36>>2],b2=j2[m+20>>2],t2=j2[m+40>>2],c2=j2[m+24>>2],d2=j2[m+32>>2],B2=j2[m>>2],Q2=j2[m+16>>2],g2=j2[m+4>>2],w2=j2[m+8>>2],T2[868+W>>2]=0,T2[852+W>>2]=0,T2[836+W>>2]=0,n2=z2(z2(T*M)+z2(z2(z2(A2*x)-z2(i2*J))-z2(r2*N))),$=z2(z2(T*N)+z2(z2(A2*J)+z2(z2(i2*x)+z2(r2*M)))),o2=z2(z2(A2*N)+z2(z2(z2(r2*x)-z2(i2*M))-z2(T*J))),e2=z2(z2(r2*J)+z2(z2(z2(T*x)-z2(i2*N))-z2(A2*M))),z=z2(z2(z2(N*n2)+z2(z2(M*$)+z2(x*o2)))-z2(J*e2)),j=z2(z2(z2(z2(x*$)-z2(M*o2))-z2(J*n2))-z2(N*e2)),l2=z2(z2(z2(J*o2)+z2(z2(N*$)+z2(x*e2)))-z2(M*n2)),N=z2(z2(z2(M*e2)+z2(z2(x*n2)+z2(J*$)))-z2(N*o2)),J=z2(z2(2)/z2(z2(j*j)+z2(z2(l2*l2)+z2(z2(z*z)+z2(N*N))))),M=z2(l2*J),$=z2(z*M),x=z2(N*J),o2=z2(j*x),n2=z2($-o2),e2=z2(N*M),k2=z2(z*J),D2=z2(j*k2),J=z2(e2+D2),k2=z2(z*k2),h2=z2(N*x),N=z2(z2(1)-z2(k2+h2)),j2[864+W>>2]=z2(z2(w2*n2)+z2(c2*J))+z2(t2*N),j2[860+W>>2]=z2(z2(n2*g2)+z2(J*b2))+z2(N*q),j2[856+W>>2]=z2(z2(n2*B2)+z2(J*Q2))+z2(N*d2),x=z2(z*x),z=z2(j*M),N=z2(x+z),j=z2(l2*M),J=z2(z2(1)-z2(k2+j)),M=z2(e2-D2),j2[848+W>>2]=z2(z2(w2*N)+z2(c2*J))+z2(t2*M),j2[844+W>>2]=z2(z2(N*g2)+z2(J*b2))+z2(M*q),j2[840+W>>2]=z2(z2(N*B2)+z2(J*Q2))+z2(M*d2),N=z2(z2(1)-z2(h2+j)),J=z2(x-z),M=z2($+o2),j2[832+W>>2]=z2(z2(w2*N)+z2(c2*J))+z2(t2*M),j2[828+W>>2]=z2(z2(N*g2)+z2(J*b2))+z2(M*q),j2[824+W>>2]=z2(z2(N*B2)+z2(J*Q2))+z2(M*d2)),m=T2[764+W>>2],T2[C>>2]=T2[760+W>>2],T2[4+C>>2]=m,m=T2[u2+4>>2],T2[G>>2]=T2[u2>>2],T2[4+G>>2]=m,m=T2[K+4>>2],T2[w>>2]=T2[K>>2],T2[4+w>>2]=m,m=T2[L+4>>2],T2[g>>2]=T2[L>>2],T2[4+g>>2]=m,p=T2[(V=768+W|0)+4>>2],T2[(m=8+C|0)>>2]=T2[V>>2],T2[m+4>>2]=p,p=T2[(V=u2+8|0)+4>>2],T2[(m=8+G|0)>>2]=T2[V>>2],T2[m+4>>2]=p,p=T2[(V=K+8|0)+4>>2],T2[(m=8+w|0)>>2]=T2[V>>2],T2[m+4>>2]=p,p=T2[(V=L+8|0)+4>>2],T2[(m=8+g|0)>>2]=T2[V>>2],T2[m+4>>2]=p,T2[40+W>>2]=0,T2[44+W>>2]=i,T2[8+W>>2]=12764,m=T2[e+20>>2],f2=T2[(p=v2+8|0)+4>>2],T2[(V=8+Q|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[v2+4>>2],T2[Q>>2]=T2[v2>>2],T2[4+Q>>2]=V,f2=T2[(p=U+8|0)+4>>2],T2[(V=8+B|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[U+4>>2],T2[B>>2]=T2[U>>2],T2[4+B>>2]=V,f2=T2[(p=S+8|0)+4>>2],T2[(V=8+d|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[S+4>>2],T2[d>>2]=T2[S>>2],T2[4+d>>2]=V,f2=T2[(p=_+8|0)+4>>2],T2[(V=8+v|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[_+4>>2],T2[v>>2]=T2[_>>2],T2[4+v>>2]=V,f2=T2[(p=y+8|0)+4>>2],T2[(V=8+s|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[y+4>>2],T2[s>>2]=T2[y>>2],T2[4+s>>2]=V,f2=T2[(p=8+n|0)+4>>2],T2[(V=8+l|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[4+n>>2],T2[l>>2]=T2[n>>2],T2[4+l>>2]=V,f2=T2[(p=H+8|0)+4>>2],T2[(V=8+k|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[H+4>>2],T2[k>>2]=T2[H>>2],T2[4+k>>2]=V,f2=T2[(p=X+8|0)+4>>2],T2[(V=8+u|0)>>2]=T2[p>>2],T2[V+4>>2]=f2,V=T2[X+4>>2],T2[u>>2]=T2[X>>2],T2[4+u>>2]=V,T2[244+W>>2]=m,p2[240+W|0]=c,J0(320+W|0,760+W|0,8+W|0,m,0),V=T2[A+64>>2]),(0|(I=I+1|0))<(0|V););if(!S2[A+52|0])break A;if(A=T2[i+4>>2],!T2[A+844>>2])break A;if((0|(f=T2[A+836>>2]))!=(0|(r=T2[T2[i+8>>2]+8>>2]))){m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0);break A;}m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0);break A;}if(1<=(0|(e=T2[K+28>>2])))for(S=28;;){if(m=T2[K+36>>2]+S|0,M=j2[m>>2],P=j2[m-8>>2],O=j2[m-4>>2],T2[908+W>>2]=0,N=z2(z2(z2(P*j2[U+32>>2])+z2(O*j2[U+36>>2]))+z2(M*j2[U+40>>2])),j2[904+W>>2]=N,J=z2(z2(z2(P*j2[U+16>>2])+z2(O*j2[U+20>>2]))+z2(M*j2[U+24>>2])),j2[900+W>>2]=J,M=z2(z2(z2(P*j2[U>>2])+z2(O*j2[U+4>>2]))+z2(M*j2[U+8>>2])),j2[896+W>>2]=M,z2(z2(z2(M*E2)+z2(J*C2))+z2(N*G2))<z2(0)&&(N=z2(-N),j2[904+W>>2]=N,J=z2(-J),j2[900+W>>2]=J,M=z2(-M),j2[896+W>>2]=M),T2[5607]=T2[5607]+1,M0(V,U,E2,C2,G2,M,J,N,L,K,T)){if(_=0,T2[5608]=T2[5608]+1,N2(L,V,896+W|0,972+W|0,968+W|0,248+W|0,944+W|0),N2(K,U,896+W|0,964+W|0,960+W|0,928+W|0,912+W|0),(P=j2[968+W>>2])<(O=j2[964+W>>2])||(z=j2[960+W>>2])<(j=j2[972+W>>2])||(_=1,x=z2(z-j),(P=z2(P-O))<x&&(x=P)),!_)break f;x<T&&(A2=N,r2=J,i2=M,T=x);}if(S=S+36|0,!(e=e-1|0))break;}if((0|(S=T2[L+48>>2]))<1)y=-1,x=z2(0),P=z2(0),z=z2(0),j=z2(0),q=z2(0),O=z2(0),m=-1;else for(_=T2[K+48>>2],y=m=-1,O=z2(I=0),q=z2(0),j=z2(0),z=z2(0),P=z2(0),x=z2(0);;){if(1<=(0|_)){for(e=T2[L+56>>2]+(I<<4)|0,N=j2[e>>2],J=j2[e+4>>2],M=j2[e+8>>2],b2=z2(z2(z2(N*j2[V+32>>2])+z2(J*j2[V+36>>2]))+z2(M*j2[V+40>>2])),t2=z2(z2(z2(N*j2[V+16>>2])+z2(J*j2[V+20>>2]))+z2(M*j2[V+24>>2])),c2=z2(z2(z2(N*j2[V>>2])+z2(J*j2[V+4>>2]))+z2(M*j2[V+8>>2])),e=0,S=8;;){if(u2=T2[K+56>>2]+S|0,J=j2[u2>>2],M=j2[u2-8>>2],e2=j2[u2-4>>2],s2=j2[U+40>>2],o=j2[U+32>>2],b=j2[U+36>>2],N=j2[U+24>>2],$=j2[U+16>>2],o2=j2[U+20>>2],t=j2[U+8>>2],Z=j2[U>>2],Y=j2[U+4>>2],T2[908+W>>2]=0,$=z2(z2(z2(M*$)+z2(e2*o2))+z2(J*N)),o2=z2(z2(z2(M*Z)+z2(e2*Y))+z2(J*t)),N=z2(z2(c2*$)-z2(t2*o2)),e2=z2(z2(z2(M*o)+z2(e2*b))+z2(J*s2)),M=z2(z2(b2*o2)-z2(c2*e2)),s2=z2(z2(t2*e2)-z2(b2*$)),(1e-6<+z2(O2(s2))||1e-6<+z2(O2(M))||1e-6<+z2(O2(N)))&&(o=z2(z2(1)/z2(_2(z2(z2(N*N)+z2(z2(s2*s2)+z2(M*M)))))),J=z2(N*o),j2[904+W>>2]=J,N=z2(M*o),j2[900+W>>2]=N,M=z2(s2*o),j2[896+W>>2]=M,z2(z2(z2(M*E2)+z2(N*C2))+z2(G2*J))<z2(0)&&(J=z2(-J),j2[904+W>>2]=J,N=z2(-N),j2[900+W>>2]=N,M=z2(-M),j2[896+W>>2]=M),T2[5607]=T2[5607]+1,M0(V,U,E2,C2,G2,M,N,J,L,K,T))){if(_=0,T2[5608]=T2[5608]+1,N2(L,V,896+W|0,972+W|0,968+W|0,248+W|0,944+W|0),N2(K,U,896+W|0,964+W|0,960+W|0,928+W|0,912+W|0),(s2=j2[968+W>>2])<(o=j2[964+W>>2])||(b=j2[960+W>>2])<(t=j2[972+W>>2])||((a2=z2(s2-o))<(s2=z2(b-t))?(_=1,l2=j2[936+W>>2],Z2=j2[932+W>>2],Y2=j2[928+W>>2],k2=j2[952+W>>2],D2=j2[948+W>>2],h2=j2[944+W>>2]):(_=1,l2=j2[920+W>>2],Z2=j2[916+W>>2],Y2=j2[912+W>>2],k2=j2[256+W>>2],D2=j2[252+W>>2],h2=j2[248+W>>2],a2=s2)),a2<T&&_&&(A2=J,r2=N,i2=M,x=Y2,P=Z2,z=l2,j=h2,q=D2,O=k2,d2=o2,B2=$,Q2=e2,g2=c2,w2=t2,n2=b2,y=I,m=e,T=a2),!_)break f;_=T2[K+48>>2];}if(S=S+16|0,!((0|(e=e+1|0))<(0|_)))break;}S=T2[L+48>>2];}if(!((0|(I=I+1|0))<(0|S)))break;}(m|y)<0||(a2=z2(x-j),j=z2(P-q),O=z2(z-O),q=z2(z2(z2(a2*d2)+z2(j*B2))+z2(O*Q2)),T=z2(z2(z2(a2*g2)+z2(j*w2))+z2(O*n2)),N=z2(0),M=z2(z2(z2(d2*g2)+z2(B2*w2))+z2(Q2*n2)),(J=z2(z2(1)-z2(M*M)))!=z2(0)&&(N=z2(-1.0000000150474662e30),(J=z2(z2(T-z2(q*M))/J))<z2(-1.0000000150474662e30)||(N=J)>z2(1.0000000150474662e30)&&(N=z2(1.0000000150474662e30))),(J=z2(z2(M*N)-q))<z2(-1.0000000150474662e30)?(M=z2(T+z2(M*z2(-1.0000000150474662e30))))<z2(-1.0000000150474662e30)?(J=z2(-1.0000000150474662e30),N=z2(-1.0000000150474662e30)):(N=z2(1.0000000150474662e30),M>z2(1.0000000150474662e30)?J=z2(-1.0000000150474662e30):(J=z2(-1.0000000150474662e30),N=M)):J>z2(1.0000000150474662e30)&&(N=z2(-1.0000000150474662e30),J=z2(1.0000000150474662e30),(M=z2(T+z2(M*z2(1.0000000150474662e30))))<z2(-1.0000000150474662e30)||(N=M)>z2(1.0000000150474662e30)&&(N=z2(1.0000000150474662e30))),T2[260+W>>2]=0,q=z2(Q2*J),M=z2(q+z2(O-z2(n2*N))),O=z2(d2*J),T=z2(O+z2(a2-z2(g2*N))),a2=z2(B2*J),N=z2(a2+z2(j-z2(w2*N))),(J=z2(z2(M*M)+z2(z2(T*T)+z2(N*N))))>z2(1.1920928955078125e-7)&&(j=z2(_2(J)),J=z2(z2(1)/j),M=z2(M*J),j2[256+W>>2]=M,N=z2(N*J),j2[252+W>>2]=N,J=z2(T*J),j2[248+W>>2]=J,z2(z2(z2(J*E2)+z2(N*C2))+z2(M*G2))<z2(0)&&(j2[256+W>>2]=-M,j2[252+W>>2]=-N,j2[248+W>>2]=-J),T2[956+W>>2]=0,j2[952+W>>2]=z+q,j2[948+W>>2]=P+a2,j2[944+W>>2]=x+O,n1[T2[T2[i>>2]+16>>2]](i,248+W|0,944+W|0,z2(-j)))),N=z2(0),J=z2(-1.0000000150474662e30),z2(z2(z2(E2*i2)+z2(C2*r2))+z2(G2*A2))<z2(0)&&(A2=z2(-A2),r2=z2(-r2),i2=z2(-i2));}if((0|(I=T2[A+16>>2]))<=(U=-1))for(T2[A+20>>2]<=-1&&((e=T2[A+24>>2])&&S2[A+28|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[A+20>>2]=0,T2[A+24>>2]=0,p2[A+28|0]=1),m=I<<4;V=T2[252+W>>2],e=T2[A+24>>2]+m|0,T2[(y=e)>>2]=T2[248+W>>2],T2[y+4>>2]=V,V=T2[(y=256+W|0)+4>>2],T2[(e=e+8|0)>>2]=T2[y>>2],T2[e+4>>2]=V,m=m+16|0,(e=I)>>>0<=(I=I+1|0)>>>0;);if(T2[A+16>>2]=0,r=T2[r+12>>2],_=T2[f+12>>2],L=T2[H+60>>2],e=T2[X+60>>2],j2[260+W>>2]=N,N=z2(z2(1)/z2(_2(z2(z2(z2(i2*i2)+z2(r2*r2))+z2(A2*A2))))),P=z2(A2*N),j2[256+W>>2]=P,A2=z2(r2*N),j2[252+W>>2]=A2,r2=z2(i2*N),j2[248+W>>2]=r2,1<=(0|(m=T2[e+28>>2])))for(I=T2[e+36>>2]+28|0,i2=j2[r+40>>2],a2=j2[r+36>>2],O=j2[r+24>>2],z=j2[r+20>>2],j=j2[r+32>>2],q=j2[r+16>>2],b2=j2[r+8>>2],t2=j2[r+4>>2],c2=j2[r>>2],N=z2(-34028234663852886e22),V=0;M=j2[I-8>>2],x=j2[I-4>>2],T=j2[I>>2],N=(f=N<(M=z2(z2(z2(r2*z2(z2(z2(M*c2)+z2(x*t2))+z2(T*b2)))+z2(A2*z2(z2(z2(M*q)+z2(x*z))+z2(T*O))))+z2(P*z2(z2(z2(M*j)+z2(x*a2))+z2(T*i2))))))?M:N,U=f?V:U,I=I+36|0,(0|m)!=(0|(V=V+1|0)););if(T2[A+16>>2]=0,f=T2[e+36>>2]+P2(U,36)|0,1<=(0|(K=T2[f+4>>2])))for(u2=f+12|0,y=V=0;;){if(f=T2[e+16>>2]+(T2[T2[u2>>2]+(y<<2)>>2]<<4)|0,N=j2[f>>2],M=j2[f+4>>2],x=j2[f+8>>2],T=z2(z2(z2(z2(N*j2[r+32>>2])+z2(M*j2[r+36>>2]))+z2(x*j2[r+40>>2]))+j2[r+56>>2]),P=z2(z2(z2(z2(N*j2[r+16>>2])+z2(M*j2[r+20>>2]))+z2(x*j2[r+24>>2]))+j2[r+52>>2]),N=z2(z2(z2(z2(N*j2[r>>2])+z2(M*j2[r+4>>2]))+z2(x*j2[r+8>>2]))+j2[r+48>>2]),T2[A+20>>2]==(0|V)&&!((0|(m=V?V<<1:1))<=(0|V))){if(f=0,m&&(T2[5498]=T2[5498]+1,(I=K2(19+(m<<4)|0))&&(T2[(f=I+19&-16)-4>>2]=I)),1<=(0|V))for(I=0;S=T2[A+24>>2]+I|0,v2=T2[S+4>>2],T2[(X=f+I|0)>>2]=T2[S>>2],T2[X+4>>2]=v2,H=T2[(S=S+8|0)+4>>2],T2[(X=X+8|0)>>2]=T2[S>>2],T2[X+4>>2]=H,I=I+16|0,V=V-1|0;);(I=T2[A+24>>2])&&S2[A+28|0]&&(T2[5499]=T2[5499]+1,q2(T2[I-4>>2])),T2[A+24>>2]=f,p2[A+28|0]=1,T2[A+20>>2]=m,V=T2[A+16>>2];}if(f=T2[A+24>>2]+(V<<4)|0,T2[f+12>>2]=0,j2[f+8>>2]=T,j2[f+4>>2]=P,j2[f>>2]=N,V=T2[A+16>>2]+1|0,T2[A+16>>2]=V,(0|K)==(0|(y=y+1|0)))break;}(0|U)<=-1||I0(248+W|0,L,_,A+12|0,A+32|0,z2(J-R2),R2,i);}S2[A+52|0]&&(A=T2[i+4>>2],T2[A+844>>2]&&((0|(f=T2[A+836>>2]))==(0|(r=T2[T2[i+8>>2]+8>>2]))?m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0):m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0)));}L2=976+W|0;},function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l=z2(0),s=z2(0);return L2=A=L2-624|0,s=z2(j2[f+116>>2]-j2[f+52>>2]),l=z2(s*s),s=z2(j2[f+120>>2]-j2[f+56>>2]),l=z2(l+z2(s*s)),s=z2(j2[f+124>>2]-j2[f+60>>2]),l=z2(l+z2(s*s)),s=j2[f+276>>2],l<z2(s*s)&&(s=z2(1),l=z2(j2[r+116>>2]-j2[r+52>>2]),k=z2(l*l),l=z2(j2[r+120>>2]-j2[r+56>>2]),k=z2(k+z2(l*l)),l=z2(j2[r+124>>2]-j2[r+60>>2]),k=z2(k+z2(l*l)),l=j2[r+276>>2],k<z2(l*l))||(a=T2[f+192>>2],T2[(e=i=A+592|0)>>2]=0,T2[e+4>>2]=0,T2[(o=A+588|0)>>2]=1065353216,T2[(e=n=A+600|0)>>2]=0,T2[e+4>>2]=0,T2[(b=A+608|0)>>2]=0,T2[A+572>>2]=0,T2[A+576>>2]=0,T2[A+580>>2]=1065353216,T2[A+584>>2]=1065353216,T2[A+564>>2]=8,T2[A+568>>2]=0,T2[A+560>>2]=11936,T2[A+616>>2]=0,s=j2[r+272>>2],j2[A+596>>2]=s,j2[A+612>>2]=s,T2[A+556>>2]=0,T2[A+548>>2]=1566444395,T2[A+552>>2]=0,T2[A+384>>2]=12640,p2[0|(t=A+356|0)]=0,T2[A+332>>2]=953267991,T2[A+16>>2]=a,T2[A+8>>2]=12396,T2[A+20>>2]=A+560,T2[A+12>>2]=A+24,c=f+4|0,u=f+68|0,k=r+4|0,a=r+68|0,s=z2(1),x0(A+8|0,c,u,k,a,A+384|0)&&((l=j2[A+548>>2])<j2[f+268>>2]&&(j2[f+268>>2]=l),l<j2[r+268>>2]&&(j2[r+268>>2]=l),s=z2(1),l<z2(1)&&(s=l)),e=T2[r+192>>2],T2[i>>2]=0,T2[i+4>>2]=0,T2[o>>2]=1065353216,T2[n>>2]=0,T2[4+n>>2]=0,T2[b>>2]=0,T2[A+572>>2]=0,T2[A+576>>2]=0,T2[A+580>>2]=1065353216,T2[A+584>>2]=1065353216,T2[A+564>>2]=8,T2[A+568>>2]=0,T2[A+560>>2]=11936,T2[A+616>>2]=0,l=j2[f+272>>2],j2[A+596>>2]=l,j2[A+612>>2]=l,T2[A+556>>2]=0,T2[A+548>>2]=1566444395,T2[A+552>>2]=0,T2[A+384>>2]=12640,p2[0|t]=0,T2[A+332>>2]=953267991,T2[A+20>>2]=e,T2[A+8>>2]=12396,T2[A+16>>2]=A+560,T2[A+12>>2]=A+24,x0(A+8|0,c,u,k,a,A+384|0)&&((l=j2[A+548>>2])<j2[f+268>>2]&&(j2[f+268>>2]=l),l<j2[r+268>>2]&&(j2[r+268>>2]=l),l<s&&(s=l))),L2=A+624|0,z2(s);},function(A,f){A|=0,f|=0;var r,e=0,i=0,a=0,n=0;if((a=T2[A+56>>2])&&S2[A+52|0]){if((0|(i=T2[f+4>>2]))==T2[f+8>>2]&&!((0|(r=i?i<<1:1))<=(0|i))){if(r&&(T2[5498]=T2[5498]+1,(e=K2(19+(r<<2)|0))&&(T2[(n=e+19&-16)-4>>2]=e)),1<=(0|i))for(a=0,e=i;T2[a+n>>2]=T2[T2[f+12>>2]+a>>2],a=a+4|0,e=e-1|0;);(e=T2[f+12>>2])&&S2[f+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]),i=T2[f+4>>2]),T2[f+12>>2]=n,p2[f+16|0]=1,T2[f+8>>2]=r,a=T2[A+56>>2];}T2[f+4>>2]=i+1,T2[T2[f+12>>2]+(i<<2)>>2]=a;}},y2,c0,C2,_,I,I,C2,C2,U0,I,C2,C2,function(A,f,r,e){A|=0,f|=0,r|=0,e=z2(e);var i,a,n,o,b,t,c=0;L2=c=L2-16|0,j2[A+32>>2]=e,t=T2[f+4>>2],T2[A+8>>2]=T2[f>>2],T2[A+12>>2]=t,b=T2[4+(t=f+8|0)>>2],T2[(o=A+16|0)>>2]=T2[t>>2],T2[4+o>>2]=b,i=j2[t>>2],a=j2[r>>2],n=j2[f>>2],o=j2[r+4>>2],b=j2[f+4>>2],t=j2[r+8>>2],r=j2[A+28>>2],e=z2(z2(r+j2[A+24>>2])+e),j2[A+32>>2]=e,T2[12+c>>2]=0,j2[8+c>>2]=t-z2(r*i),j2[4+c>>2]=o-z2(r*b),j2[c>>2]=a-z2(n*r),e<z2(0)&&(p2[A+36|0]=1),A=T2[A+4>>2],n1[T2[T2[A>>2]+16>>2]](A,f,c,e),L2=16+c|0;},I,function(A,f,r,e){A|=0,f|=0,r|=0,e=z2(e);var i,a,n,o,b,t,c,u,k,l,s,v=z2(0),d=z2(0),B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=z2(0),C=(z2(0)),E=z2(0),D=z2(0),h=0,Z=z2(0),Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=z2(0),N=z2(0),V=z2(0),J=(z2(0));L2=h=L2-16|0,o=j2[f+8>>2],Z=j2[r+8>>2],J=z2(z2(o*e)+Z),b=j2[f+4>>2],C=j2[r+4>>2],t=z2(z2(b*e)+C),c=j2[f>>2],v=z2(c*e),e=j2[r>>2],u=z2(v+e),S2[A+232|0]?(Y=j2[A+56>>2],g=z2(-j2[A+92>>2]),R=j2[A+40>>2],Q=j2[A+88>>2],F=j2[A+72>>2],w=j2[A+96>>2],d=z2(z2(z2(Y*g)-z2(R*Q))-z2(F*w)),W=j2[A+60>>2],m=j2[A+44>>2],N=j2[A+76>>2],E=z2(z2(z2(W*g)-z2(m*Q))-z2(N*w)),V=j2[A- -64>>2],v=z2(V*g),g=j2[A+48>>2],v=z2(v-z2(g*Q)),Q=j2[A+80>>2],w=z2(v-z2(Q*w)),v=j2[A+168>>2],B=j2[A+172>>2],G=j2[A+176>>2],G=z2(z2(z2(J*z2(z2(z2(F*v)+z2(N*B))+z2(Q*G)))+z2(z2(u*z2(z2(z2(R*v)+z2(m*B))+z2(g*G)))+z2(t*z2(z2(z2(Y*v)+z2(W*B))+z2(V*G)))))+z2(z2(z2(z2(v*d)+z2(E*B))+z2(w*G))+j2[A+216>>2])),D=z2(c*z2(G-e)),e=j2[A+184>>2],v=j2[A+188>>2],B=j2[A+192>>2],v=z2(z2(z2(J*z2(z2(z2(F*e)+z2(N*v))+z2(Q*B)))+z2(z2(u*z2(z2(z2(R*e)+z2(m*v))+z2(g*B)))+z2(t*z2(z2(z2(Y*e)+z2(W*v))+z2(V*B)))))+z2(z2(z2(z2(d*e)+z2(E*v))+z2(w*B))+j2[A+220>>2])),B=z2(D+z2(b*z2(v-C))),e=j2[A+200>>2],C=j2[A+204>>2],E=z2(z2(d*e)+z2(E*C)),d=j2[A+208>>2],J=z2(z2(z2(E+z2(w*d))+j2[A+224>>2])+z2(z2(J*z2(z2(z2(F*e)+z2(N*C))+z2(Q*d)))+z2(z2(u*z2(z2(z2(R*e)+z2(m*C))+z2(g*d)))+z2(t*z2(z2(z2(Y*e)+z2(W*C))+z2(V*d)))))),e=z2(B+z2(o*z2(J-Z))),j2[4+h>>2]=v+z2(b*e),j2[h>>2]=G+z2(c*e),Z=z2(J+z2(o*e))):(l=j2[A+224>>2],Y=j2[A+208>>2],R=j2[A+200>>2],F=j2[A+204>>2],s=j2[A+216>>2],d=j2[A+172>>2],W=j2[A+176>>2],m=j2[A+168>>2],N=j2[A+120>>2],D=z2(-j2[A+156>>2]),E=j2[A+104>>2],a=j2[A+152>>2],V=j2[A+136>>2],n=j2[A+160>>2],g=z2(z2(z2(N*D)-z2(E*a))-z2(V*n)),Q=j2[A+124>>2],w=j2[A+108>>2],v=j2[A+140>>2],B=z2(z2(z2(Q*D)-z2(w*a))-z2(v*n)),G=j2[A+128>>2],i=z2(G*D),D=j2[A+112>>2],i=z2(i-z2(D*a)),a=j2[A+144>>2],n=z2(i-z2(a*n)),i=j2[A+184>>2],k=j2[A+188>>2],r=j2[A+192>>2],i=z2(z2(z2(Z*z2(z2(z2(V*i)+z2(v*k))+z2(a*r)))+z2(z2(e*z2(z2(z2(E*i)+z2(w*k))+z2(D*r)))+z2(C*z2(z2(z2(N*i)+z2(Q*k))+z2(G*r)))))+z2(z2(z2(z2(g*i)+z2(B*k))+z2(n*r))+j2[A+220>>2])),j2[4+h>>2]=i,d=z2(z2(z2(Z*z2(z2(z2(V*m)+z2(v*d))+z2(a*W)))+z2(z2(e*z2(z2(z2(E*m)+z2(w*d))+z2(D*W)))+z2(C*z2(z2(z2(N*m)+z2(Q*d))+z2(G*W)))))+z2(s+z2(z2(z2(m*g)+z2(B*d))+z2(n*W)))),j2[h>>2]=d,Z=z2(z2(l+z2(z2(z2(g*R)+z2(B*F))+z2(n*Y)))+z2(z2(Z*z2(z2(z2(V*R)+z2(v*F))+z2(a*Y)))+z2(z2(e*z2(z2(z2(E*R)+z2(w*F))+z2(D*Y)))+z2(C*z2(z2(z2(N*R)+z2(Q*F))+z2(G*Y)))))),e=z2(z2(z2(c*z2(u-d))+z2(b*z2(t-i)))+z2(o*z2(J-Z)))),T2[12+h>>2]=0,j2[8+h>>2]=Z,A=T2[A+36>>2],n1[T2[T2[A>>2]+16>>2]](A,f,h,e),L2=16+h|0;},I,X0,function(A){var f,r;return T2[(A|=0)+8>>2]=13344,T2[A>>2]=13316,r=T2[(f=A+56|0)>>2],n1[T2[T2[r>>2]+20>>2]](r,T2[(r=A+72|0)>>2]),f=T2[f>>2],n1[T2[T2[f>>2]+16>>2]](f,T2[r>>2]),0|A;},function(A){var f,r;T2[(A|=0)+8>>2]=13344,T2[A>>2]=13316,r=T2[(f=A+56|0)>>2],n1[T2[T2[r>>2]+20>>2]](r,T2[(r=A+72|0)>>2]),f=T2[f>>2],n1[T2[T2[f>>2]+16>>2]](f,T2[r>>2]),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N=0,V=(0);L2=N=L2+-64|0,n=S2[A+76|0],V=T2[(d=n?f:r)+4>>2],8<T2[V+4>>2]-21>>>0||19<T2[T2[(n=n?r:f)+4>>2]+4>>2]||(m=z2(n1[T2[T2[V>>2]+48>>2]](V)),j2[A- -64>>2]=m,T2[A+60>>2]=e,T2[A+48>>2]=d,T2[A+44>>2]=n,T2[A+52>>2]=i,T2[i+4>>2]=T2[(e=A+72|0)>>2],f=T2[d+12>>2],o=j2[f+52>>2],B=j2[f+56>>2],r=T2[n+12>>2],Q=j2[r+52>>2],g=j2[r+56>>2],a=j2[f+20>>2],b=j2[f+36>>2],w=j2[r+20>>2],G=j2[r+36>>2],C=j2[r+24>>2],t=j2[f+24>>2],E=j2[r+40>>2],c=j2[f+40>>2],D=j2[r+32>>2],u=j2[f+32>>2],h=j2[r>>2],k=j2[f>>2],Z=j2[r+16>>2],l=j2[f+16>>2],Y=j2[f+48>>2],R=j2[r+48>>2],s=j2[f+4>>2],F=j2[r+4>>2],W=j2[r+8>>2],v=j2[f+8>>2],T2[60+N>>2]=0,T2[44+N>>2]=0,T2[28+N>>2]=0,j2[40+N>>2]=z2(z2(v*W)+z2(t*C))+z2(c*E),j2[36+N>>2]=z2(z2(v*F)+z2(t*w))+z2(c*G),j2[24+N>>2]=z2(z2(s*W)+z2(a*C))+z2(b*E),j2[20+N>>2]=z2(z2(s*F)+z2(a*w))+z2(b*G),o=z2(-o),j2[56+N>>2]=z2(z2(z2(t*o)-z2(v*Y))-z2(c*B))+z2(z2(z2(v*R)+z2(t*Q))+z2(c*g)),j2[52+N>>2]=z2(z2(z2(a*o)-z2(s*Y))-z2(b*B))+z2(z2(z2(s*R)+z2(a*Q))+z2(b*g)),T2[12+N>>2]=0,j2[N>>2]=z2(z2(k*h)+z2(l*Z))+z2(u*D),j2[32+N>>2]=z2(z2(v*h)+z2(t*Z))+z2(c*D),j2[16+N>>2]=z2(z2(s*h)+z2(a*Z))+z2(b*D),j2[8+N>>2]=z2(z2(k*W)+z2(l*C))+z2(u*E),j2[4+N>>2]=z2(z2(k*F)+z2(l*w))+z2(u*G),j2[48+N>>2]=z2(z2(z2(l*o)-z2(k*Y))-z2(u*B))+z2(z2(z2(k*R)+z2(l*Q))+z2(u*g)),g=T2[n+4>>2],n1[T2[T2[g>>2]+8>>2]](g,N,f=A+12|0,r=A+28|0),a=z2(m+j2[i+32>>2]),j2[r>>2]=a+j2[r>>2],j2[(g=A+32|0)>>2]=a+j2[g>>2],j2[(g=A+36|0)>>2]=a+j2[g>>2],j2[f>>2]=j2[f>>2]-a,j2[(g=A+16|0)>>2]=j2[g>>2]-a,j2[(g=A+20|0)>>2]=j2[g>>2]-a,e=T2[e>>2],T2[e+840>>2]=T2[d+8>>2],T2[e+836>>2]=T2[n+8>>2],n1[T2[T2[V>>2]+64>>2]](V,A+8|0,f,r),f=T2[i+4>>2],T2[f+844>>2]&&(e=T2[f+836>>2],V=T2[T2[i+8>>2]+8>>2],g=f,f=T2[T2[i+12>>2]+8>>2],m0(g,((r=(0|e)==(0|V))?e:f)+4|0,(r?f:V)+4|0)),T2[A+44>>2]=0,T2[A+48>>2]=0),L2=N+64|0;},function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0,z2(0);var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I,x,y,U,X,p,T,S=z2(0);return L2=e=L2-240|0,S=z2(1),i=S2[A+76|0],a=z2(j2[(A=i?r:f)+116>>2]-j2[A+52>>2]),n=z2(a*a),a=z2(j2[A+120>>2]-j2[A+56>>2]),n=z2(n+z2(a*a)),a=z2(j2[A+124>>2]-j2[A+60>>2]),n=z2(n+z2(a*a)),a=j2[A+276>>2],n<z2(a*a)||(r=T2[(f=i?f:r)+192>>2],8<T2[r+4>>2]-21>>>0||(b=j2[f+52>>2],S=j2[f+12>>2],a=j2[f+28>>2],n=j2[f+56>>2],o=j2[f+60>>2],t=j2[f+44>>2],Q=j2[A+120>>2],g=j2[A+116>>2],w=j2[A+124>>2],c=j2[f+8>>2],u=j2[f+24>>2],k=j2[f+40>>2],l=j2[f+36>>2],s=j2[f+20>>2],v=j2[f+4>>2],G=j2[A+56>>2],C=j2[A+52>>2],E=j2[A+60>>2],D=j2[A+108>>2],h=j2[A+92>>2],Z=j2[A+76>>2],Y=j2[A+104>>2],R=j2[A+88>>2],F=j2[A+72>>2],W=j2[A+100>>2],m=j2[A+84>>2],N=j2[A+44>>2],V=j2[A+28>>2],J=j2[A+12>>2],M=j2[A+40>>2],I=j2[A+24>>2],x=j2[A+8>>2],y=j2[A+36>>2],U=j2[A+20>>2],X=j2[A+68>>2],p=j2[A+4>>2],T2[e+236>>2]=0,T2[e+220>>2]=0,T=z2(-n),n=z2(z2(z2(a*T)-z2(S*b))-z2(t*o)),d=z2(n+z2(z2(z2(S*g)+z2(a*Q))+z2(t*w))),B=z2(n+z2(z2(z2(S*C)+z2(a*G))+z2(t*E))),n=j2[A+272>>2],j2[e+232>>2]=(d<B?d:B)-n,i=z2(z2(z2(u*T)-z2(c*b))-z2(k*o)),f=z2(i+z2(z2(z2(c*g)+z2(u*Q))+z2(k*w))),i=z2(i+z2(z2(z2(c*C)+z2(u*G))+z2(k*E))),j2[e+228>>2]=(f<i?f:i)-n,o=z2(z2(z2(s*T)-z2(v*b))-z2(l*o)),b=z2(o+z2(z2(z2(v*g)+z2(s*Q))+z2(l*w))),o=z2(o+z2(z2(z2(v*C)+z2(s*G))+z2(l*E))),j2[e+224>>2]=(b<o?b:o)-n,j2[e+216>>2]=n+(B<d?d:B),j2[e+212>>2]=n+(i<f?f:i),j2[e+208>>2]=n+(o<b?b:o),T2[e+128>>2]=0,j2[e+124>>2]=d,j2[e+120>>2]=f,j2[e+116>>2]=b,T2[e+112>>2]=0,j2[e+108>>2]=z2(z2(S*Z)+z2(a*h))+z2(t*D),j2[e+104>>2]=z2(z2(S*F)+z2(a*R))+z2(t*Y),j2[e+100>>2]=z2(z2(S*X)+z2(a*m))+z2(t*W),T2[e+96>>2]=0,j2[e+92>>2]=z2(z2(c*Z)+z2(u*h))+z2(k*D),j2[e+88>>2]=z2(z2(c*F)+z2(u*R))+z2(k*Y),j2[e+84>>2]=z2(z2(c*X)+z2(u*m))+z2(k*W),T2[e+80>>2]=0,j2[e+76>>2]=z2(z2(v*Z)+z2(s*h))+z2(l*D),j2[e+72>>2]=z2(z2(v*F)+z2(s*R))+z2(l*Y),T2[e- -64>>2]=0,j2[e+60>>2]=B,j2[e+56>>2]=i,j2[e+52>>2]=o,T2[e+48>>2]=0,j2[e+44>>2]=z2(z2(S*J)+z2(a*V))+z2(t*N),j2[e+40>>2]=z2(z2(S*x)+z2(a*I))+z2(t*M),j2[e+36>>2]=z2(z2(S*p)+z2(a*U))+z2(t*y),T2[e+32>>2]=0,j2[e+28>>2]=z2(z2(c*J)+z2(u*V))+z2(k*N),j2[e+24>>2]=z2(z2(c*x)+z2(u*I))+z2(k*M),j2[e+20>>2]=z2(z2(c*p)+z2(u*U))+z2(k*y),T2[e+16>>2]=0,j2[e+12>>2]=z2(z2(v*J)+z2(s*V))+z2(l*N),j2[e+8>>2]=z2(z2(v*x)+z2(s*I))+z2(l*M),j2[e+68>>2]=z2(z2(v*X)+z2(s*m))+z2(l*W),j2[e+4>>2]=z2(z2(v*p)+z2(s*U))+z2(l*y),T2[e>>2]=13592,j2[e+196>>2]=n,j2[e+200>>2]=j2[A+268>>2],n1[T2[T2[r>>2]+64>>2]](r,e,e+224|0,e+208|0),(S=j2[e+200>>2])<j2[A+268>>2]?j2[A+268>>2]=S:S=z2(1))),L2=e+240|0,z2(S);},function(A,f){f|=0;var r,e=0,i=0,a=0,n=0;if(a=T2[(A|=0)+72>>2]){if((0|(i=T2[f+4>>2]))==T2[f+8>>2]&&!((0|(r=i?i<<1:1))<=(0|i))){if(r&&(T2[5498]=T2[5498]+1,(e=K2(19+(r<<2)|0))&&(T2[(n=e+19&-16)-4>>2]=e)),1<=(0|i))for(a=0,e=i;T2[a+n>>2]=T2[T2[f+12>>2]+a>>2],a=a+4|0,e=e-1|0;);(e=T2[f+12>>2])&&S2[f+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]),i=T2[f+4>>2]),T2[f+12>>2]=n,p2[f+16|0]=1,T2[f+8>>2]=r,a=T2[A+72>>2];}T2[f+4>>2]=i+1,T2[T2[f+12>>2]+(i<<2)>>2]=a;}},function(A){var f;return T2[(A|=0)>>2]=13344,f=T2[A+48>>2],n1[T2[T2[f>>2]+20>>2]](f,T2[A+64>>2]),f=T2[A+48>>2],n1[T2[T2[f>>2]+16>>2]](f,T2[A+64>>2]),0|A;},function(A){var f;T2[(A|=0)>>2]=13344,f=T2[A+48>>2],n1[T2[T2[f>>2]+20>>2]](f,T2[A+64>>2]),f=T2[A+48>>2],n1[T2[T2[f>>2]+16>>2]](f,T2[A+64>>2]),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i=0,a=0,n=0,o=z2(0),b=0,t=z2(0),c=z2(0),u=z2(0);L2=i=L2-144|0,o=j2[f>>2],t=j2[f+16>>2],c=j2[f+32>>2],j2[A+20>>2]<((u=o<t?o:t)<c?u:c)||j2[(c<j2[f+(a=!(t<o)<<4)>>2]?a:32)+f>>2]<j2[A+4>>2]||(o=j2[f+8>>2],t=j2[(a=f+24|0)>>2],c=j2[(b=f+40|0)>>2],j2[A+28>>2]<((u=o<t?o:t)<c?u:c)||j2[(c<j2[(a=t<o?f+8|0:a)>>2]?a:b)>>2]<j2[A+12>>2]||(o=j2[f+4>>2],t=j2[(a=f+20|0)>>2],c=j2[(b=f+36|0)>>2],j2[A+24>>2]<((u=o<t?o:t)<c?u:c)||j2[(c<j2[(a=t<o?f+4|0:a)>>2]?a:b)>>2]<j2[A+8>>2]||(a=T2[A+36>>2],19<T2[T2[a+4>>2]+4>>2]||(b=T2[A+48>>2],T2[(n=60+i|0)>>2]=1065353216,T2[n+4>>2]=0,c=T2[f+20>>2],T2[(n=112+i|0)>>2]=T2[f+16>>2],T2[n+4>>2]=c,c=T2[f+36>>2],T2[(n=128+i|0)>>2]=T2[f+32>>2],T2[n+4>>2]=c,t=T2[4+(c=f+8|0)>>2],T2[(n=104+i|0)>>2]=T2[c>>2],T2[n+4>>2]=t,t=T2[4+(c=f+24|0)>>2],T2[(n=120+i|0)>>2]=T2[c>>2],T2[n+4>>2]=t,t=T2[4+(c=f+40|0)>>2],T2[(n=136+i|0)>>2]=T2[c>>2],T2[n+4>>2]=t,T2[92+i>>2]=0,T2[52+i>>2]=1065353216,T2[56+i>>2]=1065353216,T2[44+i>>2]=0,T2[48+i>>2]=0,T2[36+i>>2]=1,T2[40+i>>2]=0,T2[32+i>>2]=13376,n=T2[f+4>>2],T2[96+i>>2]=T2[f>>2],T2[100+i>>2]=n,j2[84+i>>2]=j2[A+56>>2],T2[28+i>>2]=e,T2[24+i>>2]=r,f=T2[A+40>>2],T2[8+i>>2]=f,n=T2[f+8>>2],T2[20+i>>2]=T2[f+12>>2],T2[16+i>>2]=n,o=j2[T2[A+44>>2]+32>>2],T2[12+i>>2]=32+i,f=o>z2(0)?0|n1[T2[T2[b>>2]+8>>2]](b,a,8+i|0,0,2):0|n1[T2[T2[b>>2]+8>>2]](b,a,8+i|0,T2[A+64>>2],1),a=T2[A+44>>2],n=T2[a+8>>2],T2[n+8>>2]!=T2[T2[A+40>>2]+8>>2]?(n=T2[a+12>>2],T2[a+12>>2]=8+i,n1[T2[T2[a>>2]+12>>2]](a,r,e)):(T2[a+8>>2]=8+i,n1[T2[T2[a>>2]+8>>2]](a,r,e)),n1[T2[T2[f>>2]+8>>2]](f,T2[A+36>>2],8+i|0,T2[A+52>>2],T2[A+44>>2]),r=T2[A+44>>2],T2[(T2[T2[r+8>>2]+8>>2]==T2[T2[A+40>>2]+8>>2]?8:12)+r>>2]=n,n1[T2[T2[f>>2]>>2]](f),n1[T2[T2[b>>2]+60>>2]](b,f),T2[32+i>>2]=7916,(A=T2[92+i>>2])&&(n1[T2[T2[A>>2]>>2]](A),(A=T2[92+i>>2])&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2]))))))),L2=144+i|0;},Y2,g2,X2,function(A){return 13516;},function(A,f,r){A|=0,f|=0,r|=0,z2(0);var e=j2[r>>2],i=j2[r+4>>2],a=j2[r+8>>2],n=z2(z2(z2(e*j2[f+80>>2])+z2(i*j2[f+84>>2]))+z2(a*j2[f+88>>2])),o=z2(z2(z2(e*j2[f+96>>2])+z2(i*j2[f+100>>2]))+z2(a*j2[f+104>>2]));e=z2(z2(z2(e*j2[f+64>>2])+z2(i*j2[f+68>>2]))+z2(a*j2[f+72>>2])),r=T2[(f=(f- -64|0)+((e<n?n<o?2:1:(e<o)<<1)<<4)|0)+4>>2],T2[A>>2]=T2[f>>2],T2[A+4>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+8|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},function(A,f,r,e){var i,a,n,o,b,t;if(A|=0,f|=0,r|=0,e|=0,1<=(0|e))for(b=A- -64|0;i=j2[f>>2],a=j2[f+4>>2],n=j2[f+8>>2],o=z2(z2(z2(i*j2[A+80>>2])+z2(a*j2[A+84>>2]))+z2(n*j2[A+88>>2])),t=z2(z2(z2(i*j2[A+96>>2])+z2(a*j2[A+100>>2]))+z2(n*j2[A+104>>2])),i=z2(z2(z2(i*j2[A+64>>2])+z2(a*j2[A+68>>2]))+z2(n*j2[A+72>>2])),i=T2[4+(o=((i<o?o<t?2:1:(i<t)<<1)<<4)+b|0)>>2],T2[r>>2]=T2[o>>2],T2[r+4>>2]=i,t=T2[4+(o=8+o|0)>>2],T2[(i=r+8|0)>>2]=T2[o>>2],T2[4+i>>2]=t,f=f+16|0,r=r+16|0,e=e-1|0;);},p0,function(A,f,r){A|=0,f|=0,r|=0,z2(0);var e,i=j2[A+96>>2],a=j2[A+80>>2],n=j2[A+84>>2],o=j2[A+104>>2],b=j2[A+72>>2],t=j2[A+88>>2],c=j2[A+100>>2],u=j2[A+68>>2],k=j2[A+64>>2];T2[r+12>>2]=0,a=z2(a-k),c=z2(c-u),n=z2(n-u),k=z2(i-k),u=z2(z2(a*c)-z2(n*k)),A=z2((e=u)*u),u=z2(o-b),i=z2(t-b),b=z2(z2(n*u)-z2(i*c)),u=z2(z2(i*k)-z2(a*u)),k=z2(z2(1)/z2(_2(z2(A+z2(z2(b*b)+z2(u*u)))))),i=z2(e*k),j2[r+8>>2]=i,u=z2(u*k),j2[r+4>>2]=u,b=z2(b*k),j2[r>>2]=b,f&&(j2[r+8>>2]=-i,j2[r+4>>2]=-u,j2[r>>2]=-b);},T0,T0,function(A,f,r,e){e|=0,n1[T2[T2[(A|=0)>>2]+108>>2]](A,f|=0,r|=0),n1[T2[T2[A>>2]+108>>2]](A,(f+1|0)%3|0,e);},function(A,f,r){var e,i=T2[(f=(A=((f|=0)<<4)+(A|=0)|0)+72|0)+4>>2];T2[(e=(r|=0)+8|0)>>2]=T2[f>>2],T2[4+e>>2]=i,f=T2[(A=A- -64|0)+4>>2],T2[r>>2]=T2[A>>2],T2[r+4>>2]=f;},S0,function(A,f,r,e){n1[T2[T2[(A|=0)>>2]+124>>2]](A,e|=0,f|=0,r|=0);},function(A,f,r){A|=0,f|=0,r=z2(r),z2(0);var e,i,a,n,o,b,t,c,u,k,l,s=0,v=(0);return L2=s=L2-32|0,c=j2[A+64>>2],o=z2(j2[A+80>>2]-c),e=j2[A+68>>2],n=z2(j2[A+100>>2]-e),i=z2(j2[A+84>>2]-e),b=z2(j2[A+96>>2]-c),a=z2(z2(o*n)-z2(i*b)),l=z2((t=a)*a),k=i,i=j2[A+72>>2],a=z2(j2[A+104>>2]-i),u=z2(j2[A+88>>2]-i),n=z2(z2(k*a)-z2(u*n)),o=z2(z2(u*b)-z2(o*a)),b=z2(z2(1)/z2(_2(z2(l+z2(z2(n*n)+z2(o*o)))))),a=z2(t*b),n=z2(n*b),o=z2(o*b),e=z2(z2(z2(j2[f+8>>2]*a)+z2(z2(j2[f>>2]*n)+z2(j2[f+4>>2]*o)))-z2(z2(i*a)+z2(z2(c*n)+z2(e*o)))),(c=z2(-r))<=e&&e<=r&&(n1[T2[T2[A>>2]+104>>2]](A,0,16+s|0,s),b=j2[16+s>>2],e=z2(j2[s>>2]-b),u=j2[20+s>>2],i=z2(j2[4+s>>2]-u),r=z2(z2(o*e)-z2(n*i)),l=z2((t=r)*r),r=z2(a*i),k=j2[24+s>>2],i=z2(j2[8+s>>2]-k),r=z2(r-z2(o*i)),e=z2(z2(n*i)-z2(a*e)),i=z2(z2(1)/z2(_2(z2(l+z2(z2(r*r)+z2(e*e)))))),t=z2(t*i),r=z2(r*i),e=z2(e*i),c>z2(z2(z2(j2[f+8>>2]*t)+z2(z2(j2[f>>2]*r)+z2(j2[f+4>>2]*e)))-z2(z2(k*t)+z2(z2(b*r)+z2(u*e))))||(n1[T2[T2[A>>2]+104>>2]](A,1,16+s|0,s),b=j2[16+s>>2],e=z2(j2[s>>2]-b),u=j2[20+s>>2],i=z2(j2[4+s>>2]-u),r=z2(z2(o*e)-z2(n*i)),l=z2((t=r)*r),r=z2(a*i),k=j2[24+s>>2],i=z2(j2[8+s>>2]-k),r=z2(r-z2(o*i)),e=z2(z2(n*i)-z2(a*e)),i=z2(z2(1)/z2(_2(z2(l+z2(z2(r*r)+z2(e*e)))))),t=z2(t*i),r=z2(r*i),e=z2(e*i),c>z2(z2(z2(j2[f+8>>2]*t)+z2(z2(j2[f>>2]*r)+z2(j2[f+4>>2]*e)))-z2(z2(k*t)+z2(z2(b*r)+z2(u*e))))||(n1[T2[T2[A>>2]+104>>2]](A,2,16+s|0,s),t=c,c=j2[16+s>>2],e=z2(j2[s>>2]-c),i=j2[20+s>>2],b=z2(j2[4+s>>2]-i),r=z2(z2(o*e)-z2(n*b)),u=z2((k=r)*r),l=z2(a*b),r=o,o=j2[24+s>>2],b=z2(j2[8+s>>2]-o),r=z2(l-z2(r*b)),a=z2(z2(n*b)-z2(a*e)),n=z2(z2(1)/z2(_2(z2(u+z2(z2(r*r)+z2(a*a)))))),e=z2(k*n),r=z2(r*n),a=z2(a*n),t>z2(z2(z2(j2[f+8>>2]*e)+z2(z2(j2[f>>2]*r)+z2(j2[f+4>>2]*a)))-z2(z2(o*e)+z2(z2(c*r)+z2(i*a))))||(v=1)))),L2=32+s|0,0|v;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0,z2(0);var i,a,n=j2[A+96>>2],o=j2[A+80>>2],b=j2[A+84>>2],t=j2[A+104>>2],c=j2[(f=A+72|0)>>2],u=j2[A+88>>2],k=j2[A+100>>2],l=j2[A+68>>2],s=j2[A+64>>2];T2[r+12>>2]=0,o=z2(o-s),k=z2(k-l),b=z2(b-l),s=z2(n-s),l=z2(z2(o*k)-z2(b*s)),a=z2((i=l)*l),l=z2(t-c),n=z2(u-c),c=z2(z2(b*l)-z2(n*k)),l=z2(z2(n*s)-z2(o*l)),s=z2(z2(1)/z2(_2(z2(a+z2(z2(c*c)+z2(l*l)))))),j2[r+8>>2]=i*s,j2[r+4>>2]=l*s,j2[r>>2]=c*s,s=T2[f+4>>2],T2[(r=e+8|0)>>2]=T2[f>>2],T2[r+4>>2]=s,f=T2[A+68>>2],T2[e>>2]=T2[A+64>>2],T2[e+4>>2]=f;},I,function(A,f,r,e){var i,a,n;A|=0,f|=0,r|=0,e|=0,T2[(e=(L2=r=L2-800|0)+748|0)>>2]=0,T2[e+4>>2]=0,T2[(e=r+760|0)>>2]=0,T2[e+4>>2]=0,T2[r+756>>2]=1065353216,T2[(e=r+768|0)>>2]=0,T2[e+4>>2]=0,T2[(e=r+780|0)>>2]=0,T2[e+4>>2]=0,T2[r+776>>2]=1065353216,T2[(e=r+788|0)>>2]=0,T2[e+4>>2]=0,T2[r+796>>2]=0,T2[r+740>>2]=0,T2[r+744>>2]=0,T2[r+736>>2]=1065353216,T2[r+728>>2]=0,T2[r+732>>2]=0,T2[r+560>>2]=12640,j2[r+724>>2]=j2[A+200>>2],T2[(e=r+528|0)>>2]=0,T2[e+4>>2]=0,T2[r+524>>2]=1065353216,T2[(e=r+536|0)>>2]=0,T2[e+4>>2]=0,T2[r+544>>2]=0,T2[r+508>>2]=0,T2[r+512>>2]=0,T2[r+516>>2]=1065353216,T2[r+520>>2]=1065353216,T2[r+500>>2]=8,T2[r+504>>2]=0,T2[r+496>>2]=11936,T2[r+552>>2]=0,a=j2[A+196>>2],j2[r+532>>2]=a,j2[r+548>>2]=a,T2[(e=r+412|0)>>2]=1065353216,T2[e+4>>2]=0,n=T2[4+(i=f+8|0)>>2],T2[(e=r+456|0)>>2]=T2[i>>2],T2[e+4>>2]=n,i=T2[f+20>>2],T2[(e=r+464|0)>>2]=T2[f+16>>2],T2[e+4>>2]=i,n=T2[4+(i=f+24|0)>>2],T2[(e=r+472|0)>>2]=T2[i>>2],T2[e+4>>2]=n,i=T2[f+36>>2],T2[(e=r+480|0)>>2]=T2[f+32>>2],T2[e+4>>2]=i,n=T2[4+(i=f+40|0)>>2],T2[(e=r+488|0)>>2]=T2[i>>2],T2[e+4>>2]=n,T2[r+444>>2]=0,T2[r+436>>2]=1025758986,T2[r+404>>2]=1065353216,T2[r+408>>2]=1065353216,T2[r+396>>2]=0,T2[r+400>>2]=0,T2[r+388>>2]=1,T2[r+392>>2]=0,T2[r+384>>2]=13376,e=T2[f+4>>2],T2[r+448>>2]=T2[f>>2],T2[r+452>>2]=e,p2[r+356|0]=0,T2[r+332>>2]=953267991,T2[r+8>>2]=13256,T2[r+20>>2]=r+384,T2[r+16>>2]=r+496,T2[r+12>>2]=r+24,X0(r+8|0,A+4|0,A+68|0,r+736|0,r+736|0,r+560|0)&&(a=j2[r+724>>2])<j2[A+200>>2]&&(j2[A+200>>2]=a),T2[r+384>>2]=7916,(A=T2[r+444>>2])&&(n1[T2[T2[A>>2]>>2]](A),(A=T2[r+444>>2])&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2]))),L2=r+800|0;},P0,function(A){u(P0(A|=0));},z0,function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M=0,I=(0),x=z2(0),y=(0);if((0|(I=T2[A+52>>2]))<1)return z2(z2(1));for(F=(M=S2[A+68|0])?f:r,W=j2[(f=M?r:f)- -64>>2],Z=j2[f+60>>2],Y=j2[f+(M=56)>>2],R=j2[f+52>>2],m=j2[f+48>>2],n=j2[f+44>>2],o=j2[f+40>>2],b=j2[f+36>>2],N=j2[f+32>>2],t=j2[f+28>>2],c=j2[f+24>>2],u=j2[f+20>>2],V=j2[f+16>>2],k=j2[f+12>>2],l=j2[f+8>>2],r=T2[f+304>>2],s=j2[f+4>>2],J=T2[f+192>>2],x=z2(1);T2[f+304>>2]=r+1,r=T2[J+32>>2]+M|0,a=j2[r>>2],v=j2[r-8>>2],d=j2[r-4>>2],B=j2[r-24>>2],Q=j2[r-56>>2],g=j2[r-40>>2],w=j2[r-20>>2],G=j2[r-52>>2],C=j2[r-36>>2],E=j2[r-16>>2],D=j2[r-48>>2],h=j2[r-32>>2],T2[f+64>>2]=0,T2[f+48>>2]=0,T2[f+32>>2]=0,T2[f+16>>2]=0,j2[f+44>>2]=z2(z2(b*D)+z2(o*h))+z2(n*E),j2[f+40>>2]=z2(z2(b*G)+z2(o*C))+z2(n*w),j2[f+36>>2]=z2(z2(b*Q)+z2(o*g))+z2(n*B),j2[f+28>>2]=z2(z2(u*D)+z2(c*h))+z2(t*E),j2[f+24>>2]=z2(z2(u*G)+z2(c*C))+z2(t*w),j2[f+20>>2]=z2(z2(u*Q)+z2(c*g))+z2(t*B),j2[f+12>>2]=z2(z2(s*D)+z2(l*h))+z2(k*E),j2[f+8>>2]=z2(z2(s*G)+z2(l*C))+z2(k*w),j2[f+4>>2]=z2(z2(s*Q)+z2(l*g))+z2(k*B),j2[f+60>>2]=Z+z2(z2(z2(b*v)+z2(o*d))+z2(n*a)),j2[f+56>>2]=Y+z2(z2(z2(u*v)+z2(c*d))+z2(t*a)),j2[f+52>>2]=R+z2(z2(z2(s*v)+z2(l*d))+z2(k*a)),r=T2[T2[A+60>>2]+y>>2],a=z2(n1[T2[T2[r>>2]+12>>2]](r,f,F,e,i)),j2[f+64>>2]=W,j2[f+60>>2]=Z,j2[f+56>>2]=Y,j2[f+52>>2]=R,j2[f+48>>2]=m,j2[f+44>>2]=n,j2[f+40>>2]=o,j2[f+36>>2]=b,j2[f+32>>2]=N,j2[f+28>>2]=t,j2[f+24>>2]=c,j2[f+20>>2]=u,j2[f+16>>2]=V,j2[f+12>>2]=k,j2[f+8>>2]=l,j2[f+4>>2]=s,r=T2[f+304>>2]+1|0,T2[f+304>>2]=r,x=a<x?a:x,M=M+80|0,y=y+4|0,I=I-1|0;);return z2(x);},function(A,f){f|=0;var r,e=0,i=0,a=0;if(1<=(0|(e=T2[(A|=0)+52>>2])))for(;(r=T2[T2[A+60>>2]+i>>2])&&(n1[T2[T2[r>>2]+16>>2]](r,f),e=T2[A+52>>2]),i=i+4|0,(0|(a=a+1|0))<(0|e););},_,I,C2,function(A,f){var r=0,r=A|=0,e=T2[T2[T2[A+4>>2]+4>>2]+32>>2];A=T2[(f|=0)+36>>2],O0(r,T2[64+(e+P2(A,80)|0)>>2],A);},function(A,f,r){A|=0,f|=0,n1[T2[T2[A>>2]+12>>2]](A,f);},n0,n0,function(A){var f=0;return T2[(A|=0)>>2]=13964,(f=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+56>>2]=0,p2[A+60|0]=1,T2[(f=A+48|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+36>>2]=0,p2[A+40|0]=1,T2[(f=A+28|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+16>>2]=0,p2[A+20|0]=1,T2[(f=A+8|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f=0;T2[(A|=0)>>2]=13964,(f=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+56>>2]=0,p2[A+60|0]=1,T2[(f=A+48|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+36>>2]=0,p2[A+40|0]=1,T2[(f=A+28|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),u(A);},function(A,f,r){A|=0,f|=0,r|=0;var e=0,i=0,a=0,n=0,o=0,b=0,t=0,c=0,u=0;T2[5610]=T2[5610]+1,o=T2[A+36>>2],e=P2((e=((e=r<<16|f)<<15^-1)+e|0)>>>10^e,9),a=o+((T2[A+12>>2]-1&((e=((e^=e>>>6)<<11^-1)+e|0)>>>16^e))<<2)|0;A:if(-1!=(0|(e=T2[a>>2]))){for(n=T2[A+16>>2],i=e;b=n+P2(i,12)|0,T2[b+4>>2]!=(0|r)||T2[b>>2]!=(0|f);)if(-1==(0|(i=T2[T2[A+56>>2]+(i<<2)>>2])))break A;c=T2[8+(n+P2(i,12)|0)>>2],r=T2[A+56>>2];f:{if((0|e)!=(0|i)){for(;(0|i)!=(0|(e=T2[(t=r+((f=e)<<2)|0)>>2])););if(-1!=(0|f)){T2[t>>2]=T2[r+(i<<2)>>2];break f;}}T2[a>>2]=T2[r+(i<<2)>>2];}if((0|(a=T2[A+8>>2]-1|0))==(0|i))return T2[A+8>>2]=i,0|c;f:{if(n=n+P2(a,12)|0,f=T2[n+4>>2]<<16|T2[n>>2],f=P2((f=(f<<15^-1)+f|0)>>>10^f,9),t=T2[A+12>>2]-1&((f=((f^=f>>>6)<<11^-1)+f|0)>>>16^f),(0|a)!=(0|(e=T2[(o=o+(t<<2)|0)>>2]))){for(;(0|a)!=(0|(e=T2[(u=r+((f=e)<<2)|0)>>2])););if(-1!=(0|f)){T2[u>>2]=T2[r+(a<<2)>>2];break f;}}T2[o>>2]=T2[r+(a<<2)>>2];}f=T2[n+4>>2],T2[b>>2]=T2[n>>2],T2[b+4>>2]=f,T2[b+8>>2]=T2[n+8>>2],f=T2[A+36>>2]+(t<<2)|0,T2[T2[A+56>>2]+(i<<2)>>2]=T2[f>>2],T2[f>>2]=i,T2[A+8>>2]=T2[A+8>>2]-1;}return 0|c;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a=0,n=0,o=0,b=0,t=0,c=0,u=0;T2[5609]=T2[5609]+1,a=P2((a=((a=r<<16|f)<<15^-1)+a|0)>>>10^a,9),e=(a=((a^=a>>>6)<<11^-1)+a|0)>>>16^a,a=T2[A+12>>2];A:{if(-1!=(0|(o=T2[T2[A+36>>2]+((t=e&a-1)<<2)>>2])))for(n=T2[A+16>>2];;){if(b=n+P2(o,12)|0,T2[b+4>>2]==(0|r)&&T2[b>>2]==(0|f))break A;if(-1==(0|(o=T2[T2[A+56>>2]+(o<<2)>>2])))break;}f:{r:{if((0|(A=u=T2[(n=A)+8>>2]))==(0|a)){if((0|a)<(0|(A=a?a<<1:1)))break r;A=a;}T2[n+8>>2]=A+1,c=T2[n+16>>2];break f;}if(A&&(T2[5498]=T2[5498]+1,(o=K2(P2(A,12)+19|0))&&(T2[(c=o+19&-16)-4>>2]=o)),1<=(0|a))for(o=0;t=T2[n+16>>2]+o|0,i=T2[t+4>>2],T2[(b=o+c|0)>>2]=T2[t>>2],T2[b+4>>2]=i,T2[b+8>>2]=T2[t+8>>2],o=o+12|0,a=a-1|0;);(a=T2[n+16>>2])&&S2[n+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[n+16>>2]=c,T2[n+12>>2]=A,p2[n+20|0]=1,T2[n+8>>2]=T2[n+8>>2]+1,H0(n),t=T2[n+12>>2]-1&e;}b=P2(u,12)+c|0,T2[b+8>>2]=0,T2[b+4>>2]=r,T2[b>>2]=f,A=T2[n+36>>2]+(t<<2)|0,T2[T2[n+56>>2]+(u<<2)>>2]=T2[A>>2],T2[A>>2]=u;}return 0|b;},_0,K0,function(A){u(K0(A|=0));},function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s=0,v=0,d=0,B=0,Q=z2(0),g=z2(0),w=z2(0),G=z2(0),C=z2(0),E=z2(0),D=0,h=z2(0),Z=z2(0),Y=0,R=0,F=0,W=z2(0),m=z2(0),N=z2(0),V=z2(0),J=z2(0),M=z2(0),I=z2(0),x=z2(0),y=z2(0),U=z2(0),X=z2(0),p=z2(0),T=z2(0),S=z2(0),j=0,P=0,z=z2(0),O=z2(0),H=0,_=0,L=0,K=z2(0),q=(0),$=(L2-3584|0);if(L2=$,H=T2[f+4>>2],(j=T2[H+72>>2])&&(_=T2[r+4>>2],Y=T2[_+72>>2])){if(T2[_+76>>2]!=T2[A+112>>2]||T2[H+76>>2]!=T2[A+108>>2]){if(s=T2[A+84>>2],1<=(0|(d=T2[s+(v=8)>>2]))){for(;(D=T2[T2[s+16>>2]+v>>2])&&(n1[T2[T2[D>>2]>>2]](D),B=T2[A+4>>2],n1[T2[T2[B>>2]+60>>2]](B,D)),v=v+12|0,d=d-1|0;);s=T2[A+84>>2];}L0(s),T2[A+108>>2]=T2[H+76>>2],T2[A+112>>2]=T2[_+76>>2];}if(p2[0|(v=88+$|0)]=1,T2[84+$>>2]=0,T2[76+$>>2]=0,T2[80+$>>2]=0,T2[(s=232+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=240+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=248+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=256+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=264+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=272+$|0)>>2]=0,T2[s+4>>2]=0,T2[280+$>>2]=0,T2[(s=440+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=448+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=456+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=464+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=472+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=480+$|0)>>2]=0,T2[s+4>>2]=0,T2[488+$>>2]=0,T2[(s=648+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=656+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=664+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=672+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=680+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=688+$|0)>>2]=0,T2[s+4>>2]=0,T2[696+$>>2]=0,T2[112+$>>2]=1025,T2[904+$>>2]=0,T2[(s=896+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=888+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=880+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=872+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=864+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=856+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1100+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1108+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1116+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1124+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1132+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1140+$|0)>>2]=0,T2[s+4>>2]=0,T2[1148+$>>2]=0,T2[(s=1308+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1316+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1324+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1332+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1340+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1348+$|0)>>2]=0,T2[s+4>>2]=0,T2[1356+$>>2]=0,T2[956+$>>2]=0,T2[948+$>>2]=0,T2[952+$>>2]=0,T2[976+$>>2]=0,T2[980+$>>2]=1025,T2[1564+$>>2]=0,T2[(s=1556+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1548+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1540+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1532+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1524+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1516+$|0)>>2]=0,T2[s+4>>2]=0,T2[1772+$>>2]=0,T2[(s=1764+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1756+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1748+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1740+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1732+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1724+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1844+$|0)>>2]=0,T2[s+4>>2]=1025,T2[(s=1816+$|0)>>2]=0,T2[s+4>>2]=0,T2[1824+$>>2]=0,T2[(s=1968+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1976+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1984+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=1992+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2e3+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2008+$|0)>>2]=0,T2[s+4>>2]=0,T2[2016+$>>2]=0,T2[2224+$>>2]=0,T2[(s=2216+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2208+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2200+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2192+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2184+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2176+$|0)>>2]=0,T2[s+4>>2]=0,T2[2432+$>>2]=0,T2[(s=2424+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2416+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2408+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2400+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2392+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2384+$|0)>>2]=0,T2[s+4>>2]=0,T2[2640+$>>2]=0,T2[(s=2632+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2624+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2616+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2608+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2600+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2592+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2712+$|0)>>2]=0,T2[s+4>>2]=1025,T2[2692+$>>2]=0,T2[(s=2684+$|0)>>2]=0,T2[s+4>>2]=0,T2[2884+$>>2]=0,T2[(s=2876+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2868+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2860+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2852+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2844+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=2836+$|0)>>2]=0,T2[s+4>>2]=0,T2[3092+$>>2]=0,T2[(s=3084+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3076+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3068+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3060+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3052+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3044+$|0)>>2]=0,T2[s+4>>2]=0,T2[3300+$>>2]=0,T2[(s=3292+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3284+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3276+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3268+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3260+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3252+$|0)>>2]=0,T2[s+4>>2]=0,T2[3508+$>>2]=0,T2[(s=3500+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3492+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3484+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3476+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3468+$|0)>>2]=0,T2[s+4>>2]=0,T2[(s=3460+$|0)>>2]=0,T2[s+4>>2]=0,T2[3580+$>>2]=0,T2[3560+$>>2]=0,T2[(s=3552+$|0)>>2]=0,T2[s+4>>2]=0,D=T2[A+84>>2],p2[0|v]=0,T2[84+$>>2]=112+$,T2[76+$>>2]=0,T2[80+$>>2]=4,!((0|(B=T2[D+8>>2]))<=0)){for(d=0;;){if(v=T2[8+(T2[D+16>>2]+P2(d,12)|0)>>2]){if(n1[T2[T2[v>>2]+16>>2]](v,72+$|0),1<=(0|(v=T2[76+$>>2])))for(R=B=0;s=T2[T2[84+$>>2]+B>>2],T2[s+844>>2]&&(T2[i+4>>2]=s,F=T2[s+836>>2],P=T2[T2[i+8>>2]+8>>2],L=s,s=T2[T2[i+12>>2]+8>>2],m0(L,((v=(0|F)==(0|P))?F:s)+4|0,(v?s:P)+4|0),T2[i+4>>2]=0,v=T2[76+$>>2]),B=B+4|0,(0|(R=R+1|0))<(0|v););if((0|v)<=-1)for(T2[80+$>>2]<=-1&&((s=T2[84+$>>2])&&S2[88+$|0]&&(T2[5499]=T2[5499]+1,q2(T2[s-4>>2])),p2[88+$|0]=1,T2[80+$>>2]=0,T2[84+$>>2]=0),B=v<<2;B=B+4|(T2[T2[84+$>>2]+B>>2]=0),(s=v)>>>0<=(v=s+1|0)>>>0;);T2[76+$>>2]=0,B=T2[D+8>>2];}if(!((0|(d=d+1|0))<(0|B)))break;}(v=T2[84+$>>2])&&S2[88+$|0]&&(T2[5499]=T2[5499]+1,q2(T2[v-4>>2]));}if(T2[92+$>>2]=e,T2[76+$>>2]=0,T2[72+$>>2]=14068,T2[88+$>>2]=T2[A+4>>2],T2[104+$>>2]=T2[A+72>>2],T2[100+$>>2]=T2[A+84>>2],T2[84+$>>2]=r,e=T2[r+12>>2],Q=j2[e+56>>2],T2[80+$>>2]=f,v=T2[f+12>>2],g=j2[v+40>>2],U=j2[e+52>>2],w=j2[v+24>>2],V=j2[e+48>>2],h=j2[v+8>>2],X=j2[v+56>>2],S=j2[v+52>>2],J=j2[v+48>>2],G=j2[v+36>>2],C=j2[v+20>>2],Z=j2[v+4>>2],M=j2[e+40>>2],p=j2[e+24>>2],I=j2[e+8>>2],T=j2[e+36>>2],m=j2[e+20>>2],x=j2[e+4>>2],W=j2[v>>2],N=j2[v+16>>2],E=j2[v+32>>2],y=j2[e+16>>2],z=j2[e>>2],O=j2[e+32>>2],T2[96+$>>2]=i,(e=T2[j>>2])&&(v=T2[Y>>2])){for(S=z2(-S),K=z2(z2(z2(z2(w*S)-z2(h*J))-z2(g*X))+z2(z2(z2(h*V)+z2(w*U))+z2(g*Q))),t=z2(z2(z2(z2(C*S)-z2(Z*J))-z2(G*X))+z2(z2(z2(Z*V)+z2(C*U))+z2(G*Q))),U=z2(z2(z2(z2(N*S)-z2(W*J))-z2(E*X))+z2(z2(z2(W*V)+z2(N*U))+z2(E*Q))),Q=j2[i+32>>2],T2[116+$>>2]=v,T2[112+$>>2]=e,V=z2(z2(z2(h*I)+z2(w*p))+z2(g*M)),X=z2(O2(V)),J=z2(z2(z2(h*x)+z2(w*m))+z2(g*T)),S=z2(O2(J)),a=z2(z2(z2(h*z)+z2(w*y))+z2(g*O)),c=z2(O2(a)),n=z2(z2(z2(Z*I)+z2(C*p))+z2(G*M)),u=z2(O2(n)),o=z2(z2(z2(Z*x)+z2(C*m))+z2(G*T)),k=z2(O2(o)),b=z2(z2(z2(Z*z)+z2(C*y))+z2(G*O)),l=z2(O2(b)),M=z2(z2(z2(W*I)+z2(N*p))+z2(E*M)),p=z2(O2(M)),I=z2(z2(z2(W*x)+z2(N*m))+z2(E*T)),T=z2(O2(I)),W=z2(z2(z2(W*z)+z2(N*y))+z2(E*O)),N=z2(O2(W)),R=124,s=112+$|0,e=d=128,B=1;;){A:{f:{r:{if(F=T2[(v=(P=(j=B-1|0)<<3)+s|0)>>2],Y=T2[v+4>>2],G=j2[Y+16>>2],C=j2[Y>>2],g=z2(z2(z2(G-C)*z2(.5))+z2(0)),Z=j2[Y+20>>2],E=j2[Y+4>>2],w=z2(z2(z2(Z-E)*z2(.5))+z2(0)),m=j2[Y+24>>2],x=j2[Y+8>>2],h=z2(z2(z2(m-x)*z2(.5))+z2(0)),y=z2(z2(z2(N*g)+z2(T*w))+z2(p*h)),G=z2(z2(G+C)*z2(.5)),C=z2(z2(Z+E)*z2(.5)),Z=z2(z2(m+x)*z2(.5)),E=z2(U+z2(z2(z2(W*G)+z2(I*C))+z2(M*Z))),j2[F>>2]<=z2(Q+z2(y+E))&&j2[F+16>>2]>=z2(z2(E-y)-Q)&&(E=z2(z2(z2(l*g)+z2(k*w))+z2(u*h)),m=z2(t+z2(z2(z2(b*G)+z2(o*C))+z2(n*Z))),j2[F+4>>2]<=z2(Q+z2(E+m))&&j2[F+20>>2]>=z2(z2(m-E)-Q)&&(g=z2(z2(z2(c*g)+z2(S*w))+z2(X*h)),w=z2(K+z2(z2(z2(a*G)+z2(J*C))+z2(V*Z))),j2[F+8>>2]<=z2(Q+z2(g+w))&&j2[F+24>>2]>=z2(z2(w-g)-Q)))){if((0|j)<=(0|R))D=d,v=s;else {if((0|(D=d<<1))<=(0|d))v=s;else if((0|D)<=(0|e))v=s;else {if(v=0,d&&(T2[5498]=T2[5498]+1,(e=K2(19+(d<<4)|0))&&(T2[(v=e+19&-16)-4>>2]=e),!((0|d)<1)))for(R=v,e=s;L=T2[e+4>>2],T2[R>>2]=T2[e>>2],T2[R+4>>2]=L,R=R+8|0,e=e+8|0,d=d-1|0;);q&&(T2[5499]=T2[5499]+1,q2(T2[s-4>>2])),q=1,e=D;}R=D-4|0;}if(s=T2[Y+40>>2],T2[F+40>>2]){if(d=T2[F+36>>2],s){T2[(s=v+P|0)+4>>2]=T2[Y+36>>2],T2[s>>2]=d,d=T2[F+40>>2],T2[(s=(B<<3)+v|0)+4>>2]=T2[Y+36>>2],T2[s>>2]=d,d=T2[F+36>>2],T2[s+12>>2]=T2[Y+40>>2],T2[s+8>>2]=d,d=T2[F+40>>2],T2[s+20>>2]=T2[Y+40>>2],T2[s+16>>2]=d,B=B+3|0;break f;}T2[(s=v+P|0)+4>>2]=Y,T2[s>>2]=d,s=T2[F+40>>2],T2[(d=(B<<3)+v|0)+4>>2]=Y,T2[d>>2]=s;break r;}if(s){T2[(s=v+P|0)+4>>2]=T2[Y+36>>2],T2[s>>2]=F,T2[(s=(B<<3)+v|0)+4>>2]=T2[Y+40>>2],T2[s>>2]=F;break r;}n1[T2[T2[72+$>>2]+8>>2]](72+$|0,F,Y),d=D,s=v;}B=j;break A;}B=B+1|0;}d=D,s=v;}if(!B)break;}s&&q&&(T2[5499]=T2[5499]+1,q2(T2[s-4>>2]));}if(D=T2[A+84>>2],1<=T2[D+8>>2])for(s=0;;){if(e=(B=P2(s,12))+T2[D+16>>2]|0,(d=T2[e+8>>2])&&(e=T2[H+32>>2]+P2(T2[e>>2],80)|0,R=T2[e+64>>2],v=T2[f+12>>2],z=j2[v+52>>2],O=j2[v+56>>2],E=j2[e+48>>2],U=j2[e+52>>2],V=j2[e+56>>2],X=j2[e+4>>2],J=j2[e+20>>2],M=j2[e+36>>2],p=j2[e+8>>2],I=j2[e+24>>2],T=j2[e+40>>2],Q=j2[v+20>>2],g=j2[v+24>>2],m=j2[e>>2],w=j2[v+36>>2],x=j2[e+16>>2],h=j2[v+40>>2],y=j2[e+32>>2],S=j2[v+48>>2],G=j2[v+8>>2],C=j2[v>>2],Z=j2[v+4>>2],W=j2[v+16>>2],N=j2[v+32>>2],T2[172+$>>2]=0,T2[156+$>>2]=0,T2[140+$>>2]=0,T2[124+$>>2]=0,j2[144+$>>2]=z2(z2(N*m)+z2(w*x))+z2(h*y),j2[128+$>>2]=z2(z2(W*m)+z2(Q*x))+z2(g*y),j2[112+$>>2]=z2(z2(C*m)+z2(Z*x))+z2(G*y),j2[152+$>>2]=z2(z2(N*p)+z2(w*I))+z2(h*T),j2[148+$>>2]=z2(z2(N*X)+z2(w*J))+z2(h*M),j2[136+$>>2]=z2(z2(W*p)+z2(Q*I))+z2(g*T),j2[132+$>>2]=z2(z2(W*X)+z2(Q*J))+z2(g*M),j2[120+$>>2]=z2(z2(C*p)+z2(Z*I))+z2(G*T),j2[116+$>>2]=z2(z2(C*X)+z2(Z*J))+z2(G*M),j2[168+$>>2]=O+z2(z2(z2(N*E)+z2(w*U))+z2(h*V)),j2[164+$>>2]=z+z2(z2(z2(W*E)+z2(Q*U))+z2(g*V)),j2[160+$>>2]=S+z2(z2(z2(C*E)+z2(Z*U))+z2(G*V)),n1[T2[T2[R>>2]+8>>2]](R,112+$|0,56+$|0,40+$|0),Q=j2[i+32>>2],j2[56+$>>2]=j2[56+$>>2]-Q,j2[60+$>>2]=j2[60+$>>2]-Q,j2[64+$>>2]=j2[64+$>>2]-Q,j2[40+$>>2]=Q+j2[40+$>>2],j2[44+$>>2]=Q+j2[44+$>>2],j2[48+$>>2]=Q+j2[48+$>>2],e=T2[_+32>>2]+P2(T2[4+(B+T2[D+16>>2]|0)>>2],80)|0,R=T2[e+64>>2],v=T2[r+12>>2],O=j2[v+52>>2],S=j2[v+56>>2],U=j2[e+48>>2],V=j2[e+52>>2],X=j2[e+56>>2],J=j2[e+4>>2],M=j2[e+20>>2],p=j2[e+36>>2],I=j2[e+8>>2],T=j2[e+24>>2],m=j2[e+40>>2],g=j2[v+20>>2],w=j2[v+24>>2],x=j2[e>>2],h=j2[v+36>>2],y=j2[e+16>>2],G=j2[v+40>>2],z=j2[e+32>>2],K=j2[v+48>>2],C=j2[v+8>>2],Z=j2[v>>2],W=j2[v+4>>2],N=j2[v+16>>2],E=j2[v+32>>2],T2[172+$>>2]=0,T2[156+$>>2]=0,T2[140+$>>2]=0,T2[124+$>>2]=0,j2[144+$>>2]=z2(z2(E*x)+z2(h*y))+z2(G*z),j2[128+$>>2]=z2(z2(N*x)+z2(g*y))+z2(w*z),j2[112+$>>2]=z2(z2(Z*x)+z2(W*y))+z2(C*z),j2[152+$>>2]=z2(z2(E*I)+z2(h*T))+z2(G*m),j2[148+$>>2]=z2(z2(E*J)+z2(h*M))+z2(G*p),j2[136+$>>2]=z2(z2(N*I)+z2(g*T))+z2(w*m),j2[132+$>>2]=z2(z2(N*J)+z2(g*M))+z2(w*p),j2[120+$>>2]=z2(z2(Z*I)+z2(W*T))+z2(C*m),j2[116+$>>2]=z2(z2(Z*J)+z2(W*M))+z2(C*p),j2[168+$>>2]=S+z2(z2(z2(E*U)+z2(h*V))+z2(G*X)),j2[164+$>>2]=O+z2(z2(z2(N*U)+z2(g*V))+z2(w*X)),j2[160+$>>2]=K+z2(z2(z2(Z*U)+z2(W*V))+z2(C*X)),n1[T2[T2[R>>2]+8>>2]](R,112+$|0,24+$|0,8+$|0),g=z2(j2[24+$>>2]-Q),j2[24+$>>2]=g,w=z2(j2[28+$>>2]-Q),j2[28+$>>2]=w,h=z2(j2[32+$>>2]-Q),j2[32+$>>2]=h,G=z2(Q+j2[8+$>>2]),j2[8+$>>2]=G,C=z2(Q+j2[16+$>>2]),j2[16+$>>2]=C,Q=z2(Q+j2[12+$>>2]),(j2[12+$>>2]=Q)<j2[60+$>>2]||w>j2[44+$>>2]||G<j2[56+$>>2]||g>j2[40+$>>2]||C<j2[64+$>>2]||h>j2[48+$>>2])){if(n1[T2[T2[d>>2]>>2]](d),e=T2[A+4>>2],n1[T2[T2[e>>2]+60>>2]](e,d),e=B+T2[D+16>>2]|0,Y=T2[e+4>>2],F=T2[e>>2],(0|(B=T2[A+92>>2]))==T2[A+96>>2]&&!((0|(e=B?B<<1:1))<=(0|B))){if(e?(d=0,T2[5498]=T2[5498]+1,(v=K2(P2(e,12)+19|0))&&(T2[(d=v+19&-16)-4>>2]=v)):d=0,1<=(0|B))for(v=0;j=T2[A+100>>2]+v|0,P=T2[j+4>>2],T2[(R=v+d|0)>>2]=T2[j>>2],T2[R+4>>2]=P,T2[R+8>>2]=T2[j+8>>2],v=v+12|0,B=B-1|0;);(v=T2[A+100>>2])&&S2[A+104|0]&&(T2[5499]=T2[5499]+1,q2(T2[v-4>>2])),T2[A+100>>2]=d,p2[A+104|0]=1,T2[A+96>>2]=e,B=T2[A+92>>2];}e=T2[A+100>>2]+P2(B,12)|0,T2[e+8>>2]=0,T2[e+4>>2]=Y,T2[e>>2]=F,T2[A+92>>2]=T2[A+92>>2]+1;}if(!((0|(s=s+1|0))<T2[D+8>>2]))break;}if(1<=T2[A+92>>2])for(B=0,v=4;f=T2[A+84>>2],r=T2[A+100>>2]+v|0,n1[T2[T2[f>>2]+8>>2]](f,T2[r-4>>2],T2[r>>2]),v=v+12|0,(0|(B=B+1|0))<T2[A+92>>2];);(f=T2[A+100>>2])&&S2[A+104|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+100>>2]=0,T2[A+92>>2]=0,T2[A+96>>2]=0,p2[A+104|0]=1;}else z0(A,f,r,e,i);L2=3584+$|0;},function(A,f,r,e,i){return z2(z2(0));},function(A,f){f|=0;var r,e=0,i=0,a=0,e=8;if(A=T2[(A|=0)+84>>2],1<=(0|(i=T2[A+8>>2])))for(;(r=T2[T2[A+16>>2]+e>>2])&&(n1[T2[T2[r>>2]+16>>2]](r,f),i=T2[A+8>>2]),e=e+12|0,(0|(a=a+1|0))<(0|i););},I,function(A,f,r){A|=0,f|=0,r|=0,z2(0);var e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W=0,m=(0),N=(L2-240|0);if(L2=N,T2[A+4>>2]=T2[A+4>>2]+1,C=T2[r+36>>2],Y=P2(C,80),D=T2[A+12>>2],R=T2[D+4>>2]+32|0,W=T2[64+(Y+T2[R>>2]|0)>>2],r=T2[A+8>>2],E=T2[f+36>>2],f=T2[T2[r+4>>2]+32>>2]+P2(E,80)|0,m=T2[f+64>>2],r=T2[r+12>>2],k=j2[r+52>>2],c=j2[r+56>>2],F=j2[r+24>>2],n=j2[r+20>>2],e=j2[r+40>>2],i=j2[r+36>>2],h=j2[r+48>>2],o=j2[r+8>>2],b=j2[r>>2],t=j2[r+4>>2],u=j2[r+16>>2],a=j2[r+32>>2],T2[236+N>>2]=r=0,T2[220+N>>2]=0,T2[204+N>>2]=0,l=j2[f+8>>2],s=j2[f+24>>2],v=j2[f+40>>2],j2[216+N>>2]=z2(z2(a*l)+z2(i*s))+z2(e*v),d=j2[f+4>>2],B=j2[f+20>>2],Q=j2[f+36>>2],j2[212+N>>2]=z2(z2(a*d)+z2(i*B))+z2(e*Q),j2[200+N>>2]=z2(z2(u*l)+z2(n*s))+z2(F*v),j2[196+N>>2]=z2(z2(u*d)+z2(n*B))+z2(F*Q),g=c,c=j2[f+48>>2],w=j2[f+52>>2],G=j2[f+56>>2],j2[232+N>>2]=g+z2(z2(z2(a*c)+z2(i*w))+z2(e*G)),j2[228+N>>2]=k+z2(z2(z2(u*c)+z2(n*w))+z2(F*G)),T2[188+N>>2]=0,g=a,a=j2[f>>2],k=i,i=j2[f+16>>2],Z=e,e=j2[f+32>>2],j2[208+N>>2]=z2(z2(g*a)+z2(k*i))+z2(Z*e),j2[192+N>>2]=z2(z2(u*a)+z2(n*i))+z2(F*e),j2[184+N>>2]=z2(z2(b*l)+z2(t*s))+z2(o*v),j2[180+N>>2]=z2(z2(b*d)+z2(t*B))+z2(o*Q),j2[176+N>>2]=z2(z2(b*a)+z2(t*i))+z2(o*e),j2[224+N>>2]=h+z2(z2(z2(b*c)+z2(t*w))+z2(o*G)),f=T2[D+12>>2],k=j2[f+52>>2],c=j2[f+56>>2],F=j2[f+24>>2],n=j2[f+20>>2],e=j2[f+40>>2],i=j2[f+36>>2],D=T2[R>>2],h=j2[f+48>>2],o=j2[f+8>>2],b=j2[f>>2],t=j2[f+4>>2],u=j2[f+16>>2],a=j2[f+32>>2],T2[172+N>>2]=0,T2[156+N>>2]=0,T2[140+N>>2]=0,l=j2[(f=D+Y|0)+8>>2],s=j2[f+24>>2],v=j2[f+40>>2],j2[152+N>>2]=z2(z2(a*l)+z2(i*s))+z2(e*v),d=j2[f+4>>2],B=j2[f+20>>2],Q=j2[f+36>>2],j2[148+N>>2]=z2(z2(a*d)+z2(i*B))+z2(e*Q),j2[136+N>>2]=z2(z2(u*l)+z2(n*s))+z2(F*v),j2[132+N>>2]=z2(z2(u*d)+z2(n*B))+z2(F*Q),g=c,c=j2[f+48>>2],w=j2[f+52>>2],G=j2[f+56>>2],j2[168+N>>2]=g+z2(z2(z2(a*c)+z2(i*w))+z2(e*G)),j2[164+N>>2]=k+z2(z2(z2(u*c)+z2(n*w))+z2(F*G)),T2[124+N>>2]=0,g=a,a=j2[f>>2],k=i,i=j2[f+16>>2],Z=e,e=j2[f+32>>2],j2[144+N>>2]=z2(z2(g*a)+z2(k*i))+z2(Z*e),j2[128+N>>2]=z2(z2(u*a)+z2(n*i))+z2(F*e),j2[120+N>>2]=z2(z2(b*l)+z2(t*s))+z2(o*v),j2[116+N>>2]=z2(z2(b*d)+z2(t*B))+z2(o*Q),j2[112+N>>2]=z2(z2(b*a)+z2(t*i))+z2(o*e),j2[160+N>>2]=h+z2(z2(z2(b*c)+z2(t*w))+z2(o*G)),n1[T2[T2[m>>2]+8>>2]](m,176+N|0,96+N|0,80+N|0),n1[T2[T2[W>>2]+8>>2]](W,112+N|0,N+64|0,48+N|0),F=j2[T2[A+24>>2]+32>>2],n=z2(j2[100+N>>2]-F),j2[100+N>>2]=n,e=z2(j2[104+N>>2]-F),j2[104+N>>2]=e,i=z2(F+j2[80+N>>2]),j2[80+N>>2]=i,o=z2(F+j2[84+N>>2]),j2[84+N>>2]=o,b=z2(F+j2[88+N>>2]),j2[88+N>>2]=b,t=z2(j2[96+N>>2]-F),f=0,(j2[96+N>>2]=t)>j2[48+N>>2]||(f=0,i<j2[64+N>>2]||(f=1)),e>j2[56+N>>2]||b<j2[72+N>>2]||(r=f),!(n>j2[52+N>>2]||1^r|o<j2[68+N>>2])){T2[40+N>>2]=-1,T2[28+N>>2]=m,f=T2[A+8>>2],T2[24+N>>2]=f,T2[32+N>>2]=T2[f+8>>2],T2[36+N>>2]=176+N,T2[44+N>>2]=E,T2[5611]=T2[5611]+1,T2[16+N>>2]=-1,T2[4+N>>2]=W,f=T2[A+12>>2],T2[N>>2]=f,T2[8+N>>2]=T2[f+8>>2],T2[20+N>>2]=C,W=T2[A+28>>2],f=T2[W+12>>2],r=T2[W+28>>2],T2[12+N>>2]=112+N,m=f-1|0,f=P2((f=((f=C<<16|E)<<15^-1)+f|0)>>>10^f,9),f=m&((f=((f^=f>>>6)<<11^-1)+f|0)>>>16^f);A:{if(!((0|r)<=(0|f))&&-1!=(0|(f=T2[T2[W+36>>2]+(f<<2)>>2])))for(m=T2[W+16>>2];;){if(r=m+P2(f,12)|0,T2[r+4>>2]==(0|C)&&T2[r>>2]==(0|E))break A;if(-1==(0|(f=T2[T2[W+56>>2]+(f<<2)>>2])))break;}r=0;}F>z2(0)?(f=T2[A+16>>2],r=0|n1[T2[T2[f>>2]+8>>2]](f,24+N|0,N,0,2)):r?r=T2[r+8>>2]:(f=T2[A+16>>2],r=0|n1[T2[T2[f>>2]+8>>2]](f,24+N|0,N,T2[A+32>>2],1),f=T2[A+28>>2],F=0|n1[T2[T2[f>>2]+12>>2]](f,E,C),T2[8+F>>2]=r),f=T2[A+24>>2],W=T2[f+12>>2],m=T2[f+8>>2],T2[f+12>>2]=N,T2[f+8>>2]=24+N,n1[T2[T2[f>>2]+8>>2]](f,-1,E),f=T2[A+24>>2],n1[T2[T2[f>>2]+12>>2]](f,-1,C),n1[T2[T2[r>>2]+8>>2]](r,24+N|0,N,T2[A+20>>2],T2[A+24>>2]),A=T2[A+24>>2],T2[A+8>>2]=m,T2[A+12>>2]=W;}L2=240+N|0;},c0,_,I,function(A,f,r,e,i){},q0,c0,function(A){var f,r;return T2[(A|=0)>>2]=14248,S2[A+8|0]&&(f=T2[A+12>>2])&&(r=T2[A+4>>2],n1[T2[T2[r>>2]+16>>2]](r,f)),0|A;},function(A){var f,r;T2[(A|=0)>>2]=14248,S2[A+8|0]&&(f=T2[A+12>>2])&&(r=T2[A+4>>2],n1[T2[T2[r>>2]+16>>2]](r,f)),u(A);},function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t=z2(0),c=z2(0),u=z2(0);L2=e=L2-32|0,(A=T2[A+12>>2])&&(T2[i+4>>2]=A,T2[A+844>>2]=0,A=T2[f+4>>2],t=z2(j2[A+36>>2]*j2[A+20>>2]),A=T2[r+4>>2],a=z2(j2[A+36>>2]*j2[A+20>>2]),n=z2(t+a),A=T2[f+12>>2],f=T2[r+12>>2],b=j2[f+48>>2],o=z2(j2[A+48>>2]-b),r=j2[f+52>>2],c=z2(j2[A+52>>2]-r),f=j2[f+56>>2],u=z2(j2[A+56>>2]-f),t=z2(_2(z2(z2(z2(o*o)+z2(c*c))+z2(u*u)))),z2(n+j2[i+32>>2])<t||(T2[e+24>>2]=0,T2[e+28>>2]=0,T2[e+16>>2]=1065353216,T2[e+20>>2]=0,n=z2(t-n),t>z2(1.1920928955078125e-7)?(T2[e+28>>2]=0,t=z2(z2(1)/t),u=z2(u*t),j2[e+24>>2]=u,c=z2(c*t),j2[e+20>>2]=c,t=z2(o*t),j2[e+16>>2]=t):(t=z2(1),u=z2(0),c=z2(0)),T2[e+12>>2]=0,j2[e+8>>2]=z2(a*u)+f,j2[e+4>>2]=z2(a*c)+r,j2[e>>2]=z2(a*t)+b,n1[T2[T2[i>>2]+16>>2]](i,e+16|0,e,n))),L2=e+32|0;},q0,$0,I,A4,function(A){var f,r;return T2[(A|=0)>>2]=14384,S2[A+8|0]&&(f=T2[A+12>>2])&&(r=T2[A+4>>2],n1[T2[T2[r>>2]+16>>2]](r,f)),0|A;},function(A){var f,r;T2[(A|=0)>>2]=14384,S2[A+8|0]&&(f=T2[A+12>>2])&&(r=T2[A+4>>2],n1[T2[T2[r>>2]+16>>2]](r,f)),u(A);},function(A,f,r,e,i){f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s,v=0;L2=v=L2-160|0,(a=T2[(A|=0)+12>>2])&&(T2[i+4>>2]=a,k=S2[A+16|0],o=T2[(n=k?r:f)+4>>2],T2[152+v>>2]=T2[(r=k?f:r)+4>>2],T2[148+v>>2]=o,T2[144+v>>2]=14324,j2[156+v>>2]=j2[a+848>>2]+j2[i+32>>2],T2[136+v>>2]=1566444395,f=T2[n+12>>2],o=T2[4+(n=f+8|0)>>2],T2[(a=16+v|0)>>2]=T2[n>>2],T2[4+a>>2]=o,a=T2[f>>2],n=T2[f+4>>2],b=T2[4+(t=f+24|0)>>2],T2[(o=32+v|0)>>2]=T2[t>>2],T2[4+o>>2]=b,o=T2[f+16>>2],t=T2[f+20>>2],u=T2[4+(c=f+40|0)>>2],T2[(b=48+v|0)>>2]=T2[c>>2],T2[4+b>>2]=u,b=T2[f+32>>2],c=T2[f+36>>2],s=T2[4+(l=f+56|0)>>2],T2[(u=v+64|0)>>2]=T2[l>>2],T2[4+u>>2]=s,T2[8+v>>2]=a,T2[12+v>>2]=n,T2[24+v>>2]=o,T2[28+v>>2]=t,T2[40+v>>2]=b,T2[44+v>>2]=c,a=T2[f+52>>2],T2[56+v>>2]=T2[f+48>>2],T2[60+v>>2]=a,f=T2[r+12>>2],n=T2[(r=f+8|0)+4>>2],T2[(a=80+v|0)>>2]=T2[r>>2],T2[4+a>>2]=n,r=T2[f+4>>2],T2[72+v>>2]=T2[f>>2],T2[76+v>>2]=r,a=T2[f+20>>2],T2[(r=88+v|0)>>2]=T2[f+16>>2],T2[r+4>>2]=a,n=T2[4+(a=f+24|0)>>2],T2[(r=96+v|0)>>2]=T2[a>>2],T2[r+4>>2]=n,n=T2[4+(a=f+40|0)>>2],T2[(r=112+v|0)>>2]=T2[a>>2],T2[r+4>>2]=n,a=T2[f+36>>2],T2[(r=104+v|0)>>2]=T2[f+32>>2],T2[r+4>>2]=a,a=T2[f+52>>2],T2[(r=120+v|0)>>2]=T2[f+48>>2],T2[r+4>>2]=a,a=T2[(f=f+56|0)+4>>2],T2[(r=128+v|0)>>2]=T2[f>>2],T2[r+4>>2]=a,A4(144+v|0,8+v|0,i,T2[e+20>>2],k),S2[A+8|0]&&(A=T2[i+4>>2],T2[A+844>>2]&&((0|(f=T2[A+836>>2]))==(0|(r=T2[T2[i+8>>2]+8>>2]))?m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0):m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0)))),L2=160+v|0;},q0,$0,I,f4,function(A){var f,r;return T2[(A|=0)>>2]=14516,S2[A+8|0]&&(f=T2[A+12>>2])&&(r=T2[A+4>>2],n1[T2[T2[r>>2]+16>>2]](r,f)),0|A;},function(A){var f,r;T2[(A|=0)>>2]=14516,S2[A+8|0]&&(f=T2[A+12>>2])&&(r=T2[A+4>>2],n1[T2[T2[r>>2]+16>>2]](r,f)),u(A);},function(A,f,r,e,i){f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c=0;L2=c=L2-160|0,(b=T2[(A|=0)+12>>2])&&(T2[i+4>>2]=b,b=T2[f+4>>2],t=T2[r+4>>2],f=T2[f+12>>2],o=T2[4+(n=f+8|0)>>2],T2[(a=32+c|0)>>2]=T2[n>>2],T2[4+a>>2]=o,o=T2[4+(n=f+24|0)>>2],T2[(a=48+c|0)>>2]=T2[n>>2],T2[4+a>>2]=o,o=T2[4+(n=f+40|0)>>2],T2[(a=c+64|0)>>2]=T2[n>>2],T2[4+a>>2]=o,o=T2[4+(n=f+56|0)>>2],T2[(a=80+c|0)>>2]=T2[n>>2],T2[4+a>>2]=o,T2[152+c>>2]=1566444395,a=T2[f+4>>2],T2[24+c>>2]=T2[f>>2],T2[28+c>>2]=a,a=T2[f+20>>2],T2[40+c>>2]=T2[f+16>>2],T2[44+c>>2]=a,a=T2[f+36>>2],T2[56+c>>2]=T2[f+32>>2],T2[60+c>>2]=a,a=T2[f+52>>2],T2[72+c>>2]=T2[f+48>>2],T2[76+c>>2]=a,f=T2[r+12>>2],n=T2[(r=f+8|0)+4>>2],T2[(a=96+c|0)>>2]=T2[r>>2],T2[4+a>>2]=n,a=T2[f+20>>2],T2[(r=104+c|0)>>2]=T2[f+16>>2],T2[r+4>>2]=a,n=T2[4+(a=f+24|0)>>2],T2[(r=112+c|0)>>2]=T2[a>>2],T2[r+4>>2]=n,a=T2[f+36>>2],T2[(r=120+c|0)>>2]=T2[f+32>>2],T2[r+4>>2]=a,n=T2[4+(a=f+40|0)>>2],T2[(r=128+c|0)>>2]=T2[a>>2],T2[r+4>>2]=n,a=T2[f+52>>2],T2[(r=136+c|0)>>2]=T2[f+48>>2],T2[r+4>>2]=a,n=T2[4+(a=f+56|0)>>2],T2[(r=144+c|0)>>2]=T2[a>>2],T2[r+4>>2]=n,r=T2[f+4>>2],T2[88+c>>2]=T2[f>>2],T2[92+c>>2]=r,T2[16+c>>2]=t,T2[12+c>>2]=b,T2[8+c>>2]=14464,f4(8+c|0,24+c|0,i,T2[e+20>>2],0),S2[A+8|0]&&(A=T2[i+4>>2],T2[A+844>>2]&&((0|(f=T2[A+836>>2]))==(0|(r=T2[T2[i+8>>2]+8>>2]))?m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0):m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0)))),L2=160+c|0;},q0,$0,function(A){var f,r;return T2[(A|=0)>>2]=14588,S2[A+8|0]&&(f=T2[A+12>>2])&&(r=T2[A+4>>2],n1[T2[T2[r>>2]+16>>2]](r,f)),0|A;},function(A){var f,r;T2[(A|=0)>>2]=14588,S2[A+8|0]&&(f=T2[A+12>>2])&&(r=T2[A+4>>2],n1[T2[T2[r>>2]+16>>2]](r,f)),u(A);},function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I,x=z2(0),y=z2(0),U=z2(0),X=z2(0),p=z2(0),T=z2(0),S=(z2(0)),j=z2(0),P=(z2(0)),z=(z2(0)),O=(0),H=(z2(0)),_=(0),L=z2(0),K=z2(0),q=(z2(0)),$=(0),A2=z2(0),f2=z2(0),r2=z2(0),e2=z2(0),i2=z2(0),a2=(z2(0));if(L2=e=L2+-64|0,T2[A+12>>2]){if(t=S2[A+16|0],a=T2[(_=t?f:r)+12>>2],o=j2[a+56>>2],q=j2[a+52>>2],C=j2[a+48>>2],n=T2[(t=t?r:f)+12>>2],E=j2[n+56>>2],D=j2[n+52>>2],h=j2[n+48>>2],O=T2[t+4>>2],x=j2[n+32>>2],y=j2[n>>2],X=j2[n+16>>2],l=j2[n+36>>2],s=j2[n+20>>2],v=j2[n+4>>2],U=j2[a+40>>2],T=j2[a+24>>2],p=j2[a+8>>2],S=j2[a+36>>2],k=j2[a+20>>2],d=j2[a+4>>2],t=T2[_+4>>2],B=j2[a+32>>2],z=j2[n+40>>2],Q=j2[a+16>>2],H=j2[n+24>>2],g=j2[a>>2],j=j2[n+8>>2],T2[e+60>>2]=0,F=z2(z2(z2(j*d)+z2(H*k))+z2(z*S)),L=z2(-j2[(n=t+60|0)>>2]),W=z2(z2(z2(j*g)+z2(H*Q))+z2(z*B)),K=j2[t+56>>2],m=z2(z2(z2(j*p)+z2(H*T))+z2(z*U)),z=j2[($=t- -64|0)>>2],j2[e+56>>2]=z2(z2(F*L)-z2(W*K))-z2(m*z),c=z2(z2(z2(v*d)+z2(s*k))+z2(l*S)),b=z2(z2(z2(v*g)+z2(s*Q))+z2(l*B)),u=z2(z2(z2(v*p)+z2(s*T))+z2(l*U)),j2[e+52>>2]=z2(z2(c*L)-z2(K*b))-z2(z*u),w=z2(z2(z2(y*d)+z2(X*k))+z2(x*S)),G=z2(z2(z2(y*g)+z2(X*Q))+z2(x*B)),Z=z2(z2(z2(y*p)+z2(X*T))+z2(x*U)),j2[e+48>>2]=z2(z2(w*L)-z2(K*G))-z2(z*Z),n1[T2[T2[O>>2]+64>>2]](e,O,e+48|0),a=T2[_+12>>2],A2=j2[a+48>>2],z=j2[a+32>>2],H=j2[a+16>>2],j=j2[a+8>>2],L=j2[a+4>>2],K=j2[a>>2],f2=j2[a+56>>2],r2=j2[a+52>>2],e2=j2[a+40>>2],i2=j2[a+36>>2],P=j2[a+24>>2],a2=j2[a+20>>2],R=j2[t+72>>2],x=j2[$>>2],y=j2[t+56>>2],X=j2[n>>2],a=T2[A+12>>2],N=j2[a+848>>2],l=j2[e+8>>2],s=j2[e>>2],v=j2[e+4>>2],T2[i+4>>2]=a,J=z2(z2(z2(h*p)+z2(D*T))+z2(E*U)),Y=T,T=z2(-q),q=z2(z2(J+z2(z2(z2(Y*T)-z2(p*C))-z2(U*o)))+z2(z2(z2(Z*s)+z2(u*v))+z2(m*l))),p=z2(z2(z2(z2(z2(h*g)+z2(D*Q))+z2(E*B))+z2(z2(z2(Q*T)-z2(g*C))-z2(B*o)))+z2(z2(z2(G*s)+z2(b*v))+z2(W*l))),S=z2(z2(z2(z2(z2(h*d)+z2(D*k))+z2(E*S))+z2(z2(z2(k*T)-z2(d*C))-z2(S*o)))+z2(z2(z2(w*s)+z2(c*v))+z2(F*l))),(U=z2(z2(z2(x*q)+z2(z2(y*p)+z2(X*S)))-R))<N&&(T2[e+60>>2]=0,j2[e+56>>2]=z2(z2(y*z)+z2(X*i2))+z2(x*e2),j2[e+52>>2]=z2(z2(y*H)+z2(X*a2))+z2(x*P),j2[e+48>>2]=z2(z2(K*y)+z2(L*X))+z2(j*x),T2[e+44>>2]=0,T=z2(p-z2(y*U)),p=z2(S-z2(X*U)),S=z2(q-z2(x*U)),j2[e+40>>2]=z2(z2(z2(T*z)+z2(p*i2))+z2(S*e2))+f2,j2[e+36>>2]=z2(z2(z2(T*H)+z2(p*a2))+z2(S*P))+r2,j2[e+32>>2]=z2(z2(j*S)+z2(z2(K*T)+z2(L*p)))+A2,n1[T2[T2[i>>2]+16>>2]](i,e+48|0,e+32|0,U)),!(6<T2[O+4>>2]||T2[T2[i+4>>2]+844>>2]>=T2[A+24>>2]||(T=j2[t+64>>2],p=z2(O2(T))>z2(.7071067690849304)?(U=j2[t+60>>2],p=z2(z2(1)/z2(_2(z2(z2(T*T)+z2(U*U))))),U=z2(U*p),T=z2(p*z2(-T)),z2(0)):(U=j2[t+56>>2],p=j2[t+60>>2],S=z2(z2(1)/z2(_2(z2(z2(U*U)+z2(p*p))))),T=z2(U*S),U=z2(0),z2(S*z2(-p))),k=W2(S=z2(z2(F2(z2(z2(.019999999552965164)/z2(n1[T2[T2[O>>2]+16>>2]](O))),z2(.39269909262657166)))*z2(.5))),_=T2[A+20>>2],L=m2(S),(0|_)<1)))for(Y=U,U=z2(k/z2(_2(z2(z2(z2(p*p)+z2(T*T))+z2(U*U))))),K=z2(Y*U),e2=z2(T*U),i2=z2(p*U),$=0;n=S2[A+16|0],a=T2[(I=n?f:r)+12>>2],a2=j2[a+56>>2],R=j2[a+52>>2],q=j2[a+48>>2],n=T2[(O=n?r:f)+12>>2],F=j2[n+56>>2],W=j2[n+52>>2],m=j2[n+48>>2],M=T2[O+4>>2],U=j2[a+40>>2],T=j2[a+8>>2],p=j2[a+24>>2],S=j2[a+36>>2],k=j2[a+4>>2],d=j2[a+20>>2],O=T2[I+4>>2],B=j2[a+32>>2],C=j2[n+40>>2],E=j2[n+32>>2],D=j2[n+36>>2],Q=j2[a>>2],h=j2[n+8>>2],l=j2[n>>2],s=j2[n+4>>2],g=j2[a+16>>2],v=j2[n+24>>2],z=j2[n+16>>2],H=j2[n+20>>2],x=j2[t+64>>2],y=j2[t+56>>2],o=j2[t+60>>2],T2[e+44>>2]=0,X=z2(z2(z2(z2(6.2831854820251465)/z2(0|_))*z2(0|$))*z2(.5)),j=z2(W2(X)/z2(_2(z2(z2(z2(y*y)+z2(o*o))+z2(x*x))))),x=z2(x*j),y=z2(y*j),X=m2(X),o=z2(o*j),c=z2(z2(K*y)+z2(z2(z2(e2*X)-z2(L*o))-z2(i2*x))),b=z2(z2(K*x)+z2(z2(e2*o)+z2(z2(L*X)+z2(i2*y)))),u=z2(z2(e2*x)+z2(z2(z2(i2*X)-z2(L*y))-z2(K*o))),w=z2(z2(i2*o)+z2(z2(z2(K*X)-z2(L*x))-z2(e2*y))),j=z2(z2(z2(x*c)+z2(z2(y*b)+z2(X*u)))-z2(o*w)),P=z2(z2(z2(y*w)+z2(z2(X*c)+z2(o*b)))-z2(x*u)),G=z2(z2(z2(o*u)+z2(z2(x*b)+z2(X*w)))-z2(y*c)),x=z2(z2(z2(z2(X*b)-z2(y*u))-z2(o*c))-z2(x*w)),y=z2(z2(2)/z2(z2(z2(z2(j*j)+z2(P*P))+z2(G*G))+z2(x*x))),X=z2(G*y),Z=z2(j*X),o=z2(P*y),A2=z2(x*o),c=z2(Z+A2),f2=z2(P*X),b=z2(j*y),r2=z2(x*b),y=z2(f2-r2),N=z2(j*b),V=z2(P*o),P=z2(z2(1)-z2(N+V)),b=z2(z2(z2(E*c)+z2(D*y))+z2(C*P)),u=z2(z2(z2(l*c)+z2(s*y))+z2(h*P)),y=z2(z2(z2(z*c)+z2(H*y))+z2(v*P)),P=z2(-j2[(n=O+60|0)>>2]),c=j2[O+56>>2],w=j2[(_=O- -64|0)>>2],j2[e+40>>2]=z2(z2(z2(z2(S*b)+z2(z2(k*u)+z2(d*y)))*P)-z2(c*z2(z2(B*b)+z2(z2(Q*u)+z2(g*y)))))-z2(w*z2(z2(U*b)+z2(z2(T*u)+z2(p*y)))),y=z2(f2+r2),b=z2(j*o),u=z2(x*X),x=z2(b-u),G=z2(G*X),X=z2(z2(1)-z2(N+G)),o=z2(z2(C*y)+z2(z2(E*x)+z2(D*X))),j=z2(z2(h*y)+z2(z2(l*x)+z2(s*X))),x=z2(z2(v*y)+z2(z2(z*x)+z2(H*X))),j2[e+36>>2]=z2(z2(z2(z2(S*o)+z2(z2(k*j)+z2(d*x)))*P)-z2(c*z2(z2(B*o)+z2(z2(Q*j)+z2(g*x)))))-z2(w*z2(z2(U*o)+z2(z2(T*j)+z2(p*x)))),x=z2(Z-A2),y=z2(b+u),X=z2(z2(1)-z2(V+G)),o=z2(z2(C*x)+z2(z2(D*y)+z2(E*X))),j=z2(z2(h*x)+z2(z2(s*y)+z2(l*X))),x=z2(z2(v*x)+z2(z2(H*y)+z2(z*X))),j2[e+32>>2]=z2(z2(z2(z2(S*o)+z2(z2(k*j)+z2(d*x)))*P)-z2(c*z2(z2(B*o)+z2(z2(Q*j)+z2(g*x)))))-z2(w*z2(z2(U*o)+z2(z2(T*j)+z2(p*x)))),n1[T2[T2[M>>2]+64>>2]](e+48|0,M,e+32|0),a=T2[I+12>>2],N=j2[a+48>>2],c=j2[a+32>>2],b=j2[a+16>>2],u=j2[a+8>>2],w=j2[a+4>>2],G=j2[a>>2],V=j2[a+56>>2],M=j2[a+52>>2],Z=j2[a+40>>2],A2=j2[a+36>>2],f2=j2[a+24>>2],r2=j2[a+20>>2],I=j2[O+72>>2],x=j2[_>>2],y=j2[O+56>>2],X=j2[n>>2],a=T2[A+12>>2],Y=j2[a+848>>2],o=j2[e+56>>2],j=j2[e+48>>2],P=j2[e+52>>2],T2[i+4>>2]=a,J=Y,R=z2(-R),Y=z2(z2(z2(z2(z2(m*T)+z2(W*p))+z2(F*U))+z2(z2(z2(p*R)-z2(T*q))-z2(U*a2)))+z2(z2(z2(j*z2(z2(z2(l*T)+z2(z*p))+z2(E*U)))+z2(P*z2(z2(z2(s*T)+z2(H*p))+z2(D*U))))+z2(o*z2(z2(z2(h*T)+z2(v*p))+z2(C*U))))),T=z2(z2(z2(z2(z2(m*Q)+z2(W*g))+z2(F*B))+z2(z2(z2(g*R)-z2(Q*q))-z2(B*a2)))+z2(z2(z2(j*z2(z2(z2(l*Q)+z2(z*g))+z2(E*B)))+z2(P*z2(z2(z2(s*Q)+z2(H*g))+z2(D*B))))+z2(o*z2(z2(z2(h*Q)+z2(v*g))+z2(C*B))))),p=z2(z2(z2(z2(z2(m*k)+z2(W*d))+z2(F*S))+z2(z2(z2(d*R)-z2(k*q))-z2(S*a2)))+z2(z2(z2(j*z2(z2(z2(l*k)+z2(z*d))+z2(E*S)))+z2(P*z2(z2(z2(s*k)+z2(H*d))+z2(D*S))))+z2(o*z2(z2(z2(h*k)+z2(v*d))+z2(C*S))))),(U=z2(z2(z2(x*Y)+z2(z2(y*T)+z2(X*p)))-I))<J&&(T2[e+44>>2]=0,j2[e+40>>2]=z2(z2(y*c)+z2(X*A2))+z2(x*Z),j2[e+36>>2]=z2(z2(y*b)+z2(X*r2))+z2(x*f2),j2[e+32>>2]=z2(z2(G*y)+z2(w*X))+z2(u*x),T2[e+28>>2]=0,T=z2(T-z2(y*U)),p=z2(p-z2(X*U)),S=z2(Y-z2(x*U)),j2[e+24>>2]=z2(z2(z2(T*c)+z2(p*A2))+z2(S*Z))+V,j2[e+20>>2]=z2(z2(z2(T*b)+z2(p*r2))+z2(S*f2))+M,j2[e+16>>2]=z2(z2(u*S)+z2(z2(G*T)+z2(w*p)))+N,n1[T2[T2[i>>2]+16>>2]](i,e+32|0,e+16|0,U)),(0|($=$+1|0))<(0|(_=T2[A+20>>2])););S2[A+8|0]&&T2[T2[A+12>>2]+844>>2]&&(A=T2[i+4>>2],T2[A+844>>2]&&((0|(f=T2[A+836>>2]))==(0|(r=T2[T2[i+8>>2]+8>>2]))?m0(A,f+4|0,T2[T2[i+12>>2]+8>>2]+4|0):m0(A,T2[T2[i+12>>2]+8>>2]+4|0,r+4|0)));}L2=e- -64|0;},q0,$0,_,I,function(A,f,r,e,i,a,n,o,b,t){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,n|=0,o|=0,b|=0,t|=0;var c,u,k,l,s=0,v=z2(0),d=z2(0),B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=z2(0),C=z2(0),E=0,D=z2(0),h=0,Z=z2(0),Y=z2(0),R=0,F=z2(0),W=z2(0),m=z2(0),N=z2(0),V=z2(0),J=z2(0),M=z2(0),I=0,x=z2(0),y=z2(0),U=z2(0),X=0,p=0;T2[12+(L2=s=L2-19056|0)>>2]=0,j2[s>>2]=j2[a+48>>2]-j2[i+48>>2],j2[8+s>>2]=j2[(A=a+56|0)>>2]-j2[(f=i+56|0)>>2],j2[4+s>>2]=j2[(t=a+52|0)>>2]-j2[(E=i+52|0)>>2],T2[18916+s>>2]=e,T2[18912+s>>2]=r,d=j2[a+20>>2],Q=j2[a+36>>2],g=j2[(h=i+20|0)>>2],B=j2[(R=i+36|0)>>2],G=j2[(I=i+24|0)>>2],w=j2[a+24>>2],v=j2[i+40>>2],C=j2[a+40>>2],D=j2[a+32>>2],Y=j2[a>>2],m=j2[a+16>>2],N=j2[a+4>>2],F=j2[i+32>>2],W=j2[i>>2],V=j2[i+16>>2],J=j2[i+4>>2],M=j2[i+8>>2],Z=j2[a+8>>2],T2[18964+s>>2]=0,T2[18948+s>>2]=0,T2[18932+s>>2]=0,x=z2(z2(z2(M*Z)+z2(G*w))+z2(v*C)),j2[18960+s>>2]=x,y=z2(z2(z2(J*Z)+z2(g*w))+z2(B*C)),j2[18956+s>>2]=y,w=z2(z2(z2(W*Z)+z2(V*w))+z2(F*C)),j2[18952+s>>2]=w,C=z2(z2(z2(M*N)+z2(G*d))+z2(v*Q)),j2[18944+s>>2]=C,Z=z2(z2(z2(J*N)+z2(g*d))+z2(B*Q)),j2[18940+s>>2]=Z,d=z2(z2(z2(W*N)+z2(V*d))+z2(F*Q)),j2[18936+s>>2]=d,Q=z2(z2(z2(Y*M)+z2(m*G))+z2(D*v)),j2[18928+s>>2]=Q,g=z2(z2(z2(Y*J)+z2(m*g))+z2(D*B)),j2[18924+s>>2]=g,B=z2(z2(z2(Y*W)+z2(m*V))+z2(D*F)),j2[18920+s>>2]=B,G=j2[h>>2],D=j2[R>>2],Y=j2[I>>2],m=j2[t>>2],N=j2[E>>2],F=j2[A>>2],W=j2[f>>2],V=j2[i>>2],J=j2[i+16>>2],M=j2[i+32>>2],U=j2[i+4>>2],c=j2[i+8>>2],u=j2[a+48>>2],k=j2[i+48>>2],T2[19036+s>>2]=0,T2[19028+s>>2]=0,T2[19012+s>>2]=0,j2[19008+s>>2]=x,j2[19004+s>>2]=C,j2[19e3+s>>2]=Q,T2[18996+s>>2]=0,j2[18992+s>>2]=y,j2[18988+s>>2]=Z,j2[18984+s>>2]=g,T2[18980+s>>2]=0,j2[18976+s>>2]=w,j2[18972+s>>2]=d,d=z2(u-k),Q=z2(m-N),w=v,v=z2(F-W),j2[19024+s>>2]=z2(z2(c*d)+z2(Y*Q))+z2(w*v),j2[19020+s>>2]=z2(z2(d*U)+z2(Q*G))+z2(v*D),j2[19016+s>>2]=z2(z2(d*V)+z2(Q*J))+z2(v*M),T2[19032+s>>2]=24,j2[18968+s>>2]=B,T2[(A=18664+s|0)>>2]=0,T2[A+4>>2]=0,T2[18656+s>>2]=0,T2[18660+s>>2]=0,T2[18892+s>>2]=0,T2[18896+s>>2]=0,T2[18904+s>>2]=2,T2[18672+s>>2]=0,T2[28+s>>2]=0,v=j2[8+s>>2],j2[24+s>>2]=-v,g=j2[4+s>>2],j2[20+s>>2]=-g,B=j2[s>>2],j2[16+s>>2]=-B;A:{f:{r:{e:{i:{if(1==(0|r4(18528+s|0,18912+s|0,16+s|0))){for(T2[(A=s+64|0)>>2]=0,T2[A+4>>2]=0,T2[72+s>>2]=0,T2[18508+s>>2]=0,T2[16+s>>2]=9,T2[18512+s>>2]=0,T2[18516+s>>2]=0,T2[56+s>>2]=0,t=14336,f=A=T2[60+s>>2]=0;T2[(E=(16+s|0)+t|0)+4148>>2]=A,E=E+4100|(T2[E+4144>>2]=0),A&&(T2[A+44>>2]=E),A=18452+(P2(0-f|0,56)+s|0)|0,T2[18520+s>>2]=E,f=f+1|0,t=t-56|0;);if(T2[18524+s>>2]=256,E=T2[18900+s>>2],T[E+32>>2]<2)break i;if(!function A(f){var r=0,e=0,i=0,a=0,n=z2(0),o=z2(0),b=z2(0),t=z2(0),c=z2(0),u=0,k=z2(0),l=z2(0),s=z2(0),v=z2(0);a:{n:{o:{b:{t:{c:switch(r=T2[f+372>>2],T2[r+32>>2]-1|0){case 3:break o;case 2:break b;case 1:break t;case 0:break c;default:break n;}if(T2[r+32>>2]=2,T2[r+20>>2]=0,i=T2[f+364>>2]-1|0,T2[f+364>>2]=i,u=r,r=T2[348+((i<<2)+f|0)>>2],T2[u+4>>2]=r,e4(f,z2(1),z2(0),z2(0),r),i=1,A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(-1),z2(-0),z2(-0),e),A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(0),z2(1),z2(0),e),A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(-0),z2(-1),z2(-0),e),A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(0),z2(0),z2(1),e),A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(-0),z2(-0),z2(-1),e),A(f))break a;e=T2[f+364>>2],T2[f+364>>2]=e+1,r=T2[f+372>>2],i=T2[r+32>>2]-1|0,T2[r+32>>2]=i,T2[348+((e<<2)+f|0)>>2]=T2[r+(i<<2)>>2];break n;}if(i=1,e=T2[r+4>>2],a=T2[r>>2],l=z2(j2[e+16>>2]-j2[a+16>>2]),o=z2(l*z2(0)),s=z2(j2[e+20>>2]-j2[a+20>>2]),n=z2(o-s),b=z2(s*z2(0)),v=z2(j2[e+24>>2]-j2[a+24>>2]),k=z2(v*z2(0)),t=z2(b-k),c=z2(v-o),z2(z2(n*n)+z2(z2(t*t)+z2(c*c)))>z2(0)){if(T2[r+32>>2]=3,T2[r+24>>2]=0,e=T2[f+364>>2]-1|0,T2[f+364>>2]=e,u=r,r=T2[348+((e<<2)+f|0)>>2],e4(f,t,c,n,T2[u+8>>2]=r),A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(-t),z2(-c),z2(-n),e),A(f))break a;e=T2[f+364>>2],T2[f+364>>2]=e+1,r=T2[f+372>>2],i=T2[r+32>>2]-1|0,T2[r+32>>2]=i,T2[348+((e<<2)+f|0)>>2]=T2[r+(i<<2)>>2];}if(n=z2(l-b),t=z2(b-v),c=z2(k-o),z2(z2(n*n)+z2(z2(t*t)+z2(c*c)))>z2(0)){if(a=T2[f+364>>2]-1|0,T2[f+364>>2]=a,r=T2[f+372>>2],e=T2[r+32>>2],T2[r+32>>2]=e+(i=1),T2[16+(r=r+(e<<2)|0)>>2]=0,u=r,r=T2[348+((a<<2)+f|0)>>2],e4(f,t,c,n,T2[u>>2]=r),A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(-t),z2(-c),z2(-n),e),A(f))break a;e=T2[f+364>>2],T2[f+364>>2]=e+1,r=T2[f+372>>2],i=T2[r+32>>2]-1|0,T2[r+32>>2]=i,T2[348+((e<<2)+f|0)>>2]=T2[r+(i<<2)>>2];}if(i=1,o=z2(o-b),n=z2(s-k),b=z2(k-l),!(z2(z2(o*o)+z2(z2(n*n)+z2(b*b)))>z2(0)))break n;if(a=T2[f+364>>2]-1|0,T2[f+364>>2]=a,r=T2[f+372>>2],e=T2[r+32>>2],T2[r+32>>2]=e+1,T2[16+(r=r+(e<<2)|0)>>2]=0,u=r,r=T2[348+((a<<2)+f|0)>>2],e4(f,n,b,o,T2[u>>2]=r),A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(-n),z2(-b),z2(-o),e),A(f))break a;e=T2[f+364>>2],T2[f+364>>2]=e+1,r=T2[f+372>>2],i=T2[r+32>>2]-1|0,T2[r+32>>2]=i,T2[348+((e<<2)+f|0)>>2]=T2[r+(i<<2)>>2];break n;}if(i=1,e=T2[r+4>>2],a=T2[r>>2],o=j2[a+16>>2],b=z2(j2[e+16>>2]-o),u=T2[r+8>>2],n=j2[a+20>>2],k=z2(j2[u+20>>2]-n),n=z2(j2[e+20>>2]-n),t=z2(j2[u+16>>2]-o),o=z2(z2(b*k)-z2(n*t)),s=n,n=j2[a+24>>2],c=z2(j2[u+24>>2]-n),l=z2(j2[e+24>>2]-n),n=z2(z2(s*c)-z2(l*k)),b=z2(z2(l*t)-z2(b*c)),!(z2(z2(o*o)+z2(z2(n*n)+z2(b*b)))>z2(0)))break n;if(T2[(e=r+28|0)>>2]=0,T2[e+4>>2]=4,e=T2[f+364>>2]-1|0,T2[f+364>>2]=e,u=r,r=T2[348+((e<<2)+f|0)>>2],e4(f,n,b,o,T2[u+12>>2]=r),A(f))break a;if(r=T2[f+372>>2],i=T2[r+32>>2]-1|0,e=T2[(i<<2)+r>>2],T2[348+((T2[f+364>>2]<<2)+f|0)>>2]=e,T2[r+32>>2]=i,r=T2[f+372>>2],a=T2[r+32>>2],T2[r+32>>2]=a+(i=1),T2[(r=r+(a<<2)|0)>>2]=e,T2[r+16>>2]=0,e4(f,z2(-n),z2(-b),z2(-o),e),A(f))break a;e=T2[f+364>>2],T2[f+364>>2]=e+1,r=T2[f+372>>2],i=T2[r+32>>2]-1|0,T2[r+32>>2]=i,T2[348+((e<<2)+f|0)>>2]=T2[r+(i<<2)>>2];break n;}if(i=1,f=T2[r>>2],e=T2[r+12>>2],o=j2[e+16>>2],k=z2(j2[f+16>>2]-o),a=T2[r+4>>2],n=j2[e+20>>2],t=z2(j2[a+20>>2]-n),r=T2[r+8>>2],b=j2[e+24>>2],c=z2(j2[r+24>>2]-b),l=z2(j2[f+20>>2]-n),s=z2(j2[a+24>>2]-b),v=z2(j2[r+16>>2]-o),b=z2(j2[f+24>>2]-b),o=z2(j2[a+16>>2]-o),n=z2(j2[r+20>>2]-n),(o=z2(z2(z2(z2(k*t)*c)+z2(z2(z2(z2(z2(l*s)*v)+z2(z2(b*o)*n))-z2(z2(k*s)*n))-z2(z2(l*o)*c)))-z2(z2(b*t)*v)))>z2(0)|o<z2(0))break a;}i=0;}return i;}(18528+s|0))break i;if(A=T2[18512+s>>2]){for(t=T2[18516+s>>2],f=T2[18524+s>>2];(h=T2[A+48>>2])&&(T2[h+44>>2]=T2[A+44>>2]),(h=T2[A+44>>2])&&(T2[h+48>>2]=T2[A+48>>2]),T2[18512+s>>2]==(0|A)&&(T2[18512+s>>2]=T2[A+48>>2]),T2[A+44>>2]=0,T2[A+48>>2]=T2[18520+s>>2],(h=T2[18520+s>>2])&&(T2[h+44>>2]=A),t=t-1|0,T2[18520+s>>2]=A,f=f+1|0,A=T2[18512+s>>2];);T2[18524+s>>2]=f,T2[18516+s>>2]=t;}if(T2[18508+s>>2]=0,T2[16+s>>2]=0,t=T2[E>>2],f=T2[E+12>>2],d=j2[f+16>>2],w=z2(j2[t+16>>2]-d),A=T2[E+4>>2],Q=j2[f+20>>2],C=z2(j2[A+20>>2]-Q),h=T2[E+8>>2],G=j2[f+24>>2],D=z2(j2[h+24>>2]-G),Y=z2(j2[t+20>>2]-Q),m=z2(j2[A+24>>2]-G),N=z2(j2[h+16>>2]-d),G=z2(j2[t+24>>2]-G),d=z2(j2[A+16>>2]-d),Q=z2(j2[h+20>>2]-Q),z2(z2(z2(z2(w*C)*D)+z2(z2(z2(z2(z2(Y*m)*N)+z2(z2(G*d)*Q))-z2(z2(w*m)*Q))-z2(z2(Y*d)*D)))-z2(z2(G*C)*N))<z2(0)?(T2[E+4>>2]=t,T2[E>>2]=A,z=T2[E+16>>2],T2[E+16>>2]=T2[E+20>>2],T2[E+20>>2]=z,f=t):(f=A,A=t),f=a4(16+s|0,A,f,h,1),h=a4(16+s|0,T2[E+4>>2],T2[E>>2],T2[E+12>>2],1),I=a4(16+s|0,T2[E+8>>2],T2[E+4>>2],T2[E+12>>2],1),R=a4(16+s|0,T2[E>>2],T2[E+8>>2],T2[E+12>>2],1),4!=T2[18516+s>>2])break i;if(A=T2[18512+s>>2],v=j2[A+16>>2],t=T2[A+48>>2]){for(v=z2(v*v);d=j2[t+16>>2],A=(E=(d=z2(d*d))<v)?t:A,v=E?d:v,t=T2[t+48>>2];);v=j2[A+16>>2];}for(E=T2[A+28>>2],X=T2[A+24>>2],p=T2[A+20>>2],Q=j2[A+12>>2],g=j2[A+8>>2],B=j2[A+4>>2],d=j2[A>>2],T2[f+32>>2]=h,p2[f+52|0]=0,T2[h+32>>2]=f,p2[h+52|0]=0,T2[f+36>>2]=I,p2[f+53|0]=0,T2[I+32>>2]=f,p2[I+52|0]=1,T2[f+40>>2]=R,p2[f+54|0]=0,T2[R+32>>2]=f,p2[R+52|0]=2,T2[h+36>>2]=R,p2[h+53|0]=2,T2[R+40>>2]=h,p2[R+54|0]=1,T2[h+40>>2]=I,p2[h+54|0]=1,T2[I+36>>2]=h,p2[0|(f=I+53|0)]=2,p2[f+1|0]=1,T2[I+40>>2]=R,T2[R+36>>2]=I,p2[R+53|0]=2,h=T2[16+s>>2]=0;;){a:{n:{if(!((f=T2[18508+s>>2])>>>0<=127)){T2[16+s>>2]=6;break a;}if(p2[A+55|0]=h=h+1|0,T2[19048+s>>2]=0,T2[19040+s>>2]=0,T2[19044+s>>2]=0,T2[18508+s>>2]=f+1,e4(18528+s|0,j2[A>>2],j2[(t=A+4|0)>>2],j2[(R=A+8|0)>>2],I=(f=(16+s|0)+(f<<5)|0)+60|0),!(z2(z2(z2(z2(j2[A>>2]*j2[f+76>>2])+z2(j2[t>>2]*j2[f+80>>2]))+z2(j2[R>>2]*j2[f+84>>2]))-j2[A+16>>2])>z2(9999999747378752e-20))){T2[16+s>>2]=7;break a;}for(t=0,f=32;;){if(!(R=function A(f,r,e,i,a,n){var o,b,t=0;o:if(S2[i+55|0]!=(0|r)){if(b=T2[14656+(o=a<<2)>>2],z2(z2(z2(z2(j2[i>>2]*j2[e+16>>2])+z2(j2[i+4>>2]*j2[e+20>>2]))+z2(j2[i+8>>2]*j2[e+24>>2]))-j2[i+16>>2])<z2(-9999999747378752e-21)){if(!(f=a4(r=f,T2[(f=i+20|0)+(b<<2)>>2],T2[f+o>>2],e,0)))break o;return T2[f+32>>2]=i,p2[f+52|0]=a,p2[52+(i+a|0)|0]=0,T2[32+((a<<2)+i|0)>>2]=f,(r=T2[n>>2])?(T2[r+36>>2]=f,p2[r+53|0]=2,T2[f+40>>2]=r,p2[f+54|0]=1):T2[n+4>>2]=f,T2[n>>2]=f,T2[n+8>>2]=T2[n+8>>2]+1,1;}A(f,p2[i+55|0]=r,e,T2[32+((b<<2)+i|0)>>2],S2[52+(i+b|0)|0],n)&&(a=r,r=T2[14668+o>>2],A(f,a,e,T2[32+((r<<2)+i|0)>>2],S2[52+(r+i|0)|0],n)&&((r=T2[i+48>>2])&&(T2[r+44>>2]=T2[i+44>>2]),(r=T2[i+44>>2])&&(T2[r+48>>2]=T2[i+48>>2]),T2[f+18496>>2]==(0|i)&&(T2[f+18496>>2]=T2[i+48>>2]),T2[i+44>>2]=0,T2[i+48>>2]=T2[f+18504>>2],T2[(r=f+18500|0)>>2]=T2[r>>2]-1,(r=T2[f+18504>>2])&&(T2[r+44>>2]=i),T2[f+18504>>2]=i,T2[(f=f+18508|0)>>2]=T2[f>>2]+(t=1)));}return t;}(16+s|0,h,I,T2[A+f>>2],S2[52+(A+t|0)|0],19040+s|0)))break n;if(f=f+4|0,l=t>>>0<2,t=t+1|0,!l)break;}}if(R&2<T[19048+s>>2]){if(f=T2[19040+s>>2],p2[f+53|0]=2,t=T2[19044+s>>2],T2[f+36>>2]=t,T2[t+40>>2]=f,p2[t+54|0]=1,(f=T2[A+48>>2])&&(T2[f+44>>2]=T2[A+44>>2]),(f=T2[A+44>>2])&&(T2[f+48>>2]=T2[A+48>>2]),T2[18512+s>>2]==(0|A)&&(T2[18512+s>>2]=T2[A+48>>2]),T2[A+44>>2]=0,T2[A+48>>2]=T2[18520+s>>2],T2[18516+s>>2]=T2[18516+s>>2]-1,(f=T2[18520+s>>2])&&(T2[f+44>>2]=A),T2[18520+s>>2]=A,T2[18524+s>>2]=T2[18524+s>>2]+1,A=T2[18512+s>>2],v=j2[A+16>>2],t=T2[A+48>>2]){for(v=z2(v*v);d=j2[t+16>>2],A=(f=(d=z2(d*d))<v)?t:A,v=f?d:v,t=T2[t+48>>2];);v=j2[A+16>>2];}if(E=T2[A+28>>2],X=T2[A+24>>2],p=T2[A+20>>2],Q=j2[A+12>>2],g=j2[A+8>>2],B=j2[A+4>>2],d=j2[A>>2],255!=(0|h))continue;}else T2[16+s>>2]=4;}break;}if(j2[68+s>>2]=Q,j2[s+64>>2]=g,j2[60+s>>2]=B,j2[72+s>>2]=v,j2[56+s>>2]=d,A=36+s|0,d=z2(d*v),G=z2(j2[X+16>>2]-d),f=E+20|0,Q=z2(B*v),B=z2(j2[f>>2]-Q),w=z2(j2[(t=X+20|0)>>2]-Q),C=z2(j2[E+16>>2]-d),D=z2(z2(G*B)-z2(w*C)),v=z2(g*v),g=z2(j2[E+24>>2]-v),Z=z2(w*g),w=z2(j2[(h=X+24|0)>>2]-v),B=z2(Z-z2(w*B)),Z=z2(B*B),B=z2(z2(w*C)-z2(G*g)),B=z2(_2(z2(z2(D*D)+z2(Z+z2(B*B))))),j2[A>>2]=B,T2[20+s>>2]=p,R=40+s|0,G=z2(j2[E+16>>2]-d),w=z2(j2[(I=p+20|0)>>2]-Q),C=z2(j2[f>>2]-Q),D=z2(j2[p+16>>2]-d),Y=z2(z2(G*w)-z2(C*D)),Z=C,C=z2(j2[(f=p+24|0)>>2]-v),w=z2(z2(Z*C)-z2(g*w)),g=z2(z2(g*D)-z2(G*C)),g=z2(_2(z2(z2(Y*Y)+z2(z2(w*w)+z2(g*g))))),j2[R>>2]=g,T2[52+s>>2]=3,T2[28+s>>2]=E,T2[24+s>>2]=X,Z=z2((C=B)+g),B=z2(j2[p+16>>2]-d),G=z2(j2[t>>2]-Q),Q=z2(j2[I>>2]-Q),d=z2(j2[X+16>>2]-d),w=z2(z2(B*G)-z2(Q*d)),D=Q,Q=z2(j2[h>>2]-v),v=z2(j2[f>>2]-v),G=z2(z2(D*Q)-z2(v*G)),v=z2(z2(v*d)-z2(B*Q)),d=z2(_2(z2(z2(w*w)+z2(z2(G*G)+z2(v*v))))),v=z2(Z+d),j2[A>>2]=C/v,j2[44+s>>2]=d/v,j2[R>>2]=g/v,9!=T2[16+s>>2]){if(T2[52+s>>2])break e;d=z2(0),B=z2(0),g=z2(0);break r;}}if(T2[18532+s>>2]=e,T2[18528+s>>2]=r,Y=j2[a+32>>2],m=j2[a>>2],N=j2[a+16>>2],F=j2[a+36>>2],W=j2[a+4>>2],V=j2[a+20>>2],v=j2[i+32>>2],d=j2[i>>2],Q=j2[i+16>>2],g=j2[i+36>>2],B=j2[i+4>>2],G=j2[i+20>>2],w=j2[i+40>>2],J=j2[a+40>>2],C=j2[i+8>>2],M=j2[a+8>>2],D=j2[i+24>>2],Z=j2[a+24>>2],T2[18580+s>>2]=0,T2[18564+s>>2]=0,T2[18548+s>>2]=0,T2[18652+s>>2]=0,T2[18644+s>>2]=0,T2[18628+s>>2]=0,T2[18612+s>>2]=0,T2[18596+s>>2]=0,x=z2(z2(z2(C*M)+z2(D*Z))+z2(w*J)),j2[18576+s>>2]=x,y=z2(z2(z2(B*M)+z2(G*Z))+z2(g*J)),j2[18572+s>>2]=y,J=z2(z2(z2(d*M)+z2(Q*Z))+z2(v*J)),j2[18568+s>>2]=J,M=z2(z2(z2(C*W)+z2(D*V))+z2(w*F)),j2[18560+s>>2]=M,Z=z2(z2(z2(B*W)+z2(G*V))+z2(g*F)),j2[18556+s>>2]=Z,F=z2(z2(z2(d*W)+z2(Q*V))+z2(v*F)),j2[18552+s>>2]=F,W=z2(z2(z2(m*C)+z2(N*D))+z2(Y*w)),j2[18544+s>>2]=W,V=z2(z2(z2(m*B)+z2(N*G))+z2(Y*g)),j2[18540+s>>2]=V,j2[18624+s>>2]=x,j2[18620+s>>2]=M,j2[18616+s>>2]=W,j2[18608+s>>2]=y,j2[18604+s>>2]=Z,j2[18600+s>>2]=V,j2[18592+s>>2]=J,j2[18588+s>>2]=F,Z=C,C=z2(j2[a+48>>2]-j2[i+48>>2]),F=D,D=z2(j2[a+52>>2]-j2[i+52>>2]),W=w,w=z2(j2[a+56>>2]-j2[i+56>>2]),j2[18640+s>>2]=z2(z2(Z*C)+z2(F*D))+z2(W*w),j2[18636+s>>2]=z2(z2(C*B)+z2(D*G))+z2(w*g),j2[18632+s>>2]=z2(z2(C*d)+z2(D*Q))+z2(w*v),T2[18648+s>>2]=25,v=z2(z2(z2(m*d)+z2(N*Q))+z2(Y*v)),j2[18536+s>>2]=v,j2[18584+s>>2]=v,T2[(A=152+s|0)>>2]=0,T2[A+4>>2]=0,T2[144+s>>2]=0,T2[148+s>>2]=0,T2[380+s>>2]=0,T2[384+s>>2]=0,T2[392+s>>2]=2,!r4(16+s|(T2[160+s>>2]=0),18528+s|0,s)){if(t=T2[388+s>>2],T2[t+32>>2])for(Y=z2(0),D=z2(f=A=0),C=z2(0),w=z2(0),G=z2(0),Q=z2(0);v=j2[(e=A+t|0)+16>>2],r=T2[18648+s>>2],a=T2[18652+s>>2],t=T2[18528+s>>2]+(a>>1)|0,n1[0|(1&a?T2[r+T2[t>>2]>>2]:r)](18912+s|0,t,T2[e>>2]),r=T2[T2[388+s>>2]+A>>2],d=j2[r+8>>2],g=j2[r>>2],B=z2(-j2[r+4>>2]),r=T2[18648+s>>2],e=T2[18652+s>>2],a=T2[18532+s>>2]+(e>>1)|0,r=1&e?T2[r+T2[a>>2]>>2]:r,Y=z2(Y+z2(v*j2[18920+s>>2])),D=z2(D+z2(v*j2[18916+s>>2])),C=z2(C+z2(v*j2[18912+s>>2])),T2[19052+s>>2]=0,j2[19048+s>>2]=z2(z2(j2[18572+s>>2]*B)-z2(g*j2[18568+s>>2]))-z2(d*j2[18576+s>>2]),j2[19044+s>>2]=z2(z2(j2[18556+s>>2]*B)-z2(g*j2[18552+s>>2]))-z2(d*j2[18560+s>>2]),j2[19040+s>>2]=z2(z2(j2[18540+s>>2]*B)-z2(g*j2[18536+s>>2]))-z2(d*j2[18544+s>>2]),n1[0|r](18912+s|0,a,19040+s|0),d=j2[18912+s>>2],g=j2[18916+s>>2],B=j2[18920+s>>2],w=z2(w+z2(v*z2(z2(z2(z2(d*j2[18616+s>>2])+z2(g*j2[18620+s>>2]))+z2(B*j2[18624+s>>2]))+j2[18640+s>>2]))),G=z2(G+z2(v*z2(z2(z2(z2(d*j2[18600+s>>2])+z2(g*j2[18604+s>>2]))+z2(B*j2[18608+s>>2]))+j2[18636+s>>2]))),Q=z2(Q+z2(v*z2(z2(z2(z2(d*j2[18584+s>>2])+z2(g*j2[18588+s>>2]))+z2(B*j2[18592+s>>2]))+j2[18632+s>>2]))),A=A+4|0,t=T2[388+s>>2],(f=f+1|0)>>>0<T[t+32>>2];);else Q=z2(0),G=z2(0),w=z2(0),C=z2(0),D=z2(0),Y=z2(0);g=z2(C-Q),B=z2(D-G),d=z2(Y-w),v=(v=z2(_2(z2(z2(z2(g*g)+z2(B*B))+z2(d*d)))))>z2(9999999747378752e-20)?z2(z2(1)/v):z2(1),d=z2(d*v),m=z2(B*v),B=z2(g*v),F=j2[i+32>>2],W=j2[i+36>>2],V=j2[i+40>>2],J=j2[i+56>>2],g=z2(z2(z2(z2(Q*F)+z2(G*W))+z2(w*V))+J),M=j2[i+16>>2],Z=j2[i+20>>2],x=j2[i+24>>2],y=j2[i+52>>2],N=z2(z2(z2(z2(Q*M)+z2(G*Z))+z2(w*x))+y),U=j2[i>>2],c=j2[i+4>>2],v=w,w=j2[i+8>>2],u=j2[i+48>>2],v=z2(z2(z2(z2(Q*U)+z2(G*c))+z2(v*w))+u),Q=z2(z2(z2(z2(C*F)+z2(D*W))+z2(Y*V))+J),G=z2(z2(z2(z2(C*M)+z2(D*Z))+z2(Y*x))+y),w=z2(z2(z2(z2(C*U)+z2(D*c))+z2(Y*w))+u),A=0;break f;}A=0;break A;}T2[16+s>>2]=8,d=z2(0),Q=z2(1),G=z2(0),(w=z2(_2(z2(z2(z2(B*B)+z2(g*g))+z2(v*v)))))>z2(0)&&(Q=z2(z2(1)/w),G=z2(Q*v),d=z2(Q*g),Q=z2(Q*B)),T2[52+s>>2]=1,T2[36+s>>2]=1065353216,T2[68+s>>2]=0,T2[72+s>>2]=0,j2[64+s>>2]=G,j2[60+s>>2]=d,j2[56+s>>2]=Q,T2[20+s>>2]=T2[E>>2];}for(A=36+s|0,g=z2(0),B=z2(f=0),d=z2(0);r=T2[19032+s>>2],e=T2[19036+s>>2],a=T2[18912+s>>2]+(e>>1)|0,n1[0|(1&e?T2[r+T2[a>>2]>>2]:r)](19040+s|0,a,T2[A-16>>2]),v=j2[A>>2],g=z2(g+z2(v*j2[19048+s>>2])),B=z2(B+z2(v*j2[19044+s>>2])),d=z2(d+z2(j2[19040+s>>2]*v)),A=A+4|0,(f=f+1|0)>>>0<T[52+s>>2];);}C=j2[i+32>>2],D=j2[i+36>>2],Y=j2[i+40>>2],m=j2[i+56>>2],Q=z2(z2(z2(z2(d*C)+z2(B*D))+z2(g*Y))+m),N=j2[i+16>>2],F=j2[i+20>>2],W=j2[i+24>>2],V=j2[i+52>>2],G=z2(z2(z2(z2(d*N)+z2(B*F))+z2(g*W))+V),J=j2[i>>2],M=j2[i+4>>2],Z=j2[i+8>>2],x=j2[i+48>>2],w=z2(z2(z2(z2(d*J)+z2(B*M))+z2(g*Z))+x),y=j2[56+s>>2],v=j2[72+s>>2],d=z2(d-z2(y*v)),U=z2(d*C),C=j2[60+s>>2],B=z2(B-z2(v*C)),U=z2(U+z2(B*D)),D=j2[s+64>>2],v=z2(g-z2(v*D)),g=z2(z2(U+z2(v*Y))+m),N=z2(z2(z2(z2(d*N)+z2(B*F))+z2(v*W))+V),v=z2(z2(z2(z2(d*J)+z2(B*M))+z2(v*Z))+x),B=z2(-y),d=z2(-D),m=z2(-C),A=1;}T2[o+12>>2]=0,j2[o+8>>2]=Q,j2[o+4>>2]=G,j2[o>>2]=w,T2[b+12>>2]=0,j2[b+8>>2]=g,j2[b+4>>2]=N,j2[b>>2]=v,T2[n+12>>2]=0,j2[n+8>>2]=d,j2[n+4>>2]=m,j2[n>>2]=B;}return L2=19056+s|0,0|A;},I,C2,C2,function(A,f,r,e){A|=0,f|=0,r|=0,e=z2(e);var i,a=T2[f+4>>2];T2[A+4>>2]=T2[f>>2],T2[A+8>>2]=a,i=T2[(f=f+8|0)+4>>2],T2[(a=A+12|0)>>2]=T2[f>>2],T2[4+a>>2]=i,f=T2[r+4>>2],T2[A+20>>2]=T2[r>>2],T2[A+24>>2]=f,a=T2[(r=r+8|0)+4>>2],T2[(f=A+28|0)>>2]=T2[r>>2],T2[f+4>>2]=a,p2[A+40|0]=1,j2[A+36>>2]=e;},I,function(A,f,r,e,i,a,n,o,b,t){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,n|=0,o|=0,b|=0,t|=0;var c,u,k,l,s,v,d,B=0,Q=z2(0),g=0,w=z2(0),G=z2(0),C=0,E=z2(0),D=z2(0),h=z2(0),Z=0,Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=z2(0),N=0,V=z2(0),J=0,M=0,I=0,x=0,y=(z2(0));for(L2=A=L2-4240|0,l=T2[r+4>>2]-17>>>0<=1?T2[e+4>>2]-17>>>0<2:0;o4(),T2[(B=(A+1264|0)+g|0)+12>>2]=0,Y=j2[g+22452>>2],Q=z2(-Y),D=j2[g+22448>>2],h=j2[g+22456>>2],j2[B+8>>2]=z2(z2(j2[i+24>>2]*Q)-z2(D*j2[i+8>>2]))-z2(h*j2[i+40>>2]),j2[B+4>>2]=z2(z2(j2[i+20>>2]*Q)-z2(D*j2[i+4>>2]))-z2(h*j2[i+36>>2]),j2[B>>2]=z2(z2(j2[i+16>>2]*Q)-z2(D*j2[i>>2]))-z2(h*j2[i+32>>2]),V=j2[a+32>>2],R=j2[a>>2],F=j2[a+16>>2],W=j2[a+36>>2],m=j2[a+4>>2],E=j2[a+20>>2],w=j2[a+40>>2],G=j2[a+8>>2],Q=j2[a+24>>2],T2[(B=(A+272|0)+g|0)+12>>2]=0,j2[B+8>>2]=z2(z2(D*G)+z2(Y*Q))+z2(h*w),j2[B+4>>2]=z2(z2(D*m)+z2(Y*E))+z2(h*W),j2[B>>2]=z2(z2(D*R)+z2(Y*F))+z2(h*V),672!=(0|(g=g+16|0)););if(B=42,!((0|(J=0|n1[T2[T2[r>>2]+84>>2]](r)))<1)){for(Z=A+3256|0,g=0;n1[T2[T2[r>>2]+88>>2]](r,N,A+3248|0),w=j2[A+3248>>2],G=j2[A+3252>>2],Q=j2[Z>>2],j2[Z>>2]=z2(z2(w*j2[i+32>>2])+z2(G*j2[i+36>>2]))+z2(Q*j2[i+40>>2]),T2[A+3260>>2]=0,j2[A+3252>>2]=z2(z2(w*j2[i+16>>2])+z2(G*j2[i+20>>2]))+z2(Q*j2[i+24>>2]),j2[A+3248>>2]=z2(z2(w*j2[i>>2])+z2(G*j2[i+4>>2]))+z2(Q*j2[i+8>>2]),o4(),B=T2[Z+4>>2],T2[(C=g+23128|0)>>2]=T2[Z>>2],T2[C+4>>2]=B,B=T2[A+3252>>2],T2[(C=g+23120|0)>>2]=T2[A+3248>>2],T2[C+4>>2]=B,T2[(B=(A+1264|0)+g|0)+684>>2]=0,G=j2[A+3252>>2],Q=z2(-G),E=j2[A+3248>>2],w=j2[Z>>2],j2[B+680>>2]=z2(z2(j2[i+24>>2]*Q)-z2(E*j2[i+8>>2]))-z2(w*j2[i+40>>2]),j2[B+676>>2]=z2(z2(j2[i+20>>2]*Q)-z2(E*j2[i+4>>2]))-z2(w*j2[i+36>>2]),j2[B+672>>2]=z2(z2(j2[i+16>>2]*Q)-z2(E*j2[i>>2]))-z2(w*j2[i+32>>2]),T2[(B=(A+272|0)+g|0)+684>>2]=0,j2[B+672>>2]=z2(z2(E*j2[a>>2])+z2(G*j2[a+16>>2]))+z2(w*j2[a+32>>2]),j2[B+676>>2]=z2(z2(E*j2[a+4>>2])+z2(G*j2[a+20>>2]))+z2(w*j2[a+36>>2]),j2[B+680>>2]=z2(z2(E*j2[a+8>>2])+z2(G*j2[a+24>>2]))+z2(w*j2[a+40>>2]),g=g+16|0,(0|J)!=(0|(N=N+1|0)););B=N+42|0;}if(s=r,v=A+1264|0,d=A+3248|0,1<=(0|(N=0|n1[T2[T2[e>>2]+84>>2]](e)))){for(u=B<<4,M=A+272|0,I=A+1264|0,x=22448,g=0;n1[T2[T2[e>>2]+88>>2]](e,g,A+3248|0),w=j2[(c=A+3256|0)>>2],G=j2[A+3248>>2],Q=j2[A+3252>>2],j2[c>>2]=z2(z2(G*j2[a+32>>2])+z2(Q*j2[a+36>>2]))+z2(w*j2[a+40>>2]),T2[A+3260>>2]=0,j2[A+3252>>2]=z2(z2(G*j2[a+16>>2])+z2(Q*j2[a+20>>2]))+z2(w*j2[a+24>>2]),j2[A+3248>>2]=z2(z2(G*j2[a>>2])+z2(Q*j2[a+4>>2]))+z2(w*j2[a+8>>2]),o4(),C=T2[4+c>>2],T2[(J=(Z=u+x|0)+8|0)>>2]=T2[c>>2],T2[J+4>>2]=C,C=T2[A+3252>>2],T2[Z>>2]=T2[A+3248>>2],T2[Z+4>>2]=C,T2[(C=u+I|0)+12>>2]=0,G=j2[A+3252>>2],Q=z2(-G),E=j2[A+3248>>2],w=j2[c>>2],j2[C+8>>2]=z2(z2(j2[i+24>>2]*Q)-z2(E*j2[i+8>>2]))-z2(w*j2[i+40>>2]),j2[C+4>>2]=z2(z2(j2[i+20>>2]*Q)-z2(E*j2[i+4>>2]))-z2(w*j2[i+36>>2]),j2[C>>2]=z2(z2(j2[i+16>>2]*Q)-z2(E*j2[i>>2]))-z2(w*j2[i+32>>2]),T2[(C=u+M|0)+12>>2]=0,j2[C>>2]=z2(z2(E*j2[a>>2])+z2(G*j2[a+16>>2]))+z2(w*j2[a+32>>2]),j2[C+4>>2]=z2(z2(E*j2[a+4>>2])+z2(G*j2[a+20>>2]))+z2(w*j2[a+36>>2]),j2[C+8>>2]=z2(z2(E*j2[a+8>>2])+z2(G*j2[a+24>>2]))+z2(w*j2[a+40>>2]),x=x+16|0,I=I+16|0,M=M+16|0,(0|N)!=(0|(g=g+1|0)););B=g+B|0;}if(n1[T2[T2[r>>2]+76>>2]](s,v,d,B),n1[T2[T2[e>>2]+76>>2]](e,A+272|0,A+2256|0,B),(0|B)<1)m=z2(0xde0b6b000000000),R=z2(0),F=z2(0),W=z2(0);else for(m=z2(0xde0b6b000000000),W=z2(g=0),F=z2(0),R=z2(0);o4(),E=j2[g+22448>>2],w=j2[g+22452>>2],G=l?z2(0):j2[g+22456>>2],.01<+z2(z2(z2(E*E)+z2(w*w))+z2(G*G))&&(k=j2[(C=(A+2256|0)+g|0)>>2],D=j2[C+4>>2],h=j2[C+8>>2],Y=j2[(C=(A+3248|0)+g|0)>>2],V=j2[C+4>>2],Q=j2[C+8>>2],(Q=z2(z2(z2(E*z2(z2(z2(z2(z2(k*j2[a>>2])+z2(D*j2[a+4>>2]))+z2(h*j2[a+8>>2]))+j2[a+48>>2])-z2(z2(z2(z2(Y*j2[i>>2])+z2(V*j2[i+4>>2]))+z2(Q*j2[i+8>>2]))+j2[i+48>>2])))+z2(w*z2(z2(z2(z2(z2(k*j2[a+16>>2])+z2(D*j2[a+20>>2]))+z2(h*j2[a+24>>2]))+j2[a+52>>2])-z2(z2(z2(z2(Y*j2[i+16>>2])+z2(V*j2[i+20>>2]))+z2(Q*j2[i+24>>2]))+j2[i+52>>2]))))+z2(G*z2(l?0:z2(z2(z2(z2(k*j2[a+32>>2])+z2(D*j2[a+36>>2]))+z2(h*j2[a+40>>2]))+j2[a+56>>2])-z2(z2(z2(z2(Y*j2[i+32>>2])+z2(V*j2[i+36>>2]))+z2(Q*j2[i+40>>2]))+j2[i+56>>2])))))<m&&(y=j2[g+22460>>2],R=E,F=w,W=G,m=Q)),g=g+16|0,B=B-1|0;);if(1<<(B=T2[r+4>>2])&11571&&B>>>0<=13||z2(n1[T2[T2[r>>2]+48>>2]](r)),1<<(B=T2[e+4>>2])&11571&&B>>>0<=13||z2(n1[T2[T2[e>>2]+48>>2]](e)),!(m<z2(g=0))){A:{f:switch(T2[r+4>>2]){case 8:Q=z2(j2[r+36>>2]*j2[r+20>>2]);break A;case 0:case 1:case 13:case 11:case 10:Q=j2[r+52>>2];break A;case 4:case 5:Q=j2[r+52>>2];break A;default:break f;}Q=z2(n1[T2[T2[r>>2]+48>>2]](r));}A:{f:{r:{e:{i:{a:{n:{o:{b:switch(0|(g=T2[e+4>>2])){case 4:case 5:break r;case 10:break e;case 11:break i;case 13:break a;case 1:break n;case 0:break o;case 8:break b;default:break f;}w=z2(j2[e+36>>2]*j2[e+20>>2]),g=8;break A;}w=j2[e+52>>2],g=0;break A;}w=j2[e+52>>2],g=1;break A;}w=j2[e+52>>2],g=13;break A;}w=j2[e+52>>2],g=11;break A;}w=j2[e+52>>2],g=10;break A;}w=j2[e+52>>2];break A;}w=z2(n1[T2[T2[e>>2]+48>>2]](e)),g=T2[e+4>>2];}T2[(B=C=A+204|0)>>2]=0,T2[B+4>>2]=0,T2[A+224>>2]=e,T2[A+220>>2]=r,T2[A+216>>2]=f,T2[A+212>>2]=0,T2[A+196>>2]=0,T2[A+200>>2]=1065353216,T2[A+192>>2]=12272,T2[A+232>>2]=g,T2[A+228>>2]=T2[r+4>>2],v=A,d=z2(n1[T2[T2[r>>2]+48>>2]](r)),j2[v+236>>2]=d,G=z2(n1[T2[T2[e>>2]+48>>2]](e)),T2[A+264>>2]=1,T2[A+268>>2]=1,T2[A+252>>2]=-1,p2[A+244|0]=0,j2[A+240>>2]=G,T2[A+116>>2]=0,f=T2[(r=i+8|0)+4>>2],T2[(e=A- -64|0)>>2]=T2[r>>2],T2[e+4>>2]=f,f=T2[(r=i+24|0)+4>>2],T2[(e=A+80|0)>>2]=T2[r>>2],T2[e+4>>2]=f,f=T2[(r=i+40|0)+4>>2],T2[(e=A+96|0)>>2]=T2[r>>2],T2[e+4>>2]=f,G=z2(m+z2(z2(Q+w)+z2(.5))),j2[A+112>>2]=z2(W*G)+j2[i+56>>2],j2[A+108>>2]=z2(F*G)+j2[i+52>>2],f=T2[i+4>>2],T2[A+56>>2]=T2[i>>2],T2[A+60>>2]=f,f=T2[i+20>>2],T2[A+72>>2]=T2[i+16>>2],T2[A+76>>2]=f,f=T2[i+36>>2],T2[A+88>>2]=T2[i+32>>2],T2[A+92>>2]=f,j2[A+104>>2]=z2(R*G)+j2[i+48>>2],f=T2[(r=a+8|0)+4>>2],T2[(e=A+128|0)>>2]=T2[r>>2],T2[e+4>>2]=f,f=T2[a+20>>2],T2[(r=A+136|0)>>2]=T2[a+16>>2],T2[r+4>>2]=f,f=T2[(r=a+24|0)+4>>2],T2[(e=A+144|0)>>2]=T2[r>>2],T2[e+4>>2]=f,f=T2[a+36>>2],T2[(r=A+152|0)>>2]=T2[a+32>>2],T2[r+4>>2]=f,f=T2[(r=a+40|0)+4>>2],T2[(e=A+160|0)>>2]=T2[r>>2],T2[e+4>>2]=f,f=T2[a+52>>2],T2[(r=A+168|0)>>2]=T2[a+48>>2],T2[r+4>>2]=f,f=T2[(r=a+56|0)+4>>2],T2[(e=A+176|0)>>2]=T2[r>>2],T2[e+4>>2]=f,T2[A+184>>2]=1566444395,f=T2[a+4>>2],T2[A+120>>2]=T2[a>>2],T2[A+124>>2]=f,j2[A+200>>2]=-F,j2[B>>2]=-W,T2[A+208>>2]=0,j2[A+196>>2]=-R,p2[A+48|0]=0,T2[A+8>>2]=14800,J0(A+192|0,A+56|0,A+8|0,t,0),(e=S2[A+48|0])&&(Q=j2[A+44>>2],T2[o+12>>2]=0,Q=z2(G-Q),j2[o>>2]=j2[A+28>>2]-z2(R*Q),j2[o+8>>2]=j2[(i=A+36|0)>>2]-z2(W*Q),j2[o+4>>2]=j2[A+32>>2]-z2(F*Q),f=T2[A+32>>2],T2[b>>2]=T2[A+28>>2],T2[b+4>>2]=f,f=T2[i+4>>2],T2[(r=b+8|0)>>2]=T2[i>>2],T2[r+4>>2]=f,j2[n>>2]=R,j2[n+4>>2]=F,j2[n+8>>2]=W,j2[n+12>>2]=y),g=0!=(0|e);}return L2=A+4240|0,0|g;},t4,function(A){u(t4(A|=0));},Y0,Z0,function(A,f,r){A|=0,f|=0,r|=0;var e=0;if(!(e=8!=(0|f))&&8==(0|r))return T2[A+56>>2];if(!e&&1==(0|r))return T2[A+72>>2];if(1==(0|f)&&8==(0|r))return T2[A+76>>2];if(!(f|r))return T2[A+68>>2];if(!(19<(0|f))&&28==(0|r))return T2[A+84>>2];if(28==(0|f)&&!(19<(0|r)))return T2[A+80>>2];A:{if((0|f)<=19){if((0|r)<=19)return T2[A+28>>2];if(8<r-21>>>0)break A;return T2[A+32>>2];}if(!(19<(0|r)||8<f-21>>>0))return T2[A+36>>2];if(31==(0|f))return 31==(0|r)?T2[A+44>>2]:T2[A+40>>2];}return 31==(0|r)?T2[A+48>>2]:T2[A+52>>2];},function(A,f,r){A|=0,f|=0,r|=0;var e=0;if(!(e=8!=(0|f))&&8==(0|r))return T2[A+56>>2];if(!e&&1==(0|r))return T2[A+72>>2];if(1==(0|f)&&8==(0|r))return T2[A+76>>2];if(!(19<(0|f))&&28==(0|r))return T2[A+84>>2];if(28==(0|f)&&!(19<(0|r)))return T2[A+80>>2];A:{if((0|f)<=19){if((0|r)<=19)return T2[A+28>>2];if(8<r-21>>>0)break A;return T2[A+32>>2];}if(!(19<(0|r)||8<f-21>>>0))return T2[A+36>>2];if(31==(0|f))return 31==(0|r)?T2[A+44>>2]:T2[A+40>>2];}return 31==(0|r)?T2[A+48>>2]:T2[A+52>>2];},_,I,function(A,f,r,e){return A|=0,r|=0,e|=0,A=T2[(f|=0)>>2],A=0|n1[T2[T2[A>>2]+56>>2]](A,80),T2[A+8>>2]=13344,T2[A>>2]=13316,T2[A+60>>2]=0,T2[A+48>>2]=e,T2[A+44>>2]=r,f=T2[f>>2],T2[A+4>>2]=f,T2[A+56>>2]=f,f=0|n1[T2[T2[f>>2]+12>>2]](f,T2[r+8>>2],T2[e+8>>2]),T2[A+72>>2]=f,r=T2[A+56>>2],n1[T2[T2[r>>2]+20>>2]](r,f),(p2[A+76|0]=0)|A;},I,function(A,f,r,e){return A|=0,r|=0,e|=0,A=T2[(f|=0)>>2],A=0|n1[T2[T2[A>>2]+56>>2]](A,80),T2[A+8>>2]=13344,T2[A>>2]=13316,T2[A+60>>2]=0,T2[A+48>>2]=r,T2[A+44>>2]=e,f=T2[f>>2],T2[A+4>>2]=f,T2[A+56>>2]=f,f=0|n1[T2[T2[f>>2]+12>>2]](f,T2[e+8>>2],T2[r+8>>2]),T2[A+72>>2]=f,r=T2[A+56>>2],n1[T2[T2[r>>2]+20>>2]](r,f),p2[A+76|0]=1,0|A;},I,function(A,f,r,e){return A|=0,r|=0,e|=0,A=T2[(f|=0)>>2],A=0|n1[T2[T2[A>>2]+56>>2]](A,84),T2[A+52>>2]=0,T2[A+56>>2]=0,p2[A+24|0]=1,T2[A>>2]=13820,T2[A+20>>2]=0,p2[A+44|0]=1,T2[A+12>>2]=0,T2[A+16>>2]=0,T2[A+40>>2]=0,p2[A+64|0]=1,T2[A+32>>2]=0,T2[A+36>>2]=0,T2[A+60>>2]=0,p2[A+68|0]=0,p2[A+76|0]=0,T2[A+4>>2]=T2[f>>2],T2[A+72>>2]=T2[f+4>>2],T2[A+80>>2]=T2[T2[r+4>>2]+76>>2],j0(A,r,e),0|A;},I,function(A,f,r,e){A|=0,r|=0,e|=0;var i,a=0,n=0;return A=T2[(f|=0)>>2],A=0|n1[T2[T2[A>>2]+56>>2]](A,116),T2[A+52>>2]=0,T2[A+56>>2]=0,p2[A+24|0]=1,T2[A>>2]=13820,T2[A+20>>2]=0,p2[A+44|0]=1,T2[A+12>>2]=0,T2[A+16>>2]=0,T2[A+40>>2]=0,p2[A+64|0]=1,T2[A+32>>2]=0,T2[A+36>>2]=0,T2[A+60>>2]=0,p2[A+68|0]=0,p2[A+76|0]=0,T2[A+4>>2]=T2[f>>2],T2[A+72>>2]=T2[f+4>>2],T2[A+80>>2]=T2[T2[r+4>>2]+76>>2],j0(A,r,e),p2[A+104|0]=1,T2[A>>2]=14028,T2[A+100>>2]=0,T2[A+92>>2]=0,T2[A+96>>2]=0,i=T2[5498],f=0,(a=K2(83))&&(T2[(f=a+19&-16)-4>>2]=a),p2[f+20|0]=1,T2[f>>2]=13964,T2[f+16>>2]=0,p2[f+40|0]=1,T2[f+8>>2]=0,T2[f+12>>2]=0,T2[f+36>>2]=0,p2[f+60|0]=1,T2[f+28>>2]=0,T2[f+32>>2]=0,T2[f+56>>2]=0,T2[f+48>>2]=0,T2[f+52>>2]=0,T2[5498]=i+2,(a=K2(43))&&(T2[(n=a+19&-16)-4>>2]=a),(a=T2[f+16>>2])&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[f+16>>2]=n,p2[f+20|0]=1,T2[f+12>>2]=2,H0(f),T2[A+84>>2]=f,T2[A+108>>2]=T2[T2[r+4>>2]+76>>2],T2[A+112>>2]=T2[T2[e+4>>2]+76>>2],0|A;},I,function(A,f,r,e){return A|=0,r|=0,e|=0,A=T2[(f|=0)>>2],A=0|n1[T2[T2[A>>2]+56>>2]](A,84),T2[A+52>>2]=0,T2[A+56>>2]=0,p2[A+24|0]=1,T2[A>>2]=13820,T2[A+20>>2]=0,p2[A+44|0]=1,T2[A+12>>2]=0,T2[A+16>>2]=0,T2[A+40>>2]=0,p2[A+64|0]=1,T2[A+32>>2]=0,T2[A+36>>2]=0,T2[A+60>>2]=0,p2[A+68|0]=1,p2[A+76|0]=0,T2[A+4>>2]=T2[f>>2],T2[A+72>>2]=T2[f+4>>2],T2[A+80>>2]=T2[T2[e+4>>2]+76>>2],j0(A,r,e),0|A;},I,function(A,f,r,e){return A|=0,A=T2[(f|=0)>>2],A=0|n1[T2[T2[A>>2]+56>>2]](A,8),T2[A>>2]=14188,T2[A+4>>2]=T2[f>>2],0|A;},I,function(A,f,r,e){return A|=0,r|=0,e|=0,A=T2[(f|=0)>>2],A=0|n1[T2[T2[A>>2]+56>>2]](A,16),T2[A>>2]=14248,p2[A+8|0]=0,f=T2[f>>2],T2[A+4>>2]=f,f=(T2[A+12>>2]=0)|n1[T2[T2[f>>2]+12>>2]](f,T2[r+8>>2],T2[e+8>>2]),p2[A+8|0]=1,T2[A+12>>2]=f,0|A;},I,function(A,f,r,e){A|=0,r|=0,e|=0;var i,a=T2[(f|=0)>>2];return a=0|n1[T2[T2[a>>2]+56>>2]](a,20),p2[8+a|0]=0,T2[a>>2]=14384,i=T2[f>>2],T2[4+a>>2]=i,p2[16+a|0]=S2[A+4|0],A=T2[f+4>>2],(T2[12+a>>2]=A)||(A=0|n1[T2[T2[i>>2]+12>>2]](i,T2[r+8>>2],T2[e+8>>2]),p2[8+a|0]=1,T2[12+a>>2]=A),0|a;},I,function(A,f,r,e){return A|=0,r|=0,e|=0,A=T2[(f|=0)>>2],A=0|n1[T2[T2[A>>2]+56>>2]](A,16),T2[A>>2]=14516,p2[A+8|0]=0,f=T2[f>>2],T2[A+4>>2]=f,(T2[A+12>>2]=0)|n1[T2[T2[f>>2]+24>>2]](f,T2[r+8>>2],T2[e+8>>2])&&(f=T2[A+4>>2],f=0|n1[T2[T2[f>>2]+12>>2]](f,T2[r+8>>2],T2[e+8>>2]),p2[A+8|0]=1,T2[A+12>>2]=f),0|A;},I,function(A,f,r,e){A|=0,r|=0,e|=0;var i,a,n=T2[(f|=0)>>2];return n=0|n1[T2[T2[n>>2]+56>>2]](n,28),i=T2[A+12>>2],a=T2[A+8>>2],T2[n>>2]=14588,p2[8+n|0]=0,T2[20+n>>2]=a,T2[24+n>>2]=i,i=S2[A+4|0],p2[16+n|0]=i,A=T2[f>>2],T2[12+n>>2]=0,T2[4+n>>2]=A,0|n1[T2[T2[A>>2]+24>>2]](A,T2[(f=i?e:r)+8>>2],T2[(r=i?r:e)+8>>2])&&(A=T2[4+n>>2],A=0|n1[T2[T2[A>>2]+12>>2]](A,T2[f+8>>2],T2[r+8>>2]),p2[8+n|0]=1,T2[12+n>>2]=A),0|n;},function(A){var f=0;return T2[(A|=0)>>2]=16084,(f=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+20>>2]=0,p2[A+24|0]=1,T2[(f=A+12|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f;T2[(A|=0)>>2]=16084,(f=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),u(A);},function(A,f,r,e,i){A|=0,f|=0,r|=0,i|=0;var a,n=0;return T2[12+(L2=n=L2-16|0)>>2]=e|=0,T2[8+n>>2]=A,e=T2[T2[r+4>>2]+4>>2],a=T2[T2[f+4>>2]+4>>2],A=(A=1!=(0|i)?T2[5260+((P2(a,144)+A|0)+(e<<2)|0)>>2]:T2[76+((P2(a,144)+A|0)+(e<<2)|0)>>2],0|n1[T2[T2[A>>2]+8>>2]](A,8+n|0,f,r)),L2=16+n|0,0|A;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a=0,n=0,o=0,b=z2(0),t=z2(0),c=0;L2=o=L2-16|0,T2[5861]=T2[5861]+1,a=2&T2[A+4>>2]?(a=T2[f+192>>2],b=z2(n1[T2[T2[a>>2]+20>>2]](a,z2(.019999999552965164))),j2[12+o>>2]=b,a=T2[r+192>>2],t=z2(n1[T2[T2[a>>2]+20>>2]](a,z2(.019999999552965164))),b<(j2[8+o>>2]=t)?12+o|0:8+o|0):12260,i=j2[a>>2],b=j2[r+184>>2],t=j2[f+184>>2],a=T2[A+72>>2];A:{if(n=T2[a+12>>2])T2[a+12>>2]=T2[n>>2],T2[a+8>>2]=T2[a+8>>2]-1;else {if(4&S2[A+4|(n=0)])break A;T2[5498]=T2[5498]+1,(a=K2(887))&&(T2[(n=a+19&-16)-4>>2]=a);}if(T2[n+120>>2]=0,T2[n+124>>2]=0,T2[n>>2]=1025,T2[n+328>>2]=0,T2[n+332>>2]=0,T2[n+536>>2]=0,T2[n+540>>2]=0,T2[(a=n+128|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+136|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+144|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+152|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+160|0)>>2]=0,T2[a+4>>2]=0,T2[n+168>>2]=0,T2[(a=n+336|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+344|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+352|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+360|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+368|0)>>2]=0,T2[a+4>>2]=0,T2[n+376>>2]=0,T2[(a=n+544|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+552|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+560|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+568|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+576|0)>>2]=0,T2[a+4>>2]=0,T2[n+584>>2]=0,T2[n+792>>2]=0,T2[(a=n+784|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+776|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+768|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+760|0)>>2]=0,T2[a+4>>2]=0,T2[(a=n+752|0)>>2]=0,T2[a+4>>2]=0,T2[n+744>>2]=0,T2[n+748>>2]=0,T2[n+836>>2]=f,T2[n+840>>2]=r,T2[n+844>>2]=0,j2[n+848>>2]=i,j2[n+852>>2]=t<b?t:b,a=T2[A+12>>2],T2[n+864>>2]=a,T2[A+16>>2]==(0|a)&&!((0|(e=a?a<<1:1))<=(0|a))){if(e&&(T2[5498]=T2[5498]+1,(f=K2(19+(e<<2)|0))&&(T2[(c=f+19&-16)-4>>2]=f)),1<=(0|a))for(f=0,r=a;T2[f+c>>2]=T2[T2[A+20>>2]+f>>2],f=f+4|0,r=r-1|0;);(f=T2[A+20>>2])&&S2[A+24|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2]),a=T2[A+12>>2]),T2[A+20>>2]=c,T2[A+16>>2]=e,p2[A+24|0]=1;}T2[A+12>>2]=a+1,T2[T2[A+20>>2]+(a<<2)>>2]=n;}return L2=16+o|0,0|n;},function(A,f){var r,e,i,a,n,o,b,t;if(A|=0,f|=0,T2[5861]=T2[5861]-1,n1[T2[T2[A>>2]+20>>2]](A,f),e=T2[(r=A+20|0)>>2],a=T2[f+864>>2],o=T2[(i=e+(n=a<<2)|0)>>2],b=i,t=e,i=T2[(e=A+12|0)>>2]-1|0,T2[b>>2]=T2[t+(t=i<<2)>>2],T2[T2[r>>2]+t>>2]=o,T2[e>>2]=i,T2[T2[T2[r>>2]+n>>2]+864>>2]=a,A=T2[A+72>>2],!(f>>>0<(r=T2[A+16>>2])>>>0||r+P2(T2[A>>2],T2[A+4>>2])>>>0<=f>>>0))return T2[f>>2]=T2[A+12>>2],T2[A+12>>2]=f,void(T2[A+8>>2]=T2[A+8>>2]+1);T2[5499]=T2[5499]+1,q2(T2[f-4>>2]);},function(A,f){T2[(f|=0)+844>>2]=0;},function(A,f,r){A|=0,r|=0;A:{f:{r:switch(T2[(f|=0)+220>>2]-2|0){case 0:case 3:break r;default:break f;}switch(T2[r+220>>2]-2|(A=0)){case 0:case 3:break A;default:break f;}}if(!T2[f+280>>2]||0|n1[T2[T2[f>>2]+12>>2]](f,r)){if(A=1,!T2[r+280>>2])break A;if(0|n1[T2[T2[r>>2]+12>>2]](r,f))break A;}A=0;}return 0|A;},function(A,f,r){if(A|=0,r|=0,!(4&(f=T2[(f|=A=0)+204>>2])||4&(r=T2[r+204>>2]))){if(!(3&f))return 1;A=!(3&r);}return 0|A;},function(A,f,r,e){f|=0,r|=0,e|=0;var i=0;T2[8+(L2=i=L2-16|0)>>2]=A|=0,T2[4+i>>2]=r,T2[i>>2]=16168,n1[T2[T2[f>>2]+48>>2]](f,i,e),L2=16+i|0;},function(A){return T2[(A|=0)+12>>2];},function(A,f){return T2[T2[(A|=0)+20>>2]+((f|=0)<<2)>>2];},function(A){return T2[(A|=0)+12>>2]?T2[A+20>>2]:0;},c4,c4,function(A,f){var r;return f|=0,A=T2[(A|=0)+68>>2],(r=T2[A+12>>2])?(T2[A+12>>2]=T2[r>>2],T2[A+8>>2]=T2[A+8>>2]-1,0|r):(A=0,T2[5498]=T2[5498]+1,(f=K2(f+19|0))&&(T2[(A=f+19&-16)-4>>2]=f),0|A);},function(A,f){var r;if(A|=0,f|=0){if(A=T2[A+68>>2],!(f>>>0<(r=T2[A+16>>2])>>>0||P2(T2[A>>2],T2[A+4>>2])+r>>>0<=f>>>0))return T2[f>>2]=T2[A+12>>2],T2[A+12>>2]=f,void(T2[A+8>>2]=T2[A+8>>2]+1);T2[5499]=T2[5499]+1,q2(T2[f-4>>2]);}},_,I,function(A,f){var r=0,r=f|=0;return f=T2[(A|=0)+8>>2],n1[T2[f+64>>2]](r,f,T2[A+4>>2]),0;},function(A){var f=0;return T2[(A|=0)>>2]=16280,(f=T2[A+60>>2])&&S2[A- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+60>>2]=0,p2[A- -64|0]=1,T2[(f=A+52|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+40>>2]=0,p2[A+44|0]=1,T2[(f=A+32|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+16>>2]=0,p2[A+20|0]=1,T2[(f=A+8|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f=0;T2[(A|=0)>>2]=16280,(f=T2[A+60>>2])&&S2[A- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+60>>2]=0,p2[A- -64|0]=1,T2[(f=A+52|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+40>>2]=0,p2[A+44|0]=1,T2[(f=A+32|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+16>>2]=0,p2[A+20|0]=1,T2[(f=A+8|0)>>2]=0,T2[f+4>>2]=0,T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b,t,c=0,u=0,k=0,l=0,s=0,v=0;T2[5865]=T2[5865]+1;A:{f:{if(c=T2[A+24>>2]){if(0|n1[T2[T2[c>>2]+8>>2]](c,f,r))break f;break A;}if(!(T2[r+8>>2]&T2[f+4>>2]))break A;if(!(T2[f+8>>2]&T2[r+4>>2]))break A;}if(c=T2[f+12>>2]>T2[r+12>>2],k=T2[(e=c?f:r)+12>>2],l=T2[(i=c?r:f)+12>>2],f=P2((f=((f=k<<16|l)<<15^-1)+f|0)>>>10^f,9),c=T2[A+12>>2],-1!=(0|(f=T2[T2[A+40>>2]+((v=(n=(f=((f^=f>>>6)<<11^-1)+f|0)>>>16^f)&c-1)<<2)>>2])))for(r=T2[A+16>>2];;){if(u=(s=f<<4)+r|0,(0|k)==T2[T2[4+(r+s|0)>>2]+12>>2]&&(0|l)==T2[T2[u>>2]+12>>2])break A;if(-1==(0|(f=T2[T2[A+60>>2]+(f<<2)>>2])))break;}if((0|(f=c))==(0|(r=l=T2[A+8>>2]))&&(r=c,!((0|(k=f?f<<1:1))<=(0|f)))){if(r=0,k&&(T2[5498]=T2[5498]+1,(f=K2(19+(k<<4)|0))&&(T2[(r=f+19&-16)-4>>2]=f)),1<=(0|c))for(f=12,u=c;a=T2[A+16>>2]+f|0,T2[(s=f+r|0)-12>>2]=T2[a-12>>2],t=T2[4+(o=a-8|0)>>2],T2[(b=s-8|0)>>2]=T2[o>>2],T2[4+b>>2]=t,T2[s>>2]=T2[a>>2],f=f+16|0,u=u-1|0;);(f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+16>>2]=r,T2[A+12>>2]=k,p2[A+20|0]=1,r=T2[A+8>>2],f=k;}T2[A+8>>2]=r+1,r=T2[A+16>>2],(u=T2[A+68>>2])&&(n1[T2[T2[u>>2]+8>>2]](u,i,e),f=T2[A+12>>2]),u=r+(l<<4)|0,(0|c)<(0|f)&&(u4(A),v=T2[A+12>>2]-1&n),c=T2[e+12>>2],k=T2[i+12>>2],T2[(f=r+(l<<4)|0)+8>>2]=0,T2[f+12>>2]=0,T2[(r=f)+4>>2]=(f=(0|k)<(0|c))?e:i,T2[u>>2]=f?i:e,f=T2[A+60>>2]+(l<<2)|0,A=T2[A+40>>2]+(v<<2)|0,T2[f>>2]=T2[A>>2],T2[A>>2]=l;}return 0|u;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i=0,a=0,n=0,o=0,b=0,t=0,c=0,u=0;T2[5864]=T2[5864]+1,i=T2[f+12>>2]>T2[r+12>>2],a=T2[(b=i?f:r)+12>>2],n=T2[(t=i?r:f)+12>>2],f=P2((f=((f=a<<16|n)<<15^-1)+f|0)>>>10^f,9),o=T2[A+12>>2]-1&((f=((f^=f>>>6)<<11^-1)+f|0)>>>16^f);A:if(-1!=(0|(f=T2[T2[A+40>>2]+(o<<2)>>2]))){for(i=T2[A+16>>2];(0|a)!=T2[T2[(r=i+(f<<4)|0)+4>>2]+12>>2]||(0|n)!=T2[T2[r>>2]+12>>2];)if(-1==(0|(f=T2[T2[A+60>>2]+(f<<2)>>2])))break A;n1[T2[T2[A>>2]+32>>2]](A,r,e),c=T2[12+(i+(f<<4)|0)>>2],a=T2[A+60>>2];f:{if(n=T2[A+40>>2]+(o<<2)|0,(0|(f=T2[n>>2]))!=(0|(i=r-T2[A+16>>2]>>4))){for(;(0|i)!=(0|(f=T2[(o=a+((r=f)<<2)|0)>>2])););if(-1!=(0|r)){T2[o>>2]=T2[a+(i<<2)>>2];break f;}}T2[n>>2]=T2[a+(i<<2)>>2];}if(a=T2[A+8>>2]-1|0,(f=T2[A+68>>2])&&n1[T2[T2[f>>2]+12>>2]](f,t,b,e),(0|i)==(0|a))return T2[A+8>>2]=T2[A+8>>2]-1,0|c;b=T2[A+60>>2];f:{if(t=T2[A+16>>2],f=T2[T2[(e=t+(a<<4)|0)+4>>2]+12>>2]<<16|T2[T2[e>>2]+12>>2],f=P2((f=(f<<15^-1)+f|0)>>>10^f,9),n=T2[A+12>>2]-1&((f=((f^=f>>>6)<<11^-1)+f|0)>>>16^f),o=T2[A+40>>2]+(n<<2)|0,(0|a)!=(0|(f=T2[o>>2]))){for(;(0|a)!=(0|(f=T2[(u=b+((r=f)<<2)|0)>>2])););if(-1!=(0|r)){T2[u>>2]=T2[b+(a<<2)>>2];break f;}}T2[o>>2]=T2[b+(a<<2)>>2];}r=T2[e+4>>2],T2[(f=t+(i<<4)|0)>>2]=T2[e>>2],T2[f+4>>2]=r,e=T2[(r=e+8|0)+4>>2],T2[(f=f+8|0)>>2]=T2[r>>2],T2[f+4>>2]=e,f=T2[A+40>>2]+(n<<2)|0,T2[T2[A+60>>2]+(i<<2)>>2]=T2[f>>2],T2[f>>2]=i,T2[A+8>>2]=T2[A+8>>2]-1;}return 0|c;},function(A,f,r){A|=0,r|=0;var e=0;T2[12+(L2=e=L2-16|0)>>2]=f|=0,T2[8+e>>2]=16512,n1[T2[T2[A>>2]+48>>2]](A,8+e|0,r),L2=16+e|0;},_0,_0,f2,function(A,f,r){A|=0,f|=0,(r|=0)&&(A=T2[f+8>>2])&&(n1[T2[T2[A>>2]>>2]](A),n1[T2[T2[r>>2]+60>>2]](r,T2[f+8>>2]),T2[f+8>>2]=0);},function(A){return T2[(A|=0)+8>>2];},function(A,f,r){A|=0,f|=0;var e=0;T2[12+(L2=e=L2-16|0)>>2]=r|=0,T2[8+e>>2]=A,T2[4+e>>2]=f,T2[e>>2]=16368,n1[T2[T2[A>>2]+48>>2]](A,e,r),L2=16+e|0;},function(A,f){T2[(A|=0)+24>>2]=f|=0;},function(A,f,r){f|=0,r|=0;var e,i=0;if(1<=T2[(A|=0)+8>>2])for(;e=T2[A+16>>2]+(i<<4)|0,0|n1[T2[T2[f>>2]+8>>2]](f,e)?(n1[T2[T2[A>>2]+12>>2]](A,T2[e>>2],T2[4+e>>2],r),T2[5863]=T2[5863]-1):i=i+1|0,T2[A+8>>2]>(0|i););},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a=0;T2[5862]=T2[5862]+1,a=T2[f+12>>2]>T2[r+12>>2],e=T2[(a?f:r)+12>>2],i=T2[(a?r:f)+12>>2],f=P2((f=((f=i|e<<16)<<15^-1)+f|0)>>>10^f,9),f=T2[A+12>>2]-1&((f=((f^=f>>>6)<<11^-1)+f|0)>>>16^f);A:{if(!((0|f)>=T2[A+32>>2])&&-1!=(0|(f=T2[T2[A+40>>2]+(f<<2)>>2])))for(r=T2[A+16>>2];;){if(T2[T2[4+(a=r+(f<<4)|0)>>2]+12>>2]==(0|e)&&T2[T2[a>>2]+12>>2]==(0|i))break A;if(-1==(0|(f=T2[T2[A+60>>2]+(f<<2)>>2])))break;}a=0;}return 0|a;},G2,function(A,f){T2[(A|=0)+68>>2]=f|=0;},function(A,f){A|=0,f|=0;var r,e,i,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0,l=0;if(T2[20+(L2=b=L2-32|0)>>2]=0,T2[12+b>>2]=0,((T2[16+b>>2]=0)|(n=T2[A+8>>2]))<(p2[24+b|0]=1))n=0;else {for(n=0;;){if(e=T2[A+16>>2],(0|o)==(0|a))if((0|(k=a?a<<1:1))<=(0|a))o=a;else {if(c=0,k&&(T2[5498]=T2[5498]+1,(n=K2(19+(k<<4)|0))&&(T2[(c=n+19&-16)-4>>2]=n)),1<=(0|a))for(o=12;t=T2[20+b>>2]+o|0,T2[(n=o+c|0)-12>>2]=T2[t-12>>2],i=T2[4+(r=t-8|0)>>2],T2[(u=n-8|0)>>2]=T2[r>>2],T2[u+4>>2]=i,T2[n>>2]=T2[t>>2],o=o+16|0,a=a-1|0;);(n=T2[20+b>>2])&&S2[24+b|0]&&(T2[5499]=T2[5499]+1,q2(T2[n-4>>2])),T2[20+b>>2]=c,p2[24+b|0]=1,T2[16+b>>2]=k,o=T2[12+b>>2],t=u=n=c;}if(k=T2[(a=(l<<4)+e|0)+4>>2],T2[(o=(o<<4)+t|0)>>2]=T2[a>>2],T2[o+4>>2]=k,T2[o+8>>2]=T2[a+8>>2],T2[o+12>>2]=T2[a+12>>2],a=T2[12+b>>2],T2[12+b>>2]=o=a+1|0,!((0|(l=l+1|0))<T2[A+8>>2]))break;a=T2[16+b>>2];}if(!((0|a)<0))for(t=a+1|0;n1[T2[T2[A>>2]+12>>2]](A,T2[u>>2],T2[u+4>>2],f),u=u+16|0,t=t-1|0;);}if(1<=T2[A+52>>2])for(t=T2[A+60>>2],a=0;T2[t>>2]=-1,t=t+4|0,(0|(a=a+1|0))<T2[A+52>>2];);A:{if(2<=(0|o))k4(8+b|0,0,o-1|0);else if((0|o)<1)break A;for(;n1[T2[T2[A>>2]+8>>2]](A,T2[n>>2],T2[n+4>>2]),n=n+16|0,o=o-1|0;);}c&&(T2[5499]=T2[5499]+1,q2(T2[c-4>>2])),L2=32+b|0;},I,function(A,f){var r=0;return (0|(r=T2[(A|=0)+4>>2]))!=T2[(f|=0)+4>>2]&&(0|r)!=T2[f>>2]||(r=T2[A+8>>2],n1[T2[T2[r>>2]+32>>2]](r,f,T2[A+12>>2])),0;},I,function(A,f){return (0|(A=T2[(A|=0)+4>>2]))==T2[(f|=0)>>2]|(0|A)==T2[f+4>>2];},l4,function(A){u(l4(A|=0));},function(A,f,r,e,i,a,n,o){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,n|=0,o|=0;var b,t=0;return L2=o=L2-48|0,e=0,b=T2[5498],T2[5498]=b+1,(t=K2(83))&&(T2[(e=t+19&-16)-4>>2]=t),T2[e+8>>2]=n,T2[e+4>>2]=a,T2[e>>2]=i,i=T2[f+4>>2],T2[e+16>>2]=T2[f>>2],T2[e+20>>2]=i,t=T2[(n=i=f+8|0)+4>>2],T2[(a=e+24|0)>>2]=T2[n>>2],T2[a+4>>2]=t,a=T2[r+4>>2],T2[e+32>>2]=T2[r>>2],T2[e+36>>2]=a,t=T2[(a=r+8|0)+4>>2],T2[(n=e+40|0)>>2]=T2[a>>2],T2[n+4>>2]=t,T2[e+52>>2]=0,T2[e+56>>2]=0,t=T2[i+4>>2],T2[(n=o+24|0)>>2]=T2[i>>2],T2[n+4>>2]=t,n=T2[a+4>>2],T2[(i=o+40|0)>>2]=T2[a>>2],T2[i+4>>2]=n,i=T2[f>>2],f=T2[f+4>>2],a=T2[r+4>>2],r=T2[r>>2],T2[e+60>>2]=T2[A+104>>2],T2[o+32>>2]=r,T2[o+36>>2]=a,r=T2[A+148>>2]+1|0,T2[e+12>>2]=r,T2[A+148>>2]=r,T2[o+16>>2]=i,T2[o+20>>2]=f,i=A+4|0,(f=T2[A+8>>2])?T2[A+8>>2]=0:(T2[5498]=b+2,f=0,(r=K2(63))&&(T2[(f=r+19&-16)-4>>2]=r),T2[f>>2]=0,T2[f+4>>2]=0,T2[f+40>>2]=0,T2[(r=f+32|0)>>2]=0,T2[r+4>>2]=0,T2[(r=f+24|0)>>2]=0,T2[r+4>>2]=0,T2[(r=f+16|0)>>2]=0,T2[r+4>>2]=0,T2[(r=f+8|0)>>2]=0,T2[r+4>>2]=0),T2[f+36>>2]=e,r=T2[o+20>>2],T2[f>>2]=T2[o+16>>2],T2[f+4>>2]=r,T2[f+40>>2]=0,n=T2[(a=o+24|0)+4>>2],T2[(r=f+8|0)>>2]=T2[a>>2],T2[r+4>>2]=n,n=T2[(a=o+32|0)+4>>2],T2[(r=f+16|0)>>2]=T2[a>>2],T2[r+4>>2]=n,n=T2[(a=o+40|0)+4>>2],T2[(r=f+24|0)>>2]=T2[a>>2],T2[r+4>>2]=n,T2[f+32>>2]=0,a0(i,T2[A+4>>2],f),T2[e+52>>2]=0,T2[e+48>>2]=f,f=84+((T2[A+104>>2]<<2)+A|0)|0,T2[e+56>>2]=T2[f>>2],T2[(r=A+16|0)>>2]=T2[r>>2]+1,(r=T2[f>>2])&&(T2[r+52>>2]=e),T2[f>>2]=e,S2[A+153|0]||(T2[o+8>>2]=e,T2[o>>2]=16856,T2[o+4>>2]=A,s4(T2[A+4>>2],o+16|0,o),s4(T2[A+44>>2],o+16|0,o)),L2=o+48|0,0|e;},function(A,f,r){A|=0,r|=0;var e,i=0,a=0;i0(i=2==T2[(f|=0)+60>>2]?A+44|0:A+4|0,a=T2[f+48>>2]),(e=T2[i+4>>2])&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),T2[i+4>>2]=a,T2[i+12>>2]=T2[i+12>>2]-1,(i=T2[f+52>>2])?T2[(a=i+56|0)>>2]=T2[(i=f+56|0)>>2]:T2[84+((T2[f+60>>2]<<2)+A|0)>>2]=T2[(i=f+56|0)>>2],(i=T2[i>>2])&&(T2[i+52>>2]=T2[f+52>>2]),i=T2[A+96>>2],n1[T2[T2[i>>2]+16>>2]](i,f,r),T2[5499]=T2[5499]+1,q2(T2[f-4>>2]),p2[A+154|0]=1;},function(A,f,r,e,i){A|=0,f|=0,r|=0,e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C=0,E=0,D=0,h=z2(0),Z=0,Y=z2(0),R=z2(0),F=0,W=z2(0);if(L2=C=L2-48|0,W=j2[r>>2],j2[44+C>>2]=W,a=j2[r+4>>2],j2[40+C>>2]=a,n=j2[r+8>>2],j2[36+C>>2]=n,o=j2[e>>2],j2[32+C>>2]=o,b=j2[e+4>>2],j2[28+C>>2]=b,t=j2[e+8>>2],j2[24+C>>2]=t,c=j2[e+12>>2],u=j2[r+12>>2],2!=T2[f+60>>2]){if(T2[A+128>>2]=T2[A+128>>2]+1,D=T2[f+48>>2],(l=j2[D>>2])<=o&&W<=(s=j2[D+16>>2])&&(v=j2[D+4>>2])<=b&&a<=(d=j2[D+20>>2])&&(Y=j2[D+8>>2])<=t&&n<=(R=j2[D+24>>2])){if(B=j2[f+16>>2],w=j2[f+32>>2],k=j2[A+100>>2],Q=j2[f+24>>2],G=j2[f+40>>2],g=j2[f+20>>2],h=j2[f+36>>2],!(l<=W&&v<=a&&Y<=n&&o<=s&&b<=d&&(E=0,t<=R))){Y=z2(b+z2(.05000000074505806)),j2[28+C>>2]=Y,R=z2(a+z2(-.05000000074505806)),j2[40+C>>2]=R,h=z2(z2(z2(h-g)*z2(.5))*k),i=(h=z2(a-g)<z2(0)?z2(-h):h)>z2(0),j2[(i?28+C|0:40+C|0)>>2]=(i?Y:R)+h,Y=z2(n+z2(-.05000000074505806)),j2[36+C>>2]=Y,R=z2(t+z2(.05000000074505806)),j2[24+C>>2]=R,h=z2(k*z2(z2(G-Q)*z2(.5))),i=(h=z2(n-Q)<z2(0)?z2(-h):h)>z2(0),j2[(i?24+C|0:36+C|0)>>2]=(i?R:Y)+h,Y=z2(o+z2(.05000000074505806)),j2[32+C>>2]=Y,R=z2(W+z2(-.05000000074505806)),j2[44+C>>2]=R,h=z2(z2(z2(w-B)*z2(.5))*k),i=(h=z2(W-B)<z2(0)?z2(-h):h)>z2(0),j2[(i?32+C|0:44+C|0)>>2]=(i?Y:R)+h;A:if(i=i0(Z=A+4|0,D)){if(0<=(0|(F=T2[A+12>>2]))){if(F)for(;;){if(!(E=T2[i+32>>2]))break A;if(i=E,!(F=F-1|0))break;}}else i=T2[Z>>2];}else i=0;j2[D>>2]=j2[44+C>>2],j2[D+4>>2]=j2[40+C>>2],j2[D+12>>2]=u,j2[D+8>>2]=j2[36+C>>2],j2[D+16>>2]=j2[32+C>>2],j2[D+20>>2]=j2[28+C>>2],j2[D+24>>2]=j2[24+C>>2],j2[D+28>>2]=c,a0(Z,i,D),T2[A+132>>2]=T2[A+132>>2]+1,E=1;}}else {A:if(i=i0(Z=A+4|0,D)){if(0<=(0|(F=T2[A+12>>2]))){if(F)for(;;){if(!(E=T2[i+32>>2]))break A;if(i=E,!(F=F-1|0))break;}}else i=T2[Z>>2];}else i=0;j2[D+16>>2]=o,j2[D+12>>2]=u,j2[D+8>>2]=n,j2[D+4>>2]=a,j2[D>>2]=W,j2[D+28>>2]=c,j2[D+24>>2]=t,j2[D+20>>2]=b,a0(Z,i,D),T2[A+132>>2]=T2[A+132>>2]+1,E=1;}}else i0(A+44|0,E=T2[f+48>>2]),(i=T2[A+48>>2])&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2])),T2[A+48>>2]=E,T2[(i=A+56|0)>>2]=T2[i>>2]-1,Z=A+4|0,(i=T2[A+8>>2])?T2[A+8>>2]=0:(T2[5498]=T2[5498]+1,i=0,(E=K2(63))&&(T2[(i=E+19&-16)-4>>2]=E,W=j2[44+C>>2]),T2[i>>2]=0,T2[i+4>>2]=0,T2[i+40>>2]=0,T2[(E=i+32|0)>>2]=0,T2[E+4>>2]=0,T2[(E=i+24|0)>>2]=0,T2[E+4>>2]=0,T2[(E=i+16|0)>>2]=0,T2[E+4>>2]=0,T2[(E=i+8|0)>>2]=0,T2[E+4>>2]=0),j2[i>>2]=W,T2[i+36>>2]=f,j2[i+12>>2]=u,T2[i+40>>2]=0,j2[i+28>>2]=c,j2[i+4>>2]=j2[40+C>>2],j2[i+8>>2]=j2[36+C>>2],j2[i+16>>2]=j2[32+C>>2],j2[i+20>>2]=j2[28+C>>2],j2[i+24>>2]=j2[24+C>>2],T2[i+32>>2]=0,a0(Z,T2[A+4>>2],i),T2[f+48>>2]=i,T2[(i=A+16|0)>>2]=T2[i>>2]+1,E=1;(i=T2[f+52>>2])?T2[(D=i+56|0)>>2]=T2[(i=f+56|0)>>2]:T2[84+((T2[f+60>>2]<<2)+A|0)>>2]=T2[(i=f+56|0)>>2],(i=T2[i>>2])&&(T2[i+52>>2]=T2[f+52>>2]),i=T2[r+4>>2],T2[f+16>>2]=T2[r>>2],T2[f+20>>2]=i,r=T2[(i=r+8|0)+4>>2],T2[(Z=f+24|0)>>2]=T2[i>>2],T2[Z+4>>2]=r,r=T2[(i=e+8|0)+4>>2],T2[(Z=f+40|0)>>2]=T2[i>>2],T2[Z+4>>2]=r,r=T2[e+4>>2],T2[f+32>>2]=T2[e>>2],T2[f+36>>2]=r,T2[f+52>>2]=0,r=T2[A+104>>2],T2[f+56>>2]=T2[(e=84+((r<<2)+A|0)|0)>>2],T2[f+60>>2]=r,(r=T2[e>>2])&&(T2[r+52>>2]=f),T2[e>>2]=f,E&&(p2[A+154|0]=1,S2[A+153|0]||(T2[8+C>>2]=16856,v4(r=(T2[12+C>>2]=A)+44|0,T2[r>>2],T2[f+48>>2],8+C|0),v4(A+4|0,T2[A+4>>2],T2[f+48>>2],8+C|0))),L2=48+C|0;},function(A,f,r,e){var i;A|=0,e|=0,A=T2[(f|=0)+20>>2],T2[(r|=0)>>2]=T2[f+16>>2],T2[r+4>>2]=A,A=r+8|0,i=T2[(r=f+24|0)+4>>2],T2[A>>2]=T2[r>>2],T2[A+4>>2]=i,i=T2[(r=f+40|0)+4>>2],T2[(A=e+8|0)>>2]=T2[r>>2],T2[A+4>>2]=i,A=T2[f+36>>2],T2[e>>2]=T2[f+32>>2],T2[e+4>>2]=A;},function(A,f,r,e,i,a){var n,o,b;A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,T2[(L2=r=L2-16|0)+8>>2]=17e3,T2[r+12>>2]=e,b=T2[A+168>>2],d4(T2[A+4>>2],f,n=e+4|0,o=e+20|0,j2[e+32>>2],i,a,b,r+8|0),d4(T2[A+44>>2],f,n,o,j2[e+32>>2],i,a,b,r+8|0),L2=r+16|0;},function(A,f,r,e){A|=0,f|=0,r|=0;var i,a,n=0;T2[44+(L2=n=L2-48|0)>>2]=e|=0,T2[40+n>>2]=16928,a=T2[4+(i=f+8|0)>>2],T2[(e=16+n|0)>>2]=T2[i>>2],T2[e+4>>2]=a,a=T2[4+(i=r+8|0)>>2],T2[(e=32+n|0)>>2]=T2[i>>2],T2[e+4>>2]=a,e=T2[f+4>>2],T2[8+n>>2]=T2[f>>2],T2[12+n>>2]=e,f=T2[r+4>>2],T2[24+n>>2]=T2[r>>2],T2[28+n>>2]=f,s4(T2[A+4>>2],8+n|0,40+n|0),s4(T2[A+44>>2],8+n|0,40+n|0),L2=48+n|0;},function(A,f){A|=0,f|=0;var r=0,e=0,i=0,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0,l=z2(0),s=0;if(L2=u=L2-32|0,e0(n=A+4|0,1+((0|P2(T2[A+112>>2],T2[A+16>>2]))/100|0)|0),T2[A+124>>2]&&(e0(A+44|0,r=1+((0|P2(T2[A+108>>2],T2[A+56>>2]))/100|0)|0),r=T2[A+124>>2]-r|0,T2[A+124>>2]=0<(0|r)?r:0),r=(T2[A+104>>2]+1|0)%2|0,T2[A+104>>2]=r,r=T2[84+((r<<2)+A|0)>>2]){for(t=A+44|0,o=16+u|0;b=T2[r+56>>2],a=(e=T2[r+52>>2])?e+56|0:84+((T2[r+60>>2]<<2)+A|0)|0,T2[a>>2]=b,(e=T2[r+56>>2])&&(T2[e+52>>2]=T2[r+52>>2]),T2[r+52>>2]=0,T2[r+56>>2]=T2[A+92>>2],(e=T2[A+92>>2])&&(T2[e+52>>2]=r),T2[A+92>>2]=r,i0(n,e=T2[r+48>>2]),(a=T2[A+8>>2])&&(T2[5499]=T2[5499]+1,q2(T2[a-4>>2])),T2[A+8>>2]=e,T2[A+16>>2]=T2[A+16>>2]-1,c=T2[(i=r+24|0)+4>>2],T2[(e=a=8+u|0)>>2]=T2[i>>2],T2[e+4>>2]=c,e=T2[r+36>>2],T2[o>>2]=T2[r+32>>2],T2[o+4>>2]=e,c=T2[(i=r+40|0)+4>>2],T2[(e=o+8|0)>>2]=T2[i>>2],T2[e+4>>2]=c,e=T2[r+20>>2],T2[u>>2]=T2[r+16>>2],T2[4+u>>2]=e,(e=T2[A+48>>2])?T2[A+48>>2]=0:(e=0,T2[5498]=T2[5498]+1,(i=K2(63))&&(T2[(e=i+19&-16)-4>>2]=i),T2[e>>2]=0,T2[e+4>>2]=0,T2[e+40>>2]=0,T2[(i=e+32|0)>>2]=0,T2[i+4>>2]=0,T2[(i=e+24|0)>>2]=0,T2[i+4>>2]=0,T2[(i=e+16|0)>>2]=0,T2[i+4>>2]=0,T2[(i=e+8|0)>>2]=0,T2[i+4>>2]=0),T2[e+36>>2]=r,i=T2[4+u>>2],T2[e>>2]=T2[u>>2],T2[e+4>>2]=i,T2[e+40>>2]=0,c=T2[a+4>>2],T2[(i=e+8|0)>>2]=T2[a>>2],T2[i+4>>2]=c,i=T2[o+4>>2],T2[(a=e+16|0)>>2]=T2[o>>2],T2[a+4>>2]=i,c=T2[(i=24+u|0)+4>>2],T2[(a=e+24|0)>>2]=T2[i>>2],T2[a+4>>2]=c,T2[e+32>>2]=0,a0(t,T2[A+44>>2],e),T2[r+60>>2]=2,T2[r+48>>2]=e,e=T2[A+56>>2]+1|0,T2[A+56>>2]=e,r=b;);p2[A+154|0]=1,T2[A+124>>2]=e;}T2[u>>2]=16856,T2[4+u>>2]=A,S2[A+153|0]&&(v4(n,T2[A+4>>2],T2[A+44>>2],u),S2[A+153|0]&&v4(n,r=T2[n>>2],r,u));A:if(S2[A+154|0]&&(r=T2[A+96>>2],a=0|n1[T2[T2[r>>2]+28>>2]](r),!((0|(b=T2[a+4>>2]))<1))){f:{if(r=T2[A+120>>2],1<=(0|(e=(0|b)<(0|(r=(0|(e=(0|P2(T2[A+116>>2],b))/100|0))<(0|r)?r:e))?b:r))){for(r=0;n=T2[a+12>>2]+((T2[A+144>>2]+r|0)%(0|b)<<4)|0,i=T2[n>>2],o=T2[i+48>>2],t=T2[n+4>>2],n=T2[t+48>>2],j2[o>>2]<=j2[n+16>>2]&&j2[o+16>>2]>=j2[n>>2]&&j2[o+4>>2]<=j2[n+20>>2]&&j2[o+20>>2]>=j2[n+4>>2]&&j2[o+8>>2]<=j2[n+24>>2]&&j2[o+24>>2]>=j2[n+8>>2]||(b=T2[A+96>>2],n1[T2[T2[b>>2]+12>>2]](b,i,t,f),r=r-1|0,e=e-1|0,b=T2[a+4>>2]),(0|(r=r+1|0))<(0|e););if((0|b)<=0)break f;}T2[A+144>>2]=(T2[A+144>>2]+e|0)%(0|b);break A;}T2[A+144>>2]=0;}if(p2[A+154|0]=0,T2[A+120>>2]=1,T2[A+140>>2]=T2[A+140>>2]+1,r=T2[A+132>>2],A=T2[(a=A)+128>>2],l=z2(0),A&&(l=z2(z2(r>>>0)/z2(A>>>0))),j2[a+136>>2]=l,T2[a+132>>2]=r>>>1,T2[a+128>>2]=A>>>1,A=T2[a+96>>2],0|n1[T2[T2[A>>2]+56>>2]](A)){if(A=T2[a+96>>2],i=0|n1[T2[T2[A>>2]+28>>2]](A),2<=(0|(A=T2[i+4>>2]))&&(k4(i,0,A-1|0),A=T2[i+4>>2]),1<=(0|A)){for(n=o=b=e=0;c=T2[i+12>>2]+e|0,r=T2[(k=c+4|0)>>2],t=o,o=T2[c>>2],((0|r)!=(0|n)||(0|t)!=(0|o))&&(n=T2[o+48>>2],t=T2[r+48>>2],j2[n>>2]<=j2[t+16>>2]&&j2[n+16>>2]>=j2[t>>2]&&j2[n+4>>2]<=j2[t+20>>2]&&j2[n+20>>2]>=j2[t+4>>2]&&j2[n+8>>2]<=j2[t+24>>2]&&j2[n+24>>2]>=j2[t+8>>2])||(A=T2[a+96>>2],n1[T2[T2[A>>2]+32>>2]](A,c,f),T2[k>>2]=0,b=b+1|(T2[c>>2]=0),A=T2[i+4>>2]),e=e+16|0,n=r,(0|(s=s+1|0))<(0|A););if(2<=(0|A)&&(k4(i,0,A-1|0),A=T2[i+4>>2]),o=A-b|0,(0|b)<=-1){if((0|o)>T2[i+8>>2]){if(f=0,o&&(T2[5498]=T2[5498]+1,(r=K2(19+(o<<4)|0))&&(T2[(f=r+19&-16)-4>>2]=r)),1<=(0|A))for(r=12,e=A;a=T2[i+12>>2]+r|0,T2[(n=f+r|0)-12>>2]=T2[a-12>>2],k=T2[(c=a-8|0)+4>>2],T2[(t=n-8|0)>>2]=T2[c>>2],T2[t+4>>2]=k,T2[n>>2]=T2[a>>2],r=r+16|0,e=e-1|0;);(r=T2[i+12>>2])&&S2[i+16|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[i+12>>2]=f,p2[i+16|0]=1,T2[i+8>>2]=o;}for(r=A<<4;A=T2[i+12>>2]+r|0,T2[A>>2]=0,T2[A+4>>2]=0,T2[(A=A+8|0)>>2]=0,r=r+16|(T2[A+4>>2]=0),(A=b)>>>0<=(b=A+1|0)>>>0;);}A=o;}T2[i+4>>2]=A;}L2=32+u|0;},B4,B4,function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0),i=z2(0),a=z2(0),n=z2(0),o=z2(0),b=z2(0),t=z2(0),c=z2(0),u=T2[A+44>>2];(A=T2[A+4>>2])?(t=j2[A>>2],u?(e=j2[A+24>>2],i=(i=j2[u+24>>2])<e?e:i,e=j2[A+20>>2],a=(a=j2[u+20>>2])<e?e:a,n=(e=j2[A+8>>2])<(n=j2[u+8>>2])?e:n,o=(e=j2[A+4>>2])<(o=j2[u+4>>2])?e:o,e=j2[A+16>>2],b=(b=j2[u+16>>2])<e?e:b,t=t<(e=j2[u>>2])?t:e):(c=j2[A+28>>2],i=j2[A+24>>2],a=j2[A+20>>2],b=j2[A+16>>2],e=j2[A+12>>2],n=j2[A+8>>2],o=j2[A+4>>2])):u&&(c=j2[u+28>>2],i=j2[u+24>>2],a=j2[u+20>>2],b=j2[u+16>>2],e=j2[u+12>>2],n=j2[u+8>>2],o=j2[u+4>>2],t=j2[u>>2]),j2[f+12>>2]=e,j2[f+8>>2]=n,j2[f+4>>2]=o,j2[f>>2]=t,j2[r+12>>2]=c,j2[r+8>>2]=i,j2[r+4>>2]=a,j2[r>>2]=b;},function(A,f){f|=0,T2[(A|=0)+16>>2]==(0-T2[A+56>>2]|0)&&(r0(A+4|0),r0(A+44|0),p2[A+153|0]=0,p2[A+154|0]=1,T2[A+124>>2]=0,T2[A+104>>2]=0,T2[A+116>>2]=10,T2[A+120>>2]=1,T2[A+108>>2]=1,T2[A+112>>2]=0,T2[(f=A+84|0)>>2]=0,T2[f+4>>2]=0,T2[A+92>>2]=0,T2[A+128>>2]=0,T2[A+132>>2]=0,T2[(f=A+136|0)>>2]=0,T2[f+4>>2]=0,T2[(A=A+144|0)>>2]=0,T2[A+4>>2]=0);},Q4,I,function(A,f,r){var e;A|=0,(0|(f|=0))!=(0|(r|=0))&&(e=T2[T2[A+4>>2]+96>>2],n1[T2[T2[e>>2]+8>>2]](e,T2[f+36>>2],T2[r+36>>2]),A=T2[A+4>>2],T2[A+120>>2]=T2[A+120>>2]+1);},function(A,f){n1[T2[T2[(A|=0)>>2]+8>>2]](A,f|=0,T2[T2[A+8>>2]+48>>2]);},I,g4,I,g4,function(A){var f=0;return T2[(A|=0)>>2]=17124,(f=T2[A+556>>2])&&S2[A+560|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+556>>2]=0,T2[A>>2]=7664,p2[A+560|0]=1,T2[(f=A+548|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+296>>2])&&S2[A+300|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+296>>2]=0,p2[A+300|0]=1,T2[(f=A+288|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f=0;T2[(A|=0)>>2]=17124,(f=T2[A+556>>2])&&S2[A+560|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+556>>2]=0,T2[A>>2]=7664,p2[A+560|0]=1,T2[(f=A+548|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+296>>2])&&S2[A+300|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+296>>2]=0,p2[A+300|0]=1,T2[(f=A+288|0)>>2]=0,T2[f+4>>2]=0,T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A){return 496;},function(A,f,r){return K(A|=0,f|=0,r|=0),j2[f+264>>2]=j2[A+324>>2],j2[f+268>>2]=j2[A+328>>2],j2[f+272>>2]=j2[A+332>>2],j2[f+276>>2]=j2[A+336>>2],j2[f+280>>2]=j2[A+340>>2],j2[f+284>>2]=j2[A+344>>2],j2[f+288>>2]=j2[A+348>>2],j2[f+292>>2]=j2[A+352>>2],j2[f+296>>2]=j2[A+356>>2],j2[f+300>>2]=j2[A+360>>2],j2[f+304>>2]=j2[A+364>>2],j2[f+308>>2]=j2[A+368>>2],j2[f+312>>2]=j2[A+372>>2],j2[f+316>>2]=j2[A+376>>2],j2[f+320>>2]=j2[A+380>>2],j2[f+324>>2]=j2[A+384>>2],j2[f+328>>2]=j2[A+388>>2],j2[f+332>>2]=j2[A+392>>2],j2[f+336>>2]=j2[A+396>>2],j2[f+340>>2]=j2[A+400>>2],j2[f+456>>2]=j2[A+404>>2],j2[f+344>>2]=j2[A+604>>2],j2[f+348>>2]=j2[A+608>>2],j2[f+352>>2]=j2[A+612>>2],j2[f+356>>2]=j2[A+616>>2],j2[f+360>>2]=j2[A+408>>2],j2[f+364>>2]=j2[A+412>>2],j2[f+368>>2]=j2[A+416>>2],j2[f+372>>2]=j2[A+420>>2],j2[f+376>>2]=j2[A+424>>2],j2[f+380>>2]=j2[A+428>>2],j2[f+384>>2]=j2[A+432>>2],j2[f+388>>2]=j2[A+436>>2],j2[f+392>>2]=j2[A+440>>2],j2[f+396>>2]=j2[A+444>>2],j2[f+400>>2]=j2[A+448>>2],j2[f+404>>2]=j2[A+452>>2],j2[f+408>>2]=j2[A+456>>2],j2[f+412>>2]=j2[A+460>>2],j2[f+416>>2]=j2[A+464>>2],j2[f+420>>2]=j2[A+468>>2],j2[f+424>>2]=j2[A+472>>2],j2[f+428>>2]=j2[A+476>>2],j2[f+432>>2]=j2[A+480>>2],j2[f+436>>2]=j2[A+484>>2],j2[f+440>>2]=j2[A+488>>2],j2[f+444>>2]=j2[A+492>>2],j2[f+448>>2]=j2[A+496>>2],j2[f+452>>2]=j2[A+500>>2],r=T2[A+508>>2],T2[f+460>>2]=T2[A+504>>2],T2[f+464>>2]=r,r=T2[A+520>>2],T2[f+468>>2]=T2[A+516>>2],T2[f+472>>2]=r,r=T2[A+528>>2],T2[f+476>>2]=T2[A+524>>2],T2[f+480>>2]=r,r=T2[A+536>>2],T2[f+484>>2]=T2[A+532>>2],T2[f+488>>2]=r,T2[f+492>>2]=S2[A+512|0],17164;},function(A,f){var r=0,e=0,e=f|=0,i=0|n1[T2[T2[(A|=0)>>2]+16>>2]](A),a=T2[T2[f>>2]+16>>2],r=0|n1[a](0|e,0|i,1);e=0|n1[T2[T2[A>>2]+20>>2]](A,T2[8+(i=r)>>2],r=f),a=T2[T2[f>>2]+20>>2],n1[a](0|r,0|i,0|e,1497645650,0|A);},Z4,function(A){A=Z4(A|=0),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},C2,function(A,f,r,e,i,a,n,o,b,t){return z2(n1[T2[T2[(A|=0)>>2]+44>>2]](A,f|=0,r|=0,e|=0,i|=0,a|=0,n|=0,o|=0,b|=0)),z2(n1[T2[T2[A>>2]+48>>2]](A,f,r,e,i,a,n,o,b)),z2(n1[T2[T2[A>>2]+36>>2]](A,f,r,o)),z2(z2(0));},C2,function(A){T2[(A|=0)+232>>2]=0;},S0,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I,x,y,U,X,p,T,S,j,P,z,O,H,_,L,K,q,$=z2(0),A2=0,f2=z2(0),r2=z2(0),e2=z2(0),i2=z2(0),a2=z2(0),n2=0,o2=z2(0),b2=z2(0),t2=0,c2=z2(0),u2=z2(0),k2=z2(0),l2=z2(0),s2=z2(0),v2=0,d2=0,B2=z2(0),Q2=z2(0),g2=z2(0),w2=0,G2=0,C2=z2(0),E2=z2(0),D2=0,h2=z2(0),Z2=0,Y2=0,R2=z2(0),F2=z2(0),W2=z2(0),m2=(z2(0)),N2=z2(0),V2=z2(0),J2=z2(0),M2=0,I2=0,x2=(z2(0)),y2=z2(0),U2=z2(0),X2=z2(0);if(L2=v2=L2+-64|0,1<=(0|r))for(;;){if(g=T2[(I2<<2)+f>>2],i=T2[g+840>>2],l=Y4(A,a=T2[g+836>>2],j2[e+12>>2]),k=Y4(A,i,j2[e+12>>2]),C=P2(l,244),G2=T2[A+16>>2],$=j2[(t2=C+G2|0)+128>>2],r2=z2($*$),$=j2[t2+132>>2],r2=z2(r2+z2($*$)),$=j2[t2+136>>2],!(z2(r2+z2($*$))<z2(14210854715202004e-30)&&(A2=G2+P2(k,244)|0,$=j2[A2+128>>2],r2=z2($*$),$=j2[A2+132>>2],r2=z2(r2+z2($*$)),$=j2[A2+136>>2],z2(r2+z2($*$))<z2(14210854715202004e-30))||(0|(n2=T2[g+844>>2]))<1))for(Y=(A2=G2+(E=P2(k,244))|0)+232|0,R=A2+200|0,F=A2+228|0,W=A2+196|0,m=A2+224|0,N=A2+192|0,V=A2+216|0,J=A2+184|0,M=A2+212|0,I=A2+180|0,x=A2+208|0,y=A2+176|0,U=A2+240|0,X=t2+232|0,p=t2+200|0,T=t2+228|0,S=t2+196|0,j=t2+224|0,P=t2+192|0,z=t2+216|0,O=t2+184|0,H=t2+212|0,_=t2+180|0,L=t2+208|0,K=t2+176|0,q=t2+240|0,M2=0;;){if(n=P2(M2,208)+g|0,j2[(w=84+n|0)>>2]<=j2[g+852>>2]){if(Q=4+n|0,(0|(n2=G2=T2[A+28>>2]))==T2[A+32>>2]&&!((0|(D2=(n2=G2)?n2<<1:1))<=(0|n2))){if(t2=0,D2&&(T2[5498]=T2[5498]+1,(A2=K2(P2(D2,152)+19|0))&&(T2[(t2=A2+19&-16)-4>>2]=A2)),1<=(0|G2))for(n2=0,A2=G2;$2(n2+t2|0,T2[A+36>>2]+n2|0,152),n2=n2+152|0,A2=A2-1|0;);(A2=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[A2-4>>2])),T2[A+36>>2]=t2,p2[A+40|0]=1,T2[A+32>>2]=D2,n2=T2[A+28>>2];}T2[A+28>>2]=n2+1,A2=T2[A+36>>2]+P2(G2,152)|0,T2[A2+132>>2]=Q,T2[A2+148>>2]=k,T2[A2+144>>2]=l,T2[60+v2>>2]=0,v=z2(j2[60+n>>2]-j2[a+60>>2]),j2[56+v2>>2]=v,d=z2(j2[56+n>>2]-j2[a+56>>2]),j2[52+v2>>2]=d,o2=z2(j2[52+n>>2]-j2[a+52>>2]),j2[48+v2>>2]=o2,i2=j2[36+n>>2],r2=j2[40+n>>2],e2=j2[44+n>>2],f2=j2[i+52>>2],h2=j2[i+56>>2],$=j2[i+60>>2],T2[44+v2>>2]=0,C2=z2(e2-$),j2[40+v2>>2]=C2,l2=z2(r2-h2),j2[36+v2>>2]=l2,E2=z2(i2-f2),j2[32+v2>>2]=E2,y2=z2(0),U2=z2(0),X2=z2(0),m2=z2(0),T2[q>>2]&&(f2=z2(j2[P>>2]+j2[j>>2]),h2=z2(j2[S>>2]+j2[T>>2]),m2=z2(z2(j2[O>>2]+j2[z>>2])+z2(z2(d*f2)-z2(o2*h2))),$=z2(j2[p>>2]+j2[X>>2]),X2=z2(z2(j2[_>>2]+j2[H>>2])+z2(z2(o2*$)-z2(v*f2))),U2=z2(z2(j2[K>>2]+j2[L>>2])+z2(z2(v*h2)-z2(d*$)))),N2=z2(0),V2=z2(0),T2[U>>2]&&(f2=z2(j2[N>>2]+j2[m>>2]),h2=z2(j2[W>>2]+j2[F>>2]),V2=z2(z2(j2[J>>2]+j2[V>>2])+z2(z2(l2*f2)-z2(E2*h2))),$=z2(j2[R>>2]+j2[Y>>2]),N2=z2(z2(j2[I>>2]+j2[M>>2])+z2(z2(E2*$)-z2(C2*f2))),y2=z2(z2(j2[y>>2]+j2[x>>2])+z2(z2(C2*h2)-z2(l2*$)))),D=j2[(s=72+n|0)>>2],h=j2[(u=68+n|0)>>2],Z=j2[(B=76+n|0)>>2],e2=j2[e+12>>2],n2=T2[A+16>>2],t=T2[240+(o=n2+E|0)>>2],c=T2[240+(b=n2+C|0)>>2],x2=j2[e+36>>2],J2=j2[e+40>>2],h2=j2[e+28>>2],6&(n2=T2[(G=132+n|0)>>2])?(J2=2&n2?j2[156+n>>2]:J2,4&n2&&(x2=j2[160+n>>2])):8&n2&&($=z2(e2*j2[156+n>>2]),f2=z2(H2(z2($+j2[160+n>>2]),z2(1.1920928955078125e-7))),x2=z2($/f2),J2=z2(z2(1)/f2)),s2=z2(z2(D*o2)-z2(d*h)),g2=z2(z2(v*h)-z2(Z*o2)),u2=z2(z2(d*Z)-z2(v*D)),b2=z2(0),k2=z2(0),R2=z2(0),F2=z2(0),c&&(F2=z2(z2(z2(z2(u2*j2[c+356>>2])+z2(g2*j2[c+360>>2]))+z2(s2*j2[c+364>>2]))*j2[c+612>>2]),R2=z2(z2(z2(z2(u2*j2[c+340>>2])+z2(g2*j2[c+344>>2]))+z2(s2*j2[c+348>>2]))*j2[c+608>>2]),k2=z2(z2(z2(z2(u2*j2[c+324>>2])+z2(g2*j2[c+328>>2]))+z2(s2*j2[c+332>>2]))*j2[c+604>>2])),j2[A2+64>>2]=k2,T2[A2+76>>2]=0,j2[(d2=A2+72|0)>>2]=F2,j2[(w2=A2+68|0)>>2]=R2,f2=j2[s>>2],$=j2[u>>2],c2=z2(z2(f2*E2)-z2(l2*$)),r2=z2(C2*$),$=j2[B>>2],r2=z2(r2-z2($*E2)),i2=z2(z2(l2*$)-z2(C2*f2)),W2=z2(0),a2=z2(0),t&&($=z2(-r2),a2=z2(z2(z2(z2(j2[t+360>>2]*$)-z2(i2*j2[t+356>>2]))-z2(c2*j2[t+364>>2]))*j2[t+612>>2]),b2=z2(z2(z2(z2(j2[t+328>>2]*$)-z2(i2*j2[t+324>>2]))-z2(c2*j2[t+332>>2]))*j2[t+604>>2]),W2=z2(z2(z2(z2(j2[t+344>>2]*$)-z2(i2*j2[t+340>>2]))-z2(c2*j2[t+348>>2]))*j2[t+608>>2])),j2[A2+80>>2]=b2,T2[A2+92>>2]=0,j2[(Z2=A2+88|0)>>2]=a2,j2[(Y2=A2+84|0)>>2]=W2,n2=A2,f2=h2,Q2=z2(z2(1)/e2),e2=B2=z2(Q2*J2),$=z2(c?j2[c+404>>2]+z2(z2(z2(z2(z2(R2*v)-z2(F2*d))*j2[u>>2])+z2(z2(z2(F2*o2)-z2(v*k2))*j2[s>>2]))+z2(z2(z2(d*k2)-z2(R2*o2))*j2[B>>2])):0),a2=z2(t?j2[t+404>>2]+z2(z2(z2(z2(z2(a2*l2)-z2(W2*C2))*j2[u>>2])+z2(z2(z2(b2*C2)-z2(a2*E2))*j2[s>>2]))+z2(z2(z2(W2*E2)-z2(b2*l2))*j2[B>>2])):0),j2[n2+108>>2]=f2/z2(e2+z2($+a2)),c?(n2=T2[4+u>>2],T2[A2+16>>2]=T2[u>>2],T2[A2+20>>2]=n2,D2=T2[(n2=8+u|0)+4>>2],t2=T2[n2>>2],j2[A2>>2]=u2,T2[A2+12>>2]=0,j2[A2+8>>2]=s2,j2[A2+4>>2]=g2,T2[(n2=A2+24|0)>>2]=t2,T2[n2+4>>2]=D2):(T2[A2>>2]=0,T2[A2+4>>2]=0,T2[(n2=A2+24|0)>>2]=0,T2[n2+4>>2]=0,T2[(n2=A2+16|0)>>2]=0,T2[n2+4>>2]=0,T2[(n2=A2+8|0)>>2]=0,T2[n2+4>>2]=0),t?(f2=j2[s>>2],$=j2[B>>2],j2[A2+48>>2]=-j2[u>>2],j2[A2+32>>2]=-i2,T2[A2+60>>2]=0,j2[A2+56>>2]=-$,j2[A2+52>>2]=-f2,T2[A2+44>>2]=0,j2[A2+40>>2]=-c2,j2[A2+36>>2]=-r2):(T2[A2+32>>2]=0,T2[A2+36>>2]=0,T2[(n2=A2+56|0)>>2]=0,T2[n2+4>>2]=0,T2[(n2=A2+48|0)>>2]=0,T2[n2+4>>2]=0,T2[(n2=A2+40|0)>>2]=0,T2[n2+4>>2]=0),g2=j2[e+64>>2],u2=j2[w>>2],b2=z2(0),R2=z2(0),F2=z2(0),W2=z2(0),c&&(e2=j2[c+388>>2],f2=j2[c+392>>2],W2=z2(z2(z2(d*e2)-z2(f2*o2))+j2[c+380>>2]),$=j2[c+396>>2],F2=z2(z2(z2($*o2)-z2(v*e2))+j2[c+376>>2]),R2=z2(z2(z2(f2*v)-z2($*d))+j2[c+372>>2])),a2=z2(0),o2=z2(0),t&&(e2=j2[t+388>>2],f2=j2[t+392>>2],o2=z2(z2(z2(l2*e2)-z2(f2*E2))+j2[t+380>>2]),$=j2[t+396>>2],a2=z2(z2(z2($*E2)-z2(C2*e2))+j2[t+376>>2]),b2=z2(z2(z2(f2*C2)-z2($*l2))+j2[t+372>>2])),w=240+o|0,D2=240+b|0,e2=j2[B>>2],f2=j2[u>>2],$=j2[s>>2],j2[A2+104>>2]=j2[88+n>>2],$=z2(z2(z2(f2*z2(R2-b2))+z2($*z2(F2-a2)))+z2(e2*z2(W2-o2))),s2=j2[e+96>>2]>z2(O2($))?z2(0):z2(j2[100+n>>2]*z2(-$)),4&(n2=T2[e+72>>2])?(i2=z2(j2[136+n>>2]*j2[e+68>>2]),j2[A2+100>>2]=i2,c&&T2[D2>>2]&&(r2=j2[c+416>>2],e2=j2[A2+24>>2],f2=j2[c+412>>2],$=j2[A2+20>>2],j2[64+b>>2]=z2(j2[112+b>>2]*z2(i2*z2(z2(j2[A2+16>>2]*j2[128+b>>2])*j2[c+408>>2])))+j2[64+b>>2],j2[(t2=68+b|0)>>2]=z2(z2(i2*z2(f2*z2($*j2[132+b>>2])))*j2[116+b>>2])+j2[t2>>2],j2[(t2=72+b|0)>>2]=z2(z2(i2*z2(r2*z2(e2*j2[136+b>>2])))*j2[120+b>>2])+j2[t2>>2],e2=j2[d2>>2],f2=j2[w2>>2],j2[80+b>>2]=z2(z2(i2*j2[96+b>>2])*j2[A2- -64>>2])+j2[80+b>>2],$=j2[104+b>>2],j2[(t2=84+b|0)>>2]=z2(f2*z2(i2*j2[100+b>>2]))+j2[t2>>2],j2[(t2=88+b|0)>>2]=z2(e2*z2(i2*$))+j2[t2>>2]),!t||T2[w>>2]&&(k2=j2[t+416>>2],c2=j2[A2+56>>2],i2=j2[t+412>>2],r2=j2[A2+52>>2],e2=j2[Z2>>2],f2=j2[Y2>>2],$=j2[A2+80>>2],a2=z2(-j2[A2+100>>2]),j2[64+o>>2]=j2[64+o>>2]-z2(j2[112+o>>2]*z2(z2(z2(j2[128+o>>2]*j2[A2+48>>2])*j2[t+408>>2])*a2)),j2[(t2=68+o|0)>>2]=j2[t2>>2]-z2(z2(z2(i2*z2(r2*j2[132+o>>2]))*a2)*j2[116+o>>2]),j2[(t2=72+o|0)>>2]=j2[t2>>2]-z2(z2(z2(k2*z2(c2*j2[136+o>>2]))*a2)*j2[120+o>>2]),j2[80+o>>2]=j2[80+o>>2]-z2($*z2(j2[96+o>>2]*a2)),$=j2[104+o>>2],j2[(t2=84+o|0)>>2]=j2[t2>>2]-z2(f2*z2(j2[100+o>>2]*a2)),j2[(t2=88+o|0)>>2]=j2[t2>>2]-z2(e2*z2($*a2)))):T2[A2+100>>2]=0,T2[A2+96>>2]=0,C2=z2(0),l2=z2(0),b2=z2(0),R2=z2(0),F2=z2(0),o2=z2(0),W2=z2(0),a2=z2(0),J2=z2(0),r2=z2(0),t2=A2+108|0,e2=s2<=z2(0)?z2(0):s2,$=T2[D2>>2]?(F2=j2[224+b>>2],R2=j2[228+b>>2],C2=j2[216+b>>2],l2=j2[212+b>>2],b2=j2[232+b>>2],j2[208+b>>2]):z2(0),l2=z2(z2(z2(z2(z2($+j2[176+b>>2])*j2[A2+16>>2])+z2(z2(l2+j2[180+b>>2])*j2[A2+20>>2]))+z2(z2(C2+j2[184+b>>2])*j2[A2+24>>2]))+z2(z2(z2(z2(F2+j2[192+b>>2])*j2[A2>>2])+z2(z2(R2+j2[196+b>>2])*j2[A2+4>>2]))+z2(z2(b2+j2[200+b>>2])*j2[A2+8>>2]))),$=T2[w>>2]?(r2=j2[224+o>>2],a2=j2[232+o>>2],J2=j2[228+o>>2],W2=j2[216+o>>2],o2=j2[212+o>>2],j2[208+o>>2]):z2(0),b2=z2(e2-z2(l2+z2(z2(z2(z2(z2($+j2[176+o>>2])*j2[A2+48>>2])+z2(z2(o2+j2[180+o>>2])*j2[A2+52>>2]))+z2(z2(W2+j2[184+o>>2])*j2[A2+56>>2]))+z2(z2(z2(z2(r2+j2[192+o>>2])*j2[A2+32>>2])+z2(z2(J2+j2[196+o>>2])*j2[A2+36>>2]))+z2(z2(a2+j2[200+o>>2])*j2[A2+40>>2]))))),f2=j2[e+56>>2],T2[A2+120>>2]=0,T2[A2+124>>2]=1343554297,e2=j2[t2>>2],j2[A2+116>>2]=B2*e2,T2[A2+140>>2]=T2[A+68>>2],d2=A2,$=(r2=z2(u2+g2))>z2(0)?(b2=z2(b2-z2(Q2*r2)),z2(0)):z2(Q2*z2(x2*z2(-r2))),$=z2($*e2),t2=!T2[e+52>>2]|f2<r2,j2[d2+128>>2]=t2?z2(0):$,r2=$,$=z2(b2*e2),j2[A2+112>>2]=t2?z2(r2+$):$,t2=A2+140|0,j2[(D2=92+n|0)>>2]>z2(0)&&(R4(A,u,l,k,G2,j2[96+n>>2]),i2=j2[B>>2],l2=z2(O2(i2))>z2(.7071067690849304)?(f2=j2[s>>2],$=z2(z2(i2*i2)+z2(f2*f2)),e2=z2(z2(1)/z2(_2($))),E2=z2($*e2),$=j2[u>>2],o2=z2(e2*z2(-i2)),C2=z2($*o2),b2=z2(0),a2=z2(f2*e2),z2(a2*z2(-$))):(e2=j2[u>>2],f2=j2[s>>2],$=z2(z2(e2*e2)+z2(f2*f2)),r2=z2(z2(1)/z2(_2($))),C2=z2($*r2),o2=z2(e2*r2),E2=z2(o2*z2(-i2)),a2=z2(0),b2=z2(r2*z2(-f2)),z2(i2*b2)),$=z2(z2(1)/z2(_2(z2(z2(z2(b2*b2)+z2(o2*o2))+z2(a2*a2))))),a2=z2(a2*$),j2[24+v2>>2]=a2,o2=z2(o2*$),j2[20+v2>>2]=o2,b2=z2(b2*$),j2[16+v2>>2]=b2,$=z2(z2(1)/z2(_2(z2(z2(C2*C2)+z2(z2(E2*E2)+z2(l2*l2)))))),C2=z2(C2*$),j2[8+v2>>2]=C2,l2=z2(l2*$),j2[4+v2>>2]=l2,E2=z2(E2*$),j2[v2>>2]=E2,(n2=2&T2[a+180>>2])&&(T2[28+v2>>2]=0,g2=j2[a+4>>2],u2=j2[a+20>>2],k2=j2[a+36>>2],Q2=z2(z2(z2(z2(b2*g2)+z2(o2*u2))+z2(a2*k2))*j2[a+164>>2]),c2=j2[a+8>>2],i2=j2[a+24>>2],r2=j2[a+40>>2],s2=z2(z2(z2(z2(b2*c2)+z2(o2*i2))+z2(a2*r2))*j2[a+168>>2]),e2=j2[a+12>>2],f2=j2[a+28>>2],$=j2[a+44>>2],B2=z2(z2(z2(z2(b2*e2)+z2(o2*f2))+z2(a2*$))*j2[a+172>>2]),a2=z2(z2(z2(k2*Q2)+z2(r2*s2))+z2($*B2)),j2[24+v2>>2]=a2,o2=z2(z2(z2(u2*Q2)+z2(i2*s2))+z2(f2*B2)),j2[20+v2>>2]=o2,b2=z2(z2(z2(g2*Q2)+z2(c2*s2))+z2(e2*B2)),j2[16+v2>>2]=b2),(A2=2&T2[i+180>>2])&&(T2[28+v2>>2]=0,g2=j2[i+4>>2],u2=j2[i+20>>2],k2=j2[i+36>>2],Q2=z2(z2(z2(z2(g2*b2)+z2(u2*o2))+z2(k2*a2))*j2[i+164>>2]),c2=j2[i+8>>2],i2=j2[i+24>>2],r2=j2[i+40>>2],s2=z2(z2(z2(z2(b2*c2)+z2(o2*i2))+z2(a2*r2))*j2[i+168>>2]),e2=j2[i+12>>2],f2=j2[i+28>>2],$=j2[i+44>>2],B2=z2(z2(z2(z2(b2*e2)+z2(o2*f2))+z2(a2*$))*j2[i+172>>2]),a2=z2(z2(z2(k2*Q2)+z2(r2*s2))+z2($*B2)),j2[24+v2>>2]=a2,o2=z2(z2(z2(u2*Q2)+z2(i2*s2))+z2(f2*B2)),j2[20+v2>>2]=o2,b2=z2(z2(z2(g2*Q2)+z2(c2*s2))+z2(e2*B2)),j2[16+v2>>2]=b2),n2&&(T2[12+v2>>2]=0,g2=j2[a+4>>2],u2=j2[a+20>>2],k2=j2[a+36>>2],Q2=z2(z2(z2(z2(E2*g2)+z2(l2*u2))+z2(C2*k2))*j2[a+164>>2]),c2=j2[a+8>>2],i2=j2[a+24>>2],r2=j2[a+40>>2],s2=z2(z2(z2(z2(E2*c2)+z2(l2*i2))+z2(C2*r2))*j2[a+168>>2]),e2=j2[a+12>>2],f2=j2[a+28>>2],$=j2[a+44>>2],B2=z2(z2(z2(z2(E2*e2)+z2(l2*f2))+z2(C2*$))*j2[a+172>>2]),C2=z2(z2(z2(k2*Q2)+z2(r2*s2))+z2($*B2)),j2[8+v2>>2]=C2,l2=z2(z2(z2(u2*Q2)+z2(i2*s2))+z2(f2*B2)),j2[4+v2>>2]=l2,E2=z2(z2(z2(g2*Q2)+z2(c2*s2))+z2(e2*B2)),j2[v2>>2]=E2),A2&&(T2[12+v2>>2]=0,g2=j2[i+4>>2],u2=j2[i+20>>2],k2=j2[i+36>>2],Q2=z2(z2(z2(z2(g2*E2)+z2(u2*l2))+z2(k2*C2))*j2[i+164>>2]),c2=j2[i+8>>2],i2=j2[i+24>>2],r2=j2[i+40>>2],s2=z2(z2(z2(z2(E2*c2)+z2(l2*i2))+z2(C2*r2))*j2[i+168>>2]),e2=j2[i+12>>2],f2=j2[i+28>>2],$=j2[i+44>>2],B2=z2(z2(z2(z2(E2*e2)+z2(l2*f2))+z2(C2*$))*j2[i+172>>2]),C2=z2(z2(z2(k2*Q2)+z2(r2*s2))+z2($*B2)),j2[8+v2>>2]=C2,l2=z2(z2(z2(u2*Q2)+z2(i2*s2))+z2(f2*B2)),j2[4+v2>>2]=l2,E2=z2(z2(z2(g2*Q2)+z2(c2*s2))+z2(e2*B2)),j2[v2>>2]=E2),.001<+z2(_2(z2(z2(z2(b2*b2)+z2(o2*o2))+z2(a2*a2))))&&R4(A,16+v2|0,l,k,G2,j2[D2>>2]),.001<+z2(_2(z2(z2(z2(E2*E2)+z2(l2*l2))+z2(C2*C2))))&&R4(A,v2,l,k,G2,j2[D2>>2]),n2=T2[e+72>>2]),1&p2[0|G]&&32&n2?(F4(A,172+n|0,l,k,G2,Q,48+v2|0,32+v2|0,h2,e,j2[148+n>>2],j2[(A2=164+n|0)>>2]),16&S2[e+72|0]&&F4(A,188+n|0,l,k,G2,Q,48+v2|0,32+v2|0,h2,e,j2[152+n>>2],j2[A2>>2])):(T2[(A2=184+n|0)>>2]=0,e2=z2(U2-y2),f2=z2(X2-N2),$=z2(m2-V2),c2=z2(z2(z2(e2*h)+z2(f2*D))+z2($*Z)),w2=180+n|0,u2=j2[B>>2],i2=z2($-z2(c2*u2)),j2[w2>>2]=i2,Z2=176+n|0,k2=j2[s>>2],r2=z2(f2-z2(c2*k2)),j2[Z2>>2]=r2,d2=172+n|0,$=e2,e2=j2[u>>2],f2=z2($-z2(c2*e2)),j2[d2>>2]=f2,64&S2[e+72|0]||!(($=z2(z2(z2(f2*f2)+z2(r2*r2))+z2(i2*i2)))>z2(1.1920928955078125e-7))?(Y2=188+n|0,E2=z2(O2(u2))>z2(.7071067690849304)?(T2[d2>>2]=0,$=z2(z2(k2*k2)+z2(u2*u2)),f2=z2(z2(1)/z2(_2($))),a2=z2(f2*z2(-u2)),j2[Z2>>2]=a2,o2=z2(k2*f2),j2[w2>>2]=o2,C2=z2($*f2),l2=z2(e2*a2),b2=z2(0),z2(o2*z2(-e2))):(T2[w2>>2]=0,$=z2(z2(e2*e2)+z2(k2*k2)),f2=z2(z2(1)/z2(_2($))),a2=z2(e2*f2),j2[Z2>>2]=a2,b2=z2(f2*z2(-k2)),j2[d2>>2]=b2,l2=z2($*f2),C2=z2(a2*z2(-u2)),o2=z2(0),z2(u2*b2)),j2[Y2>>2]=C2,j2[(D2=196+n|0)>>2]=l2,j2[(n2=192+n|0)>>2]=E2,1&p2[a+180|0]&&(e2=j2[a+172>>2],Q2=j2[a+44>>2],s2=j2[a+12>>2],B2=j2[a+28>>2],f2=j2[a+164>>2],g2=j2[a+36>>2],u2=j2[a+4>>2],r2=j2[a+20>>2],$=j2[a+168>>2],k2=j2[a+40>>2],c2=j2[a+8>>2],i2=j2[a+24>>2],T2[A2>>2]=0,l2=r2,r2=z2(f2*z2(z2(z2(u2*b2)+z2(r2*a2))+z2(g2*o2))),f2=z2($*z2(z2(z2(b2*c2)+z2(a2*i2))+z2(o2*k2))),$=z2(e2*z2(z2(z2(b2*s2)+z2(a2*B2))+z2(o2*Q2))),a2=z2(z2(z2(l2*r2)+z2(i2*f2))+z2(B2*$)),j2[Z2>>2]=a2,b2=z2(z2(z2(u2*r2)+z2(c2*f2))+z2(s2*$)),j2[d2>>2]=b2,o2=z2(z2(z2(g2*r2)+z2(k2*f2))+z2(Q2*$)),j2[w2>>2]=o2),1&p2[i+180|0]&&(e2=j2[i+172>>2],Q2=j2[i+44>>2],s2=j2[i+12>>2],B2=j2[i+28>>2],f2=j2[i+164>>2],g2=j2[i+36>>2],u2=j2[i+4>>2],r2=j2[i+20>>2],$=j2[i+168>>2],k2=j2[i+40>>2],c2=j2[i+8>>2],i2=j2[i+24>>2],T2[A2>>2]=0,l2=r2,r2=z2(f2*z2(z2(z2(u2*b2)+z2(r2*a2))+z2(g2*o2))),f2=z2($*z2(z2(z2(b2*c2)+z2(a2*i2))+z2(o2*k2))),$=z2(e2*z2(z2(z2(b2*s2)+z2(a2*B2))+z2(o2*Q2))),j2[Z2>>2]=z2(z2(l2*r2)+z2(i2*f2))+z2(B2*$),j2[d2>>2]=z2(z2(u2*r2)+z2(c2*f2))+z2(s2*$),j2[w2>>2]=z2(z2(g2*r2)+z2(k2*f2))+z2(Q2*$)),F4(A,d2,l,k,G2,Q,48+v2|0,32+v2|0,h2,e,z2(0),z2(0)),16&(A2=T2[e+72>>2])&&(1&p2[a+180|0]&&(e2=j2[a+172>>2],m2=j2[a+44>>2],N2=j2[a+12>>2],V2=j2[a+28>>2],f2=j2[a+164>>2],Q2=j2[a+36>>2],r2=j2[a+4>>2],s2=j2[a+20>>2],$=j2[a+168>>2],B2=j2[a+40>>2],g2=j2[a+8>>2],u2=j2[a+24>>2],T2[200+n>>2]=0,k2=j2[Y2>>2],c2=j2[n2>>2],i2=j2[D2>>2],r2=z2(f2*z2(z2(z2((l2=r2)*k2)+z2(s2*c2))+z2(Q2*i2))),f2=z2($*z2(z2(z2(k2*g2)+z2(c2*u2))+z2(i2*B2))),$=z2(e2*z2(z2(z2(k2*N2)+z2(c2*V2))+z2(i2*m2))),j2[Y2>>2]=z2(z2(l2*r2)+z2(g2*f2))+z2(N2*$),j2[n2>>2]=z2(z2(s2*r2)+z2(u2*f2))+z2(V2*$),j2[D2>>2]=z2(z2(Q2*r2)+z2(B2*f2))+z2(m2*$)),1&p2[i+180|0]&&(e2=j2[i+172>>2],m2=j2[i+44>>2],N2=j2[i+12>>2],V2=j2[i+28>>2],f2=j2[i+164>>2],Q2=j2[i+36>>2],r2=j2[i+4>>2],s2=j2[i+20>>2],$=j2[i+168>>2],B2=j2[i+40>>2],g2=j2[i+8>>2],u2=j2[i+24>>2],T2[200+n>>2]=0,k2=j2[Y2>>2],c2=j2[n2>>2],i2=j2[D2>>2],r2=z2(f2*z2(z2(z2((l2=r2)*k2)+z2(s2*c2))+z2(Q2*i2))),f2=z2($*z2(z2(z2(k2*g2)+z2(c2*u2))+z2(i2*B2))),$=z2(e2*z2(z2(z2(k2*N2)+z2(c2*V2))+z2(i2*m2))),j2[Y2>>2]=z2(z2(l2*r2)+z2(g2*f2))+z2(N2*$),j2[n2>>2]=z2(z2(s2*r2)+z2(u2*f2))+z2(V2*$),j2[D2>>2]=z2(z2(Q2*r2)+z2(B2*f2))+z2(m2*$)),F4(A,Y2,l,k,G2,Q,48+v2|0,32+v2|0,h2,e,z2(0),z2(0)),A2=T2[e+72>>2]),80==(80&A2)&&(T2[G>>2]=1|T2[G>>2])):($=z2(z2(1)/z2(_2($))),b2=z2(r2*$),j2[Z2>>2]=b2,a2=z2(f2*$),j2[d2>>2]=a2,o2=z2(i2*$),j2[w2>>2]=o2,1&p2[a+180|0]&&(e2=j2[a+172>>2],Q2=j2[a+44>>2],s2=j2[a+12>>2],B2=j2[a+28>>2],f2=j2[a+164>>2],g2=j2[a+36>>2],u2=j2[a+4>>2],r2=j2[a+20>>2],$=j2[a+168>>2],k2=j2[a+40>>2],c2=j2[a+8>>2],i2=j2[a+24>>2],T2[A2>>2]=0,l2=r2,r2=z2(f2*z2(z2(z2(a2*u2)+z2(b2*r2))+z2(o2*g2))),f2=z2($*z2(z2(z2(a2*c2)+z2(b2*i2))+z2(o2*k2))),$=z2(e2*z2(z2(z2(a2*s2)+z2(b2*B2))+z2(o2*Q2))),b2=z2(z2(z2(l2*r2)+z2(i2*f2))+z2(B2*$)),j2[Z2>>2]=b2,a2=z2(z2(z2(u2*r2)+z2(c2*f2))+z2(s2*$)),j2[d2>>2]=a2,o2=z2(z2(z2(g2*r2)+z2(k2*f2))+z2(Q2*$)),j2[w2>>2]=o2),1&p2[i+180|0]&&(e2=j2[i+172>>2],Q2=j2[i+44>>2],s2=j2[i+12>>2],B2=j2[i+28>>2],f2=j2[i+164>>2],g2=j2[i+36>>2],u2=j2[i+4>>2],r2=j2[i+20>>2],$=j2[i+168>>2],k2=j2[i+40>>2],c2=j2[i+8>>2],i2=j2[i+24>>2],T2[A2>>2]=0,l2=r2,r2=z2(f2*z2(z2(z2(u2*a2)+z2(r2*b2))+z2(g2*o2))),f2=z2($*z2(z2(z2(a2*c2)+z2(b2*i2))+z2(o2*k2))),$=z2(e2*z2(z2(z2(a2*s2)+z2(b2*B2))+z2(o2*Q2))),j2[Z2>>2]=z2(z2(l2*r2)+z2(i2*f2))+z2(B2*$),j2[d2>>2]=z2(z2(u2*r2)+z2(c2*f2))+z2(s2*$),j2[w2>>2]=z2(z2(g2*r2)+z2(k2*f2))+z2(Q2*$)),F4(A,d2,l,k,G2,Q,48+v2|0,32+v2|0,h2,e,z2(0),z2(0)),16&S2[e+72|0]&&(n2=196+n|(T2[(D2=200+n|0)>>2]=0),i2=j2[s>>2],r2=j2[d2>>2],$=j2[Z2>>2],e2=j2[u>>2],c2=z2(z2(i2*r2)-z2($*e2)),f2=j2[B>>2],B2=z2($*f2),$=j2[w2>>2],i2=z2(B2-z2($*i2)),f2=z2(z2($*e2)-z2(f2*r2)),$=z2(z2(1)/z2(_2(z2(z2(z2(i2*i2)+z2(f2*f2))+z2(c2*c2))))),a2=z2(c2*$),j2[n2>>2]=a2,A2=192+n|0,o2=z2(f2*$),j2[A2>>2]=o2,Y2=188+n|0,b2=z2(i2*$),j2[Y2>>2]=b2,1&p2[a+180|0]&&(e2=j2[a+172>>2],Q2=j2[a+44>>2],s2=j2[a+12>>2],B2=j2[a+28>>2],f2=j2[a+164>>2],g2=j2[a+36>>2],u2=j2[a+4>>2],r2=j2[a+20>>2],$=j2[a+168>>2],k2=j2[a+40>>2],c2=j2[a+8>>2],i2=j2[a+24>>2],T2[D2>>2]=0,l2=r2,r2=z2(f2*z2(z2(z2(b2*u2)+z2(o2*r2))+z2(a2*g2))),f2=z2($*z2(z2(z2(b2*c2)+z2(o2*i2))+z2(a2*k2))),$=z2(e2*z2(z2(z2(b2*s2)+z2(o2*B2))+z2(a2*Q2))),o2=z2(z2(z2(l2*r2)+z2(i2*f2))+z2(B2*$)),j2[A2>>2]=o2,b2=z2(z2(z2(u2*r2)+z2(c2*f2))+z2(s2*$)),j2[Y2>>2]=b2,a2=z2(z2(z2(g2*r2)+z2(k2*f2))+z2(Q2*$)),j2[n2>>2]=a2),1&p2[i+180|0]&&(e2=j2[i+172>>2],Q2=j2[i+44>>2],s2=j2[i+12>>2],B2=j2[i+28>>2],f2=j2[i+164>>2],g2=j2[i+36>>2],u2=j2[i+4>>2],r2=j2[i+20>>2],$=j2[i+168>>2],k2=j2[i+40>>2],c2=j2[i+8>>2],i2=j2[i+24>>2],T2[D2>>2]=0,l2=r2,r2=z2(f2*z2(z2(z2(u2*b2)+z2(r2*o2))+z2(g2*a2))),f2=z2($*z2(z2(z2(b2*c2)+z2(o2*i2))+z2(a2*k2))),$=z2(e2*z2(z2(z2(b2*s2)+z2(o2*B2))+z2(a2*Q2))),j2[A2>>2]=z2(z2(l2*r2)+z2(i2*f2))+z2(B2*$),j2[Y2>>2]=z2(z2(u2*r2)+z2(c2*f2))+z2(s2*$),j2[n2>>2]=z2(z2(g2*r2)+z2(k2*f2))+z2(Q2*$)),F4(A,Y2,l,k,G2,Q,48+v2|0,32+v2|0,h2,e,z2(0),z2(0))))),D2=T2[A+76>>2],n2=T2[t2>>2],4&(G2=T2[e+72>>2])?(A2=T2[A+16>>2],Y2=T2[(d2=A2+E|0)+240>>2],t2=T2[(w2=A2+C|0)+240>>2],Z2=D2+P2(n2,152)|0,i2=z2(j2[140+n>>2]*j2[e+68>>2]),j2[Z2+100>>2]=i2,t2&&(e2=j2[t2+416>>2],f2=j2[Z2+24>>2],h2=j2[t2+412>>2],$=j2[Z2+20>>2],r2=j2[t2+404>>2],j2[w2+64>>2]=z2(z2(i2*z2(z2(r2*j2[Z2+16>>2])*j2[t2+408>>2]))*j2[w2+112>>2])+j2[w2+64>>2],j2[(A2=w2+68|0)>>2]=z2(z2(i2*z2(h2*z2(r2*$)))*j2[w2+116>>2])+j2[A2>>2],j2[(A2=w2+72|0)>>2]=z2(z2(i2*z2(e2*z2(r2*f2)))*j2[w2+120>>2])+j2[A2>>2],f2=j2[Z2+72>>2],h2=j2[Z2+68>>2],j2[w2+80>>2]=z2(z2(i2*j2[w2+96>>2])*j2[Z2+64>>2])+j2[w2+80>>2],$=j2[w2+104>>2],j2[(A2=w2+84|0)>>2]=z2(h2*z2(i2*j2[w2+100>>2]))+j2[A2>>2],j2[(A2=w2+88|0)>>2]=z2(f2*z2(i2*$))+j2[A2>>2]),Y2&&(c2=j2[Z2+88>>2],i2=j2[Z2+84>>2],r2=j2[Z2+80>>2],e2=j2[Y2+416>>2],f2=j2[Z2+56>>2],h2=j2[Y2+412>>2],$=j2[Z2+52>>2],k2=j2[Y2+404>>2],u2=j2[Z2+100>>2],j2[d2+64>>2]=j2[d2+64>>2]+z2(z2(z2(z2(k2*j2[Z2+48>>2])*j2[Y2+408>>2])*u2)*j2[d2+112>>2]),j2[(A2=d2+68|0)>>2]=j2[A2>>2]+z2(z2(u2*z2(h2*z2(k2*$)))*j2[d2+116>>2]),j2[(A2=d2+72|0)>>2]=j2[A2>>2]+z2(z2(u2*z2(e2*z2(k2*f2)))*j2[d2+120>>2]),j2[d2+80>>2]=j2[d2+80>>2]+z2(r2*z2(u2*j2[d2+96>>2])),$=j2[d2+104>>2],j2[(A2=d2+84|0)>>2]=j2[A2>>2]+z2(i2*z2(u2*j2[d2+100>>2])),j2[(A2=d2+88|0)>>2]=j2[A2>>2]+z2(c2*z2($*u2))),16&G2&&(G2=D2+P2(n2+1|0,152)|0,e2=z2(j2[144+n>>2]*j2[e+68>>2]),j2[G2+100>>2]=e2,t2&&(h2=j2[G2+24>>2],$=j2[G2+20>>2],f2=j2[t2+404>>2],j2[w2+64>>2]=z2(z2(e2*z2(f2*j2[G2+16>>2]))*j2[w2+112>>2])+j2[w2+64>>2],j2[(A2=w2+68|0)>>2]=z2(z2(e2*z2(f2*$))*j2[w2+116>>2])+j2[A2>>2],j2[(A2=w2+72|0)>>2]=z2(z2(e2*z2(f2*h2))*j2[w2+120>>2])+j2[A2>>2],f2=j2[G2+72>>2],h2=j2[G2+68>>2],j2[w2+80>>2]=z2(z2(e2*j2[w2+96>>2])*j2[G2+64>>2])+j2[w2+80>>2],$=j2[w2+104>>2],j2[(A2=w2+84|0)>>2]=z2(h2*z2(e2*j2[w2+100>>2]))+j2[A2>>2],j2[(A2=w2+88|0)>>2]=z2(f2*z2(e2*$))+j2[A2>>2]),Y2&&(r2=j2[G2+88>>2],e2=j2[G2+84>>2],f2=j2[G2+56>>2],h2=j2[G2+52>>2],$=j2[G2+48>>2],i2=j2[Y2+404>>2],c2=j2[G2+100>>2],j2[d2+80>>2]=j2[d2+80>>2]+z2(j2[G2+80>>2]*z2(j2[d2+96>>2]*c2)),j2[d2+64>>2]=j2[d2+64>>2]+z2(z2(c2*z2(i2*$))*j2[d2+112>>2]),j2[(A2=d2+68|0)>>2]=j2[A2>>2]+z2(z2(c2*z2(i2*h2))*j2[d2+116>>2]),j2[(A2=d2+72|0)>>2]=j2[A2>>2]+z2(z2(c2*z2(i2*f2))*j2[d2+120>>2]),$=j2[d2+104>>2],j2[(A2=d2+84|0)>>2]=j2[A2>>2]+z2(e2*z2(c2*j2[d2+100>>2])),j2[(A2=d2+88|0)>>2]=j2[A2>>2]+z2(r2*z2($*c2))))):(A2=D2+P2(n2,152)|0,T2[A2+100>>2]=0,16&G2&&(T2[A2+252>>2]=0)),n2=T2[g+844>>2];}if(!((0|(M2=M2+1|0))<(0|n2)))break;}if((0|(I2=I2+1|0))==(0|r))break;}L2=v2+64|0;},function(A,f,r,e,i,a,n,o,b){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,o|=0;var t,c=z2(0);A:if(T2[o+52>>2]&&!(T2[o+20>>2]<1||(0|(f=T2[A+28>>2]))<1))for(r=0;;){if(c=z2(0),1<=(0|f))for(e=0;t=c,a=T2[A+16>>2],i=T2[A+36>>2]+P2(T2[T2[A+116>>2]+e>>2],152)|0,c=z2(n1[T2[A+220>>2]](a+P2(T2[i+144>>2],244)|0,P2(T2[i+148>>2],244)+a|0,i)),c=z2(t+z2(c*c)),e=e+4|0,f=f-1|0;);if(j2[o+92>>2]>=c)break A;if(((f=T2[o+20>>2])-1|0)<=(0|r))break A;if((0|f)<=(0|(r=r+1|0)))break A;f=T2[A+28>>2];}},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n=0,o=0,b=0,t=z2(0),c=z2(0),u=0,k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=0,B=0,Q=0,g=L2-80|0;if(L2=g,4&(n=T2[e+72>>2])&&!((0|(r=T2[A+28>>2]))<1))if(o=T2[A+76>>2],f=T2[A+36>>2],16&n)for(f=f+140|0;n=T2[f-8>>2],j2[n+132>>2]=j2[f-40>>2],b=o+P2(T2[f>>2],152)|0,j2[n+136>>2]=j2[b+100>>2],j2[n+140>>2]=j2[b+252>>2],f=f+152|0,r=r-1|0;);else for(f=f+140|0;n=T2[f-8>>2],j2[n+132>>2]=j2[f-40>>2],j2[n+136>>2]=j2[100+(o+P2(T2[f>>2],152)|0)>>2],f=f+152|0,r=r-1|0;);if(1<=(0|(n=T2[A+48>>2])))for(f=T2[A+56>>2]+100|0;o=T2[f+32>>2],(r=T2[o+44>>2])&&(b=T2[o+28>>2],k=j2[b+416>>2],l=j2[f-76>>2],s=j2[b+412>>2],v=j2[f-80>>2],t=j2[f>>2],c=z2(z2(1)/j2[e+12>>2]),j2[r>>2]=j2[r>>2]+z2(z2(z2(j2[f-84>>2]*t)*j2[b+408>>2])*c),j2[r+4>>2]=z2(z2(s*z2(t*v))*c)+j2[r+4>>2],j2[r+8>>2]=z2(z2(k*z2(t*l))*c)+j2[r+8>>2],d=T2[o+32>>2],k=j2[d+416>>2],l=j2[f-44>>2],s=j2[d+412>>2],v=j2[f-48>>2],t=j2[f>>2],c=z2(z2(1)/j2[e+12>>2]),j2[r+32>>2]=j2[r+32>>2]+z2(z2(z2(j2[f-52>>2]*t)*j2[d+408>>2])*c),j2[(B=r+36|0)>>2]=z2(z2(s*z2(t*v))*c)+j2[B>>2],j2[(B=r+40|0)>>2]=z2(z2(k*z2(t*l))*c)+j2[B>>2],k=j2[b+612>>2],l=j2[f-92>>2],s=j2[b+608>>2],v=j2[f-96>>2],t=j2[f>>2],c=z2(z2(1)/j2[e+12>>2]),j2[r+16>>2]=j2[r+16>>2]+z2(z2(z2(j2[f-100>>2]*j2[b+604>>2])*t)*c),j2[(b=r+20|0)>>2]=z2(z2(t*z2(v*s))*c)+j2[b>>2],j2[(b=r+24|0)>>2]=z2(z2(t*z2(l*k))*c)+j2[b>>2],k=j2[d+612>>2],l=j2[f-60>>2],s=j2[d+608>>2],v=j2[f+-64>>2],t=j2[f>>2],c=z2(z2(1)/j2[e+12>>2]),j2[r+48>>2]=j2[r+48>>2]+z2(z2(z2(j2[f-68>>2]*j2[d+604>>2])*t)*c),j2[(b=r+52|0)>>2]=z2(z2(t*z2(v*s))*c)+j2[b>>2],j2[(r=r+56|0)>>2]=z2(z2(t*z2(l*k))*c)+j2[r>>2]),t=j2[f>>2],j2[o+36>>2]=t,j2[o+16>>2]<=z2(O2(t))&&(p2[o+20|0]=0),f=f+152|0,n=n-1|0;);if(1<=(0|(n=T2[A+8>>2])))for(b=T2[A+16>>2],d=g+64|0,B=48+g|0,i=32+g|0,r=144;(o=T2[(f=r+b|0)+96>>2])&&(T2[e+52>>2]?(t=j2[e+60>>2],c=j2[e+12>>2],j2[(o=f+32|0)>>2]=j2[f-80>>2]+j2[o>>2],j2[(o=f+36|0)>>2]=j2[f-76>>2]+j2[o>>2],j2[(o=f+40|0)>>2]=j2[f-72>>2]+j2[o>>2],j2[(o=f+48|0)>>2]=j2[f+-64>>2]+j2[o>>2],j2[(o=f+52|0)>>2]=j2[f-60>>2]+j2[o>>2],j2[(o=f+56|0)>>2]=j2[f-56>>2]+j2[o>>2],j2[f>>2]==z2(0)&&j2[f+4>>2]==z2(0)&&j2[f+8>>2]==z2(0)&&j2[f+16>>2]==z2(0)&&j2[f+20>>2]==z2(0)&&j2[f+24>>2]==z2(0)||(T2[12+g>>2]=0,j2[8+g>>2]=j2[f+24>>2]*t,j2[4+g>>2]=j2[f+20>>2]*t,j2[g>>2]=j2[f+16>>2]*t,W4(o=f-144|0,j2[f>>2],j2[f+4>>2],j2[f+8>>2],g,c,16+g|0),u=T2[(b=24+g|0)+4>>2],T2[(n=o+8|0)>>2]=T2[b>>2],T2[n+4>>2]=u,n=T2[20+g>>2],T2[o>>2]=T2[16+g>>2],T2[o+4>>2]=n,u=T2[(b=8+i|0)+4>>2],T2[(n=(o=f-128|0)+8|0)>>2]=T2[b>>2],T2[n+4>>2]=u,n=T2[4+i>>2],T2[o>>2]=T2[i>>2],T2[o+4>>2]=n,u=T2[(b=B+8|0)+4>>2],T2[(n=(o=f-112|0)+8|0)>>2]=T2[b>>2],T2[n+4>>2]=u,n=T2[B+4>>2],T2[o>>2]=T2[B>>2],T2[o+4>>2]=n,b=T2[(n=d+8|0)+4>>2],T2[(o=(f=f-96|0)+8|0)>>2]=T2[n>>2],T2[o+4>>2]=b,o=T2[d+4>>2],T2[f>>2]=T2[d>>2],T2[f+4>>2]=o,b=T2[A+16>>2]),t=j2[(f=r+b|0)+40>>2],c=j2[f+36>>2],k=j2[f+32>>2],o=T2[f+96>>2]):(k=z2(j2[f-80>>2]+j2[(n=f+32|0)>>2]),j2[n>>2]=k,c=z2(j2[f-76>>2]+j2[(n=f+36|0)>>2]),j2[n>>2]=c,t=z2(j2[f-72>>2]+j2[(n=f+40|0)>>2]),j2[n>>2]=t,j2[(n=f+48|0)>>2]=j2[f+-64>>2]+j2[n>>2],j2[(n=f+52|0)>>2]=j2[f-60>>2]+j2[n>>2],j2[(n=f+56|0)>>2]=j2[f-56>>2]+j2[n>>2]),l=j2[(f=r+b|0)- -64>>2],s=j2[f+68>>2],v=j2[f+72>>2],T2[o+384>>2]=0,j2[o+380>>2]=t+v,j2[o+376>>2]=c+s,j2[o+372>>2]=k+l,T2[o+304>>2]=T2[o+304>>2]+1,f=T2[A+16>>2]+r|0,t=j2[f+48>>2],c=j2[f+80>>2],k=j2[f+52>>2],l=j2[f+84>>2],s=j2[f+56>>2],v=j2[f+88>>2],f=T2[f+96>>2],T2[f+400>>2]=0,j2[f+396>>2]=s+v,j2[f+392>>2]=k+l,j2[f+388>>2]=t+c,T2[f+304>>2]=T2[f+304>>2]+1,T2[e+52>>2]&&(o=T2[A+16>>2]+r|0,f=T2[o+96>>2],T2[f+304>>2]=T2[f+304>>2]+1,a=T2[(u=(n=o-144|0)+8|0)+4>>2],T2[(b=f+12|0)>>2]=T2[u>>2],T2[b+4>>2]=a,b=T2[n+4>>2],T2[f+4>>2]=T2[n>>2],T2[f+8>>2]=b,a=T2[(u=(n=o-128|0)+8|0)+4>>2],T2[(b=f+28|0)>>2]=T2[u>>2],T2[b+4>>2]=a,u=T2[n+4>>2],T2[(b=f+20|0)>>2]=T2[n>>2],T2[b+4>>2]=u,u=T2[(n=o-112|0)+4>>2],T2[(b=f+36|0)>>2]=T2[n>>2],T2[b+4>>2]=u,u=T2[(n=n+8|0)+4>>2],T2[(b=f+44|0)>>2]=T2[n>>2],T2[b+4>>2]=u,u=T2[(b=(o=o-96|0)+8|0)+4>>2],T2[(n=f+60|0)>>2]=T2[b>>2],T2[n+4>>2]=u,n=T2[o+4>>2],T2[(f=f+52|0)>>2]=T2[o>>2],T2[f+4>>2]=n),b=T2[A+16>>2],T2[T2[96+(b+r|0)>>2]+212>>2]=-1,n=T2[A+8>>2]),r=r+244|0,(0|(Q=Q+1|0))<(0|n););return -1<T2[A+28>>2]||-1<T2[A+32>>2]||((f=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+32>>2]=0,T2[A+36>>2]=0,p2[A+40|0]=1),T2[A+28>>2]=0,-1<T2[A+48>>2]||-1<T2[A+52>>2]||((f=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+52>>2]=0,T2[A+56>>2]=0,p2[A+60|0]=1),T2[A+48>>2]=0,-1<T2[A+68>>2]||-1<T2[A+72>>2]||((f=T2[A+76>>2])&&S2[A+80|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+72>>2]=0,T2[A+76>>2]=0,p2[A+80|0]=1),T2[A+68>>2]=0,-1<T2[A+88>>2]||-1<T2[A+92>>2]||((f=T2[A+96>>2])&&S2[A+100|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+92>>2]=0,T2[A+96>>2]=0,p2[A+100|0]=1),T2[A+88>>2]=0,-1<T2[A+8>>2]||-1<T2[A+12>>2]||((f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+12>>2]=0,T2[A+16>>2]=0,p2[A+20|0]=1),T2[A+8>>2]=0,L2=80+g|0,z2(z2(0));},function(A,f,r,e,i,a,n,o,b,t){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,n|=0,o|=0,b|=0,t|=0;var c,u,k,l=z2(0),s=z2(0),v=0,d=0,B=z2(0),Q=0,g=0;if(1&p2[b+72|0]){if(c=T2[A+68>>2],u=T2[A+28>>2],1<=(0|(d=T2[A+48>>2]))){if(i=P2(T2[A+232>>2],1664525)+1013904223|0,1!=(0|d)&&(e=T2[A+136>>2],r=T2[e+4>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,a^=a>>>4,T2[e+4>>2]=T2[(a=e+((1&((a^=a>>>2)>>>1^a))<<2)|0)>>2],T2[a>>2]=r,2!=(0|d)&&(r=T2[e+8>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,T2[e+8>>2]=T2[(a=e+((((a^=a>>>4)>>>2^a)>>>0)%3<<2)|0)>>2],T2[a>>2]=r,3!=(0|d)&&(r=T2[e+12>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,T2[e+12>>2]=T2[(a=e+((3&((a^=a>>>4)>>>2^a))<<2)|0)>>2],T2[a>>2]=r,4!=(0|d)))))for(t=e+16|0,r=4;r=(a=r)+1|0,Q=T2[t>>2],k=t,v=i=P2(i,1664525)+1013904223|0,65535<a>>>0||(v=g=i>>>16^i,255<a>>>0||(v=g^=g>>>8,15<a>>>0||(v=g^g>>>4))),T2[k>>2]=T2[(a=((v>>>0)%(r>>>0)<<2)+e|0)>>2],T2[a>>2]=Q,t=t+4|0,(0|r)!=(0|d););T2[A+232>>2]=i;}if(!(T2[b+20>>2]<=(0|f))){if(1<=(0|u)){if(i=P2(T2[A+232>>2],1664525)+1013904223|0,1!=(0|u)&&(e=T2[A+116>>2],r=T2[e+4>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,a^=a>>>4,T2[e+4>>2]=T2[(a=e+((1&((a^=a>>>2)>>>1^a))<<2)|0)>>2],T2[a>>2]=r,2!=(0|u)&&(r=T2[e+8>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,T2[e+8>>2]=T2[(a=e+((((a^=a>>>4)>>>2^a)>>>0)%3<<2)|0)>>2],T2[a>>2]=r,3!=(0|u)&&(r=T2[e+12>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,T2[e+12>>2]=T2[(a=e+((3&((a^=a>>>4)>>>2^a))<<2)|0)>>2],T2[a>>2]=r,4!=(0|u)))))for(t=e+16|0,r=4;r=(a=r)+1|0,g=T2[t>>2],d=t,v=i=P2(i,1664525)+1013904223|0,65535<a>>>0||(v=Q=i>>>16^i,255<a>>>0||(v=Q^=Q>>>8,15<a>>>0||(v=Q^Q>>>4))),T2[d>>2]=T2[(a=((v>>>0)%(r>>>0)<<2)+e|0)>>2],T2[a>>2]=g,t=t+4|0,(0|r)!=(0|u););T2[A+232>>2]=i;}if(!((0|c)<1)){if(i=P2(T2[A+232>>2],1664525)+1013904223|0,1!=(0|c)&&(e=T2[A+156>>2],r=T2[e+4>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,a^=a>>>4,T2[e+4>>2]=T2[(a=e+((1&((a^=a>>>2)>>>1^a))<<2)|0)>>2],T2[a>>2]=r,2!=(0|c)&&(r=T2[e+8>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,T2[e+8>>2]=T2[(a=e+((((a^=a>>>4)>>>2^a)>>>0)%3<<2)|0)>>2],T2[a>>2]=r,3!=(0|c)&&(r=T2[e+12>>2],a=(i=P2(i,1664525)+1013904223|0)^i>>>16,a^=a>>>8,T2[e+12>>2]=T2[(a=e+((3&((a^=a>>>4)>>>2^a))<<2)|0)>>2],T2[a>>2]=r,4!=(0|c)))))for(t=e+16|0,r=4;r=(a=r)+1|0,Q=T2[t>>2],g=t,v=i=P2(i,1664525)+1013904223|0,65535<a>>>0||(v=d=i>>>16^i,255<a>>>0||(v=d^=d>>>8,15<a>>>0||(v=d^d>>>4))),T2[g>>2]=T2[(a=((v>>>0)%(r>>>0)<<2)+e|0)>>2],T2[a>>2]=Q,t=t+4|0,(0|r)!=(0|c););T2[A+232>>2]=i;}}}if(1<=(0|(a=T2[A+48>>2])))for(r=i=0;e=T2[A+56>>2]+P2(T2[T2[A+136>>2]+i>>2],152)|0,T2[e+136>>2]>(0|f)&&(s=l,a=T2[A+16>>2],l=z2(n1[T2[A+212>>2]](a+P2(T2[e+144>>2],244)|0,a+P2(T2[e+148>>2],244)|0,e)),l=z2(s+z2(l*l)),a=T2[A+48>>2]),i=i+4|0,(0|(r=r+1|0))<(0|a););if(!(T2[b+20>>2]<=(0|f))){if(1<=(0|o))for(;f=T2[n>>2],S2[f+20|0]&&(f=Y4(A,T2[f+28>>2],j2[b+12>>2]),r=Y4(A,T2[T2[n>>2]+32>>2],j2[b+12>>2]),e=T2[n>>2],i=P2(f,244),f=T2[A+16>>2],n1[T2[T2[e>>2]+24>>2]](e,i+f|0,f+P2(r,244)|0,j2[b+12>>2])),n=n+4|0,o=o-1|0;);if(i=T2[A+28>>2],512&(f=T2[b+72>>2])){if(!((0|i)<1))for(e=(16&f?2:1)<<2,n=0,r=4;s=l,a=T2[A+16>>2],f=T2[A+36>>2]+P2(T2[T2[A+116>>2]+n>>2],152)|0,l=z2(n1[T2[A+216>>2]](a+P2(T2[f+144>>2],244)|0,a+P2(T2[f+148>>2],244)|0,f)),l=z2(s+z2(l*l)),(a=!((s=j2[f+100>>2])>z2(0)))||(f=T2[A+76>>2]+P2(T2[(T2[A+156>>2]+r|0)-4>>2],152)|0,B=j2[f+104>>2],j2[f+124>>2]=s*B,j2[f+120>>2]=s*z2(-B),B=l,o=T2[A+16>>2],l=z2(n1[T2[A+212>>2]](o+P2(T2[f+144>>2],244)|0,o+P2(T2[f+148>>2],244)|0,f)),l=z2(B+z2(l*l))),16&S2[b+72|0]&&(a||(f=T2[A+76>>2]+P2(T2[T2[A+156>>2]+r>>2],152)|0,B=j2[f+104>>2],j2[f+124>>2]=s*B,j2[f+120>>2]=s*z2(-B),s=l,a=T2[A+16>>2],l=z2(n1[T2[A+212>>2]](a+P2(T2[f+144>>2],244)|0,a+P2(T2[f+148>>2],244)|0,f)),l=z2(s+z2(l*l)))),n=n+4|0,r=r+e|0,i=i-1|0;);}else {if(1<=(0|i))for(t=0;s=l,r=T2[A+16>>2],f=T2[A+36>>2]+P2(T2[T2[A+116>>2]+t>>2],152)|0,l=z2(n1[T2[A+216>>2]](r+P2(T2[f+144>>2],244)|0,r+P2(T2[f+148>>2],244)|0,f)),l=z2(s+z2(l*l)),t=t+4|0,i=i-1|0;);if(!((0|(n=T2[A+68>>2]))<1))for(t=0;f=T2[A+76>>2]+P2(T2[T2[A+156>>2]+t>>2],152)|0,(s=j2[100+(T2[A+36>>2]+P2(T2[f+140>>2],152)|0)>>2])>z2(0)&&(B=j2[f+104>>2],j2[f+124>>2]=s*B,j2[f+120>>2]=s*z2(-B),s=l,r=T2[A+16>>2],l=z2(n1[T2[A+212>>2]](r+P2(T2[f+144>>2],244)|0,r+P2(T2[f+148>>2],244)|0,f)),l=z2(s+z2(l*l))),t=t+4|0,n=n-1|0;);}if(!((0|(n=T2[A+88>>2]))<1))for(t=148;f=T2[A+96>>2]+t|0,(s=j2[100+(T2[A+36>>2]+P2(T2[f-8>>2],152)|0)>>2])>z2(0)&&(B=s,s=j2[f-44>>2],B=z2(B*s),j2[f-24>>2]=s=s<B?s:B,j2[f-28>>2]=-s,s=l,r=T2[A+16>>2],l=z2(n1[T2[A+212>>2]](r+P2(T2[f-4>>2],244)|0,r+P2(T2[f>>2],244)|0,f-148|0)),l=z2(s+z2(l*l))),t=t+152|0,n=n-1|0;);}return z2(l);},function(A,f,r,e,i,a,n,o,b){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,n|=0,o|=0,b|=0;var t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R=0,F=z2(0),W=0,m=z2(0),N=z2(0),V=0,J=z2(0),M=z2(0),I=z2(0),x=0,y=z2(0),U=z2(0),X=0,p=z2(0),T=z2(0),S=0,j=0,P=z2(0),z=z2(0),O=z2(0),H=z2(0),_=z2(0),L=z2(0),K=z2(0),q=z2(0),$=z2(0),A2=z2(0),f2=z2(0),r2=z2(0),e2=z2(0),i2=0,a2=z2(0),n2=z2(0),o2=z2(0),b2=z2(0),t2=z2(0),c2=z2(0),u2=z2(0),k2=z2(0),l2=0,s2=0,v2=0;if(L2=X=L2-256|0,T2[A+188>>2]=-1,(0|(b=T2[o+72>>2]))!=T2[A+224>>2]&&(T2[A+224>>2]=b,T2[A+220>>2]=26,T2[A+216>>2]=27,T2[A+212>>2]=28),1<=((T2[A+184>>2]=0)|r))for(b=f,W=r;T2[T2[b>>2]+212>>2]=-1,b=b+4|0,W=W-1|0;);if((0|(b=T2[A+12>>2]))<=(0|r)){if((b=r+1|0)&&(T2[5498]=T2[5498]+1,(W=K2(P2(b,244)+19|0))&&(T2[(v2=W+19&-16)-4>>2]=W)),1<=(0|(V=T2[A+8>>2])))for(S=64;l2=T2[A+16>>2]+S|0,W=T2[(j=l2+-64|0)+4>>2],T2[(R=(i2=S+v2|0)+-64|0)>>2]=T2[j>>2],T2[R+4>>2]=W,W=T2[(x=j+8|0)+4>>2],T2[(R=R+8|0)>>2]=T2[x>>2],T2[R+4>>2]=W,W=T2[(x=(j=l2-48|0)+8|0)+4>>2],T2[(R=(s2=i2-48|0)+8|0)>>2]=T2[x>>2],T2[R+4>>2]=W,W=T2[j+4>>2],T2[s2>>2]=T2[j>>2],T2[s2+4>>2]=W,W=T2[(x=(j=l2-32|0)+8|0)+4>>2],T2[(R=(s2=i2-32|0)+8|0)>>2]=T2[x>>2],T2[R+4>>2]=W,W=T2[j+4>>2],T2[s2>>2]=T2[j>>2],T2[s2+4>>2]=W,W=T2[(j=l2-16|0)+4>>2],T2[(R=i2-16|0)>>2]=T2[j>>2],T2[R+4>>2]=W,W=T2[(x=j+8|0)+4>>2],T2[(R=R+8|0)>>2]=T2[x>>2],T2[R+4>>2]=W,$2(i2,l2,180),S=S+244|0,V=V-1|0;);(W=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[W-4>>2])),T2[A+16>>2]=v2,T2[A+12>>2]=b,p2[A+20|0]=1;}if(d2(8+X|0,0,244),(0|(W=T2[A+8>>2]))<=-1)for((0|b)<=-1&&((b=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2])),T2[A+12>>2]=0,T2[A+16>>2]=0,p2[A+20|0]=1),S=P2(W,244),s2=72+X|0,l2=56+X|0,x=40+X|0,V=24+X|0;b=T2[12+X>>2],i2=T2[A+16>>2]+S|0,T2[i2>>2]=T2[8+X>>2],T2[i2+4>>2]=b,b=T2[(R=16+X|0)+4>>2],T2[(j=i2+8|0)>>2]=T2[R>>2],T2[j+4>>2]=b,b=T2[V+4>>2],T2[(R=i2+16|0)>>2]=T2[V>>2],T2[R+4>>2]=b,b=T2[(R=V+8|0)+4>>2],T2[(j=i2+24|0)>>2]=T2[R>>2],T2[j+4>>2]=b,b=T2[x+4>>2],T2[(R=i2+32|0)>>2]=T2[x>>2],T2[R+4>>2]=b,b=T2[(R=x+8|0)+4>>2],T2[(j=i2+40|0)>>2]=T2[R>>2],T2[j+4>>2]=b,b=T2[l2+4>>2],T2[(R=i2+48|0)>>2]=T2[l2>>2],T2[R+4>>2]=b,b=T2[(R=l2+8|0)+4>>2],T2[(j=i2+56|0)>>2]=T2[R>>2],T2[j+4>>2]=b,$2(i2- -64|0,s2,180),S=S+244|0,(b=W)>>>0<=(W=b+1|0)>>>0;);if(1<=((T2[A+8>>2]=0)|r))for(;x=Y4(A,T2[f>>2],j2[o+12>>2]),(R=T2[f>>2])&&2&T2[R+252>>2]&&j2[R+404>>2]!=z2(0)&&(V=T2[A+16>>2],2&(S=T2[R+564>>2])&&(a2=j2[R+388>>2],t2=j2[R+4>>2],J=(F=j2[R+456>>2])!=z2(0)?z2(z2(1)/F):z2(0),n2=j2[R+20>>2],m=z2(J*n2),c2=j2[R+8>>2],I=(F=j2[R+460>>2])!=z2(0)?z2(z2(1)/F):z2(0),P=j2[R+24>>2],N=z2(I*P),f2=j2[R+12>>2],y=(F=j2[R+464>>2])!=z2(0)?z2(z2(1)/F):z2(0),U=j2[R+28>>2],F=z2(y*U),L=j2[R+392>>2],q=j2[R+36>>2],p=j2[R+40>>2],M=j2[R+44>>2],e2=j2[R+396>>2],z=z2(z2(z2(a2*z2(z2(z2(t2*m)+z2(c2*N))+z2(f2*F)))+z2(z2(z2(z2(n2*m)+z2(P*N))+z2(U*F))*L))+z2(z2(z2(z2(m*q)+z2(N*p))+z2(F*M))*e2)),m=z2(J*t2),N=z2(I*c2),F=z2(y*f2),N=z2(z2(z2(z2(z2(z2(t2*m)+z2(c2*N))+z2(f2*F))*a2)+z2(L*z2(z2(z2(m*n2)+z2(N*P))+z2(F*U))))+z2(z2(z2(z2(m*q)+z2(N*p))+z2(F*M))*e2)),K=z2(z2(a2*z)-z2(L*N)),J=z2(J*q),m=z2(I*p),F=z2(y*M),F=z2(z2(e2*z2(z2(z2(q*J)+z2(p*m))+z2(M*F)))+z2(z2(a2*z2(z2(z2(t2*J)+z2(c2*m))+z2(f2*F)))+z2(L*z2(z2(z2(n2*J)+z2(P*m))+z2(U*F))))),M=z2(z2(L*F)-z2(e2*z)),I=z2(z2(e2*N)-z2(a2*F)),F=z2(z2(K*K)+z2(z2(M*M)+z2(I*I))),T=j2[o+84>>2],F>z2(T*T)&&(F=z2(z2(z2(1)/z2(_2(F)))*T),K=z2(K*F),M=z2(M*F),I=z2(I*F)),z=j2[R+364>>2],T=j2[R+332>>2],J=j2[R+348>>2],m=j2[R+360>>2],N=j2[R+328>>2],F=j2[R+344>>2],W=V+P2(x,244)|0,y=j2[o+12>>2],j2[W+224>>2]=j2[W+224>>2]-z2(z2(z2(z2(M*j2[R+324>>2])+z2(I*j2[R+340>>2]))+z2(K*j2[R+356>>2]))*y),j2[(b=W+228|0)>>2]=j2[b>>2]-z2(y*z2(z2(z2(M*N)+z2(I*F))+z2(K*m))),j2[(b=W+232|0)>>2]=j2[b>>2]-z2(y*z2(z2(z2(M*T)+z2(I*J))+z2(K*z))),S=T2[R+564>>2]),4&S&&(u2=j2[R+36>>2],I=(F=j2[R+456>>2])!=z2(0)?z2(z2(1)/F):z2(0),m=z2(u2*I),r2=j2[R+40>>2],y=(F=j2[R+460>>2])!=z2(0)?z2(z2(1)/F):z2(0),N=z2(r2*y),K=j2[R+44>>2],M=(F=j2[R+464>>2])!=z2(0)?z2(z2(1)/F):z2(0),F=z2(K*M),k2=j2[o+12>>2],a2=z2(k2*z2(0)),O=j2[R+396>>2],o2=z2(z2(z2(u2*m)+z2(r2*N))+z2(K*F)),H=j2[R+388>>2],L=j2[R+4>>2],P=j2[R+8>>2],f2=j2[R+12>>2],e2=z2(z2(z2(L*m)+z2(P*N))+z2(f2*F)),z=z2(H*e2),_=j2[R+392>>2],U=j2[R+20>>2],q=j2[R+24>>2],p=j2[R+28>>2],t2=z2(z2(z2(U*m)+z2(q*N))+z2(p*F)),T=z2(_*t2),$=z2(z2(O*o2)+z2(z+T)),m=z2(I*U),N=z2(y*q),F=z2(M*p),n2=z2(z2(z2(L*m)+z2(P*N))+z2(f2*F)),J=z2(H*n2),b2=z2(z2(z2(U*m)+z2(q*N))+z2(p*F)),c2=z2(z2(z2(m*u2)+z2(N*r2))+z2(F*K)),m=z2(O*c2),A2=z2(z2(J+z2(_*b2))+m),I=z2(I*L),y=z2(y*P),F=z2(M*f2),L=z2(z2(z2(L*I)+z2(P*y))+z2(f2*F)),p=z2(z2(z2(I*U)+z2(y*q))+z2(F*p)),N=z2(_*p),M=z2(z2(z2(I*u2)+z2(y*r2))+z2(F*K)),F=z2(O*M),r2=z2(z2(z2(H*L)+N)+F),K=z2(z2($+z2(z2(z2(H*A2)-z2(_*r2))*k2))-z2(a2+$)),I=z2(e2+z2(z2(A2+z2(z2(J-z2(_*L))+z2(e2*z2(0))))*k2)),P=z2(c2+z2(z2(r2+z2(z2(F+z2(c2*z2(0)))-z2(H*o2)))*k2)),f2=z2(p+z2(z2(z2(z2(z2(p*z2(0))-z2(O*b2))+T)+$)*k2)),U=z2(b2+z2(z2(z2(z2(O*p)+z2(b2*z2(0)))-z2(H*t2))*k2)),q=z2(M+z2(z2(z2(z2(z2(M*z2(0))-m)+z2(_*o2))-A2)*k2)),m=z2(z2(P*f2)-z2(U*q)),y=z2(L+z2(z2(z2(z2(L*z2(0))-z2(O*n2))+z2(_*e2))*k2)),p=z2(o2+z2(z2(z2(z2(H*c2)-z2(_*M))+z2(o2*z2(0)))*k2)),M=z2(t2+z2(z2(z2(z2(z2(H*b2)-N)+z2(t2*z2(0)))-r2)*k2)),N=z2(z2(U*p)-z2(M*P)),T=z2(n2+z2(z2(z2(z2(z2(O*L)+z2(n2*z2(0)))-z)-$)*k2)),F=z2(z2(M*q)-z2(p*f2)),J=z2(z2(I*m)+z2(z2(y*N)+z2(T*F))),J=z2(O2(J))>z2(1.1920928955078125e-7)?z2(z2(1)/J):J,W=V+P2(x,244)|0,z=z2(K*m),m=z2(z2(r2+z2(z2(z2(_*$)-z2(O*A2))*k2))-z2(a2+r2)),L=z2(N*m),N=z2(z2(A2+z2(z2(z2(O*r2)-z2(H*$))*k2))-z2(a2+A2)),j2[W+224>>2]=z2(z2(H-z2(z2(z+z2(L+z2(N*F)))*J))-H)+j2[W+224>>2],j2[(b=W+228|0)>>2]=z2(z2(_-z2(z2(z2(I*z2(z2(P*m)-z2(q*N)))+z2(z2(y*z2(z2(p*N)-z2(P*K)))+z2(T*z2(z2(q*K)-z2(p*m)))))*J))-_)+j2[b>>2],j2[(b=W+232|0)>>2]=z2(z2(O-z2(z2(z2(I*z2(z2(f2*N)-z2(U*m)))+z2(z2(y*z2(z2(U*K)-z2(M*N)))+z2(T*z2(z2(M*m)-z2(f2*K)))))*J))-O)+j2[b>>2],S=T2[R+564>>2]),8&S&&(z=j2[R+456>>2],T=j2[R+464>>2],J=j2[R+460>>2],r2=j2[R+396>>2],K=j2[R+392>>2],a2=j2[R+388>>2],O=j2[o+12>>2],C4(R+4|0,8+X|0),H=j2[16+X>>2],_=j2[20+X>>2],$=j2[12+X>>2],M=z2(z2(K*H)+z2(z2(a2*_)-z2(r2*$))),A2=j2[8+X>>2],m=z2(z2(z2(a2*A2)+z2(K*$))+z2(r2*H)),N=z2(z2(a2*$)+z2(z2(r2*_)-z2(K*A2))),F=z2(z2(r2*A2)+z2(z2(K*_)-z2(a2*H))),o2=z2(z2(z2($*M)+z2(z2(H*m)+z2(_*N)))-z2(A2*F)),I=z2(o2*z2(0)),b2=z2(z2(z2(H*F)+z2(z2(A2*m)+z2(_*M)))-z2($*N)),y=z2(b2*z2(0)),e2=J!=z2(0)?z2(z2(1)/J):z2(0),u2=z2(z2(z2(A2*N)+z2(z2($*m)+z2(_*F)))-z2(H*M)),t2=z2(I+z2(y+z2(e2*u2))),n2=z!=z2(0)?z2(z2(1)/z):z2(0),f2=z2(z2(O*z2(z2(z2(y-z2(n2*u2))+z2(0))+t2))+z2(0)),J=T!=z2(0)?z2(z2(1)/T):z2(0),F=z2(u2*z2(0)),P=z2(z2(o2*J)+z2(y+F)),U=z2(I+z2(z2(n2*b2)+F)),L=z2(O*z2(z2(o2*U)-z2(b2*P))),m=z2(o2*z2(-0)),q=z2(n2+z2(O*z2(F+z2(z2(n2*z2(0))+m)))),N=z2(u2*z2(-0)),c2=z2(z2(O*z2(z2(z2(N+z2(e2*b2))+z2(0))-U))+z2(0)),p=z2(z2(O*z2(z2(F+z2(z2(0)-z2(e2*o2)))+P))+z2(0)),M=z2(z2(O*z2(z2(z2(I+z2(0))-z2(J*b2))+U))+z2(0)),F=z2(b2*z2(-0)),z=z2(e2+z2(O*z2(F+z2(z2(e2*z2(0))+I)))),I=z2(z2(O*z2(z2(z2(J*u2)+z2(m+z2(0)))-t2))+z2(0)),m=z2(z2(p*M)-z2(z*I)),y=z2(J+z2(O*z2(z2(J*z2(0))+z2(N+y)))),N=z2(z2(z*y)-z2(c2*M)),T=z2(z2(O*z2(z2(F+z2(z2(n2*o2)+z2(0)))-P))+z2(0)),F=z2(z2(c2*I)-z2(y*p)),J=z2(z2(f2*m)+z2(z2(q*N)+z2(T*F))),J=z2(O2(J))>z2(1.1920928955078125e-7)?z2(z2(1)/J):J,W=V+P2(x,244)|0,P=z2(O*z2(z2(u2*P)-z2(o2*t2))),U=z2(O*z2(z2(b2*t2)-z2(u2*U))),z=z2(o2-z2(z2(z2(f2*z2(z2(p*L)-z2(z*P)))+z2(z2(q*z2(z2(z*U)-z2(c2*L)))+z2(T*z2(z2(c2*P)-z2(p*U)))))*J)),T=z2(u2-z2(z2(z2(f2*z2(z2(M*P)-z2(I*L)))+z2(z2(q*z2(z2(y*L)-z2(M*U)))+z2(T*z2(z2(I*U)-z2(y*P)))))*J)),F=z2(b2-z2(z2(z2(U*m)+z2(z2(P*N)+z2(L*F)))*J)),J=z2(z2(z2(_*z)+z2(A2*T))-z2($*F)),m=z2(z2(z2(_*F)+z2($*z))-z2(H*T)),N=z2(z2(z2(F*z2(-A2))-z2($*T))-z2(H*z)),F=z2(z2(z2(H*F)+z2(_*T))-z2(A2*z)),j2[W+224>>2]=z2(z2(z2($*J)+z2(z2(z2(_*m)-z2(A2*N))-z2(H*F)))-a2)+j2[W+224>>2],j2[(b=W+228|0)>>2]=z2(z2(z2(H*m)+z2(z2(z2(_*F)-z2($*N))-z2(A2*J)))-K)+j2[b>>2],j2[(b=W+232|0)>>2]=z2(z2(z2(A2*F)+z2(z2(z2(_*J)-z2(H*N))-z2($*m)))-r2)+j2[b>>2])),f=f+4|0,r=r-1|0;);if(1<=(0|n))for(b=a,W=n;f=T2[b>>2],n1[T2[T2[f>>2]+8>>2]](f),b=b+4|(T2[f+36>>2]=0),W=W-1|0;);if(!((0|n)<=(0|(f=T2[A+168>>2]))||T2[A+172>>2]>=(0|n))){if(W=0,n&&(T2[5498]=T2[5498]+1,(r=K2(19+(n<<3)|0))&&(T2[(W=r+19&-16)-4>>2]=r)),1<=(0|f))for(b=0;V=T2[A+176>>2]+b|0,r=T2[V+4>>2],T2[(x=b+W|0)>>2]=T2[V>>2],T2[x+4>>2]=r,b=b+8|0,f=f-1|0;);(f=T2[A+176>>2])&&S2[A+180|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+176>>2]=W,T2[A+172>>2]=n,p2[A+180|0]=1;}if((0|(T2[A+168>>2]=n))<1)S=0;else for(W=a,V=n,S=r=0;b=T2[A+176>>2],f=T2[W>>2],(x=T2[f+44>>2])&&(T2[x>>2]=0,T2[x+4>>2]=0,T2[(f=x+56|0)>>2]=0,T2[f+4>>2]=0,T2[(f=x+48|0)>>2]=0,T2[f+4>>2]=0,T2[(f=x+40|0)>>2]=0,T2[f+4>>2]=0,T2[(f=x+32|0)>>2]=0,T2[f+4>>2]=0,T2[(f=x+24|0)>>2]=0,T2[f+4>>2]=0,T2[(f=x+16|0)>>2]=0,T2[f+4>>2]=0,T2[(f=x+8|0)>>2]=0,T2[f+4>>2]=0,f=T2[W>>2]),b=r+b|0,W=W+4|0,r=r+8|0,S=(f=S2[f+20|0]?(n1[T2[T2[f>>2]+16>>2]](f,b),T2[b>>2]):(T2[b>>2]=0,T2[b+4>>2]=0))+S|0,V=V-1|0;);if(!((0|S)<=(0|(f=T2[A+48>>2]))||T2[A+52>>2]>=(0|S))){if(W=0,S&&(T2[5498]=T2[5498]+1,(r=K2(P2(S,152)+19|0))&&(T2[(W=r+19&-16)-4>>2]=r)),1<=(0|f))for(b=0;$2(b+W|0,T2[A+56>>2]+b|0,152),b=b+152|0,f=f-1|0;);(f=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+56>>2]=W,T2[A+52>>2]=S,p2[A+60|0]=1;}if(T2[A+48>>2]=S,1<=(0|n))for(f=T2[A+176>>2],W=v2=0;;){if(C=W,T2[(g=(G=v2<<3)+f|0)>>2]){if(Q=T2[(w=(v2<<2)+a|0)>>2],t=T2[Q+32>>2],r=T2[A+56>>2],S=Y4(A,c=T2[Q+28>>2],j2[o+12>>2]),x=Y4(A,t,j2[o+12>>2]),f=T2[Q+24>>2],b=T2[o+20>>2],(0|(V=0<(0|f)?f:b))>T2[A+184>>2]&&(T2[A+184>>2]=V),R=r+P2(W,152)|0,W=T2[A+16>>2],1<=T2[g>>2]){for(b=R+148|0,r=0;d2(b-148|0,0,152),T2[(f=b-28|0)>>2]=-8388609,T2[f+4>>2]=2139095039,T2[b>>2]=x,T2[b-4>>2]=S,T2[(f=b-52|0)>>2]=0,T2[f+4>>2]=0,T2[b-12>>2]=V,b=b+152|0,(0|(r=r+1|0))<T2[g>>2];);b=T2[o+20>>2];}if(u=W+P2(S,244)|0,T2[(f=u)+144>>2]=0,T2[f+148>>2]=0,T2[(f=f+152|0)>>2]=0,T2[f+4>>2]=0,T2[(f=160+u|0)>>2]=0,T2[f+4>>2]=0,T2[(f=168+u|0)>>2]=0,T2[f+4>>2]=0,T2[64+u>>2]=0,T2[68+u>>2]=0,T2[(f=88+u|0)>>2]=0,T2[f+4>>2]=0,T2[(f=80+u|0)>>2]=0,T2[f+4>>2]=0,T2[(f=72+u|0)>>2]=0,T2[f+4>>2]=0,r=W+P2(x,244)|0,T2[(f=r)+144>>2]=0,T2[f+148>>2]=0,T2[(f=f+152|0)>>2]=0,T2[f+4>>2]=0,T2[(f=r+160|0)>>2]=0,T2[f+4>>2]=0,T2[(f=r+168|0)>>2]=0,T2[f+4>>2]=0,T2[r+64>>2]=0,T2[r+68>>2]=0,T2[(f=r+72|0)>>2]=0,T2[f+4>>2]=0,T2[(f=r+80|0)>>2]=0,T2[f+4>>2]=0,T2[(f=r+88|0)>>2]=0,T2[f+4>>2]=0,j2[R+116>>2]=j2[o+40>>2],T2[36+X>>2]=R+112,T2[32+X>>2]=38,T2[28+X>>2]=R+32,T2[52+X>>2]=b,T2[48+X>>2]=R+124,T2[44+X>>2]=R+120,T2[40+X>>2]=R+116,j2[56+X>>2]=j2[o+4>>2],T2[24+X>>2]=R+48,T2[20+X>>2]=R,T2[16+X>>2]=R+16,j2[12+X>>2]=j2[o+32>>2],j2[8+X>>2]=z2(1)/j2[o+12>>2],f=T2[w>>2],n1[T2[T2[f>>2]+20>>2]](f,8+X|0),1<=T2[g>>2])for(b=R+68|0,E=r+232|0,D=r+228|0,h=r+224|0,Z=r+216|0,Y=r+212|0,i2=r+208|0,l2=r+240|0,s2=232+u|0,j=228+u|0,R=224+u|0,S=216+u|0,x=212+u|0,V=208+u|0,W=240+u|0,r=0;(F=j2[T2[w>>2]+16>>2])<=j2[(f=b+56|0)>>2]&&(j2[f>>2]=F),(F=z2(-F))>=j2[(f=b+52|0)>>2]&&(j2[f>>2]=F),T2[b- -64>>2]=Q,f=T2[Q+28>>2],U=j2[f+328>>2],q=j2[f+332>>2],p=j2[f+608>>2],M=j2[f+348>>2],I=j2[f+340>>2],y=j2[f+344>>2],z=j2[f+612>>2],T=j2[f+364>>2],J=j2[f+356>>2],m=j2[f+360>>2],N=j2[f+604>>2],F=j2[f+324>>2],T2[b+8>>2]=0,k=j2[b-68>>2],l=j2[b+-64>>2],s=j2[b-60>>2],j2[b+4>>2]=z*z2(z2(z2(J*k)+z2(m*l))+z2(T*s)),j2[b>>2]=p*z2(z2(z2(k*I)+z2(l*y))+z2(s*M)),j2[b-4>>2]=N*z2(z2(z2(F*k)+z2(U*l))+z2(q*s)),f=T2[Q+32>>2],U=j2[f+328>>2],q=j2[f+332>>2],p=j2[f+608>>2],M=j2[f+348>>2],I=j2[f+340>>2],y=j2[f+344>>2],z=j2[f+612>>2],T=j2[f+364>>2],J=j2[f+356>>2],m=j2[f+360>>2],N=j2[f+604>>2],F=j2[f+324>>2],T2[b+24>>2]=0,v=j2[b-36>>2],d=j2[b-32>>2],B=j2[b-28>>2],j2[b+20>>2]=z*z2(z2(z2(J*v)+z2(m*d))+z2(T*B)),j2[b+16>>2]=p*z2(z2(z2(v*I)+z2(d*y))+z2(B*M)),j2[b+12>>2]=N*z2(z2(z2(F*v)+z2(U*d))+z2(q*B)),k2=z2(0),O=j2[b-52>>2],F=j2[c+404>>2],H=j2[b-48>>2],_=j2[b-44>>2],m=z2(z2(z2(z2(O*z2(O*F))+z2(H*z2(F*H)))+z2(_*z2(F*_)))+z2(z2(z2(k*z2(z2(z2(k*j2[c+324>>2])+z2(l*j2[c+328>>2]))+z2(s*j2[c+332>>2])))+z2(l*z2(z2(z2(k*j2[c+340>>2])+z2(l*j2[c+344>>2]))+z2(s*j2[c+348>>2]))))+z2(s*z2(z2(z2(k*j2[c+356>>2])+z2(l*j2[c+360>>2]))+z2(s*j2[c+364>>2]))))),$=j2[b-20>>2],F=j2[t+404>>2],A2=j2[b-16>>2],o2=j2[b-12>>2],F=z2(z2(m+z2(z2(z2($*z2($*F))+z2(A2*z2(F*A2)))+z2(o2*z2(F*o2))))+z2(z2(z2(v*z2(z2(z2(v*j2[t+324>>2])+z2(d*j2[t+328>>2]))+z2(B*j2[t+332>>2])))+z2(d*z2(z2(z2(v*j2[t+340>>2])+z2(d*j2[t+344>>2]))+z2(B*j2[t+348>>2]))))+z2(B*z2(z2(z2(v*j2[t+356>>2])+z2(d*j2[t+360>>2]))+z2(B*j2[t+364>>2]))))),b2=z2(O2(F))>z2(1.1920928955078125e-7)?z2(z2(1)/F):z2(0),j2[b+40>>2]=b2,u2=z2(0),r2=z2(0),K=z2(0),a2=z2(0),L=z2(0),e2=z2(0),T2[W>>2]&&(L=j2[j>>2],a2=j2[R>>2],r2=j2[x>>2],K=j2[V>>2],u2=j2[S>>2],e2=j2[s2>>2]),t2=z2(0),n2=z2(0),c2=z2(0),P=z2(0),f2=z2(0),T2[l2>>2]&&(P=j2[D>>2],c2=j2[h>>2],t2=j2[Y>>2],n2=j2[i2>>2],k2=j2[Z>>2],f2=j2[E>>2]),U=j2[c+380>>2],q=j2[c+372>>2],p=j2[c+376>>2],M=j2[c+396>>2],I=j2[c+388>>2],y=j2[c+392>>2],z=j2[t+380>>2],T=j2[t+372>>2],J=j2[t+376>>2],m=j2[t+396>>2],N=j2[t+388>>2],F=j2[t+392>>2],T2[b+32>>2]=0,j2[(f=b+44|0)>>2]=z2(b2*j2[f>>2])+z2(b2*z2(z2(0)-z2(j2[56+X>>2]*z2(z2(z2(z2(z2(O*z2(K+q))+z2(H*z2(r2+p)))+z2(_*z2(u2+U)))+z2(z2(z2(k*z2(a2+I))+z2(l*z2(L+y)))+z2(s*z2(e2+M))))+z2(z2(z2(z2($*z2(n2+T))+z2(A2*z2(t2+J)))+z2(o2*z2(k2+z)))+z2(z2(z2(v*z2(c2+N))+z2(d*z2(P+F)))+z2(B*z2(f2+m)))))))),b=b+152|0,(0|(r=r+1|0))<T2[g>>2];);f=T2[A+176>>2],r=T2[G+f>>2];}else r=0;if(W=C+r|0,(0|(v2=v2+1|0))==(0|n))break;}if(n1[T2[T2[A>>2]+28>>2]](A,e,i,o),n=T2[A+68>>2],W=T2[A+28>>2],V=T2[A+128>>2],!((0|(a=T2[A+48>>2]))<=(0|V)||(0|a)<=T2[A+132>>2])){r=0,a&&(T2[5498]=T2[5498]+1,(f=K2(19+(a<<2)|0))&&(T2[(r=f+19&-16)-4>>2]=f)),e=T2[A+136>>2];A:{if(1<=(0|V))for(b=r,f=e;T2[b>>2]=T2[f>>2],b=b+4|0,f=f+4|0,V=V-1|0;);else if(!e)break A;S2[A+140|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]));}T2[A+136>>2]=r,T2[A+132>>2]=a,p2[A+140|0]=1;}if(T2[A+128>>2]=a,16&S2[o+72|0]){if(!((0|(i=W<<1))<=(0|(V=T2[A+108>>2]))||(0|i)<=T2[A+112>>2])){r=0,W&&(T2[5498]=T2[5498]+1,(f=K2(19+(W<<3)|0))&&(T2[(r=f+19&-16)-4>>2]=f)),e=T2[A+116>>2];A:{if(1<=(0|V))for(b=r,f=e;T2[b>>2]=T2[f>>2],b=b+4|0,f=f+4|0,V=V-1|0;);else if(!e)break A;S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]));}T2[A+116>>2]=r,T2[A+112>>2]=i,p2[A+120|0]=1;}T2[A+108>>2]=i;}else {if(!((0|W)<=(0|(V=T2[A+108>>2]))||(0|W)<=T2[A+112>>2])){r=0,W&&(T2[5498]=T2[5498]+1,(f=K2(19+(W<<2)|0))&&(T2[(r=f+19&-16)-4>>2]=f)),e=T2[A+116>>2];A:{if(1<=(0|V))for(b=r,f=e;T2[b>>2]=T2[f>>2],b=b+4|0,f=f+4|0,V=V-1|0;);else if(!e)break A;S2[A+120|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]));}T2[A+116>>2]=r,T2[A+112>>2]=W,p2[A+120|0]=1;}T2[A+108>>2]=W;}if(!((0|n)<=(0|(V=T2[A+148>>2]))||(0|n)<=T2[A+152>>2])){r=0,n&&(T2[5498]=T2[5498]+1,(f=K2(19+(n<<2)|0))&&(T2[(r=f+19&-16)-4>>2]=f)),e=T2[A+156>>2];A:{if(1<=(0|V))for(b=r,f=e;T2[b>>2]=T2[f>>2],b=b+4|0,f=f+4|0,V=V-1|0;);else if(!e)break A;S2[A+160|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]));}T2[A+156>>2]=r,T2[A+152>>2]=n,p2[A+160|0]=1;}if(T2[A+148>>2]=n,1<=(0|a))for(b=T2[A+136>>2],f=0;T2[b>>2]=f,b=b+4|0,(0|a)!=(0|(f=f+1|0)););if(1<=(0|W))for(b=T2[A+116>>2],f=0;T2[b>>2]=f,b=b+4|0,(0|W)!=(0|(f=f+1|0)););if(1<=(0|n))for(b=T2[A+156>>2],f=0;T2[b>>2]=f,b=b+4|0,(0|n)!=(0|(f=f+1|0)););return L2=256+X|0,z2(z2(0));},function(A,f,r,e,i,a,n,o,b){A|=0,f|=0,r|=0,e|=0,i|=0,a|=0,n|=0,o|=0,b|=0;var t,c,u,k=0,l=0;n1[T2[T2[A>>2]+32>>2]](A,f,r,e,i,a,n,o,b),k=T2[A+184>>2];A:if(!((0|(l=(0|(l=T2[o+20>>2]))<(0|k)?k:l))<1))for(u=l-1|0,k=1;;){if(c=z2(n1[T2[T2[A>>2]+40>>2]](A,t=k-1|0,f,r,e,i,a,n,o,b)),j2[A+228>>2]=c,(0|u)<=(0|t))break A;if(j2[o+92>>2]>=c)break A;if(t=(0|k)<(0|l),k=k+1|0,!t)break;}return z2(z2(0));},I,N4,M,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t=0;T2[(o=604+(L2=t=L2-688|0)|0)>>2]=1065353216,T2[4+o>>2]=0,n=T2[f+20>>2],T2[(o=656+t|0)>>2]=T2[f+16>>2],T2[4+o>>2]=n,n=T2[f+36>>2],T2[(o=672+t|0)>>2]=T2[f+32>>2],T2[4+o>>2]=n,i=T2[4+(n=f+8|0)>>2],T2[(o=648+t|0)>>2]=T2[n>>2],T2[4+o>>2]=i,i=T2[4+(n=f+24|0)>>2],T2[(o=664+t|0)>>2]=T2[n>>2],T2[4+o>>2]=i,i=T2[4+(n=f+40|0)>>2],T2[(o=680+t|0)>>2]=T2[n>>2],T2[4+o>>2]=i,T2[636+t>>2]=0,T2[596+t>>2]=1065353216,T2[600+t>>2]=1065353216,T2[588+t>>2]=0,T2[592+t>>2]=0,T2[580+t>>2]=1,T2[584+t>>2]=0,T2[576+t>>2]=13376,o=T2[f+4>>2],T2[640+t>>2]=T2[f>>2],T2[644+t>>2]=o,j2[628+t>>2]=j2[A+204>>2],p2[548+t|0]=0,T2[524+t>>2]=953267991,T2[208+t>>2]=14688,T2[204+t>>2]=0,T2[184+t>>2]=17352,T2[196+t>>2]=T2[A+4>>2],T2[200+t>>2]=576+t,T2[192+t>>2]=208+t,T2[188+t>>2]=216+t,T2[8+t>>2]=12640,T2[172+t>>2]=1065353216,T2[176+t>>2]=0,j2[180+t>>2]=j2[A+208>>2],N4(184+t|0,A+8|0,A+72|0,f=A+136|0,f,8+t|0)&&(a=j2[140+t>>2],n=j2[144+t>>2],i=j2[148+t>>2],(o=z2(z2(z2(a*a)+z2(n*n))+z2(i*i)))>z2(9999999747378752e-20)&&(b=j2[172+t>>2])<j2[A+200>>2]&&(f=i,i=z2(z2(1)/z2(_2(o))),j2[148+t>>2]=f*i,j2[144+t>>2]=n*i,j2[140+t>>2]=a*i,z2(n1[T2[T2[A>>2]+12>>2]](A,140+t|0,156+t|0,b,r,e)))),T2[576+t>>2]=7916,(A=T2[636+t>>2])&&(n1[T2[T2[A>>2]>>2]](A),(A=T2[636+t>>2])&&(T2[5499]=T2[5499]+1,q2(T2[A-4>>2]))),L2=688+t|0;},J4,function(A){var f,r,e=0,i=0,a=0;if(T2[(A|=0)>>2]=17524,1<=(0|(e=T2[A+8>>2])))for(;r=T2[T2[A+16>>2]+i>>2],(f=T2[r+188>>2])&&(e=T2[A+68>>2],e=0|n1[T2[T2[e>>2]+36>>2]](e),n1[T2[T2[e>>2]+40>>2]](e,f,T2[A+24>>2]),e=T2[A+68>>2],n1[T2[T2[e>>2]+12>>2]](e,f,T2[A+24>>2]),T2[r+188>>2]=0,e=T2[A+8>>2]),i=i+4|0,(0|(a=a+1|0))<(0|e););(e=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2])),u(A);},function(A){A|=0;var f=0,r=0,e=z2(0),i=z2(0),a=0,n=z2(0),o=z2(0),b=z2(0),t=z2(0),c=z2(0),u=0,k=0;if(L2=f=L2+-64|0,1<=(0|(a=T2[A+8>>2])))for(;;){r=T2[T2[A+16>>2]+u>>2];A:{f:if(!S2[A+76|0])switch(T2[r+220>>2]-2|0){case 0:case 3:break A;default:break f;}a=T2[r+192>>2],n1[T2[T2[a>>2]+8>>2]](a,r+4|0,48+f|0,32+f|0),i=z2(j2[48+f>>2]+z2(-.019999999552965164)),j2[48+f>>2]=i,n=z2(j2[52+f>>2]+z2(-.019999999552965164)),j2[52+f>>2]=n,o=z2(j2[56+f>>2]+z2(-.019999999552965164)),j2[56+f>>2]=o,e=z2(j2[32+f>>2]+z2(.019999999552965164)),j2[32+f>>2]=e,b=z2(j2[36+f>>2]+z2(.019999999552965164)),j2[36+f>>2]=b,t=z2(j2[40+f>>2]+z2(.019999999552965164)),j2[40+f>>2]=t,S2[A+44|0]&&2==T2[r+252>>2]&&(3&S2[r+204|0]||(a=T2[r+192>>2],n1[T2[T2[a>>2]+8>>2]](a,r+68|0,16+f|0,f),n=z2(j2[16+f>>2]+z2(-.019999999552965164)),j2[16+f>>2]=n,o=z2(j2[20+f>>2]+z2(-.019999999552965164)),j2[20+f>>2]=o,e=z2(j2[24+f>>2]+z2(-.019999999552965164)),j2[24+f>>2]=e,b=z2(j2[f>>2]+z2(.019999999552965164)),j2[f>>2]=b,t=z2(j2[4+f>>2]+z2(.019999999552965164)),j2[4+f>>2]=t,c=z2(j2[8+f>>2]+z2(.019999999552965164)),j2[8+f>>2]=c,n<(i=j2[48+f>>2])&&(i=j2[48+f>>2]=n),o<(n=j2[52+f>>2])&&(n=j2[52+f>>2]=o),e<(o=j2[56+f>>2])&&(o=j2[56+f>>2]=e),(e=j2[28+f>>2])<j2[60+f>>2]&&(j2[60+f>>2]=e),(e=j2[32+f>>2])<b&&(e=j2[32+f>>2]=b),(b=j2[36+f>>2])<t&&(b=j2[36+f>>2]=t),(t=j2[40+f>>2])<c&&(t=j2[40+f>>2]=c),(c=j2[12+f>>2])>j2[44+f>>2]&&(j2[44+f>>2]=c))),a=T2[A+68>>2],1&p2[r+204|0]||(i=z2(e-i),e=z2(i*i),i=z2(b-n),e=z2(e+z2(i*i)),i=z2(t-o),z2(e+z2(i*i))<z2(999999995904))?n1[T2[T2[a>>2]+16>>2]](a,T2[r+188>>2],48+f|0,32+f|0,T2[A+24>>2]):(4!=(-2&T2[r+220>>2])&&(T2[r+220>>2]=5),S2[23476]||(r=T2[A+72>>2])&&(p2[23476]=1,n1[T2[T2[r>>2]+44>>2]](r,18344),r=T2[A+72>>2],n1[T2[T2[r>>2]+44>>2]](r,18393),r=T2[A+72>>2],n1[T2[T2[r>>2]+44>>2]](r,18461),r=T2[A+72>>2],n1[T2[T2[r>>2]+44>>2]](r,18526))),a=T2[A+8>>2];}if(u=u+4|0,!((0|(k=k+1|0))<(0|a)))break;}L2=f+64|0;},function(A){var f=T2[(A|=0)+68>>2];n1[T2[T2[f>>2]+32>>2]](f,T2[A+24>>2]);},function(A,f){T2[(A|=0)+72>>2]=f|=0;},c4,M4,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b=0,t=0,c=0,u=0,k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=0,B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=z2(0),C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=z2(0),Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=0,N=z2(0),V=z2(0),J=z2(0),M=0,I=0,x=0,y=0;L2=b=L2-144|0,0|n1[T2[T2[A>>2]+20>>2]](A)&&(t=0|n1[T2[T2[A>>2]+20>>2]](A),32768&n1[T2[T2[t>>2]+56>>2]](t)&&(t=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[t>>2]+64>>2]](t,f,z2(.10000000149011612))));A:{f:{r:{e:{i:{a:{n:{o:{b:{t:switch(0|(t=T2[r+4>>2])){case 0:break b;case 31:break t;case 28:break r;case 13:break e;case 11:break i;case 10:break a;case 9:break n;case 8:break o;default:break f;}if((0|(t=T2[r+24>>2]))<1)break A;for(c=t+1|0,u=P2(t,80)-80|0;t=T2[r+32>>2]+u|0,d=T2[t- -64>>2],k=j2[t+56>>2],l=j2[t+48>>2],s=j2[t+52>>2],B=j2[t+32>>2],w=j2[t>>2],G=j2[t+16>>2],C=j2[t+36>>2],D=j2[t+4>>2],Z=j2[t+20>>2],v=j2[t+40>>2],Q=j2[t+8>>2],g=j2[t+24>>2],T2[60+b>>2]=0,T2[44+b>>2]=0,T2[28+b>>2]=0,T2[12+b>>2]=0,Y=j2[f+32>>2],E=j2[f+36>>2],h=j2[f+40>>2],j2[40+b>>2]=z2(z2(Q*Y)+z2(g*E))+z2(v*h),j2[36+b>>2]=z2(z2(D*Y)+z2(Z*E))+z2(C*h),j2[32+b>>2]=z2(z2(w*Y)+z2(G*E))+z2(B*h),R=j2[f+16>>2],F=j2[f+20>>2],W=j2[f+24>>2],j2[24+b>>2]=z2(z2(Q*R)+z2(g*F))+z2(v*W),j2[20+b>>2]=z2(z2(D*R)+z2(Z*F))+z2(C*W),j2[16+b>>2]=z2(z2(w*R)+z2(G*F))+z2(B*W),N=Q,Q=j2[f>>2],V=g,g=j2[f+4>>2],J=v,v=j2[f+8>>2],j2[8+b>>2]=z2(z2(N*Q)+z2(V*g))+z2(J*v),j2[4+b>>2]=z2(z2(D*Q)+z2(Z*g))+z2(C*v),j2[b>>2]=z2(z2(w*Q)+z2(G*g))+z2(B*v),j2[56+b>>2]=z2(z2(z2(l*Y)+z2(s*E))+z2(k*h))+j2[f+56>>2],j2[52+b>>2]=z2(z2(z2(l*R)+z2(s*F))+z2(k*W))+j2[f+52>>2],j2[48+b>>2]=z2(z2(z2(l*Q)+z2(s*g))+z2(k*v))+j2[f+48>>2],n1[T2[T2[A>>2]+28>>2]](A,b,d,e),u=u-80|0,1<(0|(c=c-1|0)););break A;}d=T2[(u=r+44|0)+4>>2],T2[(t=c=8+b|0)>>2]=T2[u>>2],T2[t+4>>2]=d,u=T2[(t=r+36|0)+4>>2],T2[b>>2]=T2[t>>2],T2[4+b>>2]=u,k=z2(n1[T2[T2[r>>2]+48>>2]](r)),l=z2(n1[T2[T2[r>>2]+48>>2]](r)),s=z2(z2(n1[T2[T2[r>>2]+48>>2]](r))+j2[c>>2]),j2[c>>2]=s,k=z2(k+j2[b>>2]),j2[b>>2]=k,l=z2(l+j2[4+b>>2]),j2[4+b>>2]=l,A=0|n1[T2[T2[A>>2]+20>>2]](A),T2[140+b>>2]=0,j2[136+b>>2]=-s,j2[132+b>>2]=-l,j2[128+b>>2]=-k,n1[T2[T2[A>>2]+80>>2]](A,128+b|0,b,f,e);break A;}k=z2(n1[T2[T2[r>>2]+48>>2]](r)),A=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[A>>2]+24>>2]](A,k,f,e);break A;}if((0|(t=T2[r+100>>2]))<1)break A;for(m=t+1|0,c=(t<<4)-8|0,u=(t<<2)-4|0;t=T2[r+108>>2]+c|0,k=j2[t>>2],l=j2[t-8>>2],s=j2[t-4>>2],t=0|n1[T2[T2[A>>2]+20>>2]](A),Y=j2[T2[r+128>>2]+u>>2],T2[60+b>>2]=0,T2[44+b>>2]=0,T2[28+b>>2]=0,T2[12+b>>2]=0,B=j2[f+40>>2],w=j2[f+32>>2],C=z2(w*z2(0)),G=j2[f+36>>2],D=z2(G*z2(0)),j2[40+b>>2]=B+z2(C+D),v=z2(C+G),C=z2(B*z2(0)),j2[36+b>>2]=v+C,j2[32+b>>2]=z2(w+D)+C,C=j2[f+24>>2],D=j2[f+16>>2],v=z2(D*z2(0)),Z=j2[f+20>>2],Q=z2(Z*z2(0)),j2[24+b>>2]=C+z2(v+Q),g=z2(v+Z),v=z2(C*z2(0)),j2[20+b>>2]=g+v,j2[16+b>>2]=z2(D+Q)+v,v=j2[f+8>>2],Q=j2[f>>2],E=z2(Q*z2(0)),g=j2[f+4>>2],h=z2(g*z2(0)),j2[8+b>>2]=v+z2(E+h),N=z2(E+g),E=z2(v*z2(0)),j2[4+b>>2]=N+E,j2[b>>2]=z2(Q+h)+E,j2[56+b>>2]=z2(z2(z2(l*w)+z2(s*G))+z2(k*B))+j2[f+56>>2],j2[52+b>>2]=z2(z2(z2(l*D)+z2(s*Z))+z2(k*C))+j2[f+52>>2],j2[48+b>>2]=z2(z2(z2(l*Q)+z2(s*g))+z2(k*v))+j2[f+48>>2],n1[T2[T2[t>>2]+24>>2]](t,Y,b,e),c=c-16|0,u=u-4|0,1<(0|(m=m-1|0)););break A;}c=T2[r+60>>2],k=j2[(c<<2)+(r=r+36|0)>>2],l=j2[r+((c+2|0)%3<<2)>>2],A=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[A>>2]+84>>2]](A,l,k,c,f,e);break A;}c=T2[r+76>>2],k=j2[r+68>>2],l=j2[r- -64>>2],A=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[A>>2]+92>>2]](A,l,k,c,f,e);break A;}c=T2[r+60>>2],k=z2(n1[T2[T2[r>>2]+92>>2]](r)),m=T2[(d=r+44|0)+4>>2],T2[(t=8+b|0)>>2]=T2[d>>2],T2[t+4>>2]=m,d=T2[(u=r+36|0)+4>>2],T2[b>>2]=T2[u>>2],T2[4+b>>2]=d,l=z2(n1[T2[T2[r>>2]+48>>2]](r)),s=z2(n1[T2[T2[r>>2]+48>>2]](r)),n=t,o=z2(z2(n1[T2[T2[r>>2]+48>>2]](r))+j2[t>>2]),j2[n>>2]=o,j2[b>>2]=l+j2[b>>2],j2[4+b>>2]=s+j2[4+b>>2],l=j2[(c<<2)+b>>2],A=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[A>>2]+88>>2]](A,k,l,c,f,e);break A;}k=j2[r+72>>2],A=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[A>>2]+96>>2]](A,r+56|0,k,f,e);break A;}if(!(6<(0|t)))if(d=T2[r+60>>2]){if(!(T2[d+28>>2]<1))for(;;){s=z2(0);f:if(c=(x=P2(I,36))+T2[d+36>>2]|0,M=T2[c+4>>2]){if(k=z2(0),l=z2(0),!((0|M)<1))for(u=T2[c+12>>2],c=T2[(u+(M<<2)|0)-4>>2],m=1,y=0;;){if(u=(i=(t=T2[u+y>>2])<<4)+T2[d+16>>2]|0,C=j2[u>>2],D=j2[u+4>>2],Z=j2[u+8>>2],u=0|n1[T2[T2[A>>2]+20>>2]](A),T2[12+b>>2]=0,a=T2[d+16>>2],B=j2[(c=a+(c<<4)|0)>>2],v=j2[f+32>>2],w=j2[c+4>>2],Q=j2[f+36>>2],G=j2[c+8>>2],g=j2[f+40>>2],Y=j2[f+56>>2],j2[8+b>>2]=z2(z2(z2(B*v)+z2(w*Q))+z2(G*g))+Y,E=j2[f+16>>2],h=j2[f+20>>2],R=j2[f+24>>2],F=j2[f+52>>2],j2[4+b>>2]=z2(z2(z2(B*E)+z2(w*h))+z2(G*R))+F,W=j2[f>>2],N=j2[f+4>>2],V=j2[f+8>>2],J=j2[f+48>>2],j2[b>>2]=z2(z2(z2(B*W)+z2(w*N))+z2(G*V))+J,T2[140+b>>2]=0,B=j2[(c=i+a|0)>>2],w=j2[c+4>>2],G=j2[c+8>>2],j2[136+b>>2]=Y+z2(z2(z2(v*B)+z2(Q*w))+z2(g*G)),j2[132+b>>2]=F+z2(z2(z2(E*B)+z2(h*w))+z2(R*G)),j2[128+b>>2]=J+z2(z2(z2(W*B)+z2(N*w))+z2(V*G)),n1[T2[T2[u>>2]+16>>2]](u,b,128+b|0,e),l=z2(l+Z),k=z2(k+D),s=z2(s+C),c=T2[d+36>>2]+x|0,T2[c+4>>2]<=(0|m))break f;y=y+4|0,m=m+1|0,u=T2[c+12>>2],c=t;}}else k=z2(0),l=z2(0);if(c=0|n1[T2[T2[A>>2]+20>>2]](A),16384&n1[T2[T2[c>>2]+56>>2]](c)&&(T2[8+b>>2]=0,T2[12+b>>2]=0,T2[b>>2]=1065353216,T2[4+b>>2]=1065353216,c=T2[d+36>>2]+x|0,w=j2[c+28>>2],G=j2[c+20>>2],C=j2[c+24>>2],c=0|n1[T2[T2[A>>2]+20>>2]](A),T2[140+b>>2]=0,B=z2(z2(1)/z2(0|M)),s=z2(B*s),D=j2[f+32>>2],k=z2(B*k),Z=j2[f+36>>2],l=z2(B*l),B=j2[f+40>>2],v=j2[f+56>>2],j2[136+b>>2]=z2(z2(z2(s*D)+z2(k*Z))+z2(l*B))+v,Q=j2[f+16>>2],g=j2[f+20>>2],Y=j2[f+24>>2],E=j2[f+52>>2],j2[132+b>>2]=z2(z2(z2(s*Q)+z2(k*g))+z2(l*Y))+E,h=j2[f>>2],R=j2[f+4>>2],F=j2[f+8>>2],W=j2[f+48>>2],j2[128+b>>2]=z2(z2(z2(s*h)+z2(k*R))+z2(l*F))+W,T2[124+b>>2]=0,s=z2(s+G),k=z2(k+C),l=z2(l+w),j2[120+b>>2]=v+z2(z2(z2(D*s)+z2(Z*k))+z2(B*l)),j2[116+b>>2]=E+z2(z2(z2(s*Q)+z2(k*g))+z2(l*Y)),j2[112+b>>2]=W+z2(z2(z2(s*h)+z2(k*R))+z2(l*F)),n1[T2[T2[c>>2]+16>>2]](c,128+b|0,112+b|0,b)),!((0|(I=I+1|0))<T2[d+28>>2]))break;}}else if(!((0|n1[T2[T2[r>>2]+100>>2]](r))<1))for(;n1[T2[T2[r>>2]+104>>2]](r,c,b,128+b|0),T2[124+b>>2]=0,k=j2[b>>2],B=j2[f+32>>2],l=j2[4+b>>2],w=j2[f+36>>2],s=j2[8+b>>2],G=j2[f+40>>2],C=j2[f+56>>2],j2[120+b>>2]=z2(z2(z2(k*B)+z2(l*w))+z2(s*G))+C,D=j2[f+16>>2],Z=j2[f+20>>2],v=j2[f+24>>2],Q=j2[f+52>>2],j2[116+b>>2]=z2(z2(z2(k*D)+z2(l*Z))+z2(s*v))+Q,g=j2[f>>2],Y=j2[f+4>>2],E=j2[f+8>>2],h=j2[f+48>>2],j2[112+b>>2]=z2(z2(z2(k*g)+z2(l*Y))+z2(s*E))+h,T2[108+b>>2]=0,k=j2[128+b>>2],l=j2[132+b>>2],s=j2[136+b>>2],j2[104+b>>2]=C+z2(z2(z2(B*k)+z2(w*l))+z2(G*s)),j2[100+b>>2]=Q+z2(z2(z2(D*k)+z2(Z*l))+z2(v*s)),j2[96+b>>2]=h+z2(z2(z2(g*k)+z2(Y*l))+z2(E*s)),t=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[t>>2]+16>>2]](t,112+b|0,96+b|0,e),c=c+1|0,(0|n1[T2[T2[r>>2]+100>>2]](r))>(0|c););(c=T2[r+4>>2])-21>>>0<=8&&(T2[136+b>>2]=1566444395,T2[140+b>>2]=0,T2[128+b>>2]=1566444395,T2[132+b>>2]=1566444395,T2[120+b>>2]=-581039253,T2[124+b>>2]=0,T2[112+b>>2]=-581039253,T2[116+b>>2]=-581039253,c=0|n1[T2[T2[A>>2]+20>>2]](A),d=T2[(u=e+8|0)+4>>2],T2[(t=20+b|0)>>2]=T2[u>>2],T2[t+4>>2]=d,d=T2[(u=f+8|0)+4>>2],T2[(t=36+b|0)>>2]=T2[u>>2],T2[t+4>>2]=d,u=T2[f+20>>2],T2[(t=44+b|0)>>2]=T2[f+16>>2],T2[t+4>>2]=u,d=T2[(u=f+24|0)+4>>2],T2[(t=52+b|0)>>2]=T2[u>>2],T2[t+4>>2]=d,u=T2[f+36>>2],T2[(t=60+b|0)>>2]=T2[f+32>>2],T2[t+4>>2]=u,d=T2[(u=f+40|0)+4>>2],T2[(t=68+b|0)>>2]=T2[u>>2],T2[t+4>>2]=d,T2[8+b>>2]=c,T2[4+b>>2]=18280,T2[b>>2]=18256,c=T2[e+4>>2],T2[12+b>>2]=T2[e>>2],T2[16+b>>2]=c,c=T2[f+4>>2],T2[28+b>>2]=T2[f>>2],T2[32+b>>2]=c,u=T2[(t=f+56|0)+4>>2],T2[(c=84+b|0)>>2]=T2[t>>2],T2[c+4>>2]=u,t=T2[f+52>>2],T2[(c=76+b|0)>>2]=T2[f+48>>2],T2[c+4>>2]=t,n1[T2[T2[r>>2]+64>>2]](r,b,112+b|0,128+b|0),c=T2[r+4>>2]),3==(0|c)&&(T2[136+b>>2]=1566444395,T2[140+b>>2]=0,T2[128+b>>2]=1566444395,T2[132+b>>2]=1566444395,T2[120+b>>2]=-581039253,T2[124+b>>2]=0,T2[112+b>>2]=-581039253,T2[116+b>>2]=-581039253,A=0|n1[T2[T2[A>>2]+20>>2]](A),u=T2[(t=e+8|0)+4>>2],T2[(c=20+b|0)>>2]=T2[t>>2],T2[c+4>>2]=u,u=T2[(t=f+8|0)+4>>2],T2[(c=36+b|0)>>2]=T2[t>>2],T2[c+4>>2]=u,t=T2[f+20>>2],T2[(c=44+b|0)>>2]=T2[f+16>>2],T2[c+4>>2]=t,u=T2[(t=f+24|0)+4>>2],T2[(c=52+b|0)>>2]=T2[t>>2],T2[c+4>>2]=u,t=T2[f+36>>2],T2[(c=60+b|0)>>2]=T2[f+32>>2],T2[c+4>>2]=t,u=T2[(t=f+40|0)+4>>2],T2[(c=68+b|0)>>2]=T2[t>>2],T2[c+4>>2]=u,T2[8+b>>2]=A,T2[4+b>>2]=18280,T2[b>>2]=18256,A=T2[e+4>>2],T2[12+b>>2]=T2[e>>2],T2[16+b>>2]=A,A=T2[f+4>>2],T2[28+b>>2]=T2[f>>2],T2[32+b>>2]=A,c=T2[(e=f+56|0)+4>>2],T2[(A=84+b|0)>>2]=T2[e>>2],T2[A+4>>2]=c,e=T2[f+52>>2],T2[(A=76+b|0)>>2]=T2[f+48>>2],T2[A+4>>2]=e,A=T2[r+100>>2],n1[T2[T2[A>>2]+8>>2]](A,4|b,112+b|0,128+b|0));}L2=144+b|0;},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t,c,u,k=0,l=z2(0);T2[(n=104+(L2=k=L2-256|0)|0)>>2]=0,T2[4+n>>2]=0,T2[(n=112+k|0)>>2]=0,T2[4+n>>2]=0,T2[(n=124+k|0)>>2]=0,T2[4+n>>2]=0,T2[120+k>>2]=1065353216,T2[(n=132+k|0)>>2]=0,T2[4+n>>2]=0,T2[(n=140+k|0)>>2]=1065353216,T2[4+n>>2]=0,o=T2[4+(u=f+8|0)>>2],t=T2[u>>2],T2[(a=b=76+k|0)>>2]=t,T2[4+a>>2]=o,a=T2[4+(n=r+8|0)>>2],T2[(i=92+k|0)>>2]=T2[n>>2],T2[4+i>>2]=a,T2[32+k>>2]=17592,T2[248+k>>2]=e,T2[100+k>>2]=1065353216,c=T2[f+4>>2],a=T2[f>>2],T2[68+k>>2]=a,T2[72+k>>2]=c,e=T2[r+4>>2],T2[84+k>>2]=T2[r>>2],T2[88+k>>2]=e,T2[244+k>>2]=A,T2[(e=156+k|0)>>2]=t,T2[e+4>>2]=o,T2[(e=148+k|0)>>2]=a,T2[e+4>>2]=c,T2[(e=168+k|0)>>2]=0,T2[e+4>>2]=0,T2[(e=176+k|0)>>2]=0,T2[e+4>>2]=0,T2[184+k>>2]=1065353216,T2[(e=188+k|0)>>2]=0,T2[e+4>>2]=0,T2[(e=196+k|0)>>2]=0,T2[e+4>>2]=0,T2[(e=204+k|0)>>2]=1065353216,T2[e+4>>2]=0,e=T2[r+4>>2],T2[(a=212+k|0)>>2]=T2[r>>2],T2[4+a>>2]=e,e=T2[4+n>>2],T2[(a=220+k|0)>>2]=T2[n>>2],T2[4+a>>2]=e,T2[164+k>>2]=1065353216,o=z2(j2[r>>2]-j2[f>>2]),c=z2(j2[r+4>>2]-j2[f+4>>2]),l=z2(j2[n>>2]-j2[u>>2]),a=z2(z2(1)/z2(_2(z2(z2(z2(o*o)+z2(c*c))+z2(l*l))))),u=(n=z2(l*a))==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/n),j2[44+k>>2]=u,l=(c=z2(c*a))==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/c),j2[40+k>>2]=l,T2[60+k>>2]=u<z2(0),T2[56+k>>2]=l<z2(0),l=z2(o*a),j2[64+k>>2]=z2(z2(l*z2(j2[84+k>>2]-j2[68+k>>2]))+z2(c*z2(j2[88+k>>2]-j2[72+k>>2])))+z2(n*z2(j2[i>>2]-j2[b>>2])),l=l==z2(0)?z2(0xde0b6b000000000):z2(z2(1)/l),j2[36+k>>2]=l,T2[52+k>>2]=l<z2(0),e=T2[A+68>>2],T2[(A=24+k|0)>>2]=0,T2[A+4>>2]=0,T2[16+k>>2]=0,T2[20+k>>2]=0,T2[(A=8+k|0)>>2]=0,T2[A+4>>2]=0,T2[k>>2]=0,T2[4+k>>2]=0,n1[T2[T2[e>>2]+24>>2]](e,f,r,32+k|0,16+k|0,k),L2=256+k|0;},I4,x4,function(A){var f,r,e,i;n1[T2[T2[(A|=0)>>2]+8>>2]](A),n1[T2[T2[A>>2]+12>>2]](A),(f=T2[A+24>>2])&&(i=T2[A+68>>2],r=f,e=0|n1[T2[T2[i>>2]+36>>2]](i),i=T2[A+24>>2],f=T2[T2[f>>2]+32>>2],n1[f](0|r,0|e,0|(A+28|0),0|i));},function(A,f){A|=0,n1[T2[T2[(f|=0)>>2]+32>>2]](f),y4(A,f),n1[T2[T2[f>>2]+36>>2]](f);},_,I,function(A,f){A|=0,f|=0;var r,e,i,a=0;return L2=a=L2-32|0,r=T2[A+216>>2],(e=j2[r+4>>2])!=z2(0)&&(f=T2[f>>2],0|n1[T2[T2[r>>2]+8>>2]](r,T2[f+188>>2])&&(r=T2[A+216>>2],i=T2[f+192>>2],T2[24+a>>2]=-1,T2[28+a>>2]=-1,T2[20+a>>2]=f+4,T2[16+a>>2]=f,T2[12+a>>2]=i,U4(A+68|(T2[8+a>>2]=0),A+132|0,8+a|0,r))),L2=32+a|0,e!=z2(0)|0;},I,function(A,f,r,e){A|=0,f|=0,r|=0,e|=0,z2(0);var i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h=0,Z=(0),Y=z2(0);L2=h=L2-32|0,b=j2[f+20>>2],v=j2[f+36>>2],d=j2[f+24>>2],E=j2[f+40>>2],t=j2[f+4>>2],B=j2[f+32>>2],u=j2[f+8>>2],k=j2[f>>2],Q=j2[f+16>>2],T2[28+h>>2]=0,a=z2(b-t),n=z2(E-u),i=z2(d-u),l=z2(v-t),c=z2(z2(a*n)-z2(i*l)),G=i,i=z2(B-k),o=z2(Q-k),n=z2(z2(G*i)-z2(o*n)),a=z2(z2(o*l)-z2(a*i)),i=z2(z2(u*a)+z2(z2(k*c)+z2(t*n))),s=j2[A+4>>2],o=j2[A+8>>2],g=j2[A+12>>2],l=z2(z2(z2(z2(c*s)+z2(n*o))+z2(a*g))-i),C=j2[A+20>>2],w=j2[A+24>>2],D=j2[A+28>>2],i=z2(z2(z2(z2(c*C)+z2(n*w))+z2(a*D))-i),z2(l*i)>=z2(0)||1&(f=T2[A+36>>2])&&l<=z2(0)||(i=z2(l/z2(l-i)))<j2[A+40>>2]&&(G=o,o=z2(z2(1)-i),w=z2(z2(w*i)+z2(G*o)),b=z2(b-w),s=z2(z2(C*i)+z2(s*o)),k=z2(k-s),t=z2(t-w),Q=z2(Q-s),o=z2(z2(D*i)+z2(g*o)),d=z2(d-o),u=z2(u-o),C=z2(z2(a*a)+z2(z2(c*c)+z2(n*n))),g=z2(C*z2(-9999999747378752e-20)),z2(z2(a*z2(z2(b*k)-z2(t*Q)))+z2(z2(c*z2(z2(t*d)-z2(u*b)))+z2(n*z2(z2(u*Q)-z2(d*k)))))>=g&&(v=z2(v-w),B=z2(B-s),s=z2(a*z2(z2(v*Q)-z2(b*B))),G=b,b=z2(E-o),g<=z2(s+z2(z2(c*z2(z2(G*b)-z2(d*v)))+z2(n*z2(z2(d*B)-z2(b*Q)))))&&g<=z2(z2(a*z2(z2(t*B)-z2(v*k)))+z2(z2(c*z2(z2(v*u)-z2(b*t)))+z2(n*z2(z2(b*k)-z2(u*B)))))&&(o=a,a=z2(z2(1)/z2(_2(C))),t=z2(o*a),j2[24+h>>2]=t,n=z2(n*a),j2[20+h>>2]=n,c=z2(c*a),j2[16+h>>2]=c,Y=!(l<=z2(0))||2&f?z2(n1[T2[T2[(Z=A)>>2]+12>>2]](A,16+h|0,i,r,e)):(T2[12+h>>2]=0,j2[8+h>>2]=-t,j2[4+h>>2]=-n,j2[h>>2]=-c,z2(n1[T2[T2[(Z=A)>>2]+12>>2]](A,h,i,r,e))),j2[Z+40>>2]=Y))),L2=32+h|0;},function(A,f,r,e,i){A|=0,f|=0,r=z2(r),e|=0,i|=0;var a,n,o,b,t,c,u,k,l,s=0;return T2[36+(L2=s=L2-48|0)>>2]=i,T2[32+s>>2]=e,T2[40+s>>2]=T2[A+52>>2],a=j2[A- -64>>2],n=j2[A+60>>2],o=j2[A+80>>2],b=j2[A+72>>2],t=j2[A+76>>2],c=j2[A+96>>2],u=j2[A+88>>2],k=j2[A+92>>2],l=j2[A+56>>2],i=j2[f+8>>2],e=j2[f>>2],f=j2[f+4>>2],T2[20+s>>2]=0,j2[16+s>>2]=z2(z2(e*u)+z2(f*k))+z2(i*c),j2[12+s>>2]=z2(z2(e*b)+z2(f*t))+z2(i*o),j2[8+s>>2]=z2(z2(l*e)+z2(n*f))+z2(a*i),j2[24+s>>2]=r,T2[s>>2]=T2[A+48>>2],T2[4+s>>2]=32+s,A=T2[A+44>>2],r=z2(n1[T2[T2[A>>2]+12>>2]](A,s,1)),L2=48+s|0,z2(r);},I,function(A,f){A|=0,f|=0;var r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R=0;L2=R=L2-128|0,u=T2[f+36>>2],f=T2[T2[A+8>>2]+32>>2]+P2(u,80)|0,D=T2[f+64>>2],k=j2[f+32>>2],l=j2[f>>2],s=j2[f+16>>2],v=j2[f+56>>2],d=j2[f+52>>2],B=j2[f+48>>2],Q=j2[f+36>>2],g=j2[f+20>>2],w=j2[f+4>>2],G=j2[f+40>>2],C=j2[f+24>>2],E=j2[f+8>>2],f=T2[A+12>>2],h=j2[f+52>>2],Z=j2[f+56>>2],r=j2[f+24>>2],e=j2[f+20>>2],i=j2[f+40>>2],a=j2[f+36>>2],Y=j2[f+48>>2],n=j2[f+8>>2],o=j2[f>>2],b=j2[f+4>>2],t=j2[f+16>>2],c=j2[f+32>>2],T2[124+R>>2]=0,T2[108+R>>2]=0,T2[92+R>>2]=0,j2[104+R>>2]=z2(z2(E*c)+z2(C*a))+z2(G*i),j2[100+R>>2]=z2(z2(w*c)+z2(g*a))+z2(Q*i),j2[88+R>>2]=z2(z2(E*t)+z2(C*e))+z2(G*r),j2[84+R>>2]=z2(z2(w*t)+z2(g*e))+z2(Q*r),j2[120+R>>2]=Z+z2(z2(z2(c*B)+z2(a*d))+z2(i*v)),j2[116+R>>2]=h+z2(z2(z2(t*B)+z2(e*d))+z2(r*v)),T2[76+R>>2]=0,j2[72+R>>2]=z2(z2(o*E)+z2(b*C))+z2(n*G),j2[68+R>>2]=z2(z2(o*w)+z2(b*g))+z2(n*Q),j2[64+R>>2]=z2(z2(l*o)+z2(s*b))+z2(k*n),j2[112+R>>2]=Y+z2(z2(z2(o*B)+z2(b*d))+z2(n*v)),j2[96+R>>2]=z2(z2(l*c)+z2(s*a))+z2(k*i),j2[80+R>>2]=z2(z2(l*t)+z2(s*e))+z2(k*r),T2[60+R>>2]=u,T2[56+R>>2]=-1,T2[44+R>>2]=D,T2[40+R>>2]=0,T2[48+R>>2]=T2[A+4>>2],T2[52+R>>2]=R+64,T2[12+R>>2]=1065353216,T2[16+R>>2]=0,T2[24+R>>2]=0,T2[36+R>>2]=u,T2[28+R>>2]=D,T2[8+R>>2]=17684,f=T2[A+24>>2],T2[32+R>>2]=f,j2[12+R>>2]=j2[f+4>>2],T2[24+R>>2]=T2[f+16>>2],U4(T2[A+16>>2],T2[A+20>>2],40+R|0,8+R|0),L2=128+R|0;},I,function(A,f){return A=T2[(A|=0)+24>>2],0|n1[T2[T2[A>>2]+8>>2]](A,f|=0);},function(A,f,r){A|=0,f|=0,r|=0;var e,i=0,a=0;return L2=a=L2-16|0,i=T2[A+28>>2],T2[4+a>>2]=i,T2[a>>2]=i,(e=T2[f+4>>2])?(T2[e+4>>2]=i,T2[e>>2]=i):T2[f+4>>2]=a,i=T2[A+24>>2],r=z2(n1[T2[T2[i>>2]+12>>2]](i,f,r)),j2[A+4>>2]=j2[T2[A+24>>2]+4>>2],L2=16+a|0,z2(r);},_,I,function(A,f,r,e){var i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D;A|=0,f|=0,r|=0,e|=0,T2[(L2=r=L2-96|0)+92>>2]=0,i=j2[f>>2],t=j2[A+60>>2],n=j2[f+4>>2],v=j2[A- -64>>2],o=j2[f+8>>2],d=j2[A+68>>2],B=j2[A+84>>2],k=z2(z2(z2(z2(i*t)+z2(n*v))+z2(o*d))+B),j2[r+88>>2]=k,b=j2[A+44>>2],Q=j2[A+48>>2],g=j2[A+52>>2],w=j2[A+80>>2],a=z2(z2(z2(z2(i*b)+z2(n*Q))+z2(o*g))+w),j2[r+84>>2]=a,c=i,i=j2[A+28>>2],u=n,n=j2[A+32>>2],G=o,o=j2[A+36>>2],l=j2[A+76>>2],D=z2(z2(z2(z2(c*i)+z2(u*n))+z2(G*o))+l),j2[r+80>>2]=D,T2[r+76>>2]=0,T2[r+60>>2]=0,s=j2[f+16>>2],c=j2[f+20>>2],u=j2[f+24>>2],C=z2(l+z2(z2(z2(i*s)+z2(n*c))+z2(o*u))),j2[r+64>>2]=C,E=z2(w+z2(z2(z2(b*s)+z2(Q*c))+z2(g*u))),j2[r+68>>2]=E,s=z2(B+z2(z2(z2(t*s)+z2(v*c))+z2(d*u))),j2[r+72>>2]=s,c=i,i=j2[f+32>>2],u=n,n=j2[f+36>>2],G=o,o=j2[f+40>>2],l=z2(l+z2(z2(z2(c*i)+z2(u*n))+z2(G*o))),j2[r+48>>2]=l,b=z2(w+z2(z2(z2(b*i)+z2(Q*n))+z2(g*o))),j2[r+52>>2]=b,i=z2(B+z2(z2(z2(t*i)+z2(v*n))+z2(d*o))),j2[r+56>>2]=i,T2[r+44>>2]=0,n=z2(z2(z2(k+s)+i)*z2(.3333333432674408)),j2[r+40>>2]=n,v=z2(z2(z2(a+E)+b)*z2(.3333333432674408)),j2[r+36>>2]=v,o=z2(z2(z2(D+C)+l)*z2(.3333333432674408)),j2[r+32>>2]=o,f=T2[A+8>>2],16384&n1[T2[T2[f>>2]+56>>2]](f)&&(t=j2[r+80>>2],T2[r+24>>2]=0,T2[r+28>>2]=0,T2[r+16>>2]=1065353216,T2[r+20>>2]=1065353216,f=T2[A+8>>2],T2[r+12>>2]=0,d=z2(C-t),B=z2(b-a),b=z2(E-a),t=z2(l-t),a=z2(z2(d*B)-z2(b*t)),u=z2((c=a)*a),a=z2(i-k),i=z2(s-k),k=z2(z2(b*a)-z2(i*B)),a=z2(z2(i*t)-z2(d*a)),i=z2(z2(1)/z2(_2(z2(u+z2(z2(k*k)+z2(a*a)))))),j2[r+8>>2]=z2(c*i)+n,j2[r+4>>2]=z2(a*i)+v,j2[r>>2]=o+z2(k*i),n1[T2[T2[f>>2]+16>>2]](f,r+32|0,r,r+16|0)),e=T2[A+8>>2],n1[T2[T2[e>>2]+16>>2]](e,r+80|0,r- -64|0,f=A+12|0),e=T2[A+8>>2],n1[T2[T2[e>>2]+16>>2]](e,r- -64|0,r+48|0,f),A=T2[A+8>>2],n1[T2[T2[A>>2]+16>>2]](A,r+48|0,r+80|0,f),L2=r+96|0;},R0,function(A){return (A|=0)-4|0;},function(A){u((A|=0)-4|0);},function(A,f,r,e){n1[T2[T2[(A=(A|=0)-4|0)>>2]+8>>2]](A,f|=0,r|=0,e|=0);},I,p4,I,p4,I,function(A,f){A|=0,f|=0;var r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h=0;L2=h=L2-128|0,u=T2[f+36>>2],f=T2[T2[A+24>>2]+32>>2]+P2(u,80)|0,G=T2[f+64>>2],k=j2[f+32>>2],l=j2[f>>2],s=j2[f+16>>2],v=j2[f+56>>2],d=j2[f+52>>2],B=j2[f+48>>2],Q=j2[f+36>>2],g=j2[f+20>>2],w=j2[f+4>>2],r=j2[f+40>>2],e=j2[f+24>>2],i=j2[f+8>>2],T2[124+h>>2]=0,T2[108+h>>2]=0,T2[92+h>>2]=0,f=T2[A+28>>2],a=j2[f+32>>2],n=j2[f+36>>2],o=j2[f+40>>2],j2[104+h>>2]=z2(z2(i*a)+z2(e*n))+z2(r*o),j2[100+h>>2]=z2(z2(w*a)+z2(g*n))+z2(Q*o),b=j2[f+16>>2],t=j2[f+20>>2],c=j2[f+24>>2],j2[88+h>>2]=z2(z2(i*b)+z2(e*t))+z2(r*c),j2[84+h>>2]=z2(z2(w*b)+z2(g*t))+z2(Q*c),j2[120+h>>2]=z2(z2(z2(B*a)+z2(d*n))+z2(v*o))+j2[f+56>>2],j2[116+h>>2]=z2(z2(z2(B*b)+z2(d*t))+z2(v*c))+j2[f+52>>2],T2[76+h>>2]=0,C=i,i=j2[f>>2],E=e,e=j2[f+4>>2],D=r,r=j2[f+8>>2],j2[72+h>>2]=z2(z2(C*i)+z2(E*e))+z2(D*r),j2[68+h>>2]=z2(z2(w*i)+z2(g*e))+z2(Q*r),j2[64+h>>2]=z2(z2(l*i)+z2(s*e))+z2(k*r),j2[112+h>>2]=z2(z2(z2(B*i)+z2(d*e))+z2(v*r))+j2[f+48>>2],j2[96+h>>2]=z2(z2(l*a)+z2(s*n))+z2(k*o),j2[80+h>>2]=z2(z2(l*b)+z2(s*t))+z2(k*c),T2[36+h>>2]=1065353216,T2[40+h>>2]=1,T2[44+h>>2]=-1,T2[56+h>>2]=u,T2[48+h>>2]=G,T2[32+h>>2]=18648,f=T2[A+32>>2],T2[52+h>>2]=f,j2[36+h>>2]=j2[f+4>>2],T2[28+h>>2]=u,T2[24+h>>2]=-1,T2[12+h>>2]=G,f=T2[A+4>>2],T2[8+h>>2]=f,T2[16+h>>2]=T2[f+8>>2],T2[20+h>>2]=h+64,X4(T2[A+8>>2],T2[A+12>>2],T2[A+16>>2],8+h|0,32+h|0,j2[A+20>>2]),L2=128+h|0;},_,I,function(A,f){return A=T2[(A|=0)+20>>2],0|n1[T2[T2[A>>2]+8>>2]](A,f|=0);},function(A,f,r){A|=0,f|=0,r|=0;var e,i=0;return T2[(L2=i=L2-16|0)>>2]=-1,T2[4+i>>2]=T2[A+24>>2],T2[8+i>>2]=T2[A+16>>2],T2[f+4>>2]||(T2[f+4>>2]=i),e=T2[A+20>>2],r=z2(n1[T2[T2[e>>2]+12>>2]](e,f,r)),j2[A+4>>2]=j2[T2[A+20>>2]+4>>2],L2=16+i|0,z2(r);},I,function(A,f){A|=0,f|=0;var r,e,i,a,n,o=0;return L2=o=L2-32|0,r=T2[A+184>>2],(e=j2[r+4>>2])!=z2(0)&&(f=T2[f>>2],0|n1[T2[T2[r>>2]+8>>2]](r,T2[f+188>>2])&&(i=j2[A+188>>2],r=T2[A+184>>2],a=T2[A+192>>2],n=T2[f+192>>2],T2[24+o>>2]=-1,T2[28+o>>2]=-1,T2[20+o>>2]=f+4,T2[16+o>>2]=f,T2[12+o>>2]=n,X4(a,A+36|(T2[8+o>>2]=0),A+100|0,8+o|0,r,i))),L2=32+o|0,e!=z2(0)|0;},function(A){var f=0;return T2[(A|=0)>>2]=19576,(f=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+56>>2]=0,p2[A+60|0]=1,T2[(f=A+48|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+36>>2]=0,p2[A+40|0]=1,T2[(f=A+28|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+16>>2]=0,p2[A+20|0]=1,T2[(f=A+8|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f=0;T2[(A|=0)>>2]=19576,(f=T2[A+56>>2])&&S2[A+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+56>>2]=0,p2[A+60|0]=1,T2[(f=A+48|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+36>>2])&&S2[A+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+36>>2]=0,p2[A+40|0]=1,T2[(f=A+28|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),u(A);},function(A,f,r){A|=0,r|=0;var e=0,i=0,a=0,n=0,o=0,b=0,t=0;if(1<=(0|(n=T2[(f|=0)+8>>2])))for(r=T2[f+16>>2];e=T2[r>>2],3&S2[e+204|0]||(a=(T2[e+208>>2]=a)+1|0),T2[e+268>>2]=1065353216,T2[e+212>>2]=-1,r=r+4|0,n=n-1|0;);if((0|(e=T2[A+8>>2]))<(0|a)){if(T2[A+12>>2]<(0|a)){if(n=0,a&&(T2[5498]=T2[5498]+1,(r=K2(19+(a<<3)|0))&&(T2[(n=r+19&-16)-4>>2]=r)),1<=(0|e))for(r=e;t=T2[A+16>>2]+i|0,o=T2[t+4>>2],T2[(b=i+n|0)>>2]=T2[t>>2],T2[b+4>>2]=o,i=i+8|0,r=r-1|0;);(r=T2[A+16>>2])&&S2[A+20|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+16>>2]=n,T2[A+12>>2]=a,p2[A+20|0]=1;}for(i=e<<3,r=a-e|0;e=T2[A+16>>2]+i|0,T2[e>>2]=0,i=i+8|(T2[e+4>>2]=0),r=r-1|0;);}if(1<=(0|(T2[A+8>>2]=a)))for(i=T2[A+16>>2],r=0;T2[i>>2]=r,T2[i+4>>2]=1,i=i+8|0,(0|a)!=(0|(r=r+1|0)););if(f=T2[f+68>>2],f=0|n1[T2[T2[f>>2]+36>>2]](f),(b=0|n1[T2[T2[f>>2]+36>>2]](f))&&(t=0|n1[T2[T2[f>>2]+20>>2]](f),!((0|b)<1)))for(r=0;;){if((f=T2[T2[(e=(r<<4)+t|0)>>2]>>2])&&(e=T2[T2[e+4>>2]>>2])&&!(7&T2[f+204>>2]||7&S2[e+204|0])){if(a=T2[e+208>>2],e=T2[A+16>>2],n=T2[f+208>>2],(0|(f=T2[(i=e+(n<<3)|0)>>2]))!=(0|n)&&(T2[i>>2]=T2[(f=e+(f<<3)|0)>>2],n=T2[f>>2],(0|(i=T2[(f=e+(n<<3)|0)>>2]))!=(0|n)))for(;T2[(o=f)>>2]=T2[(f=e+(i<<3)|0)>>2],n=T2[f>>2],(0|(i=T2[(f=e+(n<<3)|0)>>2]))!=(0|n););if((0|(i=T2[(f=e+(a<<3)|0)>>2]))!=(0|a)&&(T2[(o=f)>>2]=T2[(f=e+(i<<3)|0)>>2],a=T2[f>>2],(0|(i=T2[(f=e+(a<<3)|0)>>2]))!=(0|a)))for(;T2[(o=f)>>2]=T2[(f=e+(i<<3)|0)>>2],a=T2[f>>2],(0|(i=T2[(f=e+(a<<3)|0)>>2]))!=(0|a););(0|a)!=(0|n)&&(T2[(f=e+(n<<3)|0)>>2]=a,T2[(e=e+(a<<3)|0)+4>>2]=T2[e+4>>2]+T2[f+4>>2]);}if((0|b)==(0|(r=r+1|0)))break;}},function(A,f){A|=0;var r,e,i,a,n=0,o=0,b=0,t=0,c=0;if(1<=(0|(t=T2[(f|=0)+8>>2])))for(a=T2[f+16>>2];;){if(r=T2[(o<<2)+a>>2],3&S2[r+204|0])T2[r+208>>2]=-1,T2[r+212>>2]=-2;else {if(e=T2[A+16>>2],(0|(f=c))!=(0|(n=T2[(i=e+(f<<3)|0)>>2]))&&(T2[i>>2]=T2[(f=(n<<3)+e|0)>>2],(0|(f=T2[f>>2]))!=(0|(n=T2[(b=(f<<3)+e|0)>>2]))))for(;T2[b>>2]=T2[(f=(n<<3)+e|0)>>2],(0|(f=T2[f>>2]))!=(0|(n=T2[(b=(f<<3)+e|0)>>2])););T2[r+208>>2]=f,T2[r+212>>2]=-1,T2[4+i>>2]=o,c=c+1|0;}if((0|t)==(0|(o=o+1|0)))break;}},function(A){return T2[(A|=0)>>2]=19636,0|A;},M,Q4,function(A,f,r,e,i){},U0,J2,S4,z4,function(A){A=z4(A|=0),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A){A|=0;var f,r,e,i,a=0,n=0;if(M4(A),0|n1[T2[T2[A>>2]+20>>2]](A)&&(a=0|n1[T2[T2[A>>2]+20>>2]](A),6144&n1[T2[T2[a>>2]+56>>2]](a)&&!((0|(a=0|n1[T2[T2[A>>2]+104>>2]](A)))<1)))for(a=a+1|0;i=0|n1[T2[T2[(e=A)>>2]+108>>2]](A,a-2|0),r=T2[T2[A>>2]+172>>2],n1[r](0|e,0|i),1<(0|(a=a-1|0)););if(0|n1[T2[T2[A>>2]+20>>2]](A)&&(a=0|n1[T2[T2[A>>2]+20>>2]](A),16387&n1[T2[T2[a>>2]+56>>2]](a)&&0|n1[T2[T2[A>>2]+20>>2]](A)&&(a=0|n1[T2[T2[A>>2]+20>>2]](A),0|n1[T2[T2[a>>2]+56>>2]](a)&&!(T2[A+296>>2]<1))))for(a=0;f=T2[T2[A+304>>2]+a>>2],n1[T2[T2[f>>2]+12>>2]](f,T2[A+72>>2]),a=a+4|0,(0|(n=n+1|0))<T2[A+296>>2];);0|n1[T2[T2[A>>2]+20>>2]](A)&&(A=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[A>>2]+104>>2]](A));},function(A,f,r,e){I4(A|=0,f|=0,r|=0,e|=0);},function(A,f){A|=0,(f|=0)&&2&T2[f+252>>2]?n1[T2[T2[A>>2]+92>>2]](A,f):x4(A,f);},function(A,f){A|=0;var r,e=0,i=0,a=0,n=0,o=0,b=0,t=0,c=0;if(n1[T2[T2[(f|=0)>>2]+32>>2]](f),a=0|n1[T2[T2[f>>2]+16>>2]](f,104,1),e=d2(T2[a+8>>2],0,104),j2[e+88>>2]=j2[A+264>>2],j2[e+92>>2]=j2[A+268>>2],j2[e+96>>2]=j2[A+272>>2],j2[e+100>>2]=j2[A+276>>2],r=T2[(i=A+124|0)+4>>2],T2[e+28>>2]=T2[i>>2],T2[e+32>>2]=r,r=T2[(i=A+104|0)+4>>2],T2[e+12>>2]=T2[i>>2],T2[e+16>>2]=r,r=T2[(i=A+116|0)+4>>2],T2[e+20>>2]=T2[i>>2],T2[e+24>>2]=r,r=T2[(i=A+96|0)+4>>2],T2[e+4>>2]=T2[i>>2],T2[e+8>>2]=r,j2[e>>2]=j2[A+92>>2],j2[e+36>>2]=j2[A+132>>2],j2[e+40>>2]=j2[A+148>>2],j2[e+44>>2]=j2[A+152>>2],j2[e+48>>2]=j2[A+156>>2],j2[e+52>>2]=j2[A+160>>2],j2[e+56>>2]=j2[A+176>>2],j2[e+60>>2]=j2[A+180>>2],T2[e+64>>2]=T2[A+112>>2],T2[e+68>>2]=T2[A+164>>2],T2[e+72>>2]=T2[A+168>>2],T2[e+76>>2]=T2[A+172>>2],i=T2[A+144>>2],T2[e+84>>2]=0,T2[e+80>>2]=i,n1[T2[T2[f>>2]+20>>2]](f,a,20177,1145853764,e),y4(A,f),1<=(0|(e=T2[A+8>>2])))for(i=0;a=T2[T2[A+16>>2]+n>>2],2&S2[a+252|0]&&(b=f,t=0|n1[T2[T2[a>>2]+16>>2]](a),o=T2[T2[f>>2]+16>>2],e=0|n1[o](0|b,0|t,0|(c=1)),r=0|n1[T2[T2[a>>2]+20>>2]](a,T2[e+8>>2],f),n1[T2[T2[f>>2]+20>>2]](f,e,r,1497645650,a),e=T2[A+8>>2]),n=n+4|0,(0|(i=i+1|0))<(0|e););if(1<=T2[A+228>>2])for(e=n=0;a=T2[T2[A+236>>2]+n>>2],c=f,t=0|n1[T2[T2[a>>2]+36>>2]](a),o=T2[T2[f>>2]+16>>2],i=0|n1[o](0|c,0|t,0|(b=1)),c=0|n1[T2[T2[a>>2]+40>>2]](a,T2[(t=i)+8>>2],b=f),o=T2[T2[f>>2]+20>>2],n1[o](0|b,0|t,0|c,1397641027,0|a),n=n+4|0,(0|(e=e+1|0))<T2[A+228>>2];);n1[T2[T2[f>>2]+36>>2]](f);},function(A,f,r,e){A|=0,f=z2(f),r|=0,e=z2(e);var i,a=0,n=0;if(r?(j2[A+284>>2]=e,f=z2(j2[A+280>>2]+f),e<=(j2[A+280>>2]=f)&&(n=A,f=z2((i=f)/e),a=z2(O2(f))<z2(2147483648)?~~f:-2147483648,j2[n+280>>2]=i-z2(z2(0|a)*e))):(T2[A+284>>2]=0,j2[A+280>>2]=S2[A+316|0]?z2(0):f,r=a=!(z2(O2(e=f))<z2(1.1920928955078125e-7))),0|n1[T2[T2[A>>2]+20>>2]](A)&&(n=0|n1[T2[T2[A>>2]+20>>2]](A),n=n1[T2[T2[n>>2]+56>>2]](n)>>>4&1,p2[23468]=n),a){if(n1[T2[T2[A>>2]+168>>2]](A,z2(e*z2(0|(r=(0|r)<(0|a)?r:a)))),n1[T2[T2[A>>2]+176>>2]](A),!((0|r)<1))for(;n1[T2[T2[A>>2]+160>>2]](A,e),n1[T2[T2[A>>2]+80>>2]](A),r=r-1|0;);}else n1[T2[T2[A>>2]+80>>2]](A);return n1[T2[T2[A>>2]+120>>2]](A),0|a;},function(A,f,r){f|=0,r|=0;var e,i=0,a=0,n=0,o=0,a=T2[(A|=0)+228>>2];if((0|a)==T2[A+232>>2]&&!((0|(e=a?a<<1:1))<=(0|a))){if(e&&(T2[5498]=T2[5498]+1,(i=K2(19+(e<<2)|0))&&(T2[(n=i+19&-16)-4>>2]=i)),1<=(0|a))for(i=a;T2[o+n>>2]=T2[T2[A+236>>2]+o>>2],o=o+4|0,i=i-1|0;);(i=T2[A+236>>2])&&S2[A+240|0]&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2]),a=T2[A+228>>2]),T2[A+236>>2]=n,T2[A+232>>2]=e,p2[A+240|0]=1;}T2[A+228>>2]=a+1,T2[T2[A+236>>2]+(a<<2)>>2]=f,r&&(D4(T2[f+28>>2],f),D4(T2[f+32>>2],f));},function(A,f){f|=0;var r,e=0,i=0,a=0;A:if(!((0|(e=T2[(A|=0)+228>>2]))<1)){for(i=r=T2[A+236>>2];T2[i>>2]!=(0|f);)if(i=i+4|0,(0|e)==(0|(a=a+1|0)))break A;(0|e)<=(0|a)||(T2[(a=i)>>2]=T2[(e=(i=e-1|0)<<2)+r>>2],T2[A+228>>2]=i,T2[e+T2[A+236>>2]>>2]=f);}h4(T2[f+28>>2],f),h4(T2[f+32>>2],f);},function(A,f){f|=0;var r,e=0,i=0,a=0,n=0,i=T2[(A|=0)+296>>2];if((0|i)==T2[A+300>>2]&&!((0|(r=i?i<<1:1))<=(0|i))){if(r&&(T2[5498]=T2[5498]+1,(e=K2(19+(r<<2)|0))&&(T2[(a=e+19&-16)-4>>2]=e)),1<=(0|i))for(e=i;T2[n+a>>2]=T2[T2[A+304>>2]+n>>2],n=n+4|0,e=e-1|0;);(e=T2[A+304>>2])&&S2[A+308|0]&&(T2[5499]=T2[5499]+1,q2(T2[e-4>>2]),i=T2[A+296>>2]),T2[A+304>>2]=a,T2[A+300>>2]=r,p2[A+308|0]=1;}T2[A+296>>2]=i+1,T2[T2[A+304>>2]+(i<<2)>>2]=f;},function(A,f){f|=0;var r,e=0,i=0,a=0;A:if(!((0|(e=T2[(A|=0)+296>>2]))<1)){for(i=r=T2[A+304>>2];T2[i>>2]!=(0|f);)if(i=i+4|0,(0|e)==(0|(a=a+1|0)))break A;(0|e)<=(0|a)||(T2[(a=i)>>2]=T2[(e=(i=e-1|0)<<2)+r>>2],T2[A+296>>2]=i,T2[e+T2[A+304>>2]>>2]=f);}},function(A,f){A|=0,f|=0;var r,e,i,a,n,o,b=0,t=0,c=(0),u=0,b=(T2[f+4>>2]);if(T2[A+264>>2]=T2[f>>2],T2[A+268>>2]=b,i=T2[(t=e=f+8|0)+4>>2],T2[(b=A+272|0)>>2]=T2[t>>2],T2[b+4>>2]=i,1<=(0|(t=T2[A+248>>2])))for(;;){A:{f:switch(b=T2[T2[A+256>>2]+c>>2],T2[b+220>>2]-2|0){case 0:case 3:break A;default:break f;}1&p2[b+564|0]||((r=j2[b+404>>2])!=z2(0)&&(a=j2[f>>2],n=j2[f+4>>2],o=j2[f+8>>2],T2[b+436>>2]=0,r=z2(z2(1)/r),j2[b+432>>2]=o*r,j2[b+428>>2]=r*n,j2[b+424>>2]=r*a),t=T2[f+4>>2],T2[b+440>>2]=T2[f>>2],T2[b+444>>2]=t,t=T2[4+e>>2],T2[(b=b+448|0)>>2]=T2[e>>2],T2[b+4>>2]=t,t=T2[A+248>>2]);}if(c=c+4|0,!((0|(u=u+1|0))<(0|t)))break;}},function(A,f){var r=T2[(f|=0)+268>>2];T2[(A|=0)>>2]=T2[f+264>>2],T2[A+4>>2]=r,r=T2[(f=f+272|0)+4>>2],T2[(A=A+8|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},function(A){A|=0;var f=0,r=0,e=z2(0),i=0,a=0,n=0;if(L2=i=L2+-64|0,S2[A+290|0]){if(!((0|(r=T2[A+8>>2]))<1))for(;(f=T2[T2[A+16>>2]+a>>2])&&2&T2[f+252>>2]&&T2[f+540>>2]&&(3&S2[f+204|0]||(W4(r=f+68|0,j2[f+132>>2],j2[f+136>>2],j2[f+140>>2],f+148|0,e=S2[A+316|0]&&(e=j2[A+284>>2])!=z2(0)?z2(j2[A+280>>2]-e):z2(j2[A+280>>2]*j2[f+268>>2]),i),f=T2[f+540>>2],n1[T2[T2[f>>2]+12>>2]](f,i),r=T2[A+8>>2])),a=a+4|0,(0|(n=n+1|0))<(0|r););}else if(!((0|(r=T2[A+248>>2]))<1))for(;;){A:{f:switch(f=T2[T2[A+256>>2]+n>>2],T2[f+220>>2]-2|0){case 0:case 3:break A;default:break f;}T2[f+540>>2]&&(3&S2[f+204|0]||(W4(r=f+68|0,j2[f+132>>2],j2[f+136>>2],j2[f+140>>2],f+148|0,e=S2[A+316|0]&&(e=j2[A+284>>2])!=z2(0)?z2(j2[A+280>>2]-e):z2(j2[A+280>>2]*j2[f+268>>2]),i),f=T2[f+540>>2],n1[T2[T2[f>>2]+12>>2]](f,i),r=T2[A+248>>2]));}if(n=n+4|0,!((0|(a=a+1|0))<(0|r)))break;}L2=i+64|0;},function(A,f){A|=0,f|=0;var r,e,i,a,n,o=0,b=0,t=0,c=(0),u=0,k=0,l=0;if((c=3&(l=T2[f+204>>2]))||1&p2[f+564|0]||((e=j2[f+404>>2])!=z2(0)&&(i=j2[A+268>>2],a=j2[A+272>>2],r=j2[A+264>>2],T2[f+436>>2]=0,n=r,r=z2(z2(1)/e),j2[f+424>>2]=n*r,j2[f+432>>2]=r*a,j2[f+428>>2]=r*i),b=T2[(o=A+264|0)+4>>2],T2[f+440>>2]=T2[o>>2],T2[f+444>>2]=b,b=T2[(o=o+8|0)+4>>2],T2[(t=f+448|0)>>2]=T2[o>>2],T2[t+4>>2]=b),T2[f+192>>2]){if(1&l)4!=(-2&T2[f+220>>2])&&(T2[f+220>>2]=2);else {if((0|(o=T2[A+248>>2]))==T2[A+252>>2]&&!((0|(t=o?o<<1:1))<=(0|o))){if(t&&(T2[5498]=T2[5498]+1,(b=K2(19+(t<<2)|0))&&(T2[(u=b+19&-16)-4>>2]=b)),1<=(0|o))for(b=o;T2[k+u>>2]=T2[T2[A+256>>2]+k>>2],k=k+4|0,b=b-1|0;);(b=T2[A+256>>2])&&S2[A+260|0]&&(T2[5499]=T2[5499]+1,q2(T2[b-4>>2]),c=3&T2[f+204>>2],o=T2[A+248>>2]),T2[A+256>>2]=u,T2[A+252>>2]=t,p2[A+260|0]=1;}T2[A+248>>2]=o+1,T2[T2[A+256>>2]+(o<<2)>>2]=f;}n1[T2[T2[A>>2]+36>>2]](A,f,c?2:1,c?-3:-1);}},function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a,n,o,b,t=0,c=0,u=0,k=(0),l=0,s=0;if(3&(s=T2[f+204>>2])||1&p2[f+564|0]||((a=j2[f+404>>2])!=z2(0)&&(n=j2[A+268>>2],o=j2[A+272>>2],i=j2[A+264>>2],T2[f+436>>2]=0,b=i,i=z2(z2(1)/a),j2[f+424>>2]=b*i,j2[f+432>>2]=i*o,j2[f+428>>2]=i*n),c=T2[(t=A+264|0)+4>>2],T2[f+440>>2]=T2[t>>2],T2[f+444>>2]=c,c=T2[(t=t+8|0)+4>>2],T2[(u=f+448|0)>>2]=T2[t>>2],T2[u+4>>2]=c),T2[f+192>>2]){if(1&s)4!=(-2&T2[f+220>>2])&&(T2[f+220>>2]=2);else {if((0|(t=T2[A+248>>2]))==T2[A+252>>2]&&!((0|(u=t?t<<1:1))<=(0|t))){if(u&&(T2[5498]=T2[5498]+1,(c=K2(19+(u<<2)|0))&&(T2[(k=c+19&-16)-4>>2]=c)),1<=(0|t))for(c=t;T2[l+k>>2]=T2[T2[A+256>>2]+l>>2],l=l+4|0,c=c-1|0;);(c=T2[A+256>>2])&&S2[A+260|0]&&(T2[5499]=T2[5499]+1,q2(T2[c-4>>2]),t=T2[A+248>>2]),T2[A+256>>2]=k,T2[A+252>>2]=u,p2[A+260|0]=1;}T2[A+248>>2]=t+1,T2[T2[A+256>>2]+(t<<2)>>2]=f;}n1[T2[T2[A>>2]+36>>2]](A,f,r,e);}},function(A,f){f|=0;var r,e=0,i=0,a=0;A:if(!((0|(e=T2[(A|=0)+248>>2]))<1)){for(i=r=T2[A+256>>2];T2[i>>2]!=(0|f);)if(i=i+4|0,(0|e)==(0|(a=a+1|0)))break A;(0|e)<=(0|a)||(T2[(a=i)>>2]=T2[(e=(i=e-1|0)<<2)+r>>2],T2[A+248>>2]=i,T2[e+T2[A+256>>2]>>2]=f);}x4(A,f);},function(A,f){var r;f|=0,S2[(A|=0)+289|0]&&(r=T2[A+216>>2])&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+216>>2]=f,p2[A+289|0]=0,T2[T2[A+212>>2]+8>>2]=f;},function(A){return T2[(A|=0)+216>>2];},function(A){return T2[(A|=0)+228>>2];},O4,O4,p0,function(A){var f,r,e=0,i=0;if(1<=T2[(A|=0)+248>>2])for(;r=T2[T2[A+256>>2]+e>>2],T2[(f=r)+472>>2]=0,T2[f+476>>2]=0,T2[(f=f+496|0)>>2]=0,T2[4+f>>2]=0,T2[(f=r+488|0)>>2]=0,T2[4+f>>2]=0,T2[(r=r+480|0)>>2]=0,e=e+4|(T2[4+r>>2]=0),(0|(i=i+1|0))<T2[A+248>>2];);},F0,H4,F0,H4,function(A,f){A|=0,f=z2(f);var r,e,i,a,n,o=z2(0),b=z2(0),t=z2(0),c=z2(0),u=0,k=z2(0),l=z2(0),s=z2(0),v=z2(0),d=0,B=(0);if(1<=(0|(u=T2[A+248>>2])))for(;r=T2[T2[A+256>>2]+d>>2],3&S2[r+204|0]||(c=j2[(u=r+372|0)>>2],v=j2[r+504>>2],b=J(z2(z2(1)-v),f),k=z2(c*b),j2[u>>2]=k,c=z2(b*j2[(i=r+376|0)>>2]),j2[i>>2]=c,b=z2(b*j2[(a=r+380|0)>>2]),j2[a>>2]=b,o=j2[r+388>>2],n=j2[r+508>>2],t=J(z2(z2(1)-n),f),l=z2(o*t),j2[r+388>>2]=l,s=z2(t*j2[(e=r+392|0)>>2]),j2[e>>2]=s,t=z2(t*j2[(e=r+396|0)>>2]),j2[e>>2]=t,e=r+388|0,S2[r+512|0]&&(j2[r+524>>2]>z2(z2(z2(l*l)+z2(s*s))+z2(t*t))&&j2[r+520>>2]>z2(z2(z2(k*k)+z2(c*c))+z2(b*b))&&(o=j2[r+516>>2],t=z2(t*o),j2[r+396>>2]=t,s=z2(s*o),j2[r+392>>2]=s,l=z2(l*o),j2[r+388>>2]=l,b=z2(b*o),j2[a>>2]=b,c=z2(c*o),j2[i>>2]=c,k=z2(k*o),j2[r+372>>2]=k),(o=z2(_2(z2(z2(z2(k*k)+z2(c*c))+z2(b*b)))))<v&&(o>z2(.004999999888241291)?(o=z2(z2(1)/o),b=z2(b-z2(z2(b*o)*z2(.004999999888241291))),j2[a>>2]=b,c=z2(c-z2(z2(c*o)*z2(.004999999888241291))),j2[i>>2]=c,k=z2(k-z2(z2(k*o)*z2(.004999999888241291))),j2[r+372>>2]=k):(T2[u>>2]=0,T2[u+4>>2]=0,T2[(u=u+8|0)>>2]=0,T2[u+4>>2]=0,b=z2(0),c=z2(0),k=z2(0))),(o=z2(_2(z2(z2(z2(l*l)+z2(s*s))+z2(t*t)))))<n&&(o>z2(.004999999888241291)?(v=t,t=z2(z2(1)/o),j2[r+396>>2]=v-z2(z2(v*t)*z2(.004999999888241291)),j2[r+392>>2]=s-z2(z2(s*t)*z2(.004999999888241291)),j2[r+388>>2]=l-z2(z2(l*t)*z2(.004999999888241291))):(T2[e>>2]=0,T2[4+e>>2]=0,T2[(u=8+e|0)>>2]=0,T2[u+4>>2]=0))),W4(r+4|0,k,c,b,e,f,r+68|0),u=T2[A+248>>2]),d=d+4|0,(0|(B=B+1|0))<(0|u););},function(A,f){A|=0,f=z2(f);var r,e,i,a,n,o,b,t,c,u,k,l=0,s=0,v=0,d=0,B=z2(0),Q=0,g=0,w=z2(0),G=0,C=0,E=z2(0);if(L2=l=L2-304|0,1<=(0|(G=T2[A+248>>2])))for(d=T2[A+256>>2],i=56+l|0,a=40+l|0,n=24+l|0,C=104+l|0,o=168+l|0,b=152+l|0,Q=288+l|0;;){v=T2[d>>2],T2[v+268>>2]=1065353216;A:{f:switch(T2[v+220>>2]-2|0){case 0:case 3:break A;default:break f;}3&S2[v+204|0]||(W4(g=v+4|0,j2[v+372>>2],j2[(c=v+376|0)>>2],j2[(u=v+380|0)>>2],k=v+388|0,f,240+l|0),S2[A+44|0]&&(B=j2[v+276>>2],(B=z2(B*B))!=z2(0)&&(w=z2(j2[288+l>>2]-j2[(s=v+52|0)>>2]),E=z2(w*w),w=z2(j2[292+l>>2]-j2[v+56>>2]),E=z2(E+z2(w*w)),w=z2(j2[296+l>>2]-j2[v+60>>2]),B<z2(E+z2(w*w))&&!(19<T2[T2[v+192>>2]+4>>2])&&(T2[6039]=T2[6039]+1,r=T2[A+68>>2],r=0|n1[T2[T2[r>>2]+36>>2]](r),e=T2[s+4>>2],T2[b>>2]=T2[s>>2],T2[4+b>>2]=e,t=T2[(s=s+8|0)+4>>2],T2[(e=8+b|0)>>2]=T2[s>>2],T2[4+e>>2]=t,s=T2[Q+4>>2],T2[o>>2]=T2[Q>>2],T2[4+o>>2]=s,t=T2[(s=Q+8|0)+4>>2],T2[(e=8+o|0)>>2]=T2[s>>2],T2[4+e>>2]=t,T2[140+l>>2]=1065353216,T2[136+l>>2]=20112,T2[216+l>>2]=0,T2[232+l>>2]=T2[A+24>>2],T2[228+l>>2]=r,T2[220+l>>2]=v,T2[C>>2]=0,T2[C+4>>2]=0,T2[(r=C+8|0)>>2]=0,T2[4+r>>2]=0,T2[C+16>>2]=0,T2[84+l>>2]=0,T2[88+l>>2]=0,T2[100+l>>2]=1065353216,T2[92+l>>2]=1065353216,T2[96+l>>2]=1065353216,T2[76+l>>2]=8,T2[80+l>>2]=0,T2[72+l>>2]=11936,T2[128+l>>2]=0,B=j2[v+272>>2],j2[108+l>>2]=B,j2[124+l>>2]=B,j2[224+l>>2]=j2[A+56>>2],r=T2[v+188>>2],T2[144+l>>2]=T2[r+4>>2],T2[148+l>>2]=T2[r+8>>2],e=T2[s+4>>2],T2[(r=8+i|0)>>2]=T2[s>>2],T2[4+r>>2]=e,s=T2[Q+4>>2],T2[i>>2]=T2[Q>>2],T2[4+i>>2]=s,e=T2[4+(r=g+8|0)>>2],T2[(s=16+l|0)>>2]=T2[r>>2],T2[s+4>>2]=e,r=T2[(s=v+20|0)+4>>2],T2[n>>2]=T2[s>>2],T2[4+n>>2]=r,e=T2[4+(r=v+28|0)>>2],T2[(s=8+n|0)>>2]=T2[r>>2],T2[s+4>>2]=e,r=T2[(s=v+36|0)+4>>2],T2[a>>2]=T2[s>>2],T2[4+a>>2]=r,e=T2[4+(r=v+44|0)>>2],T2[(s=8+a|0)>>2]=T2[r>>2],T2[s+4>>2]=e,s=T2[g+4>>2],T2[8+l>>2]=T2[g>>2],T2[12+l>>2]=s,T4(A,72+l|0,g,8+l|0,136+l|0,z2(0)),(B=j2[140+l>>2])<z2(1))))?(j2[v+268>>2]=B,W4(g,j2[v+372>>2],j2[c>>2],j2[u>>2],k,z2(B*f),240+l|0),E4(v,240+l|(T2[v+268>>2]=0))):E4(v,240+l|0));}if(d=d+4|0,!(G=G-1|0))break;}if(S2[A+291|0]&&!((0|(d=T2[A+324>>2]))<1))for(g=0;;){if(Q=T2[T2[A+332>>2]+(g<<2)>>2],1<=(0|(G=T2[Q+844>>2]))){for(s=T2[Q+840>>2],s=T2[s+252>>2]<<30>>31&s,v=T2[Q+836>>2],v=T2[v+252>>2]<<30>>31&v,d=Q+68|0,C=0;(f=z2(j2[v+232>>2]*j2[s+232>>2]))>z2(0)&&(B=j2[d+68>>2])!=z2(0)&&(T2[148+l>>2]=0,w=z2(f*z2(B*z2(-j2[d>>2]))),j2[136+l>>2]=w,E=z2(f*z2(B*z2(-j2[d+4>>2]))),j2[140+l>>2]=E,f=z2(f*z2(B*z2(-j2[d+8>>2]))),j2[144+l>>2]=f,T2[252+l>>2]=0,j2[248+l>>2]=j2[d-8>>2]-j2[v+60>>2],j2[244+l>>2]=j2[d-12>>2]-j2[v+56>>2],j2[240+l>>2]=j2[d-16>>2]-j2[v+52>>2],T2[20+l>>2]=0,j2[16+l>>2]=j2[d-24>>2]-j2[s+60>>2],j2[12+l>>2]=j2[d-28>>2]-j2[s+56>>2],j2[8+l>>2]=j2[d-32>>2]-j2[s+52>>2],_4(v,136+l|0,240+l|0),T2[84+l>>2]=0,j2[80+l>>2]=-f,j2[76+l>>2]=-E,j2[72+l>>2]=-w,_4(s,72+l|0,8+l|0),G=T2[Q+844>>2]),d=d+208|0,(0|(C=C+1|0))<(0|G););d=T2[A+324>>2];}if(!((0|(g=g+1|0))<(0|d)))break;}L2=304+l|0;},function(A){var f=0,r=0,e=0,i=0,a=0,n=0,o=0,b=0,f=T2[(A|=0)+220>>2];if(n1[T2[T2[f>>2]+8>>2]](f,A,T2[A+24>>2]),1<=(0|(o=T2[A+324>>2])))for(b=T2[A+332>>2];;){if(f=T2[b+(n<<2)>>2],(r=T2[f+836>>2])&&(f=T2[f+840>>2])&&!(3&T2[r+204>>2]||3&S2[f+204|0])){if(f=T2[f+208>>2],i=T2[T2[A+220>>2]+16>>2],a=T2[r+208>>2],(0|(r=T2[(e=i+(a<<3)|0)>>2]))!=(0|a)&&(T2[e>>2]=T2[(r=i+(r<<3)|0)>>2],a=T2[r>>2],(0|(r=T2[(e=i+(a<<3)|0)>>2]))!=(0|a)))for(;T2[e>>2]=T2[(r=i+(r<<3)|0)>>2],a=T2[r>>2],(0|(r=T2[(e=i+(a<<3)|0)>>2]))!=(0|a););if((0|(e=T2[(r=i+(f<<3)|0)>>2]))!=(0|f)&&(T2[r>>2]=T2[(f=i+(e<<3)|0)>>2],f=T2[f>>2],(0|(r=T2[(e=i+(f<<3)|0)>>2]))!=(0|f)))for(;T2[e>>2]=T2[(f=i+(r<<3)|0)>>2],f=T2[f>>2],(0|(r=T2[(e=i+(f<<3)|0)>>2]))!=(0|f););(0|f)!=(0|a)&&(T2[(r=i+(a<<3)|0)>>2]=f,T2[(f=i+(f<<3)|0)+4>>2]=T2[f+4>>2]+T2[r+4>>2]);}if((0|o)==(0|(n=n+1|0)))break;}if(1<=(0|(o=T2[A+228>>2])))for(b=T2[A+236>>2],n=0;;){if(f=T2[b+(n<<2)>>2],S2[f+20|0]&&(r=T2[f+28>>2],!(3&S2[r+204|0]||(f=T2[f+32>>2],3&S2[f+204|0])))){if(f=T2[f+208>>2],i=T2[T2[A+220>>2]+16>>2],a=T2[r+208>>2],(0|(r=T2[(e=i+(a<<3)|0)>>2]))!=(0|a)&&(T2[e>>2]=T2[(r=i+(r<<3)|0)>>2],a=T2[r>>2],(0|(r=T2[(e=i+(a<<3)|0)>>2]))!=(0|a)))for(;T2[e>>2]=T2[(r=i+(r<<3)|0)>>2],a=T2[r>>2],(0|(r=T2[(e=i+(a<<3)|0)>>2]))!=(0|a););if((0|(e=T2[(r=i+(f<<3)|0)>>2]))!=(0|f)&&(T2[r>>2]=T2[(f=i+(e<<3)|0)>>2],f=T2[f>>2],(0|(r=T2[(e=i+(f<<3)|0)>>2]))!=(0|f)))for(;T2[e>>2]=T2[(f=i+(r<<3)|0)>>2],f=T2[f>>2],(0|(r=T2[(e=i+(f<<3)|0)>>2]))!=(0|f););(0|f)!=(0|a)&&(T2[(r=i+(a<<3)|0)>>2]=f,T2[(f=i+(f<<3)|0)+4>>2]=T2[f+4>>2]+T2[r+4>>2]);}if((0|o)==(0|(n=n+1|0)))break;}f=T2[A+220>>2],n1[T2[T2[f>>2]+12>>2]](f,A);},function(A,f){f|=0;var r,e,i,a,n,o,b,t,c=0,u=0,k=0,l=0,s=0,v=0,d=0,B=0,Q=0,g=0,w=0,G=0,C=0,E=0;if(L2=E=L2-16|0,(0|(k=T2[(A|=0)+196>>2]))<(0|(s=T2[A+228>>2]))){if((0|s)>T2[A+200>>2]){if(s&&(T2[5498]=T2[5498]+1,(c=K2(19+(s<<2)|0))&&(T2[(l=c+19&-16)-4>>2]=c)),1<=(0|k))for(c=k;T2[u+l>>2]=T2[T2[A+204>>2]+u>>2],u=u+4|0,c=c-1|0;);(c=T2[A+204>>2])&&S2[A+208|0]&&(T2[5499]=T2[5499]+1,q2(T2[c-4>>2])),T2[A+204>>2]=l,T2[A+200>>2]=s,p2[A+208|0]=1;}for(u=k<<2,c=s-k|0;u=u+4|(T2[T2[A+204>>2]+u>>2]=0),c=c-1|0;);}if(T2[A+196>>2]=s,1<=(0|n1[T2[T2[A>>2]+104>>2]](A)))for(c=u=0;T2[T2[A+204>>2]+u>>2]=T2[T2[A+236>>2]+u>>2],u=u+4|0,c=c+1|0,(0|n1[T2[T2[A>>2]+104>>2]](A))>(0|c););if(2<=(0|(c=T2[A+196>>2]))&&function A(f,r,e){var i=0,a=0,n=0,o=0,b=0,t=0,c=0,u=0,k=0,l=0;for(;;){for(k=r,a=T2[f+12>>2],u=T2[a+((r+e|0)/2<<2)>>2],i=e;;){if(c=T2[T2[u+28>>2]+208>>2],b=(0|c)<0)for(n=r-1|0,o=((r<<2)+a|0)-4|0,l=T2[T2[u+32>>2]+208>>2];n=n+1|0,t=T2[(o=o+4|0)>>2],(0|(r=(0|(r=T2[T2[t+28>>2]+208>>2]))<=-1?T2[T2[t+32>>2]+208>>2]:r))<(0|l););else for(n=r-1|0,o=((r<<2)+a|0)-4|0;n=n+1|0,t=T2[(o=o+4|0)>>2],(0|(r=(0|(r=T2[T2[t+28>>2]+208>>2]))<=-1?T2[T2[t+32>>2]+208>>2]:r))<(0|c););for(b?(r=i+1|0,b=(i<<2)+a|0,c=T2[T2[u+32>>2]+208>>2]):(r=i+1|0,b=(i<<2)+a|0);a=T2[b>>2],(0|(i=T2[T2[a+28>>2]+208>>2]))<=-1&&(i=T2[T2[a+32>>2]+208>>2]),b=b-4|0,r=r-1|0,(0|c)<(0|i););if(!((0|(r=(0|r)<(0|n)?(i=r,n):(T2[o>>2]=a,T2[T2[f+12>>2]+(r<<2)>>2]=t,i=r-1|0,n+1|0)))<=(0|i)))break;a=T2[f+12>>2];}if((0|k)<(0|i)&&A(f,k,i),!((0|r)<(0|e)))break;}}(A+192|0,0,c-1|0),(c=0)|n1[T2[T2[A>>2]+104>>2]](A)&&(c=T2[A+204>>2]),u=T2[A+196>>2],n=k=T2[A+212>>2],o=0|n1[T2[T2[A>>2]+20>>2]](A),T2[n+20>>2]=o,T2[k+16>>2]=u,T2[k+12>>2]=c,T2[k+4>>2]=f,(0|(c=T2[k+32>>2]))<=-1)for(T2[k+36>>2]<=-1&&((u=T2[k+40>>2])&&S2[k+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[u-4>>2])),T2[k+36>>2]=0,T2[k+40>>2]=0,p2[k+44|0]=1),l=c<<2;l=l+4|(T2[T2[k+40>>2]+l>>2]=0),(u=c)>>>0<=(c=c+1|0)>>>0;);if(((T2[k+32>>2]=0)|(c=T2[k+52>>2]))<=-1)for(T2[k+56>>2]<=-1&&((u=T2[k+60>>2])&&S2[k- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[u-4>>2])),T2[k+56>>2]=0,T2[k+60>>2]=0,p2[k- -64|0]=1),l=c<<2;l=l+4|(T2[T2[k+60>>2]+l>>2]=0),(u=c)>>>0<=(c=c+1|0)>>>0;);if(((T2[k+52>>2]=0)|(c=T2[k+72>>2]))<=-1)for(T2[k+76>>2]<=-1&&((u=T2[k+80>>2])&&S2[k+84|0]&&(T2[5499]=T2[5499]+1,q2(T2[u-4>>2])),T2[k+76>>2]=0,T2[k+80>>2]=0,p2[k+84|0]=1),l=c<<2;l=l+4|(T2[T2[k+80>>2]+l>>2]=0),(u=c)>>>0<=(c=c+1|0)>>>0;);if(T2[k+72>>2]=0,c=T2[A+216>>2],u=T2[A+24>>2],o=c,b=T2[A+8>>2],t=0|n1[T2[T2[u>>2]+36>>2]](u),n=T2[T2[c>>2]+8>>2],n1[n](0|o,0|b,0|t),i=T2[A+212>>2],B=T2[A+24>>2],r=T2[A+220>>2],(0|(u=T2[r+28>>2]))<=-1)for(T2[r+32>>2]<=-1&&((c=T2[r+36>>2])&&S2[r+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[c-4>>2])),T2[r+32>>2]=0,T2[r+36>>2]=0,p2[r+40|0]=1),l=u<<2;l=l+4|(T2[T2[r+36>>2]+l>>2]=0),(c=u)>>>0<=(u=c+1|0)>>>0;);if(!(((T2[r+28>>2]=0)|(d=T2[r+8>>2]))<=0)){for(Q=r+4|0,k=T2[r+16>>2],s=0;;){if((0|(c=T2[(l=k+((u=s)<<3)|0)>>2]))!=(0|u)&&(T2[l>>2]=T2[(c=k+(c<<3)|0)>>2],(0|(u=T2[c>>2]))!=(0|(v=T2[(c=k+(u<<3)|0)>>2]))))for(;T2[(u=c)>>2]=T2[(c=k+(v<<3)|0)>>2],(0|(u=T2[c>>2]))!=(0|(v=T2[(c=k+(u<<3)|0)>>2])););if(T2[l>>2]=u,(0|d)==(0|(s=s+1|0)))break;}if(2<=(0|d)&&(!function A(f,r,e){for(var i,a,n,o=0,b=0,t=0,c=0,u=0,k=0,l=0;;){for(u=T2[f+12>>2],a=T2[u+((e+(i=r)|0)/2<<3)>>2],t=r,c=e;;){for(b=((t<<3)+u|0)-8|0;t=t+1|0,T2[(b=b+8|0)>>2]<(0|a););for(r=t-1|0,o=8+(c<<3)|0;c=c-1|0,k=o+u|0,o=l=o-8|0,T2[k-8>>2]>(0|a););if((0|r)<=(0|(o=c+1|0))&&(n=T2[b>>2],k=T2[b+4>>2],r=T2[4+(o=u+l|0)>>2],T2[b>>2]=T2[o>>2],T2[b+4>>2]=r,r=T2[f+12>>2]+l|0,T2[r>>2]=n,T2[r+4>>2]=k,o=c,r=t),!((0|r)<=(0|o)))break;u=T2[f+12>>2],t=r,c=o;}if((0|i)<(0|o)&&A(f,i,o),!((0|r)<(0|e)))break;}}(Q,0,d-1|0),d=T2[r+8>>2]),!((0|d)<1))for(C=(G=T2[r+16>>2])+4|0,a=G+8|0,u=0;;){s=(l=(0|(c=(k=u)+1|0))<(0|d)?d:c)-1|0,c=(v=k<<3)+a|0,Q=T2[v+G>>2];A:{for(;;){if((0|u)==(0|s)){u=l;break A;}if(u=u+1|0,g=T2[c>>2],c=c+8|0,(0|Q)!=(0|g))break;}s=u-1|0;}A:if(!((0|s)<(0|k))){for(g=k-1|0,l=T2[A+16>>2],w=1,c=v=v+C|0;e=T2[l+(T2[c>>2]<<2)>>2],(0|Q)==T2[e+208>>2]&&(w&=4!=(0|(e=T2[e+220>>2]))&1!=(0|e)),c=c+8|0,(0|(g=g+1|0))!=(0|s););if(!w)for(c=s-k|0;;){if(k=T2[l+(T2[v>>2]<<2)>>2],(0|Q)==T2[k+208>>2]&&2==T2[k+220>>2]&&(T2[k+220>>2]=3,T2[k+224>>2]=0),!c)break A;v=v+8|0,c=c-1|0;}for(c=s-k|0;;){if(k=T2[l+(T2[v>>2]<<2)>>2],(0|Q)==T2[k+208>>2]&&4!=(-2&T2[k+220>>2])&&(T2[k+220>>2]=2),!c)break A;v=v+8|0,c=c-1|0;}}if(!((0|u)<(0|d)))break;}}if(1<=(0|(v=0|n1[T2[T2[B>>2]+36>>2]](B))))for(l=0;;){Q=0|n1[T2[T2[B>>2]+40>>2]](B,l),c=T2[Q+840>>2],u=T2[Q+836>>2];A:{if(2==T2[u+220>>2]||!u){if(!c)break A;if(2==T2[c+220>>2])break A;}if(2&(k=T2[u+204>>2])&&(4&k||2!=T2[u+220>>2]&&(3&S2[c+204|0]||(4!=(-2&T2[c+220>>2])&&(T2[c+220>>2]=1),T2[c+224>>2]=0))),2&(s=T2[c+204>>2])&&(4&s|3&k||2!=T2[c+220>>2]&&(4!=(-2&T2[u+220>>2])&&(T2[u+220>>2]=1),T2[u+224>>2]=0)),S2[r+64|0]&&0|n1[T2[T2[B>>2]+28>>2]](B,u,c)){if((0|(k=T2[r+28>>2]))==T2[r+32>>2]&&!((0|(d=k?k<<1:1))<=(0|k))){if(s=0,d&&(T2[5498]=T2[5498]+1,(c=K2(19+(d<<2)|0))&&(T2[(s=c+19&-16)-4>>2]=c)),1<=(0|k))for(u=0,c=k;T2[u+s>>2]=T2[T2[r+36>>2]+u>>2],u=u+4|0,c=c-1|0;);(c=T2[r+36>>2])&&S2[r+40|0]&&(T2[5499]=T2[5499]+1,q2(T2[c-4>>2]),k=T2[r+28>>2]),T2[r+36>>2]=s,p2[r+40|0]=1,T2[r+32>>2]=d;}T2[r+28>>2]=k+1,T2[T2[r+36>>2]+(k<<2)>>2]=Q;}}if((0|v)==(0|(l=l+1|0)))break;}if(S2[r+64|0]){if(Q=T2[r+8>>2],2<=(0|(w=T2[r+28>>2]))&&function A(f,r,e){for(var i,a,n,o=0,b=0,t=0,c=0,u=0,k=0,l=0;;){for(b=T2[f+12>>2],i=T2[b+(((a=r)+e|0)/2<<2)>>2],o=e;;){if(u=(0|(l=T2[T2[i+836>>2]+208>>2]))<0)for(t=r-1|0,c=((r<<2)+b|0)-4|0,n=T2[T2[i+840>>2]+208>>2];t=t+1|0,k=T2[(c=c+4|0)>>2],(0|(r=(0|(r=T2[T2[k+836>>2]+208>>2]))<=-1?T2[T2[k+840>>2]+208>>2]:r))<(0|n););else for(t=r-1|0,c=((r<<2)+b|0)-4|0;t=t+1|0,k=T2[(c=c+4|0)>>2],(0|(r=(0|(r=T2[T2[k+836>>2]+208>>2]))<=-1?T2[T2[k+840>>2]+208>>2]:r))<(0|l););for(u?(r=o+1|0,u=(o<<2)+b|0,l=T2[T2[i+840>>2]+208>>2]):(r=o+1|0,u=(o<<2)+b|0);b=T2[u>>2],u=u-4|0,r=r-1|0,(0|l)<(0|(o=(0|(o=T2[T2[b+836>>2]+208>>2]))<=-1?T2[T2[b+840>>2]+208>>2]:o)););if(!((0|(r=(0|r)<(0|t)?(o=r,t):(T2[c>>2]=b,T2[T2[f+12>>2]+(r<<2)>>2]=k,o=r-1|0,t+1|0)))<=(0|o)))break;b=T2[f+12>>2];}if((0|a)<(0|o)&&A(f,a,o),!((0|r)<(0|e)))break;}}(r+24|0,0,w-1|0),!((0|Q)<1))for(B=s=0,d=1;;){l=T2[r+16>>2],G=T2[l+(s<<3)>>2],C=1;A:if(!((0|Q)<=(0|s)))for(c=T2[r+52>>2],u=T2[r+48>>2];;){if(g=T2[T2[A+16>>2]+(T2[4+((s<<3)+l|0)>>2]<<2)>>2],(0|c)==(0|u)){if((0|(k=c?c<<1:1))<=(0|c))k=c;else {if(v=0,k&&(T2[5498]=T2[5498]+1,(u=K2(19+(k<<2)|0))&&(T2[(v=u+19&-16)-4>>2]=u)),1<=(0|c))for(u=0,l=c;T2[u+v>>2]=T2[T2[r+56>>2]+u>>2],u=u+4|0,l=l-1|0;);(u=T2[r+56>>2])&&S2[r+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[u-4>>2]),c=T2[r+48>>2]),T2[r+56>>2]=v,p2[r+60|0]=1,T2[r+52>>2]=k;}}else k=c,c=u;if(T2[r+48>>2]=u=c+1|0,T2[T2[r+56>>2]+(c<<2)>>2]=g,C&=2==(0|(c=T2[g+220>>2]))|5==(0|c),(0|Q)==(0|(s=s+1|0))){s=Q;break A;}if(c=k,l=T2[r+16>>2],(0|G)!=T2[l+(s<<3)>>2])break;}if(!(((c=g=0)|w)<=(0|B))&&(l=T2[r+36>>2],c=T2[(k=l+(v=B<<2)|0)>>2],(0|(u=T2[T2[c+836>>2]+208>>2]))<=-1&&(u=T2[T2[c+840>>2]+208>>2]),((c=0)|u)==(0|G))){for(g=(c=(0|(c=B+1|0))<(0|w)?w:c)-1|0,u=4+(l+v|0)|0,d=B;;){if((0|d)!=(0|g)){if(v=T2[u>>2],d=d+1|0,u=u+4|0,(0|(l=(0|(l=T2[T2[v+836>>2]+208>>2]))<=-1?T2[T2[v+840>>2]+208>>2]:l))==(0|G))continue;}else d=c;break;}g=d-B|0,c=k;}if(C||n1[T2[T2[i>>2]+8>>2]](i,T2[r+56>>2],T2[r+48>>2],c,g,G),(0|(u=T2[r+48>>2]))<=-1)for(T2[r+52>>2]<=-1&&((c=T2[r+56>>2])&&S2[r+60|0]&&(T2[5499]=T2[5499]+1,q2(T2[c-4>>2])),p2[r+60|0]=1,T2[r+52>>2]=0,T2[r+56>>2]=0),l=u<<2;l=l+4|(T2[T2[r+56>>2]+l>>2]=0),(c=u)>>>0<=(u=c+1|0)>>>0;);if(B=g?d:B,!(((T2[r+48>>2]=0)|s)<(0|Q)))break;}}else c=0|n1[T2[T2[B>>2]+44>>2]](B),u=0|n1[T2[T2[B>>2]+36>>2]](B),n1[T2[T2[i>>2]+8>>2]](i,T2[A+16>>2],T2[A+8>>2],c,u,-1);P4(T2[A+212>>2]),c=T2[A+216>>2],n1[T2[T2[c>>2]+16>>2]](c,f,T2[A+72>>2]),L2=16+E|0;},function(A,f){A|=0,f=z2(f),z2(0);var r,e,i,a,n,o=0,b=(0),t=0,c=0;if(1<=(0|(b=T2[A+248>>2])))for(n=S2[23468];;){A:if(r=T2[T2[A+256>>2]+t>>2]){f:{r:{e:switch((o=T2[r+220>>2])-2|0){case 0:case 2:break r;default:break e;}if(e=j2[r+372>>2],i=z2(e*e),e=j2[r+376>>2],i=z2(i+z2(e*e)),e=j2[r+380>>2],i=z2(i+z2(e*e)),e=j2[r+532>>2],i<z2(e*e)&&(e=j2[r+388>>2],i=z2(e*e),e=j2[r+392>>2],i=z2(i+z2(e*e)),e=j2[r+396>>2],i=z2(i+z2(e*e)),e=j2[r+536>>2],i<z2(e*e))){j2[r+224>>2]=j2[r+224>>2]+f;break f;}if(T2[r+224>>2]=0,4==(-2&o))break f;T2[r+220>>2]=o=0;break f;}if(4==(0|o))break A;}a=-2&o;f:{r:if(!n){e:{if(2!=(0|a)){if(!(j2[r+224>>2]>z2(2)))break r;if(3&S2[r+204|0]){if(4==(0|a))break A;break f;}if(1!=(0|o))break e;T2[r+220>>2]=3;break A;}if(3&S2[r+204|0])break f;}if(2!=(0|o))break A;T2[r+388>>2]=0,T2[r+392>>2]=0,T2[r+372>>2]=0,T2[r+376>>2]=0,T2[(o=r+396|0)>>2]=0,T2[o+4>>2]=0,T2[(o=r+380|0)>>2]=0,T2[o+4>>2]=0,T2[r+304>>2]=T2[r+304>>2]+2,b=T2[A+248>>2];break A;}if(4==(0|a))break A;T2[r+220>>2]=1;break A;}T2[r+220>>2]=2;}if(t=t+4|0,!((0|(c=c+1|0))<(0|b)))break;}},function(A,f){A|=0,f=z2(f);var r,e,i,a=0,n=0;if((a=T2[A+84>>2])&&n1[0|a](A,f),n1[T2[T2[A>>2]+140>>2]](A,f),T2[A+32>>2]=a=0,j2[A+28>>2]=f,e=A+48|0,i=0|n1[T2[T2[A>>2]+20>>2]](A),T2[e>>2]=i,n1[T2[T2[A>>2]+164>>2]](A,f),n1[T2[T2[A>>2]+44>>2]](A),n1[T2[T2[A>>2]+148>>2]](A),j2[A+104>>2]=f,n1[T2[T2[A>>2]+152>>2]](A,A+92|0),n1[T2[T2[A>>2]+144>>2]](A,f),1<=T2[A+296>>2])for(;r=T2[T2[A+304>>2]+a>>2],n1[T2[T2[r>>2]+8>>2]](r,A,f),a=a+4|0,(0|(n=n+1|0))<T2[A+296>>2];);n1[T2[T2[A>>2]+156>>2]](A,f),(a=T2[A+80>>2])&&n1[0|a](A,f);},function(A,f){A|=0,f=z2(f);var r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I,x=0,y=0,U=0,X=0,p=(0),T=(0),S=(0),j=(0);if(L2=y=L2-512|0,1<=T2[A+324>>2])for(;T=T2[A+24>>2],n1[T2[T2[T>>2]+16>>2]](T,T2[T2[A+332>>2]+S>>2]),S=S+4|0,(0|(U=U+1|0))<T2[A+324>>2];);if((T=T2[A+332>>2])&&S2[A+336|0]&&(T2[5499]=T2[5499]+1,q2(T2[T-4>>2])),T2[A+332>>2]=0,T2[A+324>>2]=0,T2[A+328>>2]=0,(p2[A+336|0]=1)<=(0|(D=T2[A+248>>2])))for(I=T2[A+256>>2],b=124+y|0,s=92+y|0,v=72+y|0,T=392+y|0,d=264+y|0,B=248+y|0,Q=232+y|0,u=312+y|0,g=376+y|0,w=360+y|0,c=496+y|0,S=0;;){r=T2[(S<<2)+I>>2],T2[r+268>>2]=1065353216;A:{f:switch(T2[r+220>>2]-2|0){case 0:case 3:break A;default:break f;}if(!(3&S2[r+204|0])&&(W4(a=r+4|0,j2[r+372>>2],j2[r+376>>2],j2[r+380>>2],r+388|0,f,448+y|0),S2[A+44|0]&&(e=j2[r+276>>2],(n=z2(e*e))!=z2(0)&&(k=j2[496+y>>2],e=z2(k-j2[(t=r+52|0)>>2]),i=z2(e*e),l=j2[500+y>>2],e=z2(l-j2[r+56>>2]),o=z2(i+z2(e*e)),i=j2[504+y>>2],e=z2(i-j2[r+60>>2]),n<z2(o+z2(e*e))&&!(19<T2[T2[r+192>>2]+4>>2])&&(T2[6039]=T2[6039]+1,x=T2[A+68>>2],p=0|n1[T2[T2[x>>2]+36>>2]](x),x=T2[4+t>>2],T2[w>>2]=T2[t>>2],T2[4+w>>2]=x,x=T2[(U=G=8+t|0)+4>>2],T2[(X=8+w|0)>>2]=T2[U>>2],T2[X+4>>2]=x,x=T2[4+c>>2],T2[g>>2]=T2[c>>2],T2[4+g>>2]=x,x=T2[(X=8+c|0)+4>>2],T2[(U=8+g|0)>>2]=T2[X>>2],T2[U+4>>2]=x,T2[348+y>>2]=1065353216,T2[344+y>>2]=20112,T2[424+y>>2]=0,T2[440+y>>2]=T2[A+24>>2],T2[436+y>>2]=p,T2[428+y>>2]=r,T2[u>>2]=0,T2[4+u>>2]=0,T2[(x=8+u|0)>>2]=0,T2[x+4>>2]=0,T2[16+u>>2]=0,T2[292+y>>2]=0,T2[296+y>>2]=0,T2[308+y>>2]=1065353216,T2[300+y>>2]=1065353216,T2[304+y>>2]=1065353216,T2[284+y>>2]=8,T2[288+y>>2]=0,T2[280+y>>2]=11936,T2[336+y>>2]=0,e=j2[r+272>>2],j2[316+y>>2]=e,j2[332+y>>2]=e,j2[432+y>>2]=j2[A+56>>2],x=T2[r+188>>2],T2[352+y>>2]=T2[x+4>>2],T2[356+y>>2]=T2[x+8>>2],x=T2[X+4>>2],T2[(U=8+d|0)>>2]=T2[X>>2],T2[U+4>>2]=x,x=T2[4+c>>2],T2[d>>2]=T2[c>>2],T2[4+d>>2]=x,x=T2[(U=8+a|0)+4>>2],T2[(X=224+y|0)>>2]=T2[U>>2],T2[X+4>>2]=x,x=T2[(U=r+20|0)+4>>2],T2[Q>>2]=T2[U>>2],T2[4+Q>>2]=x,x=T2[(U=r+28|0)+4>>2],T2[(X=8+Q|0)>>2]=T2[U>>2],T2[X+4>>2]=x,x=T2[(U=r+36|0)+4>>2],T2[B>>2]=T2[U>>2],T2[4+B>>2]=x,x=T2[(U=r+44|0)+4>>2],T2[(X=8+B|0)>>2]=T2[U>>2],T2[X+4>>2]=x,x=T2[4+a>>2],T2[216+y>>2]=T2[a>>2],T2[220+y>>2]=x,T4(A,280+y|0,a,216+y|0,344+y|0,z2(0)),(e=j2[348+y>>2])<z2(1)))))){if(h=z2(e*z2(l-j2[r+56>>2])),o=z2(e*z2(k-j2[r+52>>2])),Z=z2(e*z2(i-j2[r+60>>2])),n=z2(z2(z2(h*z2(-j2[396+y>>2]))-z2(o*j2[392+y>>2]))-z2(Z*j2[400+y>>2])),x=T2[A+24>>2],a=0|n1[T2[T2[x>>2]+12>>2]](x,r,T2[424+y>>2]),(0|(U=T2[A+324>>2]))==T2[A+328>>2]&&!((0|(p=U?U<<1:1))<=(0|U))){if(X=0,p&&(T2[5498]=T2[5498]+1,(x=K2(19+(p<<2)|0))&&(T2[(X=x+19&-16)-4>>2]=x)),1<=(0|U))for(j=0,x=U;T2[X+j>>2]=T2[T2[A+332>>2]+j>>2],j=j+4|0,x=x-1|0;);(x=T2[A+332>>2])&&S2[A+336|0]&&(T2[5499]=T2[5499]+1,q2(T2[x-4>>2]),U=T2[A+324>>2]),T2[A+332>>2]=X,p2[A+336|0]=1,T2[A+328>>2]=p;}T2[T2[A+332>>2]+(U<<2)>>2]=a,T2[A+324>>2]=U+1,x=T2[424+y>>2],Y=j2[x+20>>2],R=j2[x+36>>2],F=j2[x+40>>2],W=j2[x+8>>2],m=j2[x+24>>2],C=j2[x+60>>2],k=j2[x+56>>2],E=j2[x+52>>2],N=j2[x+44>>2],V=j2[x+12>>2],J=j2[x+28>>2],M=j2[x+4>>2],l=j2[r+60>>2],i=j2[r+52>>2],e=j2[r+56>>2],T2[(x=16+y|0)>>2]=0,T2[x+4>>2]=0,T2[s>>2]=0,T2[4+s>>2]=0,T2[(x=8+s|0)>>2]=0,T2[x+4>>2]=0,T2[b>>2]=0,T2[4+b>>2]=0,T2[(x=8+b|0)>>2]=0,T2[x+4>>2]=0,T2[(x=16+b|0)>>2]=0,T2[x+4>>2]=0,T2[(x=24+b|0)>>2]=0,T2[x+4>>2]=0,T2[(x=32+b|0)>>2]=0,T2[x+4>>2]=0,T2[(x=40+b|0)>>2]=0,T2[x+4>>2]=0,T2[48+b>>2]=0,x=T2[T+4>>2],T2[v>>2]=T2[T>>2],T2[4+v>>2]=x,x=T2[(U=T+8|0)+4>>2],T2[(X=8+v|0)>>2]=T2[U>>2],T2[X+4>>2]=x,T2[8+y>>2]=0,T2[12+y>>2]=0,T2[36+y>>2]=0,j2[88+y>>2]=n,o=z2(o+i),n=z2(h+e),i=z2(Z+l),e=z2(-k),j2[32+y>>2]=z2(z2(z2(V*o)+z2(J*n))+z2(N*i))+z2(z2(z2(J*e)-z2(V*E))-z2(N*C)),j2[28+y>>2]=z2(z2(z2(o*W)+z2(n*m))+z2(i*F))+z2(z2(z2(m*e)-z2(W*E))-z2(F*C)),j2[24+y>>2]=z2(z2(z2(o*M)+z2(n*Y))+z2(i*R))+z2(z2(z2(Y*e)-z2(M*E))-z2(R*C)),p=P2(W0(a,8+y|0),208)+a|0,T2[p+100>>2]=0,j2[p+88>>2]=F2(z2(H2(z2(j2[r+228>>2]*j2[T2[424+y>>2]+228>>2]),z2(-10))),z2(10)),x=T2[4+G>>2],T2[(U=p+60|0)>>2]=T2[G>>2],T2[U+4>>2]=x,X=T2[4+t>>2],U=T2[t>>2],T2[p+48>>2]=0,j2[p+44>>2]=i,j2[p+40>>2]=n,T2[(x=p+52|0)>>2]=U,T2[x+4>>2]=X,j2[p+36>>2]=o;}}if((0|D)==(0|(S=S+1|0)))break;}L2=512+y|0;},function(A,f){A|=0,f=z2(f);var r,e,i,a,n,o,b,t,c,u=0,k=0,l=0,s=0,v=(0),d=0;if(L2=s=L2-32|0,1<=(0|(l=T2[A+8>>2])))for(i=z2(z2(1)/f),k=l;(u=T2[T2[A+16>>2]+v>>2])&&2&T2[u+252>>2]&&2!=T2[u+220>>2]&&(k=(a=2&S2[u+204|0])?l:k,a&&f!=z2(0)&&((k=T2[u+540>>2])&&n1[T2[T2[k>>2]+8>>2]](k,u+4|0),T2[u+384>>2]=0,j2[(k=u+380|0)>>2]=i*z2(j2[(l=u+60|0)>>2]-j2[(a=u+124|0)>>2]),j2[u+376>>2]=i*z2(j2[u+56>>2]-j2[u+120>>2]),j2[(r=u+372|0)>>2]=i*z2(j2[(n=u+52|0)>>2]-j2[(o=u+116|0)>>2]),G4(u+68|0,u+4|0,16+s|0,12+s|0),T2[u+400>>2]=0,t=j2[12+s>>2],j2[(e=u+396|0)>>2]=i*z2(t*j2[24+s>>2]),j2[u+392>>2]=i*z2(t*j2[20+s>>2]),j2[(b=u+388|0)>>2]=i*z2(t*j2[16+s>>2]),c=T2[k+4>>2],T2[(t=u+140|0)>>2]=T2[k>>2],T2[4+t>>2]=c,k=T2[4+r>>2],T2[u+132>>2]=T2[r>>2],T2[u+136>>2]=k,k=T2[4+b>>2],T2[u+148>>2]=T2[b>>2],T2[u+152>>2]=k,r=T2[4+e>>2],T2[(k=u+156|0)>>2]=T2[e>>2],T2[k+4>>2]=r,k=T2[u+8>>2],T2[u+68>>2]=T2[u+4>>2],T2[u+72>>2]=k,e=T2[4+(r=u+12|0)>>2],T2[(k=u+76|0)>>2]=T2[r>>2],T2[k+4>>2]=e,e=T2[4+(r=u+20|0)>>2],T2[(k=u+84|0)>>2]=T2[r>>2],T2[k+4>>2]=e,e=T2[4+(r=u+28|0)>>2],T2[(k=u+92|0)>>2]=T2[r>>2],T2[k+4>>2]=e,e=T2[4+(r=u+44|0)>>2],T2[(k=u+108|0)>>2]=T2[r>>2],T2[k+4>>2]=e,k=u+100|0,r=T2[(u=u+36|0)+4>>2],T2[k>>2]=T2[u>>2],T2[k+4>>2]=r,k=T2[l+4>>2],T2[a>>2]=T2[l>>2],T2[4+a>>2]=k,k=T2[4+n>>2],T2[o>>2]=T2[n>>2],T2[4+o>>2]=k,k=l=T2[A+8>>2])),v=v+4|0,(0|(d=d+1|0))<(0|k););L2=32+s|0;},function(A,f){A|=0,f|=0;var r,e=0,i=0,a=0,n=0,o=z2(0),b=z2(0),t=0,c=z2(0),u=z2(0),k=z2(0),l=z2(0),s=0,v=z2(0),d=z2(0),B=z2(0),Q=z2(0),g=0,w=0,G=z2(0),C=(z2(0)),E=z2(0),D=0,h=z2(0),Z=z2(0),Y=z2(0),R=z2(0),F=z2(0),W=z2(0),m=0,N=0,V=z2(0),J=z2(0),M=0,I=0,x=z2(0),y=z2(0),U=z2(0),X=0,p=z2(0),T=z2(0),S=z2(0),j=z2(0),P=0;L2=e=L2-176|0,i=0|n1[T2[T2[A>>2]+20>>2]](A),i=0|n1[T2[T2[i>>2]+56>>2]](i),n=0|n1[T2[T2[A>>2]+20>>2]](A),n=0|n1[T2[T2[n>>2]+56>>2]](n);A:if(!((r=j2[f+40>>2])<=z2(0))){a=2048&i,s=4096&n;f:switch(T2[f+4>>2]-3|0){case 0:if(T2[(n=172+e|0)>>2]=0,T2[(i=t=164+e|0)>>2]=0,T2[i+4>>2]=0,T2[(i=156+e|0)>>2]=0,T2[i+4>>2]=0,T2[(i=124+e|0)>>2]=0,T2[i+4>>2]=0,T2[(i=136+e|0)>>2]=0,T2[i+4>>2]=0,T2[132+e>>2]=1065353216,T2[(i=144+e|0)>>2]=0,T2[i+4>>2]=0,T2[152+e>>2]=1065353216,T2[116+e>>2]=0,T2[120+e>>2]=0,T2[112+e>>2]=1065353216,i=T2[f+28>>2],u=j2[i+52>>2],k=j2[i+8>>2],l=j2[i+12>>2],v=j2[i+56>>2],d=j2[i+28>>2],B=j2[i+20>>2],Q=j2[i+24>>2],o=j2[i+60>>2],c=j2[i+44>>2],b=j2[i+36>>2],G=j2[i+40>>2],C=j2[i+4>>2],D=168+e|(T2[n>>2]=0),p=o,o=j2[f+300>>2],T=z2(b*o),b=j2[f+304>>2],S=c,c=j2[f+308>>2],j2[D>>2]=p+z2(z2(T+z2(G*b))+z2(S*c)),j2[t>>2]=v+z2(z2(z2(o*B)+z2(b*Q))+z2(c*d)),j2[160+e>>2]=u+z2(z2(z2(o*C)+z2(b*k))+z2(c*l)),i=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[i>>2]+64>>2]](i,112+e|0,r),i=T2[f+32>>2],u=j2[i+52>>2],k=j2[i+8>>2],l=j2[i+12>>2],v=j2[i+56>>2],d=j2[i+28>>2],B=j2[i+20>>2],Q=j2[i+24>>2],o=j2[i+60>>2],c=j2[i+44>>2],b=j2[i+36>>2],G=j2[i+40>>2],C=j2[i+4>>2],T2[n>>2]=0,p=o,o=j2[f+316>>2],T=z2(b*o),b=j2[f+320>>2],S=c,c=j2[f+324>>2],j2[D>>2]=p+z2(z2(T+z2(G*b))+z2(S*c)),j2[t>>2]=v+z2(z2(z2(o*B)+z2(b*Q))+z2(c*d)),j2[160+e>>2]=u+z2(z2(z2(o*C)+z2(b*k))+z2(c*l)),!a)break A;A=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[A>>2]+64>>2]](A,112+e|0,r);break A;case 1:if(i=T2[f+28>>2],x=j2[i+52>>2],o=j2[i+8>>2],b=j2[i+12>>2],Q=j2[f+584>>2],G=j2[f+552>>2],C=j2[f+568>>2],y=j2[i+56>>2],U=j2[i+60>>2],R=j2[f+608>>2],F=j2[f+600>>2],E=j2[f+604>>2],c=j2[i+28>>2],u=j2[i+20>>2],k=j2[i+24>>2],W=j2[f+588>>2],V=j2[f+556>>2],h=j2[f+572>>2],Z=j2[f+592>>2],l=j2[i+44>>2],Y=j2[f+560>>2],v=j2[i+36>>2],J=j2[f+576>>2],d=j2[i+40>>2],B=j2[i+4>>2],T2[172+e>>2]=0,T2[156+e>>2]=0,T2[140+e>>2]=0,j2[152+e>>2]=z2(z2(Y*v)+z2(J*d))+z2(Z*l),j2[148+e>>2]=z2(z2(V*v)+z2(h*d))+z2(W*l),j2[136+e>>2]=z2(z2(Y*u)+z2(J*k))+z2(Z*c),j2[132+e>>2]=z2(z2(V*u)+z2(h*k))+z2(W*c),j2[168+e>>2]=U+z2(z2(z2(v*F)+z2(d*E))+z2(l*R)),j2[164+e>>2]=y+z2(z2(z2(u*F)+z2(k*E))+z2(c*R)),T2[124+e>>2]=0,j2[144+e>>2]=z2(z2(G*v)+z2(C*d))+z2(Q*l),j2[128+e>>2]=z2(z2(G*u)+z2(C*k))+z2(Q*c),j2[120+e>>2]=z2(z2(B*Y)+z2(o*J))+z2(b*Z),j2[116+e>>2]=z2(z2(B*V)+z2(o*h))+z2(b*W),j2[112+e>>2]=z2(z2(G*B)+z2(C*o))+z2(Q*b),j2[160+e>>2]=x+z2(z2(z2(B*F)+z2(o*E))+z2(b*R)),a?(i=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[i>>2]+64>>2]](i,112+e|0,r),i=T2[f+32>>2],x=j2[i+52>>2],o=j2[i+8>>2],b=j2[i+12>>2],y=j2[i+56>>2],U=j2[i+60>>2],Q=j2[f+672>>2],G=j2[f+664>>2],C=j2[f+668>>2],c=j2[i+28>>2],u=j2[i+20>>2],k=j2[i+24>>2],R=j2[f+648>>2],F=j2[f+616>>2],E=j2[f+632>>2],W=j2[f+652>>2],V=j2[f+620>>2],h=j2[f+636>>2],Z=j2[f+656>>2],l=j2[i+44>>2],Y=j2[f+624>>2],v=j2[i+36>>2],J=j2[f+640>>2],d=j2[i+40>>2],B=j2[i+4>>2],T2[172+e>>2]=0,T2[156+e>>2]=0,T2[140+e>>2]=0,j2[152+e>>2]=z2(z2(Y*v)+z2(J*d))+z2(Z*l),j2[148+e>>2]=z2(z2(V*v)+z2(h*d))+z2(W*l),j2[144+e>>2]=z2(z2(F*v)+z2(E*d))+z2(R*l),j2[136+e>>2]=z2(z2(Y*u)+z2(J*k))+z2(Z*c),j2[132+e>>2]=z2(z2(V*u)+z2(h*k))+z2(W*c),j2[168+e>>2]=U+z2(z2(z2(v*G)+z2(d*C))+z2(l*Q)),j2[164+e>>2]=y+z2(z2(z2(u*G)+z2(k*C))+z2(c*Q)),j2[160+e>>2]=x+z2(z2(z2(B*G)+z2(o*C))+z2(b*Q)),T2[124+e>>2]=0,j2[128+e>>2]=z2(z2(F*u)+z2(E*k))+z2(R*c),j2[120+e>>2]=z2(z2(B*Y)+z2(o*J))+z2(b*Z),j2[116+e>>2]=z2(z2(B*V)+z2(o*h))+z2(b*W),j2[112+e>>2]=z2(z2(F*B)+z2(E*o))+z2(R*b),i=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[i>>2]+64>>2]](i,112+e|0,r)):(i=T2[f+32>>2],x=j2[i+52>>2],y=j2[i+56>>2],U=j2[i+60>>2],Q=j2[f+672>>2],G=j2[f+664>>2],C=j2[f+668>>2],o=j2[i+8>>2],b=j2[i+12>>2],c=j2[i+28>>2],u=j2[i+20>>2],k=j2[i+24>>2],R=j2[f+648>>2],F=j2[f+616>>2],E=j2[f+632>>2],W=j2[f+652>>2],V=j2[f+620>>2],h=j2[f+636>>2],Z=j2[f+656>>2],l=j2[i+44>>2],Y=j2[f+624>>2],v=j2[i+36>>2],J=j2[f+640>>2],d=j2[i+40>>2],B=j2[i+4>>2],T2[172+e>>2]=0,T2[156+e>>2]=0,T2[140+e>>2]=0,T2[124+e>>2]=0,j2[152+e>>2]=z2(z2(Y*v)+z2(J*d))+z2(Z*l),j2[148+e>>2]=z2(z2(V*v)+z2(h*d))+z2(W*l),j2[144+e>>2]=z2(z2(F*v)+z2(E*d))+z2(R*l),j2[136+e>>2]=z2(z2(Y*u)+z2(J*k))+z2(Z*c),j2[132+e>>2]=z2(z2(V*u)+z2(h*k))+z2(W*c),j2[128+e>>2]=z2(z2(F*u)+z2(E*k))+z2(R*c),j2[120+e>>2]=z2(z2(B*Y)+z2(o*J))+z2(b*Z),j2[116+e>>2]=z2(z2(B*V)+z2(o*h))+z2(b*W),j2[112+e>>2]=z2(z2(F*B)+z2(E*o))+z2(R*b),j2[168+e>>2]=U+z2(z2(z2(v*G)+z2(d*C))+z2(l*Q)),j2[164+e>>2]=y+z2(z2(z2(u*G)+z2(k*C))+z2(c*Q)),j2[160+e>>2]=x+z2(z2(z2(B*G)+z2(o*C))+z2(b*Q))),o=j2[f+688>>2],c=j2[f+692>>2],(b=o2(z2(o-c)))<z2(-3.1415927410125732)?b=z2(b+z2(6.2831854820251465)):b>z2(3.1415927410125732)&&(b=z2(b+z2(-6.2831854820251465))),(o=o2(z2(o+c)))<z2(-3.1415927410125732)?o=z2(o+z2(6.2831854820251465)):o>z2(3.1415927410125732)&&(o=z2(o+z2(-6.2831854820251465))),o==b)break A;if(!s)break A;j2[96+e>>2]=j2[120+e>>2],j2[100+e>>2]=j2[136+e>>2],T2[108+e>>2]=0,j2[104+e>>2]=j2[152+e>>2],j2[80+e>>2]=j2[112+e>>2],j2[84+e>>2]=j2[128+e>>2],T2[92+e>>2]=0,j2[88+e>>2]=j2[144+e>>2],A=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(f=72+e|0)>>2]=0,T2[f+4>>2]=0,T2[64+e>>2]=0,T2[68+e>>2]=0,f=c>z2(0),n1[T2[T2[A>>2]+68>>2]](A,160+e|0,96+e|0,80+e|0,r,r,f?b:z2(0),f?o:z2(6.2831854820251465),e+64|0,f,z2(10));break A;case 2:if(i=T2[f+28>>2],x=j2[i+52>>2],o=j2[i+8>>2],b=j2[i+12>>2],Q=j2[f+332>>2],G=j2[f+300>>2],C=j2[f+316>>2],y=j2[i+56>>2],U=j2[i+60>>2],R=j2[f+356>>2],F=j2[f+348>>2],E=j2[f+352>>2],c=j2[i+28>>2],u=j2[i+20>>2],k=j2[i+24>>2],W=j2[f+336>>2],V=j2[f+304>>2],h=j2[f+320>>2],Z=j2[f+340>>2],l=j2[i+44>>2],Y=j2[f+308>>2],v=j2[i+36>>2],J=j2[f+324>>2],d=j2[i+40>>2],B=j2[i+4>>2],T2[172+e>>2]=0,T2[156+e>>2]=0,T2[140+e>>2]=0,j2[152+e>>2]=z2(z2(Y*v)+z2(J*d))+z2(Z*l),j2[148+e>>2]=z2(z2(V*v)+z2(h*d))+z2(W*l),j2[136+e>>2]=z2(z2(Y*u)+z2(J*k))+z2(Z*c),j2[132+e>>2]=z2(z2(V*u)+z2(h*k))+z2(W*c),j2[168+e>>2]=U+z2(z2(z2(v*F)+z2(d*E))+z2(l*R)),j2[164+e>>2]=y+z2(z2(z2(u*F)+z2(k*E))+z2(c*R)),T2[124+e>>2]=0,j2[144+e>>2]=z2(z2(G*v)+z2(C*d))+z2(Q*l),j2[128+e>>2]=z2(z2(G*u)+z2(C*k))+z2(Q*c),j2[120+e>>2]=z2(z2(B*Y)+z2(o*J))+z2(b*Z),j2[116+e>>2]=z2(z2(B*V)+z2(o*h))+z2(b*W),j2[112+e>>2]=z2(z2(G*B)+z2(C*o))+z2(Q*b),j2[160+e>>2]=x+z2(z2(z2(B*F)+z2(o*E))+z2(b*R)),a?(i=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[i>>2]+64>>2]](i,112+e|0,r),i=T2[f+32>>2],x=j2[i+52>>2],o=j2[i+8>>2],b=j2[i+12>>2],y=j2[i+56>>2],U=j2[i+60>>2],Q=j2[f+420>>2],G=j2[f+412>>2],C=j2[f+416>>2],c=j2[i+28>>2],u=j2[i+20>>2],k=j2[i+24>>2],R=j2[f+396>>2],F=j2[f+364>>2],E=j2[f+380>>2],W=j2[f+400>>2],V=j2[f+368>>2],h=j2[f+384>>2],Z=j2[f+404>>2],l=j2[i+44>>2],Y=j2[f+372>>2],v=j2[i+36>>2],J=j2[f+388>>2],d=j2[i+40>>2],B=j2[i+4>>2],T2[172+e>>2]=0,T2[156+e>>2]=0,T2[140+e>>2]=0,j2[152+e>>2]=z2(z2(Y*v)+z2(J*d))+z2(Z*l),j2[148+e>>2]=z2(z2(V*v)+z2(h*d))+z2(W*l),j2[144+e>>2]=z2(z2(F*v)+z2(E*d))+z2(R*l),j2[136+e>>2]=z2(z2(Y*u)+z2(J*k))+z2(Z*c),j2[132+e>>2]=z2(z2(V*u)+z2(h*k))+z2(W*c),j2[168+e>>2]=U+z2(z2(z2(v*G)+z2(d*C))+z2(l*Q)),j2[164+e>>2]=y+z2(z2(z2(u*G)+z2(k*C))+z2(c*Q)),j2[160+e>>2]=x+z2(z2(z2(B*G)+z2(o*C))+z2(b*Q)),T2[124+e>>2]=0,j2[128+e>>2]=z2(z2(F*u)+z2(E*k))+z2(R*c),j2[120+e>>2]=z2(z2(B*Y)+z2(o*J))+z2(b*Z),j2[116+e>>2]=z2(z2(B*V)+z2(o*h))+z2(b*W),j2[112+e>>2]=z2(z2(F*B)+z2(E*o))+z2(R*b),i=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[i>>2]+64>>2]](i,112+e|0,r)):(i=T2[f+32>>2],x=j2[i+52>>2],y=j2[i+56>>2],U=j2[i+60>>2],Q=j2[f+420>>2],G=j2[f+412>>2],C=j2[f+416>>2],o=j2[i+8>>2],b=j2[i+12>>2],c=j2[i+28>>2],u=j2[i+20>>2],k=j2[i+24>>2],R=j2[f+396>>2],F=j2[f+364>>2],E=j2[f+380>>2],W=j2[f+400>>2],V=j2[f+368>>2],h=j2[f+384>>2],Z=j2[f+404>>2],l=j2[i+44>>2],Y=j2[f+372>>2],v=j2[i+36>>2],J=j2[f+388>>2],d=j2[i+40>>2],B=j2[i+4>>2],T2[172+e>>2]=0,T2[156+e>>2]=0,T2[140+e>>2]=0,T2[124+e>>2]=0,j2[152+e>>2]=z2(z2(Y*v)+z2(J*d))+z2(Z*l),j2[148+e>>2]=z2(z2(V*v)+z2(h*d))+z2(W*l),j2[144+e>>2]=z2(z2(F*v)+z2(E*d))+z2(R*l),j2[136+e>>2]=z2(z2(Y*u)+z2(J*k))+z2(Z*c),j2[132+e>>2]=z2(z2(V*u)+z2(h*k))+z2(W*c),j2[128+e>>2]=z2(z2(F*u)+z2(E*k))+z2(R*c),j2[120+e>>2]=z2(z2(B*Y)+z2(o*J))+z2(b*Z),j2[116+e>>2]=z2(z2(B*V)+z2(o*h))+z2(b*W),j2[112+e>>2]=z2(z2(F*B)+z2(E*o))+z2(R*b),j2[168+e>>2]=U+z2(z2(z2(v*G)+z2(d*C))+z2(l*Q)),j2[164+e>>2]=y+z2(z2(z2(u*G)+z2(k*C))+z2(c*Q)),j2[160+e>>2]=x+z2(z2(z2(B*G)+z2(o*C))+z2(b*Q))),!s)break A;for(T2[108+e>>2]=0,o=j2[f+444>>2],d=z2(z2(.0395662896335125)/z2(o*o)),o=j2[f+448>>2],o=m2(b=z2(z2(_2(z2(z2(1.0395662784576416)/z2(d+z2(z2(1)/z2(o*o))))))*z2(.5))),u=z2(W2(b)/z2(.9999999403953552)),b=z2(u*z2(.9807851910591125)),d=z2(o*z2(0)),c=z2(u*z2(0)),B=z2(c*z2(0)),k=z2(z2(d+B)-z2(b*r)),v=z2(b*z2(0)),u=z2(u*z2(.19509069621562958)),Q=z2(u*z2(0)),l=z2(z2(z2(o*r)+v)-Q),v=z2(z2(z2(r*z2(-c))-v)-Q),d=z2(z2(d+z2(u*r))-B),B=z2(z2(b*k)+z2(z2(z2(o*l)-z2(c*v))-z2(u*d))),Q=z2(z2(u*l)+z2(z2(z2(o*d)-z2(b*v))-z2(c*k))),o=z2(z2(c*d)+z2(z2(z2(o*k)-z2(u*v))-z2(b*l))),j2[104+e>>2]=z2(z2(z2(B*j2[144+e>>2])+z2(Q*j2[148+e>>2]))+z2(o*j2[152+e>>2]))+j2[168+e>>2],j2[100+e>>2]=z2(z2(z2(B*j2[128+e>>2])+z2(Q*j2[132+e>>2]))+z2(o*j2[136+e>>2]))+j2[164+e>>2],j2[96+e>>2]=z2(z2(z2(B*j2[112+e>>2])+z2(Q*j2[116+e>>2]))+z2(o*j2[120+e>>2]))+j2[160+e>>2],n=160+e|0,t=72+e|0,i=0;b=m2(c=z2(z2(z2(0|i)*z2(6.283185005187988))*z2(.03125))),o=j2[f+444>>2],k=W2(c),z2(O2(b))>z2(1.1920928955078125e-7)?(c=z2(k*k),u=z2(b*b),l=z2(c/u),d=z2(l/z2(o*o)),o=j2[f+448>>2],o=z2(_2(z2(z2(l+z2(1))/z2(d+z2(z2(1)/z2(o*o))))))):(c=z2(k*k),u=z2(b*b)),T2[92+e>>2]=0,d=b,b=z2(o*z2(.5)),u=z2(W2(b)/z2(_2(z2(c+z2(u+z2(0)))))),o=z2(d*u),b=m2(b),d=z2(b*z2(0)),c=z2(u*z2(0)),B=z2(c*z2(0)),l=z2(z2(d+B)-z2(o*r)),v=z2(o*z2(0)),u=z2(u*z2(-k)),Q=z2(u*z2(0)),k=z2(z2(z2(b*r)+v)-Q),v=z2(z2(z2(r*z2(-c))-v)-Q),d=z2(z2(d+z2(u*r))-B),B=z2(z2(o*l)+z2(z2(z2(b*k)-z2(c*v))-z2(u*d))),Q=z2(z2(u*k)+z2(z2(z2(b*d)-z2(o*v))-z2(c*l))),o=z2(z2(c*d)+z2(z2(z2(b*l)-z2(u*v))-z2(o*k))),j2[88+e>>2]=z2(z2(z2(B*j2[144+e>>2])+z2(Q*j2[148+e>>2]))+z2(o*j2[152+e>>2]))+j2[168+e>>2],j2[84+e>>2]=z2(z2(z2(B*j2[128+e>>2])+z2(Q*j2[132+e>>2]))+z2(o*j2[136+e>>2]))+j2[164+e>>2],j2[80+e>>2]=z2(z2(z2(B*j2[112+e>>2])+z2(Q*j2[116+e>>2]))+z2(o*j2[120+e>>2]))+j2[160+e>>2],a=0|n1[T2[T2[A>>2]+20>>2]](A),T2[t>>2]=0,T2[t+4>>2]=0,T2[64+e>>2]=0,T2[68+e>>2]=0,n1[T2[T2[a>>2]+16>>2]](a,96+e|0,80+e|0,e+64|0),3&i||(a=0|n1[T2[T2[A>>2]+20>>2]](A),T2[t>>2]=0,T2[t+4>>2]=0,T2[64+e>>2]=0,T2[68+e>>2]=0,n1[T2[T2[a>>2]+16>>2]](a,n,80+e|0,e+64|0)),M=T2[(D=88+e|0)+4>>2],T2[(a=104+e|0)>>2]=T2[D>>2],T2[a+4>>2]=M,a=T2[84+e>>2],T2[96+e>>2]=T2[80+e>>2],T2[100+e>>2]=a,32!=(0|(i=i+1|0)););C=j2[f+512>>2],R=j2[f+452>>2],i=T2[f+32>>2],d=(l=(k=(v=(b=(u=(S=(o=(p=j2[i+404>>2]>z2(0)?(o=j2[i+36>>2],c=j2[f+412>>2],b=j2[i+40>>2],u=j2[f+416>>2],F=z2(z2(o*c)+z2(b*u)),k=j2[i+20>>2],l=j2[i+24>>2],v=j2[i+28>>2],E=j2[f+420>>2],W=z2(z2(z2(k*c)+z2(l*u))+z2(v*E)),d=j2[i+4>>2],B=j2[i+8>>2],Q=j2[i+12>>2],V=z2(z2(z2(d*c)+z2(B*u))+z2(Q*E)),h=j2[f+372>>2],Z=j2[f+388>>2],Y=j2[f+404>>2],G=j2[i+44>>2],J=z2(z2(z2(h*o)+z2(Z*b))+z2(Y*G)),x=j2[f+368>>2],y=j2[f+384>>2],U=j2[f+400>>2],c=z2(z2(z2(x*o)+z2(y*b))+z2(U*G)),j=j2[f+364>>2],T=j2[f+380>>2],j2[f+396>>2]):(i=T2[f+28>>2],o=j2[i+36>>2],c=j2[f+348>>2],b=j2[i+40>>2],u=j2[f+352>>2],F=z2(z2(o*c)+z2(b*u)),k=j2[i+20>>2],l=j2[i+24>>2],v=j2[i+28>>2],E=j2[f+356>>2],W=z2(z2(z2(k*c)+z2(l*u))+z2(v*E)),d=j2[i+4>>2],B=j2[i+8>>2],Q=j2[i+12>>2],V=z2(z2(z2(d*c)+z2(B*u))+z2(Q*E)),h=j2[f+308>>2],Z=j2[f+324>>2],Y=j2[f+340>>2],G=j2[i+44>>2],J=z2(z2(z2(h*o)+z2(Z*b))+z2(Y*G)),x=j2[f+304>>2],y=j2[f+320>>2],U=j2[f+336>>2],c=z2(z2(z2(x*o)+z2(y*b))+z2(U*G)),j=j2[f+300>>2],T=j2[f+316>>2],j2[f+332>>2]),z2(z2(z2(j*o)+z2(T*b))+z2(p*G))),z2(z2(z2(h*k)+z2(Z*l))+z2(Y*v))),z2(z2(z2(x*k)+z2(y*l))+z2(U*v))),z2(z2(z2(j*k)+z2(T*l))+z2(p*v))),z2(z2(z2(d*h)+z2(B*Z))+z2(Q*Y))),z2(z2(z2(d*x)+z2(B*y))+z2(Q*U))),z2(z2(z2(j*d)+z2(T*B))+z2(p*Q))),z2(G*E)),T2[156+e>>2]=0,j2[152+e>>2]=J,j2[148+e>>2]=c,j2[144+e>>2]=o,T2[140+e>>2]=0,j2[136+e>>2]=S,j2[132+e>>2]=u,j2[128+e>>2]=b,T2[124+e>>2]=0,j2[120+e>>2]=v,j2[116+e>>2]=k,j2[112+e>>2]=l,v=j2[i+52>>2],B=j2[i+56>>2],Q=j2[i+60>>2],T2[172+e>>2]=0,j2[168+e>>2]=Q+z2(F+d),j2[164+e>>2]=W+B,j2[160+e>>2]=v+V,t=T2[(i=n+8|0)+4>>2],T2[(f=88+e|0)>>2]=T2[i>>2],T2[f+4>>2]=t,f=T2[n+4>>2],T2[80+e>>2]=T2[n>>2],T2[84+e>>2]=f,T2[76+e>>2]=0,j2[72+e>>2]=o,j2[68+e>>2]=b,j2[64+e>>2]=l,T2[60+e>>2]=0,j2[56+e>>2]=c,j2[52+e>>2]=u,j2[48+e>>2]=k,A=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(f=40+e|0)>>2]=0,T2[f+4>>2]=0,T2[32+e>>2]=0,T2[36+e>>2]=0,n1[T2[T2[A>>2]+68>>2]](A,80+e|0,e+64|0,48+e|0,r,r,z2(z2(-C)-R),z2(R-C),32+e|0,1,z2(10));break A;case 3:case 6:if(t=T2[(n=f+1072|0)+4>>2],T2[(i=g=120+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+1088|0)+4>>2],T2[(i=136+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+1104|0)+4>>2],T2[(i=152+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+1120|0)+4>>2],T2[(i=168+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,n=T2[(i=D=f+1064|0)+4>>2],T2[112+e>>2]=T2[i>>2],T2[116+e>>2]=n,n=T2[(i=M=f+1080|0)+4>>2],T2[128+e>>2]=T2[i>>2],T2[132+e>>2]=n,n=T2[(i=I=f+1096|0)+4>>2],T2[144+e>>2]=T2[i>>2],T2[148+e>>2]=n,n=T2[(i=X=f+1112|0)+4>>2],T2[160+e>>2]=T2[i>>2],T2[164+e>>2]=n,i=160+e|0,n=144+e|0,t=128+e|0,a&&(a=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[a>>2]+64>>2]](a,112+e|0,r),m=T2[(w=f+1184|0)+4>>2],T2[(a=i+8|0)>>2]=T2[w>>2],T2[a+4>>2]=m,w=T2[(a=f+1176|0)+4>>2],T2[i>>2]=T2[a>>2],T2[i+4>>2]=w,w=T2[(a=f+1144|0)+4>>2],T2[t>>2]=T2[a>>2],T2[t+4>>2]=w,m=T2[(w=f+1152|0)+4>>2],T2[(a=t+8|0)>>2]=T2[w>>2],T2[a+4>>2]=m,w=T2[(a=f+1160|0)+4>>2],T2[n>>2]=T2[a>>2],T2[n+4>>2]=w,m=T2[(w=f+1168|0)+4>>2],T2[(a=n+8|0)>>2]=T2[w>>2],T2[a+4>>2]=m,w=T2[(a=f+1136|0)+4>>2],T2[g>>2]=T2[a>>2],T2[g+4>>2]=w,g=T2[(a=f+1128|0)+4>>2],T2[112+e>>2]=T2[a>>2],T2[116+e>>2]=g,a=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[a>>2]+64>>2]](a,112+e|0,r)),!s)break A;a=T2[M+4>>2],T2[t>>2]=T2[M>>2],T2[t+4>>2]=a,a=T2[I+4>>2],T2[n>>2]=T2[I>>2],T2[n+4>>2]=a,a=T2[X+4>>2],T2[i>>2]=T2[X>>2],T2[i+4>>2]=a,w=T2[(g=D+8|0)+4>>2],T2[(a=s=120+e|0)>>2]=T2[g>>2],T2[a+4>>2]=w,m=T2[(w=M+8|0)+4>>2],T2[(a=g=t+8|0)>>2]=T2[w>>2],T2[a+4>>2]=m,N=T2[(m=I+8|0)+4>>2],T2[(a=w=n+8|0)>>2]=T2[m>>2],T2[a+4>>2]=N,P=T2[(N=X+8|0)+4>>2],T2[(a=m=i+8|0)>>2]=T2[N>>2],T2[a+4>>2]=P,a=T2[D+4>>2],T2[112+e>>2]=T2[D>>2],T2[116+e>>2]=a,j2[96+e>>2]=j2[s>>2],j2[100+e>>2]=j2[136+e>>2],T2[108+e>>2]=0,j2[104+e>>2]=j2[152+e>>2],j2[80+e>>2]=j2[112+e>>2],j2[84+e>>2]=j2[128+e>>2],T2[92+e>>2]=0,j2[88+e>>2]=j2[144+e>>2],o=j2[f+932>>2],b=j2[f+936>>2],c=j2[f+996>>2],u=j2[f+1e3>>2],N=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(a=72+e|0)>>2]=0,T2[a+4>>2]=0,T2[64+e>>2]=0,T2[68+e>>2]=0,n1[T2[T2[N>>2]+72>>2]](N,a=f+1176|0,96+e|0,80+e|0,z2(r*z2(.8999999761581421)),o,b,c,u,e+64|0,z2(10),1),T2[92+e>>2]=0,u=j2[148+e>>2],j2[88+e>>2]=u,o=j2[132+e>>2],j2[84+e>>2]=o,b=j2[116+e>>2],j2[80+e>>2]=b,k=j2[f+1196>>2],l=j2[f+1200>>2],P=T2[(N=f+1136|0)+4>>2],T2[s>>2]=T2[N>>2],T2[s+4>>2]=P,N=T2[(s=f+1144|0)+4>>2],T2[t>>2]=T2[s>>2],T2[t+4>>2]=N,N=T2[(s=f+1152|0)+4>>2],T2[g>>2]=T2[s>>2],T2[g+4>>2]=N,g=T2[(s=f+1160|0)+4>>2],T2[n>>2]=T2[s>>2],T2[n+4>>2]=g,g=T2[(s=f+1168|0)+4>>2],T2[w>>2]=T2[s>>2],T2[w+4>>2]=g,s=T2[a+4>>2],T2[i>>2]=T2[a>>2],T2[i+4>>2]=s,g=T2[(s=f+1184|0)+4>>2],T2[m>>2]=T2[s>>2],T2[m+4>>2]=g,g=T2[(s=f+1128|0)+4>>2],T2[112+e>>2]=T2[s>>2],T2[116+e>>2]=g,c=W2(l),l=m2(l),j2[68+e>>2]=z2(o*l)-z2(c*b),v=W2(k),k=m2(k),j2[72+e>>2]=z2(z2(b*z2(l*v))+z2(o*z2(v*c)))+z2(u*k),j2[64+e>>2]=z2(z2(b*z2(k*l))+z2(o*z2(k*c)))-z2(v*u),T2[60+e>>2]=0,j2[56+e>>2]=-j2[144+e>>2],j2[52+e>>2]=-j2[128+e>>2],j2[48+e>>2]=-j2[112+e>>2],o=j2[f+868>>2],(b=j2[f+872>>2])<o?(s=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(g=40+e|0)>>2]=0,T2[g+4>>2]=0,T2[32+e>>2]=0,T2[36+e>>2]=0,n1[T2[T2[s>>2]+68>>2]](s,a,48+e|0,e+64|0,r,r,z2(-3.1415927410125732),z2(3.1415927410125732),32+e|0,0,z2(10))):o<b&&(s=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(g=40+e|0)>>2]=0,T2[g+4>>2]=0,T2[32+e>>2]=0,T2[36+e>>2]=0,n1[T2[T2[s>>2]+68>>2]](s,a,48+e|0,e+64|0,r,r,o,b,32+e|0,1,z2(10))),a=T2[M+4>>2],T2[t>>2]=T2[M>>2],T2[t+4>>2]=a,a=T2[I+4>>2],T2[n>>2]=T2[I>>2],T2[n+4>>2]=a,a=T2[X+4>>2],T2[i>>2]=T2[X>>2],T2[i+4>>2]=a,g=T2[(s=D+8|0)+4>>2],T2[(a=120+e|0)>>2]=T2[s>>2],T2[a+4>>2]=g,M=T2[(a=M+8|0)+4>>2],T2[(t=t+8|0)>>2]=T2[a>>2],T2[t+4>>2]=M,a=T2[(t=I+8|0)+4>>2],T2[(n=n+8|0)>>2]=T2[t>>2],T2[n+4>>2]=a,t=T2[(n=X+8|0)+4>>2],T2[(i=i+8|0)>>2]=T2[n>>2],T2[i+4>>2]=t,i=T2[D+4>>2],T2[112+e>>2]=T2[D>>2],T2[116+e>>2]=i,t=T2[(n=f+688|0)+4>>2],T2[(i=40+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,n=T2[(i=f+680|0)+4>>2],T2[32+e>>2]=T2[i>>2],T2[36+e>>2]=n,t=T2[(n=f+704|0)+4>>2],T2[(i=24+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,i=T2[(f=f+696|0)+4>>2],T2[16+e>>2]=T2[f>>2],T2[20+e>>2]=i,A=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(f=8+e|0)>>2]=0,T2[f+4>>2]=0,T2[e>>2]=0,T2[4+e>>2]=0,n1[T2[T2[A>>2]+80>>2]](A,32+e|0,16+e|0,112+e|0,e);break A;case 9:if(t=T2[(n=f+1244|0)+4>>2],T2[(i=g=120+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+1260|0)+4>>2],T2[(i=136+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+1276|0)+4>>2],T2[(i=152+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+1292|0)+4>>2],T2[(i=168+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,n=T2[(i=D=f+1236|0)+4>>2],T2[112+e>>2]=T2[i>>2],T2[116+e>>2]=n,n=T2[(i=M=f+1252|0)+4>>2],T2[128+e>>2]=T2[i>>2],T2[132+e>>2]=n,n=T2[(i=I=f+1268|0)+4>>2],T2[144+e>>2]=T2[i>>2],T2[148+e>>2]=n,n=T2[(i=X=f+1284|0)+4>>2],T2[160+e>>2]=T2[i>>2],T2[164+e>>2]=n,i=160+e|0,n=144+e|0,t=128+e|0,a&&(a=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[a>>2]+64>>2]](a,112+e|0,r),m=T2[(w=f+1356|0)+4>>2],T2[(a=i+8|0)>>2]=T2[w>>2],T2[a+4>>2]=m,w=T2[(a=f+1348|0)+4>>2],T2[i>>2]=T2[a>>2],T2[i+4>>2]=w,w=T2[(a=f+1316|0)+4>>2],T2[t>>2]=T2[a>>2],T2[t+4>>2]=w,m=T2[(w=f+1324|0)+4>>2],T2[(a=t+8|0)>>2]=T2[w>>2],T2[a+4>>2]=m,w=T2[(a=f+1332|0)+4>>2],T2[n>>2]=T2[a>>2],T2[n+4>>2]=w,m=T2[(w=f+1340|0)+4>>2],T2[(a=n+8|0)>>2]=T2[w>>2],T2[a+4>>2]=m,w=T2[(a=f+1308|0)+4>>2],T2[g>>2]=T2[a>>2],T2[g+4>>2]=w,g=T2[(a=f+1300|0)+4>>2],T2[112+e>>2]=T2[a>>2],T2[116+e>>2]=g,a=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[a>>2]+64>>2]](a,112+e|0,r)),!s)break A;a=T2[M+4>>2],T2[t>>2]=T2[M>>2],T2[t+4>>2]=a,a=T2[I+4>>2],T2[n>>2]=T2[I>>2],T2[n+4>>2]=a,a=T2[X+4>>2],T2[i>>2]=T2[X>>2],T2[i+4>>2]=a,w=T2[(g=D+8|0)+4>>2],T2[(a=s=120+e|0)>>2]=T2[g>>2],T2[a+4>>2]=w,m=T2[(w=M+8|0)+4>>2],T2[(a=g=t+8|0)>>2]=T2[w>>2],T2[a+4>>2]=m,N=T2[(m=I+8|0)+4>>2],T2[(a=w=n+8|0)>>2]=T2[m>>2],T2[a+4>>2]=N,P=T2[(N=X+8|0)+4>>2],T2[(a=m=i+8|0)>>2]=T2[N>>2],T2[a+4>>2]=P,a=T2[D+4>>2],T2[112+e>>2]=T2[D>>2],T2[116+e>>2]=a,j2[96+e>>2]=j2[s>>2],j2[100+e>>2]=j2[136+e>>2],T2[108+e>>2]=0,j2[104+e>>2]=j2[152+e>>2],j2[80+e>>2]=j2[112+e>>2],j2[84+e>>2]=j2[128+e>>2],T2[92+e>>2]=0,j2[88+e>>2]=j2[144+e>>2],o=j2[f+1060>>2],b=j2[f+1144>>2],c=j2[f+1148>>2],u=j2[f+1056>>2],N=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(a=72+e|0)>>2]=0,T2[a+4>>2]=0,T2[64+e>>2]=0,T2[68+e>>2]=0,n1[T2[T2[N>>2]+72>>2]](N,a=f+1348|0,96+e|0,80+e|0,z2(r*z2(.8999999761581421)),u,o,b,c,e+64|0,z2(10),1),T2[92+e>>2]=0,u=j2[148+e>>2],j2[88+e>>2]=u,o=j2[132+e>>2],j2[84+e>>2]=o,b=j2[116+e>>2],j2[80+e>>2]=b,k=j2[f+1368>>2],l=j2[f+1372>>2],P=T2[(N=f+1308|0)+4>>2],T2[s>>2]=T2[N>>2],T2[s+4>>2]=P,N=T2[(s=f+1316|0)+4>>2],T2[t>>2]=T2[s>>2],T2[t+4>>2]=N,N=T2[(s=f+1324|0)+4>>2],T2[g>>2]=T2[s>>2],T2[g+4>>2]=N,g=T2[(s=f+1332|0)+4>>2],T2[n>>2]=T2[s>>2],T2[n+4>>2]=g,g=T2[(s=f+1340|0)+4>>2],T2[w>>2]=T2[s>>2],T2[w+4>>2]=g,s=T2[a+4>>2],T2[i>>2]=T2[a>>2],T2[i+4>>2]=s,g=T2[(s=f+1356|0)+4>>2],T2[m>>2]=T2[s>>2],T2[m+4>>2]=g,g=T2[(s=f+1300|0)+4>>2],T2[112+e>>2]=T2[s>>2],T2[116+e>>2]=g,c=W2(l),l=m2(l),j2[68+e>>2]=z2(o*l)-z2(b*c),v=W2(k),k=m2(k),j2[72+e>>2]=z2(z2(b*z2(l*v))+z2(o*z2(v*c)))+z2(u*k),j2[64+e>>2]=z2(z2(b*z2(k*l))+z2(o*z2(k*c)))-z2(v*u),T2[60+e>>2]=0,j2[56+e>>2]=-j2[144+e>>2],j2[52+e>>2]=-j2[128+e>>2],j2[48+e>>2]=-j2[112+e>>2],o=j2[f+968>>2],(b=j2[f+972>>2])<o?(s=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(g=40+e|0)>>2]=0,T2[g+4>>2]=0,T2[32+e>>2]=0,T2[36+e>>2]=0,n1[T2[T2[s>>2]+68>>2]](s,a,48+e|0,e+64|0,r,r,z2(-3.1415927410125732),z2(3.1415927410125732),32+e|0,0,z2(10))):o<b&&(s=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(g=40+e|0)>>2]=0,T2[g+4>>2]=0,T2[32+e>>2]=0,T2[36+e>>2]=0,n1[T2[T2[s>>2]+68>>2]](s,a,48+e|0,e+64|0,r,r,o,b,32+e|0,1,z2(10))),a=T2[M+4>>2],T2[t>>2]=T2[M>>2],T2[t+4>>2]=a,a=T2[I+4>>2],T2[n>>2]=T2[I>>2],T2[n+4>>2]=a,a=T2[X+4>>2],T2[i>>2]=T2[X>>2],T2[i+4>>2]=a,g=T2[(s=D+8|0)+4>>2],T2[(a=120+e|0)>>2]=T2[s>>2],T2[a+4>>2]=g,M=T2[(a=M+8|0)+4>>2],T2[(t=t+8|0)>>2]=T2[a>>2],T2[t+4>>2]=M,a=T2[(t=I+8|0)+4>>2],T2[(n=n+8|0)>>2]=T2[t>>2],T2[n+4>>2]=a,t=T2[(n=X+8|0)+4>>2],T2[(i=i+8|0)>>2]=T2[n>>2],T2[i+4>>2]=t,i=T2[D+4>>2],T2[112+e>>2]=T2[D>>2],T2[116+e>>2]=i,t=T2[(n=f+688|0)+4>>2],T2[(i=40+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,n=T2[(i=f+680|0)+4>>2],T2[32+e>>2]=T2[i>>2],T2[36+e>>2]=n,t=T2[(n=f+704|0)+4>>2],T2[(i=24+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,i=T2[(f=f+696|0)+4>>2],T2[16+e>>2]=T2[f>>2],T2[20+e>>2]=i,A=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(f=8+e|0)>>2]=0,T2[f+4>>2]=0,T2[e>>2]=0,T2[4+e>>2]=0,n1[T2[T2[A>>2]+80>>2]](A,32+e|0,16+e|0,112+e|0,e);break A;case 4:break f;default:break A;}t=T2[(n=f+832|0)+4>>2],T2[(i=D=120+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+848|0)+4>>2],T2[(i=136+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+864|0)+4>>2],T2[(i=152+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+880|0)+4>>2],T2[(i=168+e|0)>>2]=T2[n>>2],T2[i+4>>2]=t,n=T2[(i=M=f+824|0)+4>>2],T2[112+e>>2]=T2[i>>2],T2[116+e>>2]=n,n=T2[(i=f+840|0)+4>>2],T2[128+e>>2]=T2[i>>2],T2[132+e>>2]=n,n=T2[(i=f+856|0)+4>>2],T2[144+e>>2]=T2[i>>2],T2[148+e>>2]=n,n=T2[(i=f+872|0)+4>>2],T2[160+e>>2]=T2[i>>2],T2[164+e>>2]=n,i=160+e|0,n=144+e|0,t=128+e|0,a?(a=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[a>>2]+64>>2]](a,112+e|0,r),X=T2[(I=f+944|0)+4>>2],T2[(a=i+8|0)>>2]=T2[I>>2],T2[a+4>>2]=X,I=T2[(a=f+936|0)+4>>2],T2[i>>2]=T2[a>>2],T2[i+4>>2]=I,a=T2[(i=f+904|0)+4>>2],T2[t>>2]=T2[i>>2],T2[t+4>>2]=a,i=t+8|0,a=T2[(t=f+912|0)+4>>2],T2[i>>2]=T2[t>>2],T2[i+4>>2]=a,t=T2[(i=f+920|0)+4>>2],T2[n>>2]=T2[i>>2],T2[n+4>>2]=t,i=n+8|0,t=T2[(n=f+928|0)+4>>2],T2[i>>2]=T2[n>>2],T2[i+4>>2]=t,n=T2[(i=f+896|0)+4>>2],T2[D>>2]=T2[i>>2],T2[D+4>>2]=n,n=T2[(i=f+888|0)+4>>2],T2[112+e>>2]=T2[i>>2],T2[116+e>>2]=n,i=0|n1[T2[T2[A>>2]+20>>2]](A),n1[T2[T2[i>>2]+64>>2]](i,112+e|0,r)):(I=T2[(a=f+896|0)+4>>2],T2[D>>2]=T2[a>>2],T2[D+4>>2]=I,D=T2[(a=f+904|0)+4>>2],T2[t>>2]=T2[a>>2],T2[t+4>>2]=D,D=T2[(a=f+912|0)+4>>2],T2[(t=t+8|0)>>2]=T2[a>>2],T2[t+4>>2]=D,a=T2[(t=f+920|0)+4>>2],T2[n>>2]=T2[t>>2],T2[n+4>>2]=a,a=T2[(t=f+928|0)+4>>2],T2[(n=n+8|0)>>2]=T2[t>>2],T2[n+4>>2]=a,t=T2[(n=f+936|0)+4>>2],T2[i>>2]=T2[n>>2],T2[i+4>>2]=t,t=T2[(n=f+944|0)+4>>2],T2[(i=i+8|0)>>2]=T2[n>>2],T2[i+4>>2]=t,n=T2[(i=f+888|0)+4>>2],T2[112+e>>2]=T2[i>>2],T2[116+e>>2]=n),s&&(i=S2[f+180|0]?M:f+888|0,u=j2[i+48>>2],G=j2[i+8>>2],o=j2[i>>2],k=j2[i+4>>2],l=j2[i+52>>2],C=j2[i+24>>2],b=j2[i+16>>2],v=j2[i+20>>2],d=j2[i+56>>2],Q=j2[i+40>>2],c=j2[i+32>>2],B=j2[i+36>>2],T2[108+e>>2]=0,R=z2(Q*z2(0)),F=z2(B*z2(0)),Q=j2[f+184>>2],j2[104+e>>2]=d+z2(R+z2(F+z2(c*Q))),C=z2(C*z2(0)),E=z2(v*z2(0)),j2[100+e>>2]=l+z2(C+z2(E+z2(b*Q))),G=z2(G*z2(0)),W=z2(k*z2(0)),j2[96+e>>2]=u+z2(G+z2(W+z2(o*Q))),T2[92+e>>2]=0,S=d,d=j2[f+188>>2],j2[88+e>>2]=S+z2(R+z2(F+z2(c*d))),j2[84+e>>2]=l+z2(C+z2(E+z2(b*d))),j2[80+e>>2]=u+z2(G+z2(W+z2(o*d))),i=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(n=72+e|0)>>2]=0,T2[n+4>>2]=0,T2[64+e>>2]=0,T2[68+e>>2]=0,n1[T2[T2[i>>2]+16>>2]](i,96+e|0,80+e|0,e+64|0),T2[76+e>>2]=0,j2[72+e>>2]=c,j2[68+e>>2]=b,j2[64+e>>2]=o,T2[60+e>>2]=0,j2[56+e>>2]=B,j2[52+e>>2]=v,j2[48+e>>2]=k,o=j2[f+196>>2],b=j2[f+192>>2],A=0|n1[T2[T2[A>>2]+20>>2]](A),T2[(i=40+e|0)>>2]=0,T2[i+4>>2]=0,T2[32+e>>2]=0,T2[36+e>>2]=0,n1[T2[T2[A>>2]+68>>2]](A,f+936|0,e+64|0,48+e|0,r,r,b,o,32+e|0,1,z2(10)));}L2=176+e|0;},function(A){var f,r=0,e=0,i=0;if(1<=(0|(e=T2[(A|=0)+248>>2])))for(A=T2[A+256>>2];;){A:{f:switch(r=T2[A>>2],T2[r+220>>2]-2|0){case 0:case 3:break A;default:break f;}3&S2[r+204|0]||(j2[r+472>>2]=z2(j2[r+424>>2]*j2[r+408>>2])+j2[r+472>>2],j2[(f=r+476|0)>>2]=z2(j2[r+428>>2]*j2[r+412>>2])+j2[f>>2],j2[(f=r+480|0)>>2]=z2(j2[r+432>>2]*j2[r+416>>2])+j2[f>>2]);}if(A=A+4|0,!((0|(i=i+1|0))<(0|e)))break;}},c0,function(A,f){A|=0,f=z2(f);var r,e=0,i=0;if(1<=T2[A+296>>2])for(;r=T2[T2[A+304>>2]+e>>2],n1[T2[T2[r>>2]+8>>2]](r,A,f),e=e+4|0,(0|(i=i+1|0))<T2[A+296>>2];);},function(A){var f=0;return T2[(A|=0)>>2]=19980,(f=T2[A+80>>2])&&S2[A+84|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+80>>2]=0,p2[A+84|0]=1,T2[(f=A+72|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+60>>2])&&S2[A- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+60>>2]=0,p2[A- -64|0]=1,T2[(f=A+52|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+40>>2]=0,p2[A+44|0]=1,T2[(f=A+32|0)>>2]=0,(T2[f+4>>2]=0)|A;},function(A){var f=0;T2[(A|=0)>>2]=19980,(f=T2[A+80>>2])&&S2[A+84|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+80>>2]=0,p2[A+84|0]=1,T2[(f=A+72|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+60>>2])&&S2[A- -64|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+60>>2]=0,p2[A- -64|0]=1,T2[(f=A+52|0)>>2]=0,T2[f+4>>2]=0,(f=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),u(A);},function(A,f,r,e,i,a){A|=0,f|=0,r|=0,e|=0,i|=0;var n,o=0,b=0,t=0,c=0,u=0,k=0,l=0;A:{f:{r:{if(0<=(0|(a|=0))){if(1<=(0|(o=T2[A+16>>2])))break r;break f;}return a=T2[A+8>>2],void z2(n1[T2[T2[a>>2]+12>>2]](a,f,r,e,i,T2[A+12>>2],T2[A+16>>2],T2[A+4>>2],T2[A+20>>2],T2[A+24>>2]));}for(k=T2[A+12>>2];;){if(c=T2[k>>2],(0|a)==(0|(b=(0|(b=T2[T2[c+28>>2]+208>>2]))<=-1?T2[T2[c+32>>2]+208>>2]:b)))break f;if(k=k+4|0,(0|o)==(0|(t=t+1|0)))break;}k=0;break A;}if(!((0|o)<=(0|t)))for(b=o-t|0,o=T2[A+12>>2]+(t<<2)|0;c=T2[o>>2],o=o+4|0,l=((0|a)==(0|(t=(0|(t=T2[T2[c+28>>2]+208>>2]))<=-1?T2[T2[c+32>>2]+208>>2]:t)))+l|0,b=b-1|0;);}if(a=T2[A+4>>2],2<=T2[a+80>>2]){if(1<=(0|r))for(b=T2[A+36>>2],t=T2[A+32>>2];;){if(n=(u<<2)+f|0,(0|b)==(0|t)){if((0|(c=b?b<<1:1))<=(0|b))o=b;else {if(a=0,c&&(T2[5498]=T2[5498]+1,(o=K2(19+(c<<2)|0))&&(T2[(a=o+19&-16)-4>>2]=o)),1<=(0|b))for(o=0,t=b;T2[a+o>>2]=T2[T2[A+40>>2]+o>>2],o=o+4|0,t=t-1|0;);(o=T2[A+40>>2])&&S2[A+44|0]&&(T2[5499]=T2[5499]+1,q2(T2[o-4>>2]),b=T2[A+32>>2]),o=b,T2[A+40>>2]=a,p2[A+44|0]=1,b=T2[A+36>>2]=c;}}else o=t;if(T2[A+32>>2]=t=o+1|0,T2[T2[A+40>>2]+(o<<2)>>2]=T2[n>>2],(0|(u=u+1|0))==(0|r))break;}if(1<=(0|i))for(b=T2[A+56>>2],t=T2[A+52>>2],u=0;;){if(c=(u<<2)+e|0,(0|b)==(0|t)){if((0|(f=b?b<<1:1))<=(0|b))o=b;else {if(a=0,f&&(T2[5498]=T2[5498]+1,(r=K2(19+(f<<2)|0))&&(T2[(a=r+19&-16)-4>>2]=r)),1<=(0|b))for(o=0,t=b;T2[a+o>>2]=T2[T2[A+60>>2]+o>>2],o=o+4|0,t=t-1|0;);(r=T2[A+60>>2])&&S2[A+64|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),b=T2[A+52>>2]),o=b,T2[A+60>>2]=a,p2[A+64|0]=1,b=T2[A+56>>2]=f;}}else o=t;if(T2[A+52>>2]=t=o+1|0,T2[T2[A+60>>2]+(o<<2)>>2]=T2[c>>2],(0|(u=u+1|0))==(0|i))break;}if(l)for(b=T2[A+76>>2],t=T2[A+72>>2],u=0;;){if(e=(u<<2)+k|0,(0|b)==(0|t)){if((0|(f=b?b<<1:1))<=(0|b))o=b;else {if(a=0,f&&(T2[5498]=T2[5498]+1,(r=K2(19+(f<<2)|0))&&(T2[(a=r+19&-16)-4>>2]=r)),1<=(0|b))for(o=0,t=b;T2[a+o>>2]=T2[T2[A+80>>2]+o>>2],o=o+4|0,t=t-1|0;);(r=T2[A+80>>2])&&S2[A+84|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),b=T2[A+72>>2]),o=b,T2[A+80>>2]=a,p2[A+84|0]=1,b=T2[A+76>>2]=f;}}else o=t;if(T2[A+72>>2]=t=o+1|0,T2[T2[A+80>>2]+(o<<2)>>2]=T2[e>>2],(0|l)==(0|(u=u+1|0)))break;}else t=T2[A+72>>2];T2[T2[A+4>>2]+80>>2]<(T2[A+52>>2]+t|0)&&P4(A);}else b=T2[A+8>>2],z2(n1[T2[T2[b>>2]+12>>2]](b,f,r,e,i,k,l,a,T2[A+20>>2],T2[A+24>>2]));},I,function(A,f){var r=0,e=0,i=0;return (0|(r=T2[(f|=0)>>2]))!=(0|(e=T2[(A|=0)+84>>2]))&&T2[A+12>>2]&T2[f+4>>2]&&T2[f+8>>2]&T2[A+8>>2]&&(A=T2[A+96>>2],i=0|n1[T2[T2[A>>2]+28>>2]](A,e,r)),0|i;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b,t,c,u,k,l,s=0,v=z2(0),v=(z2(1));return (0|(s=T2[f>>2]))!=T2[A+84>>2]&&(4&S2[s+204|0]||z2(-j2[A+88>>2])<=z2(z2(z2(z2(j2[A+32>>2]-j2[A+16>>2])*j2[f+8>>2])+z2(z2(j2[A+36>>2]-j2[A+20>>2])*j2[f+12>>2]))+z2(z2(j2[A+40>>2]-j2[A+24>>2])*j2[f+16>>2]))||(T2[A+80>>2]=s,j2[A+4>>2]=j2[f+40>>2],r?(s=T2[(r=f+8|0)+4>>2],T2[A+48>>2]=T2[r>>2],T2[A+52>>2]=s,i=T2[(r=r+8|0)+4>>2],T2[(s=A+56|0)>>2]=T2[r>>2],T2[s+4>>2]=i):(a=j2[s+12>>2],n=j2[s+8>>2],o=j2[s+28>>2],b=j2[s+20>>2],t=j2[s+24>>2],c=j2[s+44>>2],u=j2[s+36>>2],k=j2[s+40>>2],l=j2[s+4>>2],v=j2[f+16>>2],e=j2[f+8>>2],i=j2[f+12>>2],T2[A+60>>2]=0,j2[A+56>>2]=z2(z2(e*u)+z2(i*k))+z2(v*c),j2[A+52>>2]=z2(z2(e*b)+z2(i*t))+z2(v*o),j2[A+48>>2]=z2(z2(l*e)+z2(n*i))+z2(a*v)),r=T2[f+28>>2],T2[A+64>>2]=T2[f+24>>2],T2[A+68>>2]=r,s=T2[(r=f+32|0)+4>>2],T2[(A=A+72|0)>>2]=T2[r>>2],T2[A+4>>2]=s,v=j2[f+40>>2])),z2(v);},function(A){return z4(A|=0),0|A;},function(A){z4(A|=0),T2[5499]=T2[5499]+1,q2(T2[A-4>>2]);},function(A,f){A|=0,f=z2(f);var r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z,Y,R,F,W,m,N,V,J,M,I=0,x=0,y=0,U=0,X=(0),p=(0),T=(0),S=(0);if(L2=x=L2-496|0,1<=T2[A+324>>2])for(;p=T2[A+24>>2],n1[T2[T2[p>>2]+16>>2]](p,T2[T2[A+332>>2]+T>>2]),T=T+4|0,(0|(y=y+1|0))<T2[A+324>>2];);if((p=T2[A+332>>2])&&S2[A+336|0]&&(T2[5499]=T2[5499]+1,q2(T2[p-4>>2])),T2[A+332>>2]=0,T2[A+324>>2]=0,T2[A+328>>2]=0,(p2[A+336|0]=1)<=(0|(D=T2[A+248>>2])))for(o=116+x|0,l=84+x|0,s=x+64|0,p=384+x|0,v=256+x|0,d=240+x|0,B=224+x|0,c=304+x|0,Q=368+x|0,g=352+x|0,t=480+x|0,T=0;;){r=T2[T2[A+256>>2]+(T<<2)>>2],T2[r+268>>2]=1065353216;A:{f:switch(T2[r+220>>2]-2|0){case 0:case 3:break A;default:break f;}if(!(3&S2[r+204|0])&&(W4(X=r+4|0,j2[r+372>>2],j2[r+376>>2],j2[r+380>>2],r+388|0,f,432+x|0),S2[A+44|0]&&(e=j2[r+276>>2],(a=z2(e*e))!=z2(0)&&(u=j2[480+x>>2],e=z2(u-j2[(b=r+52|0)>>2]),i=z2(e*e),k=j2[484+x>>2],e=z2(k-j2[r+56>>2]),n=z2(i+z2(e*e)),i=j2[488+x>>2],e=z2(i-j2[r+60>>2]),a<z2(n+z2(e*e))&&!(19<T2[T2[r+192>>2]+4>>2])&&(I=T2[4+b>>2],T2[g>>2]=T2[b>>2],T2[4+g>>2]=I,I=T2[4+t>>2],T2[Q>>2]=T2[t>>2],T2[4+Q>>2]=I,I=T2[(y=w=8+b|0)+4>>2],T2[(U=8+g|0)>>2]=T2[y>>2],T2[U+4>>2]=I,I=T2[(U=8+t|0)+4>>2],T2[(y=8+Q|0)>>2]=T2[U>>2],T2[y+4>>2]=I,T2[340+x>>2]=1065353216,T2[336+x>>2]=20576,T2[416+x>>2]=0,T2[420+x>>2]=0,T2[428+x>>2]=A,T2[424+x>>2]=r,T2[c>>2]=0,T2[4+c>>2]=0,T2[(I=8+c|0)>>2]=0,T2[I+4>>2]=0,T2[16+c>>2]=0,T2[284+x>>2]=0,T2[288+x>>2]=0,T2[300+x>>2]=1065353216,T2[292+x>>2]=1065353216,T2[296+x>>2]=1065353216,T2[276+x>>2]=8,T2[280+x>>2]=0,T2[272+x>>2]=11936,T2[328+x>>2]=0,e=j2[r+272>>2],j2[308+x>>2]=e,j2[324+x>>2]=e,I=T2[r+188>>2],T2[344+x>>2]=T2[I+4>>2],T2[348+x>>2]=T2[I+8>>2],I=T2[U+4>>2],T2[(y=8+v|0)>>2]=T2[U>>2],T2[y+4>>2]=I,I=T2[4+t>>2],T2[v>>2]=T2[t>>2],T2[4+v>>2]=I,I=T2[(y=X+8|0)+4>>2],T2[(U=216+x|0)>>2]=T2[y>>2],T2[U+4>>2]=I,I=T2[(y=r+20|0)+4>>2],T2[B>>2]=T2[y>>2],T2[4+B>>2]=I,I=T2[(y=r+28|0)+4>>2],T2[(U=8+B|0)>>2]=T2[y>>2],T2[U+4>>2]=I,I=T2[(y=r+36|0)+4>>2],T2[d>>2]=T2[y>>2],T2[4+d>>2]=I,I=T2[(y=r+44|0)+4>>2],T2[(U=8+d|0)>>2]=T2[y>>2],T2[U+4>>2]=I,I=T2[X+4>>2],T2[208+x>>2]=T2[X>>2],T2[212+x>>2]=I,T4(A,272+x|0,X,208+x|0,336+x|0,z2(0)),(e=j2[340+x>>2])<z2(1)))))){if(h=z2(z2(k-j2[r+56>>2])*e),n=z2(z2(u-j2[r+52>>2])*e),Z=z2(e*z2(i-j2[r+60>>2])),a=z2(z2(z2(h*z2(-j2[388+x>>2]))-z2(j2[384+x>>2]*n))-z2(Z*j2[392+x>>2])),I=T2[A+24>>2],G=0|n1[T2[T2[I>>2]+12>>2]](I,r,T2[416+x>>2]),(0|(y=T2[A+324>>2]))==T2[A+328>>2]&&!((0|(X=y?y<<1:1))<=(0|y))){if(U=0,X&&(T2[5498]=T2[5498]+1,(I=K2(19+(X<<2)|0))&&(T2[(U=I+19&-16)-4>>2]=I)),1<=(0|y))for(S=0,I=y;T2[U+S>>2]=T2[T2[A+332>>2]+S>>2],S=S+4|0,I=I-1|0;);(I=T2[A+332>>2])&&S2[A+336|0]&&(T2[5499]=T2[5499]+1,q2(T2[I-4>>2]),y=T2[A+324>>2]),T2[A+332>>2]=U,p2[A+336|0]=1,T2[A+328>>2]=X;}T2[T2[A+332>>2]+(y<<2)>>2]=G,T2[A+324>>2]=y+1,I=T2[416+x>>2],Y=j2[I+20>>2],R=j2[I+36>>2],F=j2[I+40>>2],W=j2[I+8>>2],m=j2[I+24>>2],C=j2[I+60>>2],u=j2[I+56>>2],E=j2[I+52>>2],N=j2[I+44>>2],V=j2[I+12>>2],J=j2[I+28>>2],M=j2[I+4>>2],k=j2[r+60>>2],i=j2[r+52>>2],e=j2[r+56>>2],T2[(I=8+x|0)>>2]=0,T2[I+4>>2]=0,T2[l>>2]=0,T2[4+l>>2]=0,T2[(I=8+l|0)>>2]=0,T2[I+4>>2]=0,T2[o>>2]=0,T2[4+o>>2]=0,T2[(I=8+o|0)>>2]=0,T2[I+4>>2]=0,T2[(I=16+o|0)>>2]=0,T2[I+4>>2]=0,T2[(I=24+o|0)>>2]=0,T2[I+4>>2]=0,T2[(I=32+o|0)>>2]=0,T2[I+4>>2]=0,T2[(I=40+o|0)>>2]=0,T2[I+4>>2]=0,T2[48+o>>2]=0,I=T2[p+4>>2],T2[s>>2]=T2[p>>2],T2[4+s>>2]=I,I=T2[(y=p+8|0)+4>>2],T2[(U=8+s|0)>>2]=T2[y>>2],T2[U+4>>2]=I,T2[x>>2]=0,T2[4+x>>2]=0,T2[28+x>>2]=0,j2[80+x>>2]=a,n=z2(n+i),a=z2(h+e),i=z2(Z+k),e=z2(-u),j2[24+x>>2]=z2(z2(z2(V*n)+z2(J*a))+z2(N*i))+z2(z2(z2(J*e)-z2(V*E))-z2(N*C)),j2[20+x>>2]=z2(z2(z2(n*W)+z2(a*m))+z2(i*F))+z2(z2(z2(m*e)-z2(W*E))-z2(F*C)),j2[16+x>>2]=z2(z2(z2(n*M)+z2(a*Y))+z2(i*R))+z2(z2(z2(Y*e)-z2(M*E))-z2(R*C)),T2[200+x>>2]=T2[r+192>>2],T2[204+x>>2]=T2[420+x>>2],X=P2(W0(G,x),208)+G|0,T2[X+100>>2]=0,j2[X+88>>2]=F2(z2(H2(z2(j2[r+228>>2]*j2[T2[416+x>>2]+228>>2]),z2(-10))),z2(10)),I=T2[4+w>>2],T2[(y=X+60|0)>>2]=T2[w>>2],T2[y+4>>2]=I,U=T2[4+b>>2],y=T2[b>>2],T2[X+48>>2]=0,j2[X+44>>2]=i,j2[X+40>>2]=a,T2[(I=X+52|0)>>2]=y,T2[I+4>>2]=U,j2[X+36>>2]=n;}}if((0|D)==(0|(T=T+1|0)))break;}L2=496+x|0;},function(A){var f=0,r=0,e=0,i=0;if(1<=T2[(A|=0)+248>>2])for(;;){A:{f:switch(f=T2[T2[A+256>>2]+e>>2],T2[f+220>>2]-2|0){case 0:case 3:break A;default:break f;}2&(r=T2[f+204>>2])||(j2[f+504>>2]!=z2(1)?3&r||(j2[f+472>>2]=z2(j2[f+424>>2]*j2[f+408>>2])+j2[f+472>>2],j2[(r=f+476|0)>>2]=z2(j2[f+428>>2]*j2[f+412>>2])+j2[r>>2],j2[(r=f+480|0)>>2]=z2(j2[f+432>>2]*j2[f+416>>2])+j2[r>>2]):(T2[f+472>>2]=0,T2[f+476>>2]=0,T2[(r=f+480|0)>>2]=0,T2[r+4>>2]=0),j2[f+508>>2]==z2(1)&&(T2[f+488>>2]=0,T2[f+492>>2]=0,T2[(f=f+496|0)>>2]=0,T2[f+4>>2]=0));}if(e=e+4|0,!((0|(i=i+1|0))<T2[A+248>>2]))break;}},_,I,function(A,f,r){return A|=0,T2[(r|=A=0)+8>>2]&T2[(f|=0)+4>>2]&&T2[f+8>>2]&T2[r+4>>2]&&(f=T2[f>>2],r=T2[r>>2],1&p2[r+204|0]&&1&p2[f+204|0]||2==T2[r+220>>2]&&2==T2[f+220>>2]||(A=1)),0|A;},I,function(A,f){var r=0,e=0,i=0;return (0|(r=T2[(f|=0)>>2]))!=(0|(e=T2[(A|=0)+88>>2]))&&T2[A+12>>2]&T2[f+4>>2]&&T2[f+8>>2]&T2[A+8>>2]&&(A=T2[T2[A+92>>2]+24>>2],i=0|n1[T2[T2[A>>2]+28>>2]](A,e,r)),0|i;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b,t,c,u,k,l,s,v=0;return j2[A+4>>2]=j2[f+40>>2],v=T2[f>>2],T2[A+80>>2]=v,T2[A+84>>2]=T2[T2[f+4>>2]+8>>2],r?(r=T2[f+12>>2],T2[A+48>>2]=T2[f+8>>2],T2[A+52>>2]=r,a=T2[(v=f+16|0)+4>>2],T2[(r=A+56|0)>>2]=T2[v>>2],T2[r+4>>2]=a):(n=j2[v+8>>2],o=j2[v+12>>2],b=j2[v+20>>2],t=j2[v+24>>2],c=j2[v+28>>2],u=j2[v+36>>2],k=j2[v+40>>2],e=j2[f+12>>2],l=j2[v+44>>2],i=j2[f+16>>2],s=j2[v+4>>2],a=j2[f+8>>2],T2[A+60>>2]=0,j2[A+56>>2]=z2(z2(a*u)+z2(e*k))+z2(i*l),j2[A+52>>2]=z2(z2(a*b)+z2(e*t))+z2(i*c),j2[A+48>>2]=z2(z2(s*a)+z2(n*e))+z2(o*i)),r=T2[f+28>>2],T2[A+64>>2]=T2[f+24>>2],T2[A+68>>2]=r,v=T2[(r=f+32|0)+4>>2],T2[(A=A+72|0)>>2]=T2[r>>2],T2[A+4>>2]=v,z2(j2[f+40>>2]);},L4,function(A){A|=0;var f,r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w=0,G=0,C=z2(0),E=z2(0),D=z2(0),h=z2(0),Z=0,Y=z2(0),R=0,F=z2(0),W=z2(0),m=0,N=z2(0),V=z2(0),J=z2(0),M=z2(0),I=z2(0),x=z2(0),y=z2(0),U=z2(0),X=z2(0),p=z2(0),T=z2(0),S=z2(0),j=z2(0),P=(z2(0)),z=z2(0),O=(z2(0)),H=(0),_=0,L=0,K=0,q=0,$=0,A2=0,f2=0,r2=0,e2=0,i2=0,a2=0,n2=(z2(0));L2=w=L2-176|0,S2[A+738|0]&&(T2[A+744>>2]=0,T2[A+36>>2]=0,S2[A+736|0]||(D=j2[A+664>>2],Z=T2[A+32>>2],X=j2[Z+4>>2],h=j2[A+668>>2],J=j2[Z+8>>2],p=j2[A+672>>2],I=j2[Z+12>>2],P=z2(z2(z2(z2(D*X)+z2(h*J))+z2(p*I))+j2[Z+52>>2]),V=j2[A+600>>2],G=T2[A+28>>2],E=j2[A+604>>2],C=j2[A+608>>2],O=z2(z2(z2(z2(V*j2[G+4>>2])+z2(E*j2[G+8>>2]))+z2(C*j2[G+12>>2]))+j2[G+52>>2]),M=z2(P-O),y=j2[Z+20>>2],U=j2[Z+24>>2],F=j2[Z+28>>2],T=z2(z2(z2(z2(D*y)+z2(h*U))+z2(p*F))+j2[Z+56>>2]),S=z2(z2(z2(z2(V*j2[G+20>>2])+z2(E*j2[G+24>>2]))+z2(C*j2[G+28>>2]))+j2[G+56>>2]),W=z2(T-S),z=D,D=j2[Z+36>>2],n2=h,h=j2[Z+40>>2],j=z2(z2(z2(z2(z*D)+z2(n2*h))+z2(p*j2[Z+44>>2]))+j2[Z+60>>2]),p=z2(z2(z2(z2(V*j2[G+36>>2])+z2(E*j2[G+40>>2]))+z2(C*j2[G+44>>2]))+j2[G+60>>2]),E=z2(j-p),C=(C=z2(z2(z2(M*M)+z2(W*W))+z2(E*E)))>z2(1.1920928955078125e-7)?(C=z2(z2(1)/z2(_2(C))),Y=z2(E*C),N=z2(W*C),z2(M*C)):z2(1),T2[140+w>>2]=0,j2[132+w>>2]=N,j2[128+w>>2]=C,j2[136+w>>2]=Y,a2=160+w|0,G=144+w|0,z2(O2(Y))>z2(.7071067690849304)?(E=z2(z2(Y*Y)+z2(N*N)),V=z2(z2(1)/z2(_2(E))),M=z2(E*V),W=z2(V*z2(-Y)),E=z2(C*W),Y=z2(N*V),N=z2(Y*z2(-C))):(E=z2(z2(C*C)+z2(N*N)),W=z2(z2(1)/z2(_2(E))),E=z2(E*W),x=z2(W*z2(-N)),N=z2(Y*x),W=z2(C*W),M=z2(W*z2(-Y)),Y=z2(0)),j2[168+w>>2]=E,j2[164+w>>2]=N,j2[152+w>>2]=Y,j2[148+w>>2]=W,j2[160+w>>2]=M,j2[144+w>>2]=x,T2[(H=108+w|0)>>2]=0,R=T2[A+28>>2],j2[(m=100+w|0)>>2]=j2[R+24>>2],j2[(_=104+w|0)>>2]=j2[R+40>>2],j2[(L=116+w|0)>>2]=j2[R+28>>2],T2[92+w>>2]=0,j2[80+w>>2]=j2[R+4>>2],j2[84+w>>2]=j2[R+20>>2],j2[88+w>>2]=j2[R+36>>2],j2[96+w>>2]=j2[R+8>>2],j2[112+w>>2]=j2[R+12>>2],T2[(K=124+w|0)>>2]=0,j2[(q=120+w|0)>>2]=j2[R+44>>2],j2[($=68+w|0)>>2]=F,T2[(A2=60+w|0)>>2]=0,j2[(f2=56+w|0)>>2]=h,j2[(r2=52+w|0)>>2]=U,T2[(e2=76+w|0)>>2]=0,j2[(i2=72+w|0)>>2]=j2[Z+44>>2],j2[64+w>>2]=I,j2[48+w>>2]=J,T2[44+w>>2]=0,j2[40+w>>2]=D,j2[36+w>>2]=y,j2[32+w>>2]=X,T2[28+w>>2]=0,j2[24+w>>2]=p-j2[R+60>>2],j2[20+w>>2]=S-j2[R+56>>2],j2[16+w>>2]=O-j2[R+52>>2],T2[12+w>>2]=0,j2[8+w>>2]=j-j2[Z+60>>2],j2[4+w>>2]=T-j2[Z+56>>2],j2[w>>2]=P-j2[Z+52>>2],j4(A+48|0,80+w|0,32+w|0,16+w|0,w,128+w|0,R+456|0,j2[R+404>>2],Z+456|0,j2[Z+404>>2]),T2[H>>2]=0,Z=T2[A+28>>2],j2[m>>2]=j2[Z+24>>2],j2[_>>2]=j2[Z+40>>2],j2[L>>2]=j2[Z+28>>2],T2[92+w>>2]=0,j2[80+w>>2]=j2[Z+4>>2],j2[84+w>>2]=j2[Z+20>>2],j2[88+w>>2]=j2[Z+36>>2],j2[96+w>>2]=j2[Z+8>>2],j2[112+w>>2]=j2[Z+12>>2],T2[K>>2]=0,j2[q>>2]=j2[Z+44>>2],T2[A2>>2]=0,R=T2[A+32>>2],j2[r2>>2]=j2[R+24>>2],j2[f2>>2]=j2[R+40>>2],j2[$>>2]=j2[R+28>>2],T2[44+w>>2]=0,j2[32+w>>2]=j2[R+4>>2],j2[36+w>>2]=j2[R+20>>2],j2[40+w>>2]=j2[R+36>>2],j2[48+w>>2]=j2[R+8>>2],j2[64+w>>2]=j2[R+12>>2],T2[e2>>2]=0,j2[i2>>2]=j2[R+44>>2],T2[28+w>>2]=0,j2[24+w>>2]=p-j2[Z+60>>2],j2[20+w>>2]=S-j2[Z+56>>2],j2[16+w>>2]=O-j2[Z+52>>2],T2[12+w>>2]=0,j2[8+w>>2]=j-j2[R+60>>2],j2[4+w>>2]=T-j2[R+56>>2],j2[w>>2]=P-j2[R+52>>2],j4(A+132|0,80+w|0,32+w|0,16+w|0,w,G,Z+456|0,j2[Z+404>>2],R+456|0,j2[R+404>>2]),T2[H>>2]=0,G=m,m=T2[A+28>>2],j2[G>>2]=j2[m+24>>2],j2[_>>2]=j2[m+40>>2],j2[L>>2]=j2[m+28>>2],T2[92+w>>2]=0,j2[80+w>>2]=j2[m+4>>2],j2[84+w>>2]=j2[m+20>>2],j2[88+w>>2]=j2[m+36>>2],j2[96+w>>2]=j2[m+8>>2],j2[112+w>>2]=j2[m+12>>2],T2[K>>2]=0,j2[q>>2]=j2[m+44>>2],T2[A2>>2]=0,G=T2[A+32>>2],j2[r2>>2]=j2[G+24>>2],j2[f2>>2]=j2[G+40>>2],j2[$>>2]=j2[G+28>>2],T2[44+w>>2]=0,j2[32+w>>2]=j2[G+4>>2],j2[36+w>>2]=j2[G+20>>2],j2[40+w>>2]=j2[G+36>>2],j2[48+w>>2]=j2[G+8>>2],j2[64+w>>2]=j2[G+12>>2],T2[e2>>2]=0,j2[i2>>2]=j2[G+44>>2],T2[28+w>>2]=0,j2[24+w>>2]=p-j2[m+60>>2],j2[20+w>>2]=S-j2[m+56>>2],j2[16+w>>2]=O-j2[m+52>>2],T2[12+w>>2]=0,j2[8+w>>2]=j-j2[G+60>>2],j2[4+w>>2]=T-j2[G+56>>2],j2[w>>2]=P-j2[G+52>>2],j4(A+216|0,80+w|0,32+w|0,16+w|0,w,a2,m+456|0,j2[m+404>>2],G+456|0,j2[G+404>>2])),i=j2[A+576>>2],n=j2[A+560>>2],a=j2[A+592>>2],C=z2(O2(a))>z2(.7071067690849304)?(C=z2(z2(i*i)+z2(a*a)),E=z2(z2(1)/z2(_2(C))),Y=z2(C*E),V=z2(E*z2(-a)),N=z2(n*V),x=z2(0),M=z2(i*E),z2(M*z2(-n))):(C=z2(z2(n*n)+z2(i*i)),E=z2(z2(1)/z2(_2(C))),N=z2(C*E),V=z2(n*E),Y=z2(V*z2(-a)),M=z2(0),x=z2(E*z2(-i)),z2(a*x)),f=T2[A+32>>2],X=j2[(v=f+36|0)>>2],J=j2[(d=f+20|0)>>2],I=j2[(B=f+40|0)>>2],y=j2[(Q=f+24|0)>>2],U=j2[(g=f+8|0)>>2],F=j2[(Z=f+44|0)>>2],D=j2[(R=f+28|0)>>2],h=j2[(H=f+12|0)>>2],r=T2[A+28>>2],o=j2[(m=r+44|0)>>2],b=j2[(_=r+36|0)>>2],t=j2[(L=r+40|0)>>2],c=j2[(K=r+12|0)>>2],u=j2[(q=r+8|0)>>2],k=j2[($=r+28|0)>>2],l=j2[(A2=r+20|0)>>2],s=j2[(f2=r+24|0)>>2],E=j2[f+4>>2],e=j2[r+4>>2],T2[A+344>>2]=0,T2[A+328>>2]=0,T2[(G=A+308|0)>>2]=0,T2[G+4>>2]=0,T2[A+300>>2]=0,T2[A+304>>2]=0,T=z2(z2(z2(x*e)+z2(V*u))+z2(M*c)),W=z2(z2(z2(x*l)+z2(V*s))+z2(M*k)),S=z2(z2(z2(x*b)+z2(V*t))+z2(M*o)),j=z2(z2(z2(c*T)+z2(k*W))+z2(o*S)),j2[A+324>>2]=j,p=z2(z2(z2(u*T)+z2(s*W))+z2(t*S)),j2[A+320>>2]=p,V=z2(z2(z2(e*T)+z2(l*W))+z2(b*S)),j2[A+316>>2]=V,z=D,D=z2(-W),M=z2(z2(z2(z*D)-z2(T*h))-z2(S*F)),j2[A+340>>2]=M,W=z2(z2(z2(y*D)-z2(T*U))-z2(S*I)),j2[A+336>>2]=W,J=z2(z2(z2(J*D)-z2(T*E))-z2(S*X)),j2[A+332>>2]=J,D=j2[(r2=r+460|0)>>2],h=j2[(e2=r+464|0)>>2],E=j2[r+456>>2],T2[A+360>>2]=0,I=z2(j*h),j2[A+356>>2]=I,y=z2(p*D),j2[A+352>>2]=y,U=z2(V*E),j2[A+348>>2]=U,F=j2[(i2=f+460|0)>>2],h=j2[(a2=f+464|0)>>2],E=j2[f+456>>2],T2[A+376>>2]=0,D=z2(M*h),j2[A+372>>2]=D,h=z2(W*F),j2[A+368>>2]=h,E=z2(J*E),j2[A+364>>2]=E,j2[A+380>>2]=z2(z2(z2(V*U)+z2(p*y))+z2(j*I))+z2(z2(z2(J*E)+z2(W*h))+z2(M*D)),P=j2[_>>2],O=j2[A2>>2],T=j2[L>>2],S=j2[q>>2],j=j2[f2>>2],p=j2[m>>2],V=j2[K>>2],M=j2[$>>2],W=j2[v>>2],X=j2[d>>2],J=j2[B>>2],I=j2[Q>>2],y=j2[g>>2],U=j2[Z>>2],F=j2[R>>2],D=j2[H>>2],h=j2[r+4>>2],E=j2[f+4>>2],T2[A+428>>2]=0,T2[A+412>>2]=0,T2[(G=A+392|0)>>2]=0,T2[G+4>>2]=0,T2[(G=A+384|0)>>2]=0,T2[G+4>>2]=0,z=F,x=z2(z2(z2(Y*l)+z2(C*s))+z2(N*k)),F=z2(-x),n2=D,D=z2(z2(z2(Y*e)+z2(C*u))+z2(N*c)),C=z2(z2(z2(Y*b)+z2(C*t))+z2(N*o)),Y=z2(z2(z2(z*F)-z2(n2*D))-z2(U*C)),j2[A+424>>2]=Y,N=z2(z2(z2(I*F)-z2(D*y))-z2(C*J)),j2[A+420>>2]=N,W=z2(z2(z2(X*F)-z2(D*E))-z2(C*W)),j2[A+416>>2]=W,X=z2(z2(z2(D*V)+z2(x*M))+z2(C*p)),j2[A+408>>2]=X,J=z2(z2(z2(D*S)+z2(x*j))+z2(C*T)),j2[A+404>>2]=J,I=z2(z2(z2(D*h)+z2(x*O))+z2(C*P)),j2[A+400>>2]=I,h=j2[r2>>2],E=j2[e2>>2],C=j2[r+456>>2],T2[A+444>>2]=0,y=z2(X*E),j2[A+440>>2]=y,U=z2(J*h),j2[A+436>>2]=U,F=z2(I*C),j2[A+432>>2]=F,D=j2[i2>>2],E=j2[a2>>2],C=j2[f+456>>2],T2[A+460>>2]=0,h=z2(Y*E),j2[A+456>>2]=h,E=z2(N*D),j2[A+452>>2]=E,C=z2(W*C),j2[A+448>>2]=C,j2[A+464>>2]=z2(z2(z2(I*F)+z2(J*U))+z2(X*y))+z2(z2(z2(W*C)+z2(N*E))+z2(Y*h)),O=j2[_>>2],T=j2[A2>>2],S=j2[L>>2],j=j2[q>>2],p=j2[f2>>2],V=j2[m>>2],M=j2[K>>2],W=j2[$>>2],X=j2[v>>2],J=j2[d>>2],I=j2[B>>2],y=j2[Q>>2],U=j2[g>>2],F=j2[Z>>2],D=j2[R>>2],h=j2[H>>2],E=j2[r+4>>2],C=j2[f+4>>2],T2[A+512>>2]=0,T2[A+496>>2]=0,T2[(G=A+476|0)>>2]=0,T2[G+4>>2]=0,T2[(G=A+468|0)>>2]=0,T2[G+4>>2]=0,z=D,x=z2(z2(z2(n*l)+z2(i*s))+z2(a*k)),D=z2(-x),e=z2(z2(z2(n*e)+z2(i*u))+z2(a*c)),z=z2(z2(z*D)-z2(h*e)),h=z2(z2(z2(n*b)+z2(i*t))+z2(a*o)),Y=z2(z-z2(F*h)),j2[A+508>>2]=Y,N=z2(z2(z2(y*D)-z2(e*U))-z2(h*I)),j2[A+504>>2]=N,P=z2(z2(z2(J*D)-z2(e*C))-z2(h*X)),j2[A+500>>2]=P,X=z2(z2(z2(e*M)+z2(x*W))+z2(h*V)),j2[A+492>>2]=X,J=z2(z2(z2(e*j)+z2(x*p))+z2(h*S)),j2[A+488>>2]=J,I=z2(z2(z2(e*E)+z2(x*T))+z2(h*O)),j2[A+484>>2]=I,h=j2[r2>>2],E=j2[e2>>2],C=j2[r+456>>2],T2[A+528>>2]=0,y=z2(X*E),j2[A+524>>2]=y,U=z2(J*h),j2[A+520>>2]=U,F=z2(I*C),j2[A+516>>2]=F,D=j2[i2>>2],E=j2[a2>>2],C=j2[f+456>>2],T2[A+724>>2]=0,T2[A+544>>2]=0,h=z2(Y*E),j2[A+540>>2]=h,E=z2(N*D),j2[A+536>>2]=E,C=z2(P*C),j2[A+532>>2]=C,j2[A+548>>2]=z2(z2(z2(I*F)+z2(J*U))+z2(X*y))+z2(z2(z2(P*C)+z2(N*E))+z2(Y*h)),C=K4(A,r+4|0,f+4|0),T2[(G=A+708|0)>>2]=0,T2[G+4>>2]=0,j2[A+728>>2]=C,p2[A+716|0]=0,(E=j2[A+692>>2])>=z2(0)&&((Y=o2(z2(C-j2[A+688>>2])))<z2(-3.1415927410125732)?Y=z2(Y+z2(6.2831854820251465)):Y>z2(3.1415927410125732)&&(Y=z2(Y+z2(-6.2831854820251465))),z2(-E)>Y?(T2[A+712>>2]=1065353216,p2[A+716|0]=1,j2[A+708>>2]=-z2(E+Y)):E<Y&&(T2[A+712>>2]=-1082130432,p2[A+716|0]=1,j2[A+708>>2]=E-Y)),h=j2[(m=A)+560>>2],G=T2[A+28>>2],E=j2[A+576>>2],C=j2[A+592>>2],F=z2(z2(z2(h*j2[G+4>>2])+z2(E*j2[G+8>>2]))+z2(C*j2[G+12>>2])),D=z2(z2(z2(h*j2[G+20>>2])+z2(E*j2[G+24>>2]))+z2(C*j2[G+28>>2])),C=z2(z2(z2(h*j2[G+36>>2])+z2(E*j2[G+40>>2]))+z2(C*j2[G+44>>2])),A=T2[A+32>>2],j2[m+720>>2]=z2(1)/z2(z2(z2(z2(F*z2(z2(z2(F*j2[G+324>>2])+z2(D*j2[G+340>>2]))+z2(C*j2[G+356>>2])))+z2(D*z2(z2(z2(F*j2[G+328>>2])+z2(D*j2[G+344>>2]))+z2(C*j2[G+360>>2]))))+z2(C*z2(z2(z2(F*j2[G+332>>2])+z2(D*j2[G+348>>2]))+z2(C*j2[G+364>>2]))))+z2(z2(z2(F*z2(z2(z2(F*j2[A+324>>2])+z2(D*j2[A+340>>2]))+z2(C*j2[A+356>>2])))+z2(D*z2(z2(z2(F*j2[A+328>>2])+z2(D*j2[A+344>>2]))+z2(C*j2[A+360>>2]))))+z2(C*z2(z2(z2(F*j2[A+332>>2])+z2(D*j2[A+348>>2]))+z2(C*j2[A+364>>2])))))),L2=176+w|0;},function(A,f){A|=0,f|=0;var r,e,i=z2(0);if(S2[A+738|0])return T2[f>>2]=0,void(T2[f+4>>2]=0);T2[f>>2]=5,T2[f+4>>2]=1,i=K4(A,T2[A+28>>2]+4|0,T2[A+32>>2]+4|0),T2[(e=A+708|0)>>2]=0,T2[4+e>>2]=0,j2[A+728>>2]=i,p2[A+716|0]=0;A:{f:{if((r=j2[A+692>>2])>=z2(0)){if((i=o2(z2(i-j2[A+688>>2])))<z2(-3.1415927410125732)?i=z2(i+z2(6.2831854820251465)):i>z2(3.1415927410125732)&&(i=z2(i+z2(-6.2831854820251465))),z2(-r)>i){T2[A+712>>2]=1065353216,p2[A+716|0]=1,j2[A+708>>2]=-z2(r+i);break f;}if(r<i){T2[A+712>>2]=-1082130432,p2[A+716|0]=1,j2[A+708>>2]=r-i;break f;}}if(!S2[A+737|0])break A;}T2[f>>2]=T2[f>>2]+1,T2[f+4>>2]=T2[f+4>>2]-1;}},function(A,f){A|=0,f|=0;var r,e=z2(0),i=z2(0),a=z2(0),n=0,o=0,b=z2(0),t=z2(0),c=0,u=z2(0),k=0,l=z2(0),s=z2(0),v=z2(0),d=z2(0),B=z2(0),Q=z2(0),g=z2(0),w=z2(0),G=z2(0),C=0,E=z2(0),D=0,h=z2(0),Z=z2(0),Y=z2(0),R=z2(0),F=0,W=0,m=z2(0),N=z2(0),V=z2(0),J=z2(0),M=0,I=z2(0),x=z2(0),y=z2(0),U=z2(0),X=z2(0),p=z2(0),T=z2(0),S=0,j=z2(0),P=z2(0),z=z2(0),O=z2(0),H=z2(0),_=z2(0),L=z2(0),K=z2(0),q=z2(0),$=z2(0),A2=z2(0),f2=z2(0),r2=z2(0),c=T2[f+24>>2],e2=T2[A+32>>2],i2=T2[A+28>>2];A:{if(S2[A+739|0]){if(a=j2[T2[A+32>>2]+404>>2],_=j2[T2[A+28>>2]+404>>2],e=(e=z2(a+_))>z2(0)?z2(a/e):z2(.5),i=z2(z2(1)-e),v=j2[e2+36>>2],u=j2[A+664>>2],l=j2[e2+40>>2],G=j2[A+668>>2],B=j2[e2+44>>2],b=j2[A+672>>2],s=j2[e2+60>>2],L=z2(z2(z2(z2(v*u)+z2(l*G))+z2(B*b))+s),x=h=z2(L-s),s=j2[A+560>>2],w=j2[i2+36>>2],g=j2[A+576>>2],Q=j2[i2+40>>2],t=j2[A+592>>2],Y=j2[i2+44>>2],j=z2(z2(z2(s*w)+z2(g*Q))+z2(t*Y)),d=j2[A+624>>2],J=z2(d*v),v=j2[A+640>>2],J=z2(J+z2(v*l)),l=j2[A+656>>2],P=z2(J+z2(l*B)),B=z2(z2(j*e)+z2(P*i)),I=z2((J=B)*B),R=j2[i2+4>>2],m=j2[i2+8>>2],N=j2[i2+12>>2],z=z2(z2(z2(R*s)+z2(m*g))+z2(N*t)),E=j2[e2+4>>2],Z=j2[e2+8>>2],y=j2[e2+12>>2],O=z2(z2(z2(E*d)+z2(Z*v))+z2(y*l)),B=z2(z2(z*e)+z2(O*i)),V=j2[i2+20>>2],X=j2[i2+24>>2],H=j2[i2+28>>2],p=z2(z2(z2(s*V)+z2(g*X))+z2(t*H)),U=j2[e2+20>>2],t=v,v=j2[e2+24>>2],s=l,l=j2[e2+28>>2],T=z2(z2(z2(d*U)+z2(t*v))+z2(s*l)),t=z2(z2(p*e)+z2(T*i)),d=z2(z2(1)/z2(_2(z2(I+z2(z2(B*B)+z2(t*t)))))),s=z2(J*d),J=z2(h*s),g=j2[e2+52>>2],y=z2(g+z2(z2(z2(E*u)+z2(Z*G))+z2(y*b))),h=z2(y-g),g=z2(B*d),v=z2(z2(z2(U*u)+z2(v*G))+z2(l*b)),u=j2[e2+56>>2],U=z2(v+u),v=z2(U-u),G=z2(t*d),u=z2(J+z2(z2(h*g)+z2(v*G))),l=z2(s*u),K=z2(x-l),b=j2[A+600>>2],t=j2[A+604>>2],d=j2[A+608>>2],B=j2[i2+60>>2],q=z2(z2(z2(z2(w*b)+z2(Q*t))+z2(Y*d))+B),E=z2(q-B),B=j2[i2+52>>2],$=z2(B+z2(z2(z2(R*b)+z2(m*t))+z2(N*d))),Z=z2($-B),B=z2(z2(z2(V*b)+z2(X*t))+z2(H*d)),b=j2[i2+56>>2],A2=z2(B+b),d=z2(A2-b),b=z2(z2(s*E)+z2(z2(Z*g)+z2(d*G))),I=z2(s*b),l=z2(I-l),t=z2(K-z2(i*l)),B=v,v=z2(G*u),f2=z2(B-v),r2=z2(G*b),x=z2(r2-v),v=z2(f2-z2(i*x)),u=z2(g*u),J=z2(h-u),b=z2(g*b),u=z2(b-u),B=z2(J-z2(i*u)),I=z2(E-I),h=z2(I+z2(e*l)),l=z2(d-r2),E=z2(l+z2(e*x)),b=z2(Z-b),Z=z2(b+z2(e*u)),o=_<z2(1.1920928955078125e-7)|a<z2(1.1920928955078125e-7),a=z2(z2(e*K)+z2(i*I)),d=z2(z2(e*J)+z2(i*b)),u=z2(z2(e*f2)+z2(i*l)),(b=z2(z2(a*a)+z2(z2(d*d)+z2(u*u))))>z2(1.1920928955078125e-7)?(l=a,a=z2(z2(1)/z2(_2(b))),b=z2(l*a),u=z2(u*a),a=z2(d*a)):(b=j2[A+556>>2],d=j2[A+572>>2],l=j2[A+588>>2],a=z2(z2(z2(R*b)+z2(m*d))+z2(N*l)),u=z2(z2(z2(b*V)+z2(d*X))+z2(l*H)),b=z2(z2(z2(b*w)+z2(d*Q))+z2(l*Y))),n=T2[f+12>>2],j2[n+8>>2]=z2(Z*u)-z2(E*a),j2[n+4>>2]=z2(h*a)-z2(Z*b),j2[n>>2]=z2(E*b)-z2(h*u),n=T2[f+20>>2],j2[n+8>>2]=-z2(z2(B*u)-z2(v*a)),j2[n+4>>2]=-z2(z2(t*a)-z2(B*b)),j2[n>>2]=-z2(z2(v*b)-z2(t*u)),Q=z2(z2(s*a)-z2(g*b)),Y=z2(z2(G*b)-z2(s*u)),l=z2(z2(B*Q)-z2(v*Y)),d=z2(z2(g*u)-z2(G*a)),w=z2(z2(t*Y)-z2(B*d)),m=z2(z2(v*d)-z2(t*Q)),N=z2(z2(Z*Q)-z2(E*Y)),V=z2(z2(h*Y)-z2(Z*d)),R=z2(z2(E*d)-z2(h*Q)),o&&S2[A+716|0]&&(N=z2(e*N),V=z2(e*V),R=z2(e*R),l=z2(i*l),w=z2(i*w),m=z2(i*m)),n=(k=c<<2)+T2[f+12>>2]|0,j2[n+8>>2]=N,j2[n+4>>2]=V,j2[n>>2]=R,n=T2[f+20>>2],j2[n+k>>2]=-m,j2[n+((C=c+1|0)<<2)>>2]=-w,j2[n+((D=c+2|0)<<2)>>2]=-l,l=z2(z2(B*G)-z2(v*g)),B=z2(z2(t*g)-z2(B*s)),v=z2(z2(v*s)-z2(t*G)),w=z2(z2(Z*G)-z2(E*g)),t=z2(z2(h*g)-z2(Z*s)),h=z2(z2(E*s)-z2(h*G)),o&&(w=z2(e*w),h=z2(e*h),l=z2(i*l),B=z2(i*B),v=z2(i*v),t=z2(e*t)),n=(k=(o=c<<1)<<2)+T2[f+12>>2]|0,j2[n+8>>2]=w,j2[n+4>>2]=t,j2[n>>2]=h,n=T2[f+20>>2],j2[k+n>>2]=-v,j2[((F=1|o)<<2)+n>>2]=-B,j2[((W=o+2|0)<<2)+n>>2]=-l,v=j2[(8&S2[A+748|0]?A+756|0:f+4|0)>>2],S2[A+736|0]?(e=z2(-d),i=z2(-Q),w=z2(-Y),B=z2(-b),h=z2(-u),t=z2(-a),D=T2[f+28>>2]):(l=j2[f>>2],n=T2[f+8>>2],j2[n+8>>2]=b,j2[n+4>>2]=u,j2[n>>2]=a,k=(n=c<<2)+T2[f+8>>2]|0,j2[k+8>>2]=d,j2[k+4>>2]=Q,j2[k>>2]=Y,o=(k=o<<2)+T2[f+8>>2]|0,j2[o+8>>2]=s,j2[o+4>>2]=G,j2[o>>2]=g,o=T2[f+16>>2],B=z2(-b),j2[o+8>>2]=B,h=z2(-u),j2[o+4>>2]=h,t=z2(-a),j2[o>>2]=t,w=z2(-Y),j2[n+o>>2]=w,e=z2(-d),j2[o+(D<<2)>>2]=e,i=z2(-Q),j2[o+(C<<2)>>2]=i,j2[o+k>>2]=-g,j2[o+(W<<2)>>2]=-s,j2[o+(F<<2)>>2]=-G,D=T2[f+28>>2],l=z2(v*l),E=z2(y-$),Z=z2(U-A2),R=z2(L-q),j2[D>>2]=l*z2(z2(z2(E*a)+z2(Z*u))+z2(R*b)),j2[n+D>>2]=l*z2(z2(z2(E*Y)+z2(Z*Q))+z2(R*d)),j2[k+D>>2]=l*z2(z2(z2(E*g)+z2(Z*G))+z2(R*s)),n=T2[f+20>>2]),k=T2[f+12>>2],o=P2(c,12),j2[k+o>>2]=a,j2[(C=o+4|0)+k>>2]=u,j2[(F=o+8|0)+k>>2]=b,j2[(c<<=4)+k>>2]=Y,j2[(W=8|c)+k>>2]=d,j2[(M=4|c)+k>>2]=Q,j2[n+o>>2]=t,j2[n+F>>2]=B,j2[n+C>>2]=h,j2[n+c>>2]=w,j2[n+W>>2]=e,j2[n+M>>2]=i,e=z2(v*j2[f>>2]),i=z2(z2(p*P)-z2(j*T)),l=z2(i*a),a=z2(z2(j*O)-z2(z*P)),l=z2(l+z2(a*u)),u=z2(z2(z*T)-z2(p*O)),j2[o+D>>2]=e*z2(l+z2(u*b)),j2[c+D>>2]=e*z2(z2(z2(i*Y)+z2(a*Q))+z2(u*d)),W=S2[A+716|0])F=0!=S2[A+737|0],o=(u=z2(j2[A+708>>2]*j2[A+732>>2]))>z2(0)?1:2;else {if(!S2[A+737|0])break A;u=z2(0),F=1,o=0;}if(C=P2(T2[f+24>>2],5),j2[(c=C<<2)+k>>2]=g,j2[(M=c+4|0)+k>>2]=G,j2[(S=k)+(k=c+8|0)>>2]=s,j2[n+c>>2]=-g,j2[n+k>>2]=-s,j2[n+M>>2]=-G,i=j2[A+688>>2],a=j2[A+692>>2],(e=o2(z2(i-a)))<z2(-3.1415927410125732)?e=z2(e+z2(6.2831854820251465)):e>z2(3.1415927410125732)&&(e=z2(e+z2(-6.2831854820251465))),(i=o2(z2(i+a)))<z2(-3.1415927410125732)?i=z2(i+z2(6.2831854820251465)):i>z2(3.1415927410125732)&&(i=z2(i+z2(-6.2831854820251465))),T2[(c=(C<<2)+D|0)>>2]=0,v=2&(n=T2[A+748>>2])?j2[A+764>>2]:v,D=((k=e!=i)|!W)&F){4&n&&(j2[T2[f+32>>2]+(C<<2)>>2]=j2[A+752>>2]),w=j2[A+680>>2];f:if(i<=e)a=z2(i<e?1:0);else {b=j2[A+728>>2];r:{if((t=z2(w/z2(v*j2[f>>2])))<z2(0)){if(e<=b&&b<z2(e-t)){a=z2(z2(e-b)/t);break f;}if(a=z2(0),!(b<e))break r;break f;}if(a=z2(0),!(t>z2(0)))break f;if(b<=i&&b>z2(i-t)){a=z2(z2(i-b)/t);break f;}if(i<b)break f;}a=z2(1);}j2[c>>2]=z2(z2(a*w)*j2[A+732>>2])+j2[c>>2],j2[(D=C<<2)+T2[f+36>>2]>>2]=-j2[A+684>>2],j2[D+T2[f+40>>2]>>2]=j2[A+684>>2];}if(!W)break A;return j2[c>>2]=j2[c>>2]+z2(u*z2(v*j2[f>>2])),1&n&&(j2[T2[f+32>>2]+(C<<2)>>2]=j2[A+760>>2]),e=k?(n=T2[f+36>>2]+(C<<2)|0,1!=(0|o)?(T2[n>>2]=-8388609,z2(0)):(T2[n>>2]=0,z2(34028234663852886e22))):(T2[T2[f+36>>2]+(C<<2)>>2]=-8388609,z2(34028234663852886e22)),j2[T2[f+40>>2]+(C<<2)>>2]=e,(i=j2[A+704>>2])>z2(0)&&(e=z2(z2(z2(z2(j2[i2+388>>2]*g)+z2(j2[i2+392>>2]*G))+z2(j2[i2+396>>2]*s))-z2(z2(z2(g*j2[e2+388>>2])+z2(G*j2[e2+392>>2]))+z2(s*j2[e2+396>>2]))),1!=(0|o)?e>z2(0)&&(e=z2(e*z2(-i)))<j2[c>>2]&&(j2[c>>2]=e):e<z2(0)&&(e=z2(e*z2(-i)))>j2[c>>2]&&(j2[c>>2]=e)),void(j2[c>>2]=j2[A+700>>2]*j2[c>>2]);}if(e=j2[A+624>>2],E=j2[e2+36>>2],i=j2[A+640>>2],Z=j2[e2+40>>2],j=z2(z2(e*E)+z2(i*Z)),a=j2[A+656>>2],R=j2[e2+44>>2],P=z2(a*R),m=j2[e2+20>>2],N=j2[e2+24>>2],z=z2(z2(e*m)+z2(i*N)),V=j2[e2+28>>2],O=z2(a*V),X=j2[e2+12>>2],H=z2(X*a),p=j2[e2+4>>2],T=j2[e2+8>>2],_=z2(z2(p*e)+z2(T*i)),t=j2[A+560>>2],e=j2[i2+36>>2],Q=j2[A+576>>2],i=j2[i2+40>>2],L=z2(z2(t*e)+z2(Q*i)),b=j2[A+592>>2],a=j2[i2+44>>2],y=z2(b*a),Y=j2[A+556>>2],d=j2[A+572>>2],U=z2(z2(Y*e)+z2(d*i)),v=j2[A+588>>2],K=z2(v*a),l=j2[A+584>>2],q=z2(l*a),B=j2[A+552>>2],h=j2[A+568>>2],$=z2(z2(B*e)+z2(h*i)),u=j2[i2+20>>2],s=j2[i2+24>>2],A2=z2(z2(t*u)+z2(Q*s)),g=j2[i2+28>>2],I=z2(b*g),G=j2[i2+12>>2],f2=z2(G*b),b=j2[i2+4>>2],w=j2[i2+8>>2],r2=z2(z2(b*t)+z2(w*Q)),t=j2[A+664>>2],Q=j2[A+668>>2],x=z2(z2(E*t)+z2(Z*Q)),E=j2[A+672>>2],Z=z2(z2(x+z2(R*E))+j2[e2+60>>2]),m=z2(z2(z2(z2(m*t)+z2(N*Q))+z2(V*E))+j2[e2+56>>2]),Q=z2(j2[e2+52>>2]+z2(z2(z2(p*t)+z2(T*Q))+z2(X*E))),E=j2[A+600>>2],x=i,i=j2[A+604>>2],J=a,a=j2[A+608>>2],t=j2[i2+60>>2],N=z2(z2(z2(z2(e*E)+z2(x*i))+z2(J*a))+t),e=j2[i2+56>>2],V=z2(z2(z2(z2(u*E)+z2(s*i))+z2(g*a))+e),R=j2[i2+52>>2],i=z2(R+z2(z2(z2(b*E)+z2(w*i))+z2(G*a))),k=c<<1,(F=S2[A+736|0])||(o=T2[f+8>>2],T2[o>>2]=1065353216,T2[(n=4+(c<<2)|0)+o>>2]=1065353216,T2[(k=8+(c<<3)|0)+o>>2]=1065353216,o=T2[f+16>>2],T2[o>>2]=-1082130432,T2[n+o>>2]=-1082130432,T2[o+k>>2]=-1082130432,t=j2[i2+60>>2],e=j2[i2+56>>2],R=j2[i2+52>>2],k=c<<1),n=T2[f+12>>2],T2[n+12>>2]=0,a=z2(N-t),j2[n+4>>2]=a,T2[n>>2]=0,e=z2(V-e),j2[n+8>>2]=-e,j2[(o=(C=c<<2)+n|0)>>2]=-a,a=z2(i-R),j2[o+8>>2]=a,T2[o+12>>2]=0,T2[o+4>>2]=0,j2[(o=(D=k<<2)+n|0)>>2]=e,j2[o+4>>2]=-a,T2[o+8>>2]=0,T2[o+12>>2]=0,e=j2[e2+52>>2],a=j2[e2+60>>2],t=j2[e2+56>>2],k=T2[f+20>>2],T2[k+12>>2]=0,T2[k>>2]=0,t=z2(m-t),j2[k+8>>2]=t,a=z2(Z-a),j2[k+4>>2]=-a,j2[(o=k+C|0)>>2]=a,e=z2(Q-e),j2[o+8>>2]=-e,T2[o+12>>2]=0,T2[o+4>>2]=0,j2[(o=k+D|0)>>2]=-t,j2[o+4>>2]=e,T2[o+8>>2]=0,T2[o+12>>2]=0,W=T2[A+748>>2],t=j2[(8&W?A+756|0:f+4|0)>>2],e=z2(t*j2[f>>2]),D=T2[f+28>>2],F||(j2[D>>2]=e*z2(Q-i),j2[C+D>>2]=e*z2(m-V),j2[D+(c<<3)>>2]=e*z2(Z-N)),o=P2(c,12),i=z2(z2(z2(B*b)+z2(h*w))+z2(l*G)),j2[o+n>>2]=i,F=o+4|0,a=z2(z2(z2(B*u)+z2(h*s))+z2(l*g)),j2[F+n>>2]=a,M=o+8|0,Q=z2($+q),j2[M+n>>2]=Q,r=4|(C=c<<4),u=z2(z2(z2(Y*u)+z2(d*s))+z2(v*g)),j2[r+n>>2]=u,s=z2(z2(z2(b*Y)+z2(w*d))+z2(G*v)),j2[n+C>>2]=s,S=8|C,w=z2(U+K),j2[S+n>>2]=w,j2[k+F>>2]=-a,j2[o+k>>2]=-i,j2[k+M>>2]=-Q,j2[k+r>>2]=-u,j2[k+C>>2]=-s,j2[k+S>>2]=-w,v=Q,g=z2(r2+f2),Q=z2(z+O),G=z2(A2+I),Y=z2(_+H),d=z2(z2(g*Q)-z2(G*Y)),l=i,i=z2(j+P),b=z2(L+y),Q=z2(z2(G*i)-z2(b*Q)),i=z2(z2(b*Y)-z2(g*i)),j2[o+D>>2]=z2(z2(v*d)+z2(z2(l*Q)+z2(a*i)))*e,j2[C+D>>2]=z2(z2(w*d)+z2(z2(s*Q)+z2(u*i)))*e,M=S2[A+716|0])F=(u=z2(j2[A+708>>2]*j2[A+732>>2]))>z2(0)?1:2,o=0!=S2[A+737|0];else {if(!S2[A+737|0])break A;u=z2(F=0),o=1;}if(C=P2(c,5),j2[(c=C<<2)+n>>2]=g,j2[(r=c+4|0)+n>>2]=G,j2[(S=n)+(n=c+8|0)>>2]=b,j2[k+r>>2]=-G,j2[c+k>>2]=-g,j2[n+k>>2]=-b,i=j2[A+688>>2],a=j2[A+692>>2],(e=o2(z2(i-a)))<z2(-3.1415927410125732)?e=z2(e+z2(6.2831854820251465)):e>z2(3.1415927410125732)&&(e=z2(e+z2(-6.2831854820251465))),(i=o2(z2(i+a)))<z2(-3.1415927410125732)?i=z2(i+z2(6.2831854820251465)):i>z2(3.1415927410125732)&&(i=z2(i+z2(-6.2831854820251465))),T2[(c=D+(C<<2)|0)>>2]=0,t=2&W?j2[A+764>>2]:t,n=(k=o)&((o=e!=i)|!M)){4&W&&(j2[T2[f+32>>2]+(C<<2)>>2]=j2[A+752>>2]),Q=j2[A+680>>2];f:if(i<=e)a=z2(i<e?1:0);else {s=j2[A+728>>2];r:{if((w=z2(Q/z2(t*j2[f>>2])))<z2(0)){if(e<=s&&s<z2(e-w)){a=z2(z2(e-s)/w);break f;}if(a=z2(0),!(s<e))break r;break f;}if(a=z2(0),!(w>z2(0)))break f;if(s<=i&&s>z2(i-w)){a=z2(z2(i-s)/w);break f;}if(i<s)break f;}a=z2(1);}j2[c>>2]=z2(z2(a*Q)*j2[A+732>>2])+j2[c>>2],j2[(n=C<<2)+T2[f+36>>2]>>2]=-j2[A+684>>2],j2[n+T2[f+40>>2]>>2]=j2[A+684>>2];}M&&(j2[c>>2]=j2[c>>2]+z2(u*z2(t*j2[f>>2])),1&W&&(j2[T2[f+32>>2]+(C<<2)>>2]=j2[A+760>>2]),e=o?(o=T2[f+36>>2]+(C<<2)|0,1!=(0|F)?(T2[o>>2]=-8388609,z2(0)):(T2[o>>2]=0,z2(34028234663852886e22))):(T2[T2[f+36>>2]+(C<<2)>>2]=-8388609,z2(34028234663852886e22)),j2[T2[f+40>>2]+(C<<2)>>2]=e,(i=j2[A+704>>2])>z2(0)&&(e=z2(z2(z2(z2(g*j2[i2+388>>2])+z2(G*j2[i2+392>>2]))+z2(b*j2[i2+396>>2]))-z2(z2(z2(g*j2[e2+388>>2])+z2(G*j2[e2+392>>2]))+z2(b*j2[e2+396>>2]))),1!=(0|F)?e>z2(0)&&(e=z2(e*z2(-i)))<j2[c>>2]&&(j2[c>>2]=e):e<z2(0)&&(e=z2(e*z2(-i)))>j2[c>>2]&&(j2[c>>2]=e)),j2[c>>2]=j2[A+700>>2]*j2[c>>2]);}},function(A,f,r,e){A|=0,f|=0,r=z2(r);A:{f:switch((e|=0)+1|0){case 0:case 6:break f;default:break A;}f:switch(f-1|0){case 1:return j2[A+764>>2]=r,void(T2[A+748>>2]=2|T2[A+748>>2]);case 3:return j2[A+760>>2]=r,void(T2[A+748>>2]=1|T2[A+748>>2]);case 2:return j2[A+752>>2]=r,void(T2[A+748>>2]=4|T2[A+748>>2]);case 0:break f;default:break A;}j2[A+756>>2]=r,T2[A+748>>2]=8|T2[A+748>>2];}},function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0);A:{f:switch(r+1|0){case 0:case 6:break f;default:break A;}f:switch(f-1|0){case 1:return z2(j2[A+764>>2]);case 3:return z2(j2[A+760>>2]);case 2:return z2(j2[A+752>>2]);case 0:break f;default:break A;}e=j2[A+756>>2];}return z2(e);},function(A){return 220;},function(A,f,r){A|=0,f|=0,r|=0;var e,i,a=z2(0);return S4(A,f,r),j2[f+52>>2]=j2[A+552>>2],j2[f+56>>2]=j2[A+556>>2],j2[f+60>>2]=j2[A+560>>2],j2[f+64>>2]=j2[A+564>>2],j2[f+68>>2]=j2[A+568>>2],j2[f+72>>2]=j2[A+572>>2],j2[f+76>>2]=j2[A+576>>2],j2[f+80>>2]=j2[A+580>>2],j2[f+84>>2]=j2[A+584>>2],j2[f+88>>2]=j2[A+588>>2],j2[f+92>>2]=j2[A+592>>2],j2[f+96>>2]=j2[A+596>>2],j2[f+100>>2]=j2[A+600>>2],j2[f+104>>2]=j2[A+604>>2],j2[f+108>>2]=j2[A+608>>2],j2[f+112>>2]=j2[A+612>>2],j2[f+116>>2]=j2[A+616>>2],j2[f+120>>2]=j2[A+620>>2],j2[f+124>>2]=j2[A+624>>2],j2[f+128>>2]=j2[A+628>>2],j2[f+132>>2]=j2[A+632>>2],j2[f+136>>2]=j2[A+636>>2],j2[f+140>>2]=j2[A+640>>2],j2[f+144>>2]=j2[A+644>>2],j2[f+148>>2]=j2[A+648>>2],j2[f+152>>2]=j2[A+652>>2],j2[f+156>>2]=j2[A+656>>2],j2[f+160>>2]=j2[A+660>>2],j2[f+164>>2]=j2[A+664>>2],j2[f+168>>2]=j2[A+668>>2],j2[f+172>>2]=j2[A+672>>2],j2[f+176>>2]=j2[A+676>>2],T2[f+184>>2]=S2[A+736|0],r=T2[A+684>>2],T2[f+192>>2]=T2[A+680>>2],T2[f+196>>2]=r,T2[f+188>>2]=S2[A+737|0],T2[f+180>>2]=S2[A+740|0],e=j2[A+688>>2],i=j2[A+692>>2],(a=o2(z2(e-i)))<z2(-3.1415927410125732)?a=z2(a+z2(6.2831854820251465)):a>z2(3.1415927410125732)&&(a=z2(a+z2(-6.2831854820251465))),j2[f+200>>2]=a,(a=o2(z2(e+i)))<z2(-3.1415927410125732)?a=z2(a+z2(6.2831854820251465)):a>z2(3.1415927410125732)&&(a=z2(a+z2(-6.2831854820251465))),j2[f+204>>2]=a,j2[f+208>>2]=j2[A+696>>2],r=T2[(A=A+700|0)+4>>2],T2[f+212>>2]=T2[A>>2],T2[f+216>>2]=r,20812;},function(A){return T2[(A|=0)+748>>2];},L4,function(A){A|=0;var f,r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w,G,C,E,D,h,Z=0,Y=(0),R=0;for(L2=Z=L2-144|0,T2[A+36>>2]=0,T2[(f=136+Z|0)>>2]=0,T2[4+f>>2]=0,T2[128+Z>>2]=0,Y=A+48|(T2[132+Z>>2]=0);T2[(t=(128+Z|0)+R|0)>>2]=1065353216,T2[92+Z>>2]=0,T2[108+Z>>2]=0,f=T2[A+28>>2],n=j2[f+4>>2],j2[80+Z>>2]=n,o=j2[f+20>>2],j2[84+Z>>2]=o,r=j2[f+36>>2],j2[88+Z>>2]=r,c=j2[f+8>>2],j2[96+Z>>2]=c,u=j2[f+24>>2],j2[100+Z>>2]=u,e=j2[f+40>>2],j2[104+Z>>2]=e,k=j2[f+12>>2],j2[112+Z>>2]=k,l=j2[f+28>>2],j2[116+Z>>2]=l,T2[124+Z>>2]=0,a=j2[f+44>>2],j2[120+Z>>2]=a,T2[44+Z>>2]=0,T2[60+Z>>2]=0,i=T2[A+32>>2],s=j2[i+4>>2],j2[32+Z>>2]=s,v=j2[i+20>>2],j2[36+Z>>2]=v,d=j2[i+36>>2],j2[40+Z>>2]=d,B=j2[i+8>>2],j2[48+Z>>2]=B,Q=j2[i+24>>2],j2[52+Z>>2]=Q,g=j2[i+40>>2],j2[56+Z>>2]=g,w=j2[i+12>>2],j2[64+Z>>2]=w,G=j2[i+28>>2],j2[68+Z>>2]=G,T2[76+Z>>2]=0,C=j2[i+44>>2],j2[72+Z>>2]=C,T2[28+Z>>2]=0,b=r,r=j2[A+300>>2],D=e,e=j2[A+304>>2],h=a,a=j2[A+308>>2],E=j2[f+60>>2],j2[24+Z>>2]=z2(z2(z2(z2(b*r)+z2(D*e))+z2(h*a))+E)-E,b=z2(z2(z2(r*o)+z2(e*u))+z2(a*l)),o=j2[f+56>>2],j2[20+Z>>2]=z2(b+o)-o,e=z2(z2(z2(r*n)+z2(e*c))+z2(a*k)),r=j2[f+52>>2],j2[16+Z>>2]=z2(e+r)-r,T2[12+Z>>2]=0,r=j2[A+316>>2],e=j2[A+320>>2],a=j2[A+324>>2],n=j2[i+60>>2],j2[8+Z>>2]=z2(z2(z2(z2(d*r)+z2(g*e))+z2(C*a))+n)-n,n=j2[i+56>>2],j2[4+Z>>2]=z2(z2(z2(z2(r*v)+z2(e*Q))+z2(a*G))+n)-n,e=z2(z2(z2(r*s)+z2(e*B))+z2(a*w)),r=j2[i+52>>2],j2[Z>>2]=z2(e+r)-r,j4(Y,80+Z|0,32+Z|0,16+Z|0,Z,128+Z|0,f+456|0,j2[f+404>>2],i+456|0,j2[i+404>>2]),Y=Y+84|(T2[t>>2]=0),12!=(0|(R=R+4|0)););L2=144+Z|0;},function(A,f){A=S2[(A|=0)+344|0]?0:3,T2[(f|=0)+4>>2]=A,T2[f>>2]=A;},function(A,f){A|=0,f|=0;var r,e,i,a,n,o,b,t,c,u,k,l,s,v,d,B,Q,g,w=0,G=0,C=(z2(0)),E=(0),w=(T2[f+8>>2]);T2[w>>2]=1065353216,u=T2[f+24>>2],T2[(a=(E=u<<2)+4|0)+w>>2]=1065353216,T2[w+(g=8+(k=u<<3)|0)>>2]=1065353216,G=T2[A+28>>2],b=j2[G+8>>2],n=j2[G+12>>2],t=j2[G+20>>2],o=j2[G+24>>2],l=j2[G+28>>2],c=j2[G+36>>2],C=j2[A+304>>2],s=j2[G+40>>2],e=j2[A+308>>2],v=j2[G+44>>2],d=j2[G+4>>2],i=j2[A+300>>2],w=T2[f+12>>2],T2[w>>2]=0,T2[w+12>>2]=0,c=z2(z2(z2(i*c)+z2(C*s))+z2(e*v)),j2[w+4>>2]=c,t=z2(z2(z2(i*t)+z2(C*o))+z2(e*l)),j2[w+8>>2]=-t,j2[(r=w+E|0)>>2]=-c,b=z2(z2(z2(d*i)+z2(b*C))+z2(n*e)),j2[8+r>>2]=b,T2[12+r>>2]=0,T2[4+r>>2]=0,j2[(r=w+k|0)>>2]=t,j2[4+r>>2]=-b,w=T2[A+32>>2],T2[8+r>>2]=0,T2[12+r>>2]=0,r=T2[f+16>>2],T2[r>>2]=-1082130432,T2[r+a>>2]=-1082130432,T2[r+g>>2]=-1082130432,l=j2[w+8>>2],s=j2[w+12>>2],o=j2[w+36>>2],v=j2[w+40>>2],d=j2[w+44>>2],n=j2[w+20>>2],C=j2[A+320>>2],B=j2[w+24>>2],e=j2[A+324>>2],Q=j2[w+28>>2],g=j2[w+4>>2],i=j2[A+316>>2],r=T2[f+20>>2],T2[r>>2]=0,T2[r+12>>2]=0,n=z2(z2(z2(i*n)+z2(C*B))+z2(e*Q)),j2[r+8>>2]=n,o=z2(z2(z2(i*o)+z2(C*v))+z2(e*d)),j2[r+4>>2]=-o,j2[(a=r+E|0)>>2]=o,C=z2(z2(z2(g*i)+z2(l*C))+z2(s*e)),j2[8+a>>2]=-C,T2[12+a>>2]=0,T2[4+a>>2]=0,j2[4+(r=r+k|0)>>2]=C,j2[r>>2]=-n,T2[8+r>>2]=0,T2[12+r>>2]=0,r=T2[f+28>>2],a=T2[A+332>>2],e=z2(j2[(1&a?A+336|0:f+4|0)>>2]*j2[f>>2]),j2[r>>2]=e*z2(z2(z2(C+j2[w+52>>2])-b)-j2[G+52>>2]),j2[r+E>>2]=e*z2(z2(z2(n+j2[w+56>>2])-t)-j2[G+56>>2]),j2[r+k>>2]=e*z2(z2(z2(o+j2[w+60>>2])-c)-j2[G+60>>2]),w=u<<1,2&a&&(G=T2[f+32>>2],j2[G>>2]=j2[A+340>>2],j2[G+E>>2]=j2[A+340>>2],j2[G+(w<<2)>>2]=j2[A+340>>2]),(e=j2[A+356>>2])>z2(0)&&(G=T2[f+36>>2],i=z2(-e),j2[G>>2]=i,r=T2[f+40>>2],j2[r>>2]=e,(C=j2[A+356>>2])>z2(0)&&(j2[(E=u<<2)+G>>2]=i,j2[r+E>>2]=e,C=j2[A+356>>2]),C>z2(0)&&(j2[(w<<=2)+G>>2]=i,j2[w+r>>2]=e)),j2[f+48>>2]=j2[A+352>>2];},function(A,f,r,e){A|=0,f|=0,r=z2(r);A:if(-1==(0|(e|=0))){f:switch(f-1|0){case 0:case 1:return j2[A+336>>2]=r,void(T2[A+332>>2]=1|T2[A+332>>2]);case 2:case 3:break f;default:break A;}j2[A+340>>2]=r,T2[A+332>>2]=2|T2[A+332>>2];}},function(A,f,r){A|=0,f|=0,r|=0;var e=z2(0),e=z2(34028234663852886e22);A:if(-1==(0|r)){f:switch(f-1|0){case 0:case 1:return z2(j2[A+336>>2]);case 2:case 3:break f;default:break A;}e=j2[A+340>>2];}return z2(e);},w0,function(A,f,r){return S4(A|=0,f|=0,r|=0),j2[f+52>>2]=j2[A+300>>2],j2[f+56>>2]=j2[A+304>>2],j2[f+60>>2]=j2[A+308>>2],j2[f+64>>2]=j2[A+312>>2],j2[f+68>>2]=j2[A+316>>2],j2[f+72>>2]=j2[A+320>>2],j2[f+76>>2]=j2[A+324>>2],j2[f+80>>2]=j2[A+328>>2],20928;},function(A){return T2[(A|=0)+332>>2];},_,I,function(A,f){var r,e,i=T2[(A|=0)+12>>2];T2[(f|=0)>>2]=T2[A+8>>2],T2[f+4>>2]=i,e=T2[4+(r=A+16|0)>>2],T2[(i=f+8|0)>>2]=T2[r>>2],T2[4+i>>2]=e,e=T2[4+(r=A+32|0)>>2],T2[(i=f+24|0)>>2]=T2[r>>2],T2[4+i>>2]=e,r=T2[4+(i=A+24|0)>>2],T2[f+16>>2]=T2[i>>2],T2[f+20>>2]=r,r=T2[4+(i=A+40|0)>>2],T2[f+32>>2]=T2[i>>2],T2[f+36>>2]=r,e=T2[4+(r=A+48|0)>>2],T2[(i=f+40|0)>>2]=T2[r>>2],T2[4+i>>2]=e,e=T2[4+(r=A- -64|0)>>2],T2[(i=f+56|0)>>2]=T2[r>>2],T2[4+i>>2]=e,i=T2[(A=A+56|0)+4>>2],T2[f+48>>2]=T2[A>>2],T2[f+52>>2]=i;},function(A,f){var r,e,i=T2[(f|=0)+4>>2];T2[(A|=0)+8>>2]=T2[f>>2],T2[A+12>>2]=i,e=T2[4+(r=f+8|0)>>2],T2[(i=A+16|0)>>2]=T2[r>>2],T2[4+i>>2]=e,e=T2[4+(r=f+24|0)>>2],T2[(i=A+32|0)>>2]=T2[r>>2],T2[4+i>>2]=e,r=T2[f+20>>2],T2[(i=A+24|0)>>2]=T2[f+16>>2],T2[4+i>>2]=r,r=T2[f+36>>2],T2[(i=A+40|0)>>2]=T2[f+32>>2],T2[4+i>>2]=r,e=T2[4+(r=f+40|0)>>2],T2[(i=A+48|0)>>2]=T2[r>>2],T2[4+i>>2]=e,e=T2[4+(r=f+56|0)>>2],T2[(i=A- -64|0)>>2]=T2[r>>2],T2[4+i>>2]=e,r=T2[f+52>>2],T2[(i=A+56|0)>>2]=T2[f+48>>2],T2[4+i>>2]=r,a(T2[A+4>>2]);}];function o1(){return e.byteLength/65536|0;}function b1(A){var f=0|o1(),A=f+(A|=0)|0;return f<A&&A<65536&&(A=new ArrayBuffer(P2(A,65536)),new Int8Array(A).set(p2),p2=new Int8Array(A),$=new Int16Array(A),T2=new Int32Array(A),S2=new Uint8Array(A),A2=new Uint16Array(A),T=new Uint32Array(A),j2=new Float32Array(A),X=new Float64Array(A),e=A,r.buffer=e,t1=S2),f;}return {RayCallback_hasHit:function(A){return 0!=T2[(A|=0)+8>>2]|0;},ccClosestRayCallback_static:function(){return S2[22e3]||(T2[5502]=1065353216,T2[5503]=0,p2[22092]=1,T2[5501]=7304,T2[5504]=-1,T2[5505]=0,T2[5522]=0,t(22),p2[22e3]=1),22004;},ccClosestRayCallback_reset:function(A,f,r,e,i){r|=0,e|=0,i|=0;var a,n=T2[(f|=0)+4>>2];T2[(A|=0)+20>>2]=T2[f>>2],T2[A+24>>2]=n,a=T2[(f=f+8|0)+4>>2],T2[(n=A+28|0)>>2]=T2[f>>2],T2[4+n>>2]=a,f=T2[r+4>>2],T2[A+36>>2]=T2[r>>2],T2[A+40>>2]=f,n=T2[(r=r+8|0)+4>>2],T2[(f=A+44|0)>>2]=T2[r>>2],T2[f+4>>2]=n,p2[A+88|0]=i,T2[A+12>>2]=e,T2[A+4>>2]=1065353216,T2[A+8>>2]=0;},ccClosestRayCallback_getHitNormalWorld:function(A){return (A|=0)+52|0;},ccClosestRayCallback_getHitPointWorld:function(A){return (A|=0)+68|0;},ccClosestRayCallback_getCollisionShapePtr:function(A){return T2[(A|=0)+84>>2];},ccAllRayCallback_static:function(){return S2[22096]||(p2[22136]=1,T2[5526]=1065353216,T2[5527]=0,p2[22188]=1,T2[5531]=0,T2[5532]=0,p2[22208]=1,T2[5544]=0,T2[5545]=0,p2[22228]=1,T2[5549]=0,T2[5550]=0,T2[5554]=0,T2[5555]=0,p2[22248]=1,T2[5525]=7508,T2[5529]=0,T2[5533]=0,T2[5546]=0,T2[5551]=0,T2[5556]=0,T2[5561]=0,p2[22252]=1,T2[5559]=0,T2[5560]=0,T2[5528]=-1,t(23),p2[22096]=1),22100;},ccAllRayCallback_reset:function(A,f,r,e,i){r|=0,e|=0,i|=0;var a,n=0,o=0;if(L2=o=L2-16|0,n=T2[(f|=0)+4>>2],T2[(A|=0)+40>>2]=T2[f>>2],T2[A+44>>2]=n,a=T2[(f=f+8|0)+4>>2],T2[(n=A+48|0)>>2]=T2[f>>2],T2[n+4>>2]=a,f=T2[r+4>>2],T2[A+56>>2]=T2[r>>2],T2[A+60>>2]=f,n=T2[(r=r+8|0)+4>>2],T2[(f=A- -64|0)>>2]=T2[r>>2],T2[f+4>>2]=n,p2[A+152|0]=i,T2[A+12>>2]=e,T2[A+4>>2]=1065353216,((T2[A+8>>2]=0)|(r=T2[A+136>>2]))<=-1&&(f=T2[A+144>>2],T2[A+140>>2]<=-1&&(f&&S2[A+148|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),p2[A+148|0]=1,T2[A+140>>2]=0,f=T2[A+144>>2]=0),d2((e=f)+(f=r<<2)|0,0,0-f|0)),((T2[A+136>>2]=0)|(r=T2[A+116>>2]))<=-1&&(f=T2[A+124>>2],T2[A+120>>2]<=-1&&(f&&S2[A+128|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),p2[A+128|0]=1,T2[A+120>>2]=0,f=T2[A+124>>2]=0),d2((e=f)+(f=r<<2)|0,0,0-f|0)),((T2[A+116>>2]=0)|(r=T2[A+24>>2]))<=-1)for(T2[A+28>>2]<=-1&&((f=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+28>>2]=0,T2[A+32>>2]=0,p2[A+36|0]=1),f=r<<2;f=f+4|(T2[T2[A+32>>2]+f>>2]=0),(e=r)>>>0<=(r=r+1|0)>>>0;);if(((T2[A+24>>2]=0)|(r=T2[A+96>>2]))<=-1)for(T2[A+100>>2]<=-1&&((f=T2[A+104>>2])&&S2[A+108|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+100>>2]=0,T2[A+104>>2]=0,p2[A+108|0]=1),f=r<<4;n=T2[4+o>>2],e=T2[A+104>>2]+f|0,T2[e>>2]=T2[o>>2],T2[e+4>>2]=n,n=T2[(i=8+o|0)+4>>2],T2[(e=e+8|0)>>2]=T2[i>>2],T2[e+4>>2]=n,f=f+16|0,(e=r)>>>0<=(r=r+1|0)>>>0;);if(((T2[A+96>>2]=0)|(r=T2[A+76>>2]))<=-1)for(T2[A+80>>2]<=-1&&((f=T2[A+84>>2])&&S2[A+88|0]&&(T2[5499]=T2[5499]+1,q2(T2[f-4>>2])),T2[A+80>>2]=0,T2[A+84>>2]=0,p2[A+88|0]=1),f=r<<4;n=T2[4+o>>2],e=T2[A+84>>2]+f|0,T2[e>>2]=T2[o>>2],T2[e+4>>2]=n,n=T2[(i=8+o|0)+4>>2],T2[(e=e+8|0)>>2]=T2[i>>2],T2[e+4>>2]=n,f=f+16|0,(e=r)>>>0<=(r=r+1|0)>>>0;);T2[A+76>>2]=0,L2=16+o|0;},ccAllRayCallback_getHitPointWorld:U,ccAllRayCallback_getHitNormalWorld:function(A){return (A|=0)+72|0;},ccAllRayCallback_getCollisionShapePtrs:function(A){return (A|=0)+132|0;},ManifoldPoint_get_m_positionWorldOnA:H,ManifoldPoint_get_m_positionWorldOnB:function(A){return (A|=0)+32|0;},ManifoldPoint_get_m_normalWorldOnB:function(A){return (A|=0)- -64|0;},ManifoldPoint_get_m_localPointA:_,ManifoldPoint_get_m_localPointB:function(A){return (A|=0)+16|0;},ManifoldPoint_getDistance:function(A){A|=0,z2(0);A=j2[A+80>>2];return z2(O2(A))<z2(2147483648)?0|~~A:-2147483648;},ManifoldPoint_getShape0:function(A){return T2[(A|=0)+200>>2];},ManifoldPoint_getShape1:L,ManifoldPoint_get_m_index0:function(A){return T2[(A|=0)+108>>2];},ManifoldPoint_get_m_index1:function(A){return T2[(A|=0)+112>>2];},PersistentManifold_getBody0:function(A){return T2[(A|=0)+836>>2];},PersistentManifold_getBody1:function(A){return T2[(A|=0)+840>>2];},PersistentManifold_getNumContacts:function(A){return T2[(A|=0)+844>>2];},PersistentManifold_getContactPoint:function(A,f){return A|=0,4+(P2(f|=0,208)+A|0)|0;},CollisionObject_new:function(){var A=0,f=0;return T2[5498]=T2[5498]+1,(f=K2(343))&&(T2[(A=f+19&-16)-4>>2]=f),T2[A+132>>2]=0,T2[A+136>>2]=0,T2[A>>2]=7664,T2[A+188>>2]=0,T2[A+192>>2]=0,T2[A+180>>2]=0,T2[A+184>>2]=1566444395,T2[A+172>>2]=1065353216,T2[A+176>>2]=0,T2[A+164>>2]=1065353216,T2[A+168>>2]=1065353216,p2[A+300|0]=1,T2[A+276>>2]=0,T2[A+280>>2]=0,T2[A+268>>2]=1065353216,T2[A+272>>2]=0,T2[A+260>>2]=-1,T2[A+264>>2]=-1,T2[A+252>>2]=1,T2[A+256>>2]=0,T2[A+244>>2]=1036831949,T2[A+248>>2]=1176256512,T2[A+236>>2]=0,T2[A+240>>2]=0,T2[A+228>>2]=1056964608,T2[A+232>>2]=0,T2[A+220>>2]=1,T2[A+224>>2]=0,T2[A+212>>2]=-1,T2[A+216>>2]=-1,T2[A+204>>2]=1,T2[A+208>>2]=-1,T2[(f=A+140|0)>>2]=0,T2[f+4>>2]=0,T2[(f=A+148|0)>>2]=0,T2[f+4>>2]=0,T2[(f=A+156|0)>>2]=0,T2[f+4>>2]=0,T2[(f=A+196|0)>>2]=0,T2[f+4>>2]=0,T2[A+304>>2]=0,T2[A+296>>2]=0,T2[A+288>>2]=0,T2[A+292>>2]=0,T2[A+4>>2]=1065353216,T2[A+8>>2]=0,T2[A+12>>2]=0,T2[(f=A+16|0)>>2]=0,T2[f+4>>2]=0,T2[A+24>>2]=1065353216,T2[A+28>>2]=0,T2[A+32>>2]=0,T2[(f=A+36|0)>>2]=0,T2[f+4>>2]=0,T2[A+44>>2]=1065353216,T2[A+48>>2]=0,T2[A+52>>2]=0,T2[(f=A+56|0)>>2]=0,T2[f+4>>2]=0,T2[(f=A- -64|0)>>2]=0,T2[f+4>>2]=1065353216,T2[A+72>>2]=0,T2[A+76>>2]=0,T2[(f=A+80|0)>>2]=0,T2[f+4>>2]=0,T2[A+88>>2]=1065353216,T2[A+92>>2]=0,T2[A+96>>2]=0,T2[(f=A+100|0)>>2]=0,T2[f+4>>2]=0,T2[A+112>>2]=0,T2[A+116>>2]=0,T2[A+108>>2]=1065353216,T2[(f=A+120|0)>>2]=0,T2[f+4>>2]=0,(T2[A+128>>2]=0)|A;},CollisionObject_del:q,CollisionObject_isStaticObject:function(A){return 1&T2[(A|=0)+204>>2];},CollisionObject_isKinematicObject:function(A){return (2&S2[(A|=0)+204|0])>>>1|0;},CollisionObject_isStaticOrKinematicObject:function(A){return 0!=(3&S2[(A|=0)+204|0])|0;},CollisionObject_forceActivationState:function(A,f){T2[(A|=0)+220>>2]=f|=0;},CollisionObject_activate:function(A,f){f|=0,3&S2[(A|=0)+204|0]&&!f||(4!=(-2&T2[A+220>>2])&&(T2[A+220>>2]=1),T2[A+224>>2]=0);},CollisionObject_isActive:function(A){return 2!=(0|(A=T2[(A|=0)+220>>2]))&5!=(0|A);},CollisionObject_setMaterial:function(A,f,r,e,i){A|=0,f=z2(f),r=z2(r),e=z2(e),i=z2(i),j2[A+232>>2]=f,j2[A+236>>2]=e,j2[A+228>>2]=r,j2[A+240>>2]=i,T2[A+304>>2]=T2[A+304>>2]+4;},CollisionObject_getCollisionFlags:L,CollisionObject_setCollisionFlags:function(A,f){T2[(A|=0)+204>>2]=f|=0;},CollisionObject_getWorldTransform:f2,CollisionObject_setCollisionShape:r2,CollisionObject_getCollisionShape:function(A){return T2[(A|=0)+192>>2];},CollisionObject_getCcdMotionThreshold:function(A){return z2(j2[(A|=0)+276>>2]);},CollisionObject_setCcdMotionThreshold:function(A,f){A|=0,f=z2(f),j2[A+276>>2]=f;},CollisionObject_getCcdSweptSphereRadius:function(A){return z2(j2[(A|=0)+272>>2]);},CollisionObject_setCcdSweptSphereRadius:function(A,f){A|=0,f=z2(f),j2[A+272>>2]=f;},CollisionObject_getUserIndex:function(A){return T2[(A|=0)+264>>2];},CollisionObject_setUserIndex:function(A,f){T2[(A|=0)+264>>2]=f|=0;},CollisionObject_getActivationState:function(A){return T2[(A|=0)+220>>2];},CollisionObject_setIgnoreCollisionCheck:function(A,f,r){f|=0;var e=0,i=0,a=0,n=0,e=T2[(A|=0)+288>>2];A:if(r|=0){if(T2[A+292>>2]==(0|e)&&!((0|(a=e?e<<1:1))<=(0|e))){if(a&&(T2[5498]=T2[5498]+1,(r=K2(19+(a<<2)|0))&&(T2[(n=r+19&-16)-4>>2]=r)),1<=(0|e))for(r=0,i=e;T2[r+n>>2]=T2[T2[A+296>>2]+r>>2],r=r+4|0,i=i-1|0;);(r=T2[A+296>>2])&&S2[A+300|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2]),e=T2[A+288>>2]),T2[A+296>>2]=n,T2[A+292>>2]=a,p2[A+300|0]=1;}T2[A+288>>2]=i=e+1|0,T2[T2[A+296>>2]+(e<<2)>>2]=f;}else if((0|e)<1)i=e;else {r=n=T2[A+296>>2];f:{for(;;){if(T2[r>>2]==(0|f))break f;if(r=r+4|0,(0|(i=i+1|0))==(0|e))break;}i=e;break A;}(0|e)<=(0|i)?i=e:(T2[(a=r)>>2]=T2[(r=(i=e-1|0)<<2)+n>>2],T2[A+288>>2]=i,T2[r+T2[A+296>>2]>>2]=f);}T2[A+280>>2]=0<(0|i);},CollisionShape_del:q,CollisionShape_setMaterial:function(A,f){T2[(A|=0)+16>>2]=f|=0;},CollisionShape_getMaterial:Z0,CollisionShape_setUserPointer:function(A,f){T2[(A|=0)+8>>2]=f|=0;},CollisionShape_getUserPointer:Y0,CollisionShape_getLocalScaling:function(A){return 0|n1[T2[T2[(A|=0)>>2]+28>>2]](A);},CollisionShape_setLocalScaling:function(A,f){n1[T2[T2[(A|=0)>>2]+24>>2]](A,f|=0);},CollisionShape_calculateLocalInertia:function(A,f,r){A|=0,f=z2(f),n1[T2[T2[A>>2]+32>>2]](A,f,r|=0);},CollisionShape_isCompound:function(A){return 31==T2[(A|=0)+4>>2]|0;},CollisionShape_getAabb:R0,CollisionShape_getLocalBoundingSphere:function(A){A|=0;var f,r=0;return T2[(f=44+(L2=r=L2-96|0)|0)>>2]=0,T2[4+f>>2]=0,T2[(f=56+r|0)>>2]=0,T2[4+f>>2]=0,T2[52+r>>2]=1065353216,T2[(f=r+64|0)>>2]=0,T2[4+f>>2]=0,T2[(f=76+r|0)>>2]=0,T2[4+f>>2]=0,T2[72+r>>2]=1065353216,T2[(f=84+r|0)>>2]=0,T2[4+f>>2]=0,T2[92+r>>2]=0,T2[36+r>>2]=0,T2[40+r>>2]=0,T2[32+r>>2]=1065353216,n1[T2[T2[A>>2]+8>>2]](A,32+r|0,16+r|0,r),L2=96+r|0,f=z2(j2[r>>2]-j2[16+r>>2]),A=z2(f*f),f=z2(j2[4+r>>2]-j2[20+r>>2]),A=z2(A+z2(f*f)),f=z2(j2[8+r>>2]-j2[24+r>>2]),z2(z2(z2(_2(z2(A+z2(f*f))))*z2(.5)));},CollisionShape_setMargin:function(A,f){A|=0,f=z2(f),n1[T2[T2[A>>2]+44>>2]](A,f);},BoxShape_new:function(A){A|=0;var f,r,e,i=0,a=z2(0),n=z2(0),o=0;return T2[5498]=T2[5498]+1,(o=K2(83))&&(T2[(i=o+19&-16)-4>>2]=o),T2[i+52>>2]=1025758986,T2[i+28>>2]=1065353216,T2[i+32>>2]=0,T2[i+20>>2]=1065353216,T2[i+24>>2]=1065353216,T2[i+12>>2]=0,T2[i+16>>2]=0,T2[i+4>>2]=0,T2[i+8>>2]=0,n=j2[A+8>>2],a=j2[A+4>>2],f=j2[A>>2],T2[i+48>>2]=0,f=z2(f+z2(-.03999999910593033)),j2[i+36>>2]=f,r=z2(a+z2(-.03999999910593033)),j2[i+40>>2]=r,e=z2(n+z2(-.03999999910593033)),j2[i+44>>2]=e,T2[i+60>>2]=0,T2[i>>2]=8140,n=j2[A>>2],a=j2[A+4>>2],(a=z2(j2[((j2[A+8>>2]>((o=n<a)?n:a)?!o:2)<<2)+A>>2]*z2(.10000000149011612)))<z2(.03999999910593033)&&(n=j2[i+52>>2],j2[i+52>>2]=a,a=j2[i+52>>2],T2[i+48>>2]=0,j2[i+44>>2]=z2(n+e)-a,j2[i+40>>2]=z2(n+r)-a,j2[i+36>>2]=z2(n+f)-a),0|i;},BoxShape_setUnscaledHalfExtents:function(A,f){A|=0,f|=0;var r=z2(0),r=(z2(n1[T2[T2[A>>2]+48>>2]](A))),e=z2(n1[T2[T2[A>>2]+48>>2]](A)),i=z2(n1[T2[T2[A>>2]+48>>2]](A)),a=j2[f>>2],n=j2[f+4>>2],o=j2[f+8>>2];T2[A+48>>2]=0,j2[A+44>>2]=z2(o*j2[A+28>>2])-i,j2[A+40>>2]=z2(n*j2[A+24>>2])-e,j2[A+36>>2]=z2(a*j2[A+20>>2])-r,r=j2[f>>2],e=j2[f+4>>2],r=z2(j2[((j2[f+8>>2]>((a=r<e)?r:e)?!a:2)<<2)+f>>2]*z2(.10000000149011612)),z2(n1[T2[T2[A>>2]+48>>2]](A))>r&&n1[T2[T2[A>>2]+44>>2]](A,r);},SphereShape_new:function(A){A=z2(A);var f=0,r=0;return T2[5498]=T2[5498]+1,(r=K2(79))&&(T2[(f=r+19&-16)-4>>2]=r),T2[f+32>>2]=0,T2[f+36>>2]=0,T2[f+12>>2]=0,T2[f+16>>2]=0,T2[f+4>>2]=8,T2[f+8>>2]=0,T2[f+28>>2]=1065353216,T2[f+20>>2]=1065353216,T2[f+24>>2]=1065353216,T2[f>>2]=11936,T2[f+56>>2]=0,j2[f+52>>2]=A,j2[f+36>>2]=A,T2[(r=f+40|0)>>2]=0,T2[r+4>>2]=0,(T2[f+48>>2]=0)|f;},SphereShape_setUnscaledRadius:function(A,f){A|=0,f=z2(f),j2[A+52>>2]=f,j2[A+36>>2]=f;},CapsuleShape_new:function(A,f){A=z2(A),f=z2(f);var r,e=0;return T2[5498]=T2[5498]+1,(r=K2(83))&&(T2[(e=r+19&-16)-4>>2]=r),T2[e+28>>2]=1065353216,T2[e+32>>2]=0,T2[e+20>>2]=1065353216,T2[e+24>>2]=1065353216,T2[e+12>>2]=0,T2[e+16>>2]=0,T2[e+4>>2]=10,T2[e+8>>2]=0,j2[e+52>>2]=A,T2[e>>2]=8500,T2[e+60>>2]=1,T2[e+48>>2]=0,j2[e+44>>2]=A,j2[e+36>>2]=A,j2[e+40>>2]=f*z2(.5),0|e;},CapsuleShape_updateProp:function(A,f,r,e){A|=0,f=z2(f),r=z2(r),e|=0;var i,a=z2(0),n=z2(0);T2[A+20>>2]=1065353216,T2[A+24>>2]=1065353216,T2[A+60>>2]=e,T2[(i=A+28|0)>>2]=1065353216,n=f,a=r;A:{f:switch((T2[4+i>>2]=0)|e){case 0:n=r,a=f;break A;case 1:break A;default:break f;}a=f,f=r;}j2[A+36>>2]=n,T2[A+48>>2]=0,j2[A+44>>2]=f,j2[A+40>>2]=a,j2[A+52>>2]=j2[(A+36|0)+((e+2|0)%3<<2)>>2];},ConvexInternalShape_getImplicitShapeDimensions:function(A){return (A|=0)+36|0;},CylinderShape_new:function(A){A|=0;var f,r,e,i=0,a=z2(0),n=z2(0),o=0;return T2[5498]=T2[5498]+1,(o=K2(83))&&(T2[(i=o+19&-16)-4>>2]=o),T2[i+52>>2]=1025758986,T2[i+28>>2]=1065353216,T2[i+32>>2]=0,T2[i+20>>2]=1065353216,T2[i+24>>2]=1065353216,T2[i+12>>2]=0,T2[i+16>>2]=0,T2[i+4>>2]=35,T2[i+8>>2]=0,n=j2[A+8>>2],a=j2[A+4>>2],f=j2[A>>2],T2[i+48>>2]=0,f=z2(f+z2(-.03999999910593033)),j2[i+36>>2]=f,r=z2(a+z2(-.03999999910593033)),j2[i+40>>2]=r,e=z2(n+z2(-.03999999910593033)),j2[i+44>>2]=e,T2[i+60>>2]=1,T2[i>>2]=8664,n=j2[A>>2],a=j2[A+4>>2],(a=z2(j2[((j2[A+8>>2]>((o=n<a)?n:a)?!o:2)<<2)+A>>2]*z2(.10000000149011612)))<z2(.03999999910593033)&&(n=j2[i+52>>2],j2[i+52>>2]=a,a=j2[i+52>>2],T2[i+48>>2]=0,j2[i+44>>2]=z2(n+e)-a,j2[i+40>>2]=z2(n+r)-a,j2[i+36>>2]=z2(n+f)-a),T2[i+4>>2]=13,0|i;},CylinderShape_updateProp:function(A,f,r,e){A|=0,f=z2(f),r=z2(r),e|=0;var i,a=z2(0),n=z2(0);T2[A+20>>2]=1065353216,T2[A+24>>2]=1065353216,T2[A+60>>2]=e,T2[(i=A+28|0)>>2]=1065353216,n=f,a=r;A:{f:switch((T2[4+i>>2]=0)|e){case 0:n=r,a=f;break A;case 1:break A;default:break f;}a=f,f=r;}j2[A+36>>2]=n,T2[A+48>>2]=0,j2[(e=A+44|0)>>2]=f,j2[(i=A+40|0)>>2]=a,f=z2(n1[T2[T2[A>>2]+48>>2]](A)),r=z2(n1[T2[T2[A>>2]+48>>2]](A)),a=z2(n1[T2[T2[A>>2]+48>>2]](A)),j2[A+36>>2]=j2[A+36>>2]-f,j2[i>>2]=j2[i>>2]-r,j2[e>>2]=j2[e>>2]-a;},ConeShape_new:function(A,f){A=z2(A),f=z2(f);var r,e=0;return T2[5498]=T2[5498]+1,(r=K2(103))&&(T2[(e=r+19&-16)-4>>2]=r),T2[e+52>>2]=1025758986,T2[e+28>>2]=1065353216,T2[e+32>>2]=0,T2[e+20>>2]=1065353216,T2[e+24>>2]=1065353216,T2[e+12>>2]=0,T2[e+16>>2]=0,T2[e+4>>2]=11,T2[e+8>>2]=0,j2[e+68>>2]=f,j2[e+64>>2]=A,T2[e>>2]=8828,T2[e+80>>2]=2,T2[e+72>>2]=0,T2[e+76>>2]=1,j2[e+44>>2]=A,j2[e+40>>2]=f,j2[e+36>>2]=A,j2[e+60>>2]=A/z2(_2(z2(z2(A*A)+z2(f*f)))),0|e;},ConeShape_setRadius:function(A,f){A|=0,f=z2(f),j2[A+64>>2]=f;},ConeShape_setHeight:function(A,f){A|=0,f=z2(f),j2[A+68>>2]=f;},ConeShape_setConeUpIndex:function(A,f){A|=0;var r,e=0,i=0;A:{f:switch(0|(f|=0)){default:e=T2[A+76>>2],i=T2[A+72>>2],f=T2[A+80>>2];break A;case 0:T2[A+72>>2]=1,T2[A+76>>2]=0,i=1,f=T2[A+80>>2]=2;break A;case 1:T2[A+72>>2]=0,e=T2[A+76>>2]=1,f=T2[A+80>>2]=2;break A;case 2:break f;}T2[A+72>>2]=0,e=T2[A+76>>2]=2,f=T2[A+80>>2]=1;}j2[(r=A+36|0)+(i<<2)>>2]=j2[A+64>>2],j2[(e<<2)+r>>2]=j2[A+68>>2],j2[(f<<2)+r>>2]=j2[A+64>>2];},StaticPlaneShape_new:function(A,f){A|=0,f=z2(f);var r,e,i,a=0;return T2[5498]=T2[5498]+1,(i=K2(111))&&(T2[(a=i+19&-16)-4>>2]=i),T2[a+20>>2]=0,T2[a+12>>2]=0,T2[a+16>>2]=0,T2[a+4>>2]=35,T2[a+8>>2]=0,T2[a>>2]=9008,r=j2[A+8>>2],e=j2[A>>2],i=j2[A+4>>2],A=j2[A+12>>2],T2[a+84>>2]=1065353216,T2[a+88>>2]=0,T2[a+76>>2]=1065353216,T2[a+80>>2]=1065353216,j2[a+72>>2]=f,j2[a+68>>2]=A,T2[a+4>>2]=28,f=z2(z2(1)/z2(_2(z2(z2(z2(e*e)+z2(i*i))+z2(r*r))))),j2[a+64>>2]=r*f,j2[a+60>>2]=i*f,j2[a+56>>2]=e*f,0|a;},StaticPlaneShape_setPlaneConstant:function(A,f){A|=0,f=z2(f),j2[A+72>>2]=f;},StaticPlaneShape_getPlaneNormal:function(A){return (A|=0)+56|0;},ccCompoundShape_new:function(){var A,f=0,r=0,e=0,i=T2[5498];return (r=K2(119))&&(T2[(f=r+19&-16)-4>>2]=r),T2[(r=f+32|0)>>2]=0,T2[r+4>>2]=0,T2[f+8>>2]=0,T2[f+12>>2]=0,T2[f>>2]=9180,T2[f+96>>2]=0,T2[f+88>>2]=1065353216,T2[f+92>>2]=1065353216,T2[f+80>>2]=0,T2[f+84>>2]=1065353216,T2[f+72>>2]=0,T2[f+76>>2]=1,T2[f+64>>2]=-581039253,T2[f+68>>2]=0,T2[f+56>>2]=-581039253,T2[f+60>>2]=-581039253,T2[f+48>>2]=1566444395,T2[f+52>>2]=0,T2[f+40>>2]=1566444395,T2[f+44>>2]=1566444395,T2[f+24>>2]=0,T2[f+28>>2]=0,T2[f+4>>2]=31,T2[(A=f+16|0)>>2]=0,T2[4+A>>2]=0,T2[5498]=i+2,p2[f+36|0]=1,T2[r>>2]=0,(r=K2(59))&&(T2[(e=r+19&-16)-4>>2]=r),T2[e+32>>2]=0,p2[e+36|0]=1,T2[e+24>>2]=0,T2[e+28>>2]=0,T2[e+16>>2]=0,T2[e+8>>2]=-1,T2[e+12>>2]=0,T2[e>>2]=0,T2[e+4>>2]=0,T2[f+72>>2]=e,T2[f>>2]=12064,0|f;},CompoundShape_getNumChildShapes:k0,CompoundShape_addChildShape:function(A,f,r){A|=0,f|=0,r|=0;var e,i,a,n,o,b,t,c,u,k,l,s=0,v=0,d=0,B=z2(0),Q=0,g=0,w=(L2-128|0);if(L2=w,T2[A+76>>2]=T2[A+76>>2]+1,s=T2[(v=f+24|0)>>2],v=T2[v+4>>2],Q=T2[(d=f+8|0)>>2],d=T2[d+4>>2],c=T2[(o=f+40|0)>>2],o=T2[4+o>>2],u=T2[f+16>>2],t=T2[f+20>>2],e=T2[f>>2],i=T2[f+4>>2],k=T2[f+32>>2],a=T2[f+36>>2],l=T2[4+(b=f+56|0)>>2],T2[(n=120+w|0)>>2]=T2[b>>2],T2[4+n>>2]=l,T2[(n=104+w|0)>>2]=c,T2[4+n>>2]=o,T2[(o=72+w|0)>>2]=Q,T2[4+o>>2]=d,T2[(d=88+w|0)>>2]=s,T2[d+4>>2]=v,v=T2[f+52>>2],T2[112+w>>2]=T2[f+48>>2],T2[116+w>>2]=v,T2[96+w>>2]=k,T2[100+w>>2]=a,T2[64+w>>2]=e,T2[68+w>>2]=i,T2[80+w>>2]=u,T2[84+w>>2]=t,k=T2[r+4>>2],l=z2(n1[T2[T2[r>>2]+48>>2]](r)),n1[T2[T2[r>>2]+8>>2]](r,f,48+w|0,32+w|0),(B=j2[48+w>>2])<j2[A+40>>2]&&(j2[A+40>>2]=B),(B=j2[32+w>>2])>j2[A+56>>2]&&(j2[A+56>>2]=B),(B=j2[52+w>>2])<j2[A+44>>2]&&(j2[A+44>>2]=B),(B=j2[36+w>>2])>j2[A+60>>2]&&(j2[A+60>>2]=B),(B=j2[56+w>>2])<j2[A+48>>2]&&(j2[A+48>>2]=B),(B=j2[40+w>>2])>j2[A- -64>>2]&&(j2[A+64>>2]=B),(v=T2[A+72>>2])?(d=T2[(s=40+w|0)+4>>2],T2[(f=24+w|0)>>2]=T2[s>>2],T2[f+4>>2]=d,d=T2[(s=56+w|0)+4>>2],T2[(f=8+w|0)>>2]=T2[s>>2],T2[f+4>>2]=d,f=T2[52+w>>2],T2[w>>2]=T2[48+w>>2],T2[4+w>>2]=f,f=T2[36+w>>2],T2[16+w>>2]=T2[32+w>>2],T2[20+w>>2]=f,d=T2[A+24>>2],(f=T2[v+4>>2])?T2[v+4>>2]=0:(T2[5498]=T2[5498]+1,f=0,(s=K2(63))&&(T2[(f=s+19&-16)-4>>2]=s),T2[f>>2]=0,T2[f+4>>2]=0,T2[f+40>>2]=0,T2[(s=f+32|0)>>2]=0,T2[s+4>>2]=0,T2[(s=f+24|0)>>2]=0,T2[s+4>>2]=0,T2[(s=f+16|0)>>2]=0,T2[s+4>>2]=0,T2[(s=f+8|0)>>2]=0,T2[s+4>>2]=0),T2[f+36>>2]=d,s=T2[4+w>>2],T2[f>>2]=T2[w>>2],T2[f+4>>2]=s,T2[f+40>>2]=0,Q=T2[(d=8+w|0)+4>>2],T2[(s=f+8|0)>>2]=T2[d>>2],T2[s+4>>2]=Q,Q=T2[(d=16+w|0)+4>>2],T2[(s=f+16|0)>>2]=T2[d>>2],T2[s+4>>2]=Q,Q=T2[(d=24+w|0)+4>>2],T2[(s=f+24|0)>>2]=T2[d>>2],T2[s+4>>2]=Q,T2[f+32>>2]=0,a0(v,T2[v>>2],f),T2[v+12>>2]=T2[v+12>>2]+1):f=0,o=112+w|0,c=96+w|0,u=80+w|0,(0|(v=T2[A+24>>2]))==T2[A+28>>2]&&!((0|(t=v?v<<1:1))<=(0|v))){if(t&&(T2[5498]=T2[5498]+1,(s=K2(P2(t,80)+19|0))&&(T2[(g=s+19&-16)-4>>2]=s)),1<=(0|v))for(Q=64;d=T2[A+32>>2]+Q|0,n=T2[4+(e=d+-64|0)>>2],T2[(i=(s=Q+g|0)+-64|0)>>2]=T2[e>>2],T2[4+i>>2]=n,a=T2[4+(e=8+e|0)>>2],T2[(i=8+i|0)>>2]=T2[e>>2],T2[4+i>>2]=a,b=T2[4+(n=8+(i=d-48|0)|0)>>2],T2[(a=8+(e=s-48|0)|0)>>2]=T2[n>>2],T2[4+a>>2]=b,a=T2[4+i>>2],T2[e>>2]=T2[i>>2],T2[4+e>>2]=a,b=T2[4+(n=8+(i=d-32|0)|0)>>2],T2[(a=8+(e=s-32|0)|0)>>2]=T2[n>>2],T2[4+a>>2]=b,a=T2[4+i>>2],T2[e>>2]=T2[i>>2],T2[4+e>>2]=a,b=T2[4+(n=8+(i=d-16|0)|0)>>2],T2[(a=8+(e=s-16|0)|0)>>2]=T2[n>>2],T2[4+a>>2]=b,a=T2[4+i>>2],T2[e>>2]=T2[i>>2],T2[4+e>>2]=a,e=T2[d+4>>2],T2[s>>2]=T2[d>>2],T2[s+4>>2]=e,e=T2[(d=d+8|0)+4>>2],T2[(s=s+8|0)>>2]=T2[d>>2],T2[s+4>>2]=e,Q=Q+80|0,v=v-1|0;);(v=T2[A+32>>2])&&S2[A+36|0]&&(T2[5499]=T2[5499]+1,q2(T2[v-4>>2])),T2[A+32>>2]=g,T2[A+28>>2]=t,p2[A+36|0]=1,v=T2[A+24>>2];}d=T2[4+u>>2],v=T2[A+32>>2]+P2(v,80)|0,T2[(s=v)+16>>2]=T2[u>>2],T2[s+20>>2]=d,s=T2[68+w>>2],T2[v>>2]=T2[64+w>>2],T2[v+4>>2]=s,s=T2[4+c>>2],T2[v+32>>2]=T2[c>>2],T2[v+36>>2]=s,s=T2[4+o>>2],T2[v+48>>2]=T2[o>>2],T2[v+52>>2]=s,T2[v+64>>2]=r,d=T2[(s=72+w|0)+4>>2],T2[(r=v+8|0)>>2]=T2[s>>2],T2[r+4>>2]=d,d=T2[(s=8+u|0)+4>>2],T2[(r=v+24|0)>>2]=T2[s>>2],T2[r+4>>2]=d,d=T2[(s=8+c|0)+4>>2],T2[(r=v+40|0)>>2]=T2[s>>2],T2[r+4>>2]=d,d=T2[(s=8+o|0)+4>>2],T2[(r=v+56|0)>>2]=T2[s>>2],T2[r+4>>2]=d,T2[v+76>>2]=f,j2[v+72>>2]=l,T2[v+68>>2]=k,T2[A+24>>2]=T2[A+24>>2]+1,L2=128+w|0;},CompoundShape_removeChildShape:F0,CompoundShape_removeChildShapeByIndex:function(A,f){b0(A|=0,f|=0);},CompoundShape_getChildShape:function(A,f){return T2[64+(T2[(A|=0)+32>>2]+P2(f|=0,80)|0)>>2];},CompoundShape_updateChildTransform:function(A,f,r,e){f|=0,r|=0,e|=0;var i=0,a=0,n=0,o=0,b=0,t=0;L2=n=L2+-64|0,i=(a=T2[(A|=0)+24>>2])+1|0,a=P2(a,80)+76|0;A:{for(;;){if((0|(i=i-1|0))<1)break A;if(t=(o=T2[A+32>>2])+a|0,a=b=a-80|0,T2[t-92>>2]==(0|f))break;}if(f=o+b|0,o=T2[r+4>>2],T2[(i=a=f-76|0)>>2]=T2[r>>2],T2[i+4>>2]=o,o=T2[(i=r+8|0)+4>>2],T2[(a=a+8|0)>>2]=T2[i>>2],T2[a+4>>2]=o,t=T2[(o=r+24|0)+4>>2],T2[(i=(a=f-60|0)+8|0)>>2]=T2[o>>2],T2[i+4>>2]=t,i=T2[r+20>>2],T2[a>>2]=T2[r+16>>2],T2[a+4>>2]=i,t=T2[(o=r+40|0)+4>>2],T2[(i=(a=f-44|0)+8|0)>>2]=T2[o>>2],T2[i+4>>2]=t,i=T2[r+36>>2],T2[a>>2]=T2[r+32>>2],T2[a+4>>2]=i,o=T2[(i=r+56|0)+4>>2],T2[(a=(f=f-28|0)+8|0)>>2]=T2[i>>2],T2[a+4>>2]=o,a=T2[r+52>>2],T2[f>>2]=T2[r+48>>2],T2[f+4>>2]=a,T2[A+72>>2]){f=T2[(T2[A+32>>2]+b|0)-12>>2],n1[T2[T2[f>>2]+8>>2]](f,r,48+n|0,32+n|0),a=T2[(r=56+n|0)+4>>2],T2[(f=8+n|0)>>2]=T2[r>>2],T2[f+4>>2]=a,a=T2[(r=40+n|0)+4>>2],T2[(f=24+n|0)>>2]=T2[r>>2],T2[f+4>>2]=a,f=T2[52+n>>2],T2[n>>2]=T2[48+n>>2],T2[4+n>>2]=f,f=T2[36+n>>2],T2[16+n>>2]=T2[32+n>>2],T2[20+n>>2]=f;f:if(a=i0(o=T2[A+72>>2],r=T2[T2[A+32>>2]+b>>2])){if(0<=(0|(i=T2[o+8>>2]))){if(i)for(;;){if(!(f=T2[a+32>>2]))break f;if(a=f,!(i=i-1|0))break;}}else a=T2[o>>2];}else a=0;f=T2[4+n>>2],T2[r>>2]=T2[n>>2],T2[r+4>>2]=f,b=T2[(i=24+n|0)+4>>2],T2[(f=r+24|0)>>2]=T2[i>>2],T2[f+4>>2]=b,b=T2[(i=16+n|0)+4>>2],T2[(f=r+16|0)>>2]=T2[i>>2],T2[f+4>>2]=b,b=T2[(i=8+n|0)+4>>2],T2[(f=r+8|0)>>2]=T2[i>>2],T2[f+4>>2]=b,a0(o,a,r);}e&&n1[T2[T2[A>>2]+68>>2]](A);}L2=n+64|0;},StridingMeshInterface_del:q,TriangleMesh_new:function(){var A,f=0,r=0,e=0,i=0,i=T2[5498];return (r=K2(191))&&(T2[(f=r+19&-16)-4>>2]=r),p2[f+36|0]=1,T2[f+12>>2]=1065353216,T2[f+16>>2]=0,T2[f+4>>2]=1065353216,T2[f+8>>2]=1065353216,T2[f+32>>2]=0,T2[f+48>>2]=0,T2[f+24>>2]=0,T2[f+28>>2]=0,p2[f+100|0]=1,T2[f>>2]=9704,T2[f+96>>2]=0,p2[f+120|0]=1,T2[f+88>>2]=0,T2[f+92>>2]=0,T2[f+116>>2]=0,p2[f+140|0]=1,T2[f+108>>2]=0,T2[f+112>>2]=0,T2[f+136>>2]=0,p2[f+160|0]=1,T2[f+128>>2]=0,T2[f+132>>2]=0,T2[f+168>>2]=0,T2[f+156>>2]=0,T2[f+148>>2]=0,T2[f+152>>2]=0,$[f+164>>1]=257,T2[5498]=i+2,(r=K2(51))&&(T2[(e=r+19&-16)-4>>2]=r),r=0,(i=T2[f+32>>2])&&(T2[5499]=T2[5499]+1,q2(T2[i-4>>2]),r=T2[f+24>>2]),T2[f+32>>2]=e,p2[f+36|0]=1,T2[f+28>>2]=1,T2[(r=(r<<5)+e|0)+24>>2]=2,T2[r+28>>2]=0,T2[r+16>>2]=0,T2[r+20>>2]=16,T2[r+8>>2]=12,T2[r+12>>2]=0,T2[r>>2]=0,T2[r+4>>2]=0,T2[f+24>>2]=T2[f+24>>2]+1,r=T2[f+32>>2],T2[r+4>>2]=0,e=S2[f+164|0],T2[r+24>>2]=e?2:3,A=T2[(e?128:148)+f>>2],i=12,T2[r+8>>2]=e?12:6,T2[r>>2]=(0|A)/3,e=S2[f+165|0]?(i=16,T2[f+88>>2]):T2[f+108>>2]/3|0,T2[r+20>>2]=i,T2[r+16>>2]=0,T2[r+12>>2]=e,0|f;},TriangleMesh_del:q,TriangleMesh_addTriangle:function(A,f,r,e,i){f|=0,r|=0,e|=0,i|=0;var a=T2[(A|=0)+32>>2];T2[a>>2]=T2[a>>2]+1,l0(A,s0(A,f,i)),l0(A,s0(A,r,i)),l0(A,s0(A,e,i));},BvhTriangleMeshShape_new:function(A,f,r){A|=0,f|=0,r|=0;var e,i,a=0,n=0,o=0;return L2=n=L2-48|0,T2[5498]=T2[5498]+1,(o=K2(103))&&(T2[(a=o+19&-16)-4>>2]=o),T2[a+12>>2]=0,T2[a+16>>2]=0,T2[a+4>>2]=21,T2[a+8>>2]=0,T2[a>>2]=9804,T2[a+56>>2]=A,(T2[a+20>>2]=0)|n1[T2[T2[A>>2]+40>>2]](A)?n1[T2[T2[A>>2]+48>>2]](A,a+24|0,a+40|0):(T2[44+n>>2]=0,T2[36+n>>2]=0,T2[40+n>>2]=0,T2[32+n>>2]=1065353216,n1[T2[T2[a>>2]+68>>2]](16+n|0,a,32+n|0),j2[a+40>>2]=j2[16+n>>2]+j2[a+20>>2],T2[32+n>>2]=-1082130432,n1[T2[T2[a>>2]+68>>2]](n,a,32+n|0),i=T2[(o=8+n|0)+4>>2],T2[(A=24+n|0)>>2]=T2[o>>2],T2[A+4>>2]=i,e=T2[4+n>>2],T2[16+n>>2]=T2[n>>2],T2[20+n>>2]=e,j2[a+24>>2]=j2[16+n>>2]-j2[a+20>>2],T2[(e=40+n|0)>>2]=0,T2[4+e>>2]=0,T2[32+n>>2]=0,T2[36+n>>2]=0,T2[36+n>>2]=1065353216,n1[T2[T2[a>>2]+68>>2]](16+n|0,a,32+n|0),j2[a+44>>2]=j2[20+n>>2]+j2[a+20>>2],T2[36+n>>2]=-1082130432,n1[T2[T2[a>>2]+68>>2]](n,a,32+n|0),i=T2[o+4>>2],T2[A>>2]=T2[o>>2],T2[A+4>>2]=i,i=T2[4+n>>2],T2[16+n>>2]=T2[n>>2],T2[20+n>>2]=i,j2[a+28>>2]=j2[20+n>>2]-j2[a+20>>2],T2[e>>2]=0,T2[4+e>>2]=0,T2[e>>2]=1065353216,T2[32+n>>2]=0,T2[36+n>>2]=0,n1[T2[T2[a>>2]+68>>2]](16+n|0,a,32+n|0),T2[e>>2]=-1082130432,j2[a+48>>2]=j2[A>>2]+j2[a+20>>2],n1[T2[T2[a>>2]+68>>2]](n,a,32+n|0),e=T2[o+4>>2],T2[A>>2]=T2[o>>2],T2[A+4>>2]=e,o=T2[4+n>>2],T2[16+n>>2]=T2[n>>2],T2[20+n>>2]=o,j2[a+32>>2]=j2[A>>2]-j2[a+20>>2]),p2[a+69|(A=0)]=0,p2[a+68|0]=f,T2[a+60>>2]=0,T2[a+64>>2]=0,T2[a>>2]=10608,T2[a+4>>2]=21,r&&(T2[5498]=T2[5498]+1,(r=K2(191))&&(T2[(A=r+19&-16)-4>>2]=r),p2[A+80|0]=1,p2[A+60|0]=0,T2[A+52>>2]=287,T2[A+76>>2]=0,p2[A+100|0]=1,T2[A+68>>2]=0,T2[A+72>>2]=0,T2[A+96>>2]=0,p2[A+120|0]=1,T2[A+88>>2]=0,T2[A+92>>2]=0,T2[A+116>>2]=0,p2[A+140|0]=1,T2[A+108>>2]=0,T2[A+112>>2]=0,T2[A+136>>2]=0,p2[A+164|0]=1,T2[A+144>>2]=0,T2[A+128>>2]=0,T2[A+132>>2]=0,T2[A+160>>2]=0,T2[A+152>>2]=0,T2[A+156>>2]=0,T2[A+168>>2]=0,T2[A+28>>2]=2139095039,T2[A+32>>2]=0,T2[A+20>>2]=2139095039,T2[A+24>>2]=2139095039,T2[A+12>>2]=-8388609,T2[A+16>>2]=0,T2[A+4>>2]=-8388609,T2[A+8>>2]=-8388609,T2[A>>2]=10280,G0(T2[a+60>>2]=A,T2[a+56>>2],f,a+24|0,a+40|0),p2[a+69|0]=1),L2=48+n|0,0|a;},ConvexTriangleMeshShape_new:function(A){A|=0;var f,r=0,e=(0);return L2=e=L2-96|0,T2[5498]=T2[5498]+1,(f=K2(123))&&(T2[(r=f+19&-16)-4>>2]=f),T2[r+88>>2]=-1082130432,T2[r+92>>2]=0,T2[r+80>>2]=-1082130432,T2[r+84>>2]=-1082130432,T2[r+72>>2]=1065353216,T2[r+76>>2]=0,T2[r+64>>2]=1065353216,T2[r+68>>2]=1065353216,T2[r+60>>2]=0,T2[r+52>>2]=1025758986,T2[r+28>>2]=1065353216,T2[r+32>>2]=0,T2[r+20>>2]=1065353216,T2[r+24>>2]=1065353216,T2[r+12>>2]=0,T2[r+16>>2]=0,T2[r+4>>2]=3,T2[r+8>>2]=0,T2[r+100>>2]=A,T2[r>>2]=11240,p2[r+96|0]=1,S2[22256]||(T2[5569]=0,T2[5570]=0,T2[5568]=1065353216,T2[5571]=0,T2[5572]=0,T2[5574]=0,T2[5575]=0,T2[5573]=1065353216,T2[5576]=0,T2[5577]=0,T2[5581]=0,T2[5582]=0,T2[5580]=-1082130432,T2[5578]=1065353216,T2[5579]=0,T2[5583]=0,T2[5584]=0,T2[5586]=0,T2[5587]=0,T2[5585]=-1082130432,T2[5588]=0,T2[5589]=0,T2[5590]=-1082130432,T2[5591]=0,p2[22256]=1),A=d2(e,0,96),n1[T2[T2[r>>2]+76>>2]](r,22272,A,6),e=j2[r+52>>2],j2[r+64>>2]=j2[A+48>>2]-e,j2[r+80>>2]=e+j2[A>>2],j2[r+84>>2]=e+j2[A+20>>2],j2[r+88>>2]=e+j2[A+40>>2],j2[r+68>>2]=j2[A+68>>2]-e,j2[r+72>>2]=j2[A+88>>2]-e,L2=A+96|0,0|r;},EmptyShape_static:function(){return S2[22372]||(T2[5597]=0,T2[5598]=0,T2[5595]=27,T2[5596]=0,T2[5594]=11488,p2[22372]=1,T2[5599]=0),22376;},SimplexShape_new:function(A){var f;return A|=0,T2[5498]=T2[5498]+1,A=0,(f=K2(187))&&(T2[(A=f+19&-16)-4>>2]=f),p2[A+96|0]=0,T2[A+92>>2]=0,T2[A+84>>2]=-1082130432,T2[A+88>>2]=-1082130432,T2[A+76>>2]=0,T2[A+80>>2]=-1082130432,T2[A+68>>2]=1065353216,T2[A+72>>2]=1065353216,T2[A+60>>2]=0,T2[A+64>>2]=1065353216,T2[A+52>>2]=1025758986,T2[A+32>>2]=0,T2[A+24>>2]=1065353216,T2[A+28>>2]=1065353216,T2[A+16>>2]=0,T2[A+20>>2]=1065353216,T2[A+8>>2]=0,T2[A+12>>2]=0,T2[A+100>>2]=0,T2[A>>2]=11600,T2[A+4>>2]=2,0|A;},SimplexShape_addVertex:function(A,f){A|=0,f|=0,z2(0);var r,e,i,a=0;L2=a=L2-96|0,r=T2[A+100>>2],T2[A+100>>2]=r+1,i=T2[f+4>>2],T2[(e=104+(r=(r<<4)+A|0)|0)>>2]=T2[f>>2],T2[4+e>>2]=i,e=T2[(f=f+8|0)+4>>2],T2[(r=112+r|0)>>2]=T2[f>>2],T2[4+r>>2]=e,p2[A+96|0]=1,S2[22256]||(T2[5569]=0,T2[5570]=0,T2[5568]=1065353216,T2[5571]=0,T2[5572]=0,T2[5574]=0,T2[5575]=0,T2[5573]=1065353216,T2[5576]=0,T2[5577]=0,T2[5581]=0,T2[5582]=0,T2[5580]=-1082130432,T2[5578]=1065353216,T2[5579]=0,T2[5583]=0,T2[5584]=0,T2[5586]=0,T2[5587]=0,T2[5585]=-1082130432,T2[5588]=0,T2[5589]=0,T2[5590]=-1082130432,T2[5591]=0,p2[22256]=1),f=d2(a,0,96),n1[T2[T2[A>>2]+76>>2]](A,22272,f,6),a=j2[A+52>>2],j2[A+64>>2]=j2[f+48>>2]-a,j2[A+80>>2]=a+j2[f>>2],j2[A+84>>2]=a+j2[f+20>>2],j2[A+88>>2]=a+j2[f+40>>2],j2[A+68>>2]=j2[f+68>>2]-a,j2[A+72>>2]=j2[f+88>>2]-a,L2=f+96|0;},TerrainShape_new:function(A,f,r,e,i,a){A|=0,f|=0,r|=0,e=z2(e),i=z2(i),a=z2(a);var n,o=0;return T2[5498]=T2[5498]+1,(n=K2(151))&&(T2[(o=n+19&-16)-4>>2]=n),T2[o+20>>2]=0,T2[o+12>>2]=0,T2[o+16>>2]=0,T2[o+4>>2]=24,T2[o+8>>2]=0,T2[o+104>>2]=0,T2[o+100>>2]=r,j2[o+96>>2]=e,j2[o+84>>2]=a,j2[o+80>>2]=i,T2[o+76>>2]=f,T2[o+72>>2]=A,T2[o>>2]=11796,T2[o+124>>2]=1065353216,T2[o+128>>2]=0,T2[o+116>>2]=1065353216,T2[o+120>>2]=1065353216,T2[o+112>>2]=1,p2[0|(r=o+107|0)]=0,p2[r+1|0]=0,p2[r+2|0]=0,p2[r+3|0]=0,e=z2(f-1|0),j2[o+92>>2]=e,A=z2(A-1|0),j2[o+88>>2]=A,T2[o+68>>2]=0,j2[o+64>>2]=e*z2(.5),j2[o+60>>2]=z2(i+a)*z2(.5),j2[o+56>>2]=A*z2(.5),T2[o+52>>2]=0,j2[o+48>>2]=e,j2[o+44>>2]=a,j2[o+40>>2]=A,T2[o+32>>2]=0,T2[o+36>>2]=0,j2[o+28>>2]=i,(T2[o+24>>2]=0)|o;},DefaultCollisionConfiguration_static:function(){var A=0;return L2=A=L2-32|0,S2[24160]||(T2[24+A>>2]=0,T2[28+A>>2]=1,T2[16+A>>2]=4096,T2[20+A>>2]=4096,T2[8+A>>2]=0,b4(8+A|(T2[12+A>>2]=0)),t(29),p2[24160]=1),L2=32+A|0,24164;},Dispatcher_getNumManifolds:function(A){return 0|n1[T2[T2[(A|=0)>>2]+36>>2]](A);},Dispatcher_getManifoldByIndexInternal:function(A,f){return 0|n1[T2[T2[(A|=0)>>2]+40>>2]](A,f|=0);},CollisionDispatcher_new:function(){var A,f,r,e,i=0,a=0,n=0,o=0,b=0;for(L2=i=L2-32|0,A=c(10448),S2[24160]||(T2[24+i>>2]=0,T2[28+i>>2]=1,T2[16+i>>2]=4096,T2[20+i>>2]=4096,T2[8+i>>2]=0,b4(8+i|(T2[12+i>>2]=0)),t(29),p2[24160]=1),p2[A+24|0]=1,T2[A+4>>2]=2,T2[A>>2]=16084,T2[A+20>>2]=0,T2[A+10444>>2]=24164,T2[A+60>>2]=0,T2[A+28>>2]=12508,T2[A+12>>2]=0,T2[A+16>>2]=0,T2[A+64>>2]=30,r=A,e=0|n1[T2[T2[6041]+12>>2]](24164),T2[r+68>>2]=e,r=A,e=0|n1[T2[T2[6041]+8>>2]](24164),T2[r+72>>2]=e,b=A+5260|0;;){for(a=0,n=b;f=T2[A+10444>>2],r=n-5184|0,e=0|n1[T2[T2[f>>2]+16>>2]](f,o,a),T2[r>>2]=e,f=T2[A+10444>>2],r=n,e=0|n1[T2[T2[f>>2]+20>>2]](f,o,a),T2[r>>2]=e,n=n+4|0,36!=(0|(a=a+1|0)););if(b=b+144|0,36==(0|(o=o+1|0)))break;}return L2=32+i|0,0|A;},CollisionDispatcher_del:q,DbvtBroadphase_new:function(){var A,f,r=0,e=0,i=0,a=0,n=0,o=0,b=0,t=0;L2=b=L2-32|0,A=c(176),p2[A+40|0]=1,T2[A>>2]=16780,T2[A+36>>2]=0,T2[A+28>>2]=0,T2[A+32>>2]=0,p2[A+80|0]=1,T2[A+20>>2]=0,T2[A+12>>2]=-1,T2[A+16>>2]=0,T2[A+4>>2]=0,T2[A+8>>2]=0,T2[A+76>>2]=0,T2[A+68>>2]=0,T2[A+72>>2]=0,p2[A+172|0]=1,T2[A+60>>2]=0,T2[A+52>>2]=-1,T2[A+56>>2]=0,T2[A+44>>2]=0,T2[A+48>>2]=0,T2[A+168>>2]=0,T2[A+160>>2]=0,T2[A+164>>2]=0,p2[A+153|0]=0,p2[A+154|0]=1,p2[A+152|0]=1,T2[A+124>>2]=0,T2[A+100>>2]=0,T2[A+104>>2]=0,T2[A+136>>2]=0,T2[A+128>>2]=0,T2[A+132>>2]=0,T2[A+116>>2]=10,T2[A+120>>2]=1,T2[A+108>>2]=1,T2[A+112>>2]=0,a=T2[5498],(r=K2(91))&&(T2[(e=r+19&-16)-4>>2]=r),p2[e+20|0]=1,T2[e>>2]=16280,T2[e+16>>2]=0,p2[e+44|0]=1,T2[e+24>>2]=0,T2[e+8>>2]=0,T2[e+12>>2]=0,T2[e+40>>2]=0,p2[e+64|0]=1,T2[e+32>>2]=0,T2[e+36>>2]=0,T2[e+60>>2]=0,T2[e+68>>2]=0,T2[e+52>>2]=0,T2[e+56>>2]=0,T2[5498]=a+2,(r=K2(51))&&(T2[(i=r+19&-16)-4>>2]=r),(r=T2[e+16>>2])&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[e+16>>2]=i,p2[e+20|0]=1,T2[e+12>>2]=2,u4(e),T2[A+148>>2]=0,T2[A+96>>2]=e,T2[A+140>>2]=0,T2[A+144>>2]=0,T2[(i=A+84|0)>>2]=0,T2[i+4>>2]=0,T2[A+92>>2]=0,i=T2[A+160>>2],T2[20+b>>2]=0,p2[24+b|0]=1,T2[12+b>>2]=0;A:{if(2<=((T2[16+b>>2]=0)|i))for(e=i-1|0,i=36;r=T2[A+168>>2]+i|0,(n=T2[(a=r-4|0)>>2])&&S2[0|r]&&(T2[5499]=T2[5499]+1,q2(T2[n-4>>2])),T2[a>>2]=0,p2[0|r]=1,T2[(r=r-12|0)>>2]=0,i=i+20|(T2[r+4>>2]=0),e=e-1|0;);else if(1!=(0|i)){for(T2[A+164>>2]<=(e=0)&&(T2[5498]=T2[5498]+1,(r=K2(39))&&(T2[(e=r+19&-16)-4>>2]=r),(r=T2[A+168>>2])&&S2[A+172|0]&&(T2[5499]=T2[5499]+1,q2(T2[r-4>>2])),T2[A+168>>2]=e,p2[A+172|0]=1,T2[A+164>>2]=1),e=P2(i,20),i=i-1|0;;){if(r=T2[A+168>>2]+e|(n=0),T2[r+4>>2]=0,T2[r+8>>2]=0,T2[r+12>>2]=0,p2[r+16|0]=1,(0|(a=T2[4+(f=8+b|0)>>2]))<=0)T2[r+4>>2]=a;else {if(T2[5498]=T2[5498]+1,(o=K2(19+(a<<2)|0))&&(T2[(n=o+19&-16)-4>>2]=o),(o=T2[r+12>>2])&&(T2[5499]=T2[5499]+1,q2(T2[o-4>>2])),T2[r+12>>2]=n,p2[r+16|0]=1,T2[r+8>>2]=a,1!=((T2[n>>2]=o=0)|a))for(t=a-1|0,n=4;n=n+4|(T2[T2[r+12>>2]+n>>2]=0),t=t-1|0;);for(T2[r+4>>2]=a,r=T2[r+12>>2];T2[r+o>>2]=T2[T2[12+f>>2]+o>>2],o=o+4|0,a=a-1|0;);}if(e=e+20|0,!((r=i)>>>0<=(i=r+1|0)>>>0))break;}if(T2[A+160>>2]=1,!(i=T2[20+b>>2]))break A;if(!S2[24+b|0])break A;T2[5499]=T2[5499]+1,q2(T2[i-4>>2]);break A;}T2[A+160>>2]=1;}return L2=32+b|0,0|A;},DbvtBroadphase_del:q,SequentialImpulseConstraintSolver_new:function(){var A,f=0;return T2[5498]=T2[5498]+1,(A=K2(255))&&(T2[(f=A+19&-16)-4>>2]=A),p2[f+20|0]=1,T2[f>>2]=17208,T2[f+16>>2]=0,p2[f+40|0]=1,T2[f+8>>2]=0,T2[f+12>>2]=0,T2[f+36>>2]=0,p2[f+60|0]=1,T2[f+28>>2]=0,T2[f+32>>2]=0,T2[f+56>>2]=0,p2[f+80|0]=1,T2[f+48>>2]=0,T2[f+52>>2]=0,T2[f+76>>2]=0,p2[f+100|0]=1,T2[f+68>>2]=0,T2[f+72>>2]=0,T2[f+96>>2]=0,p2[f+120|0]=1,T2[f+88>>2]=0,T2[f+92>>2]=0,T2[f+116>>2]=0,p2[f+140|0]=1,T2[f+108>>2]=0,T2[f+112>>2]=0,T2[f+136>>2]=0,T2[f+128>>2]=0,T2[f+132>>2]=0,p2[f+160|0]=1,T2[f+156>>2]=0,T2[f+148>>2]=0,T2[f+152>>2]=0,p2[f+180|0]=1,T2[f+176>>2]=0,T2[f+168>>2]=0,T2[f+172>>2]=0,p2[f+208|0]=1,T2[f+232>>2]=0,T2[f+204>>2]=0,T2[f+196>>2]=0,T2[f+200>>2]=0,T2[f+224>>2]=0,T2[f+212>>2]=28,T2[f+216>>2]=27,T2[f+220>>2]=26,0|f;},SequentialImpulseConstraintSolver_del:q,CollisionWorld_get_m_useContinuous:function(A){return S2[(A|=0)+16|0];},CollisionWorld_set_m_useContinuous:function(A,f){p2[(A|=0)+16|0]=f|=0;},CollisionWorld_del:q,CollisionWorld_rayTest:function(A,f,r,e){n1[T2[T2[(A|=0)>>2]+32>>2]](A,f|=0,r|=0,e|=0);},CollisionWorld_getDispatchInfo:function(A){return (A|=0)+28|0;},CollisionWorld_addCollisionObject:function(A,f,r,e){n1[T2[T2[(A|=0)>>2]+36>>2]](A,f|=0,r|=0,e|=0);},CollisionWorld_removeCollisionObject:function(A,f){n1[T2[T2[(A|=0)>>2]+40>>2]](A,f|=0);},CollisionWorld_convexSweepTest:function(A,f,r,e,i,a){T4(A|=0,f|=0,r|=0,e|=0,i|=0,a=z2(a));},DynamicsWorld_addAction:F0,DynamicsWorld_removeAction:H4,DynamicsWorld_getSolverInfo:U,ccDiscreteDynamicsWorld_new:function(A,f,r){A|=0,f|=0,r|=0;var e=0,i=0,a=0,n=0;return L2=n=L2-32|0,T2[5498]=T2[5498]+1,(e=K2(367))&&(T2[(i=e+19&-16)-4>>2]=e),S2[24160]||(T2[24+n>>2]=0,T2[28+n>>2]=1,T2[16+n>>2]=4096,T2[20+n>>2]=4096,T2[8+n>>2]=0,b4(8+n|(T2[12+n>>2]=0)),t(29),p2[24160]=1),T2[i+16>>2]=0,p2[i+20|0]=1,T2[i+116>>2]=1101004800,T2[i+108>>2]=0,T2[(e=i)+100>>2]=1050253722,T2[e+104>>2]=1015580809,T2[e+92>>2]=1058642330,T2[e+96>>2]=1065353216,T2[e+88>>2]=0,T2[e+80>>2]=0,T2[e+84>>2]=0,p2[e+76|0]=1,T2[e+72>>2]=0,T2[e+68>>2]=f,T2[e+64>>2]=0,p2[e+60|0]=0,T2[e+56>>2]=1025758986,p2[e+54|0]=1,$[e+52>>1]=256,T2[e+48>>2]=0,p2[e+44|0]=1,T2[e+36>>2]=1,T2[e+40>>2]=1065353216,T2[e+28>>2]=0,T2[e+32>>2]=0,T2[e+24>>2]=A,T2[e+8>>2]=0,T2[e+12>>2]=0,T2[e+132>>2]=0,T2[e+136>>2]=1045220557,T2[e+124>>2]=1045220557,T2[e+128>>2]=1045220557,T2[e+112>>2]=10,T2[e+140>>2]=0,T2[e+144>>2]=1,T2[e+172>>2]=128,T2[e+148>>2]=-1121724662,T2[e+152>>2]=1036831949,T2[e+156>>2]=0,T2[e+160>>2]=1062836634,T2[e+176>>2]=1120403456,T2[e+180>>2]=1900671690,T2[e+184>>2]=0,T2[e+188>>2]=1045220557,T2[e+164>>2]=260,T2[e+168>>2]=2,T2[e+120>>2]=1065353216,T2[e>>2]=19784,p2[e+208|0]=1,T2[e+212>>2]=0,T2[e+204>>2]=0,T2[e+216>>2]=r,T2[e+196>>2]=0,T2[e+200>>2]=0,p2[e+240|0]=1,p2[e+260|0]=1,T2[e+236>>2]=0,T2[e+228>>2]=0,T2[e+232>>2]=0,T2[e+256>>2]=0,T2[e+248>>2]=0,T2[e+252>>2]=0,T2[e+264>>2]=0,T2[e+268>>2]=-1054867456,$[e+290>>1]=0,T2[(f=e+280|0)>>2]=0,T2[f+4>>2]=0,T2[e+272>>2]=0,T2[e+276>>2]=0,p2[e+308|0]=1,p2[e+336|0]=1,T2[e+304>>2]=0,p2[e+316|0]=1,T2[e+296>>2]=0,T2[e+300>>2]=0,T2[e+312>>2]=0,T2[e+332>>2]=0,T2[e+340>>2]=0,T2[e+324>>2]=0,T2[e+328>>2]=0,f=r?0:(T2[5498]=T2[5498]+1,r=0,(f=K2(255))&&(T2[(r=f+19&-16)-4>>2]=f),p2[r+20|0]=1,T2[r>>2]=17208,T2[r+16>>2]=0,p2[r+40|0]=1,T2[r+8>>2]=0,T2[r+12>>2]=0,T2[r+36>>2]=0,p2[r+60|0]=1,T2[r+28>>2]=0,T2[r+32>>2]=0,T2[r+56>>2]=0,p2[r+80|0]=1,T2[r+48>>2]=0,T2[r+52>>2]=0,T2[r+76>>2]=0,p2[r+100|0]=1,T2[r+68>>2]=0,T2[r+72>>2]=0,T2[r+96>>2]=0,p2[r+120|0]=1,T2[r+88>>2]=0,T2[r+92>>2]=0,T2[r+116>>2]=0,T2[r+168>>2]=0,T2[r+172>>2]=0,T2[r+148>>2]=0,T2[r+152>>2]=0,T2[r+128>>2]=0,T2[r+132>>2]=0,T2[r+108>>2]=0,T2[r+112>>2]=0,T2[r+196>>2]=0,T2[r+200>>2]=0,p2[r+140|0]=1,T2[r+136>>2]=0,p2[r+160|0]=1,T2[r+156>>2]=0,p2[r+180|0]=1,T2[r+176>>2]=0,p2[r+208|0]=1,T2[r+232>>2]=0,T2[r+204>>2]=0,T2[r+224>>2]=0,T2[r+212>>2]=28,T2[r+216>>2]=27,T2[r+220>>2]=26,T2[i+216>>2]=r,1),p2[e+289|0]=f,f=T2[5498],(r=K2(87))&&(T2[(a=r+19&-16)-4>>2]=r),p2[a+20|0]=1,T2[a>>2]=19576,T2[a+16>>2]=0,p2[a+40|0]=1,T2[a+8>>2]=0,T2[a+12>>2]=0,T2[a+36>>2]=0,p2[a+60|0]=1,T2[a+28>>2]=0,T2[a+32>>2]=0,T2[a+56>>2]=0,p2[a+64|0]=1,T2[a+48>>2]=0,T2[a+52>>2]=0,p2[i+288|0]=1,T2[i+220>>2]=a,T2[5498]=f+2,r=0,(f=K2(107))&&(T2[(r=f+19&-16)-4>>2]=f),T2[r>>2]=19980,T2[r+52>>2]=0,T2[r+56>>2]=0,T2[r+72>>2]=0,T2[r+76>>2]=0,T2[r+12>>2]=0,T2[r+16>>2]=0,T2[r+32>>2]=0,T2[r+36>>2]=0,p2[r+44|0]=1,T2[r+24>>2]=A,T2[r+20>>2]=0,T2[r+4>>2]=0,T2[r+40>>2]=0,p2[r+64|0]=1,T2[r+60>>2]=0,p2[r+84|0]=1,T2[r+80>>2]=0,T2[i+344>>2]=20464,T2[i>>2]=20268,T2[r+8>>2]=T2[i+216>>2],T2[i+212>>2]=r,T2[i+56>>2]=1008981770,A=T2[i+68>>2],A=0|n1[T2[T2[A>>2]+36>>2]](A),n1[T2[T2[A>>2]+44>>2]](A,i+344|0),L2=32+n|0,0|i;},DynamicsWorld_setGravity:function(A,f){n1[T2[T2[(A|=0)>>2]+72>>2]](A,f|=0);},DynamicsWorld_addRigidBody:function(A,f,r,e){n1[T2[T2[(A|=0)>>2]+88>>2]](A,f|=0,r|=0,e|=0);},DynamicsWorld_removeRigidBody:function(A,f){n1[T2[T2[(A|=0)>>2]+92>>2]](A,f|=0);},DynamicsWorld_addConstraint:function(A,f,r){n1[T2[T2[(A|=0)>>2]+56>>2]](A,f|=0,r|=0);},DynamicsWorld_removeConstraint:function(A,f){n1[T2[T2[(A|=0)>>2]+60>>2]](A,f|=0);},DynamicsWorld_stepSimulation:function(A,f,r,e){A|=0,f=z2(f),r|=0,e=z2(e),n1[T2[T2[A>>2]+52>>2]](A,f,r,e);},ccDiscreteDynamicsWorld_setAllowSleep:function(A,f){p2[23468]=1^(f|=0);},TypedConstraint_del:q,TypedConstraint_getFixedBody:function(){var A,f=0;return L2=f=L2-144|0,S2[23477]||(T2[5909]=0,T2[5910]=0,T2[5907]=0,T2[5908]=0,T2[5905]=0,T2[5906]=0,T2[5903]=0,T2[5904]=0,T2[5917]=0,T2[5918]=0,T2[5915]=0,T2[5916]=1566444395,T2[5913]=1065353216,T2[5914]=0,T2[5911]=1065353216,T2[5912]=1065353216,T2[5919]=0,T2[5920]=0,p2[23780]=1,T2[5939]=0,T2[5940]=0,T2[5937]=1065353216,T2[5938]=0,T2[5935]=-1,T2[5936]=-1,T2[5933]=1,T2[5934]=0,T2[5931]=1036831949,T2[5932]=1176256512,T2[5929]=0,T2[5930]=0,T2[5927]=1056964608,T2[5928]=0,T2[5925]=1,T2[5926]=0,T2[5923]=-1,T2[5924]=-1,T2[5921]=1,T2[5922]=-1,T2[5942]=0,T2[5943]=0,T2[5871]=1065353216,T2[5872]=0,T2[5873]=0,T2[5874]=0,T2[5875]=0,T2[5876]=1065353216,T2[5877]=0,T2[5878]=0,T2[5879]=0,T2[5880]=0,T2[5881]=1065353216,T2[5882]=0,T2[5883]=0,T2[5884]=0,T2[5885]=0,T2[5886]=0,T2[5887]=1065353216,T2[5888]=0,T2[5889]=0,T2[5890]=0,T2[5891]=0,T2[5892]=1065353216,T2[5893]=0,T2[5894]=0,T2[5895]=0,T2[5896]=0,T2[5946]=0,T2[5944]=0,T2[5898]=0,T2[5899]=0,T2[5897]=1065353216,T2[5900]=0,T2[5901]=0,p2[24040]=1,T2[5870]=17124,T2[6007]=0,T2[6008]=0,T2[5902]=0,T2[6009]=0,T2[(A=80+f|0)>>2]=0,T2[4+A>>2]=0,T2[(A=88+f|0)>>2]=0,T2[4+A>>2]=0,T2[96+f>>2]=0,T2[(A=12+f|0)>>2]=0,T2[4+A>>2]=0,T2[(A=20+f|0)>>2]=0,T2[4+A>>2]=0,T2[28+f>>2]=1065353216,T2[(A=32+f|0)>>2]=0,T2[4+A>>2]=0,T2[(A=40+f|0)>>2]=0,T2[4+A>>2]=0,T2[48+f>>2]=1065353216,T2[72+f>>2]=0,T2[76+f>>2]=0,T2[f>>2]=0,T2[4+f>>2]=0,T2[136+f>>2]=1008981770,T2[140+f>>2]=1008981770,T2[128+f>>2]=1000593162,T2[132+f>>2]=1008981770,p2[124+f|0]=0,T2[116+f>>2]=1061997773,T2[120+f>>2]=1065353216,T2[108+f>>2]=0,T2[112+f>>2]=0,T2[100+f>>2]=1056964608,T2[104+f>>2]=0,T2[8+f>>2]=1065353216,T2[68+f>>2]=0,T2[(A=60+f|0)>>2]=0,T2[4+A>>2]=0,T2[(A=52+f|0)>>2]=0,T2[4+A>>2]=0,w4(23480,f),t(31),p2[23477]=1),T2[5984]=0,T2[5985]=0,T2[5986]=0,T2[5987]=0,T2[5921]=1|T2[5921],j2[5978]=j2[5982]*z2(0),j2[5977]=j2[5981]*z2(0),j2[5976]=j2[5980]*z2(0),j2[6027]=j2[5974]*z2(0),j2[6026]=j2[5973]*z2(0),j2[6025]=j2[5972]*z2(0),T2[5971]=0,T2[5979]=0,T2[6028]=0,L2=144+f|0,23480;},HingeConstraint_new:function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i=0,a=0;return T2[5498]=T2[5498]+1,(a=K2(787))&&(T2[(i=a+19&-16)-4>>2]=a),T2[i+44>>2]=0,T2[i+36>>2]=0,T2[i+40>>2]=1028443341,T2[i+32>>2]=f,T2[i+28>>2]=A,T2[i+24>>2]=-1,$[i+20>>1]=1,T2[i+12>>2]=-1,T2[i+16>>2]=2139095039,T2[i+4>>2]=4,T2[i+8>>2]=-1,T2[i>>2]=20752,a=T2[(f=r+8|0)+4>>2],T2[(A=i+560|0)>>2]=T2[f>>2],T2[A+4>>2]=a,A=T2[r+4>>2],T2[i+552>>2]=T2[r>>2],T2[i+556>>2]=A,a=T2[(f=r+24|0)+4>>2],T2[(A=i+576|0)>>2]=T2[f>>2],T2[A+4>>2]=a,A=T2[r+20>>2],T2[i+568>>2]=T2[r+16>>2],T2[i+572>>2]=A,a=T2[(f=r+40|0)+4>>2],T2[(A=i+592|0)>>2]=T2[f>>2],T2[A+4>>2]=a,A=T2[r+36>>2],T2[i+584>>2]=T2[r+32>>2],T2[i+588>>2]=A,a=T2[(f=r+56|0)+4>>2],T2[(A=i+608|0)>>2]=T2[f>>2],T2[A+4>>2]=a,A=T2[r+52>>2],T2[i+600>>2]=T2[r+48>>2],T2[i+604>>2]=A,r=T2[(f=e+8|0)+4>>2],T2[(A=i+624|0)>>2]=T2[f>>2],T2[A+4>>2]=r,A=T2[e+4>>2],T2[i+616>>2]=T2[e>>2],T2[i+620>>2]=A,r=T2[(f=e+24|0)+4>>2],T2[(A=i+640|0)>>2]=T2[f>>2],T2[A+4>>2]=r,A=T2[e+20>>2],T2[i+632>>2]=T2[e+16>>2],T2[i+636>>2]=A,r=T2[(f=e+40|0)+4>>2],T2[(A=i+656|0)>>2]=T2[f>>2],T2[A+4>>2]=r,A=T2[e+36>>2],T2[i+648>>2]=T2[e+32>>2],T2[i+652>>2]=A,r=T2[(f=e+56|0)+4>>2],T2[(A=i+672|0)>>2]=T2[f>>2],T2[A+4>>2]=r,A=T2[e+52>>2],T2[i+664>>2]=T2[e+48>>2],T2[i+668>>2]=A,T2[i+704>>2]=1065353216,T2[i+696>>2]=1063675494,T2[i+700>>2]=1050253722,T2[i+688>>2]=0,T2[i+692>>2]=-1082130432,p2[i+716|0]=0,T2[i+708>>2]=0,T2[i+712>>2]=0,p2[i+740|0]=0,T2[i+736>>2]=16777216,T2[i+764>>2]=0,T2[(A=i+756|0)>>2]=0,T2[A+4>>2]=0,T2[i+748>>2]=0,T2[i+752>>2]=0,T2[i+732>>2]=1065353216,0|i;},HingeConstraint_setFrames:function(A,f,r){r|=0;var e,i,a=T2[(f|=0)+4>>2];T2[(A|=0)+552>>2]=T2[f>>2],T2[A+556>>2]=a,i=T2[4+(e=f+8|0)>>2],T2[(a=A+560|0)>>2]=T2[e>>2],T2[4+a>>2]=i,i=T2[4+(e=f+24|0)>>2],T2[(a=A+576|0)>>2]=T2[e>>2],T2[4+a>>2]=i,e=T2[f+20>>2],T2[(a=A+568|0)>>2]=T2[f+16>>2],T2[4+a>>2]=e,i=T2[4+(e=f+40|0)>>2],T2[(a=A+592|0)>>2]=T2[e>>2],T2[4+a>>2]=i,e=T2[f+36>>2],T2[(a=A+584|0)>>2]=T2[f+32>>2],T2[4+a>>2]=e,i=T2[4+(e=f+56|0)>>2],T2[(a=A+608|0)>>2]=T2[e>>2],T2[4+a>>2]=i,e=T2[f+52>>2],T2[(a=A+600|0)>>2]=T2[f+48>>2],T2[4+a>>2]=e,e=T2[4+(a=r+8|0)>>2],T2[(f=A+624|0)>>2]=T2[a>>2],T2[f+4>>2]=e,f=T2[r+4>>2],T2[A+616>>2]=T2[r>>2],T2[A+620>>2]=f,a=T2[r+20>>2],T2[(f=A+632|0)>>2]=T2[r+16>>2],T2[f+4>>2]=a,e=T2[4+(a=r+24|0)>>2],T2[(f=A+640|0)>>2]=T2[a>>2],T2[f+4>>2]=e,a=T2[r+36>>2],T2[(f=A+648|0)>>2]=T2[r+32>>2],T2[f+4>>2]=a,e=T2[4+(a=r+40|0)>>2],T2[(f=A+656|0)>>2]=T2[a>>2],T2[f+4>>2]=e,e=T2[4+(a=r+56|0)>>2],T2[(f=A+672|0)>>2]=T2[a>>2],T2[f+4>>2]=e,a=T2[r+52>>2],T2[(f=A+664|0)>>2]=T2[r+48>>2],T2[f+4>>2]=a,n1[T2[T2[A>>2]+8>>2]](A);},P2PConstraint_new:function(A,f,r,e){A|=0,f|=0,r|=0,e|=0;var i,a=0;return T2[5498]=T2[5498]+1,(i=K2(379))&&(T2[(a=i+19&-16)-4>>2]=i),T2[a+44>>2]=0,T2[a+36>>2]=0,T2[a+40>>2]=1028443341,T2[a+32>>2]=f,T2[a+28>>2]=A,T2[a+24>>2]=-1,$[a+20>>1]=1,T2[a+12>>2]=-1,T2[a+16>>2]=2139095039,T2[a+4>>2]=3,T2[a+8>>2]=-1,T2[a>>2]=20868,A=T2[r+4>>2],T2[a+300>>2]=T2[r>>2],T2[a+304>>2]=A,r=T2[(f=r+8|0)+4>>2],T2[(A=a+308|0)>>2]=T2[f>>2],T2[A+4>>2]=r,A=T2[e+4>>2],T2[a+316>>2]=T2[e>>2],T2[a+320>>2]=A,r=T2[(f=e+8|0)+4>>2],T2[(A=a+324|0)>>2]=T2[f>>2],T2[A+4>>2]=r,T2[a+332>>2]=0,p2[a+344|0]=0,T2[a+348>>2]=1050253722,T2[a+352>>2]=1065353216,(T2[a+356>>2]=0)|a;},P2PConstraint_setPivotA:function(A,f){var r=T2[(f|=0)+4>>2];T2[(A|=0)+300>>2]=T2[f>>2],T2[A+304>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+308|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},P2PConstraint_setPivotB:function(A,f){var r=T2[(f|=0)+4>>2];T2[(A|=0)+316>>2]=T2[f>>2],T2[A+320>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+324|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},_malloc:function(A){return 0|K2(A|=0);},_free:function(A){q2(A|=0);},_read_f32:q4,_write_f32:function(A,f){A|=0,f=z2(f),j2[A>>2]=f;},Vec3_new:function(A,f,r){A=z2(A),f=z2(f),r=z2(r);var e,i=0;return T2[5498]=T2[5498]+1,(e=K2(35))&&(T2[(i=e+19&-16)-4>>2]=e),T2[i+12>>2]=0,j2[i+8>>2]=r,j2[i+4>>2]=f,j2[i>>2]=A,0|i;},Vec3_del:$4,Vec3_set:function(A,f,r,e){A|=0,f=z2(f),r=z2(r),e=z2(e),T2[A+12>>2]=0,j2[A+8>>2]=e,j2[A+4>>2]=r,j2[A>>2]=f;},Vec3_x:q4,Vec3_y:A1,Vec3_z:f1,Quat_new:function(A,f,r,e){A=z2(A),f=z2(f),r=z2(r),e=z2(e);var i=c(16);return j2[i+12>>2]=e,j2[i+8>>2]=r,j2[i+4>>2]=f,j2[i>>2]=A,0|i;},Quat_del:$4,Quat_set:r1,Quat_x:q4,Quat_y:A1,Quat_z:f1,Quat_w:function(A){return z2(j2[(A|=0)+12>>2]);},Transform_new:function(){var A=0,f=c(64);return T2[(A=f)+4>>2]=0,T2[A+8>>2]=0,T2[A>>2]=1065353216,T2[A+24>>2]=0,T2[A+28>>2]=0,T2[A+20>>2]=1065353216,T2[A+44>>2]=0,T2[A+48>>2]=0,T2[A+40>>2]=1065353216,T2[(A=A+12|0)>>2]=0,T2[4+A>>2]=0,T2[(A=f+32|0)>>2]=0,T2[4+A>>2]=0,T2[(A=f+52|0)>>2]=0,T2[4+A>>2]=0,(T2[f+60>>2]=0)|f;},Transform_del:function(A){(A|=0)&&u(A);},Transform_setIdentity:function(A){var f;T2[(A|=0)+4>>2]=0,T2[A+8>>2]=0,T2[A>>2]=1065353216,T2[(f=A+12|0)>>2]=0,T2[4+f>>2]=0,T2[(f=A+24|0)>>2]=0,T2[4+f>>2]=0,T2[A+20>>2]=1065353216,T2[(f=A+32|0)>>2]=0,T2[4+f>>2]=0,T2[(f=A+44|0)>>2]=0,T2[4+f>>2]=0,T2[A+40>>2]=1065353216,T2[(f=A+52|0)>>2]=0,T2[4+f>>2]=0,T2[A+60>>2]=0;},Transform_setOrigin:function(A,f){var r=T2[(f|=0)+4>>2];T2[(A|=0)+48>>2]=T2[f>>2],T2[A+52>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+56|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},Transform_setRotation:function(A,f){A|=0,f|=0,z2(0);var r,e,i,a,n,o,b=j2[f+12>>2],t=j2[f+8>>2],c=j2[f>>2],u=j2[f+4>>2];T2[A+44>>2]=0,T2[A+28>>2]=0,T2[A+12>>2]=0,r=z2(z2(2)/z2(z2(z2(z2(c*c)+z2(u*u))+z2(t*t))+z2(b*b))),i=z2(t*r),e=z2(u*i),a=z2(c*r),n=z2(b*a),j2[A+36>>2]=e+n,o=z2(c*i),r=z2(u*r),f=z2(b*r),j2[A+32>>2]=o-f,j2[A+24>>2]=e-n,e=z2(c*r),b=z2(b*i),j2[A+16>>2]=e+b,j2[A+8>>2]=o+f,j2[A+4>>2]=e-b,c=z2(c*a),b=z2(u*r),j2[A+40>>2]=z2(1)-z2(c+b),f=c,c=z2(t*i),j2[A+20>>2]=z2(1)-z2(f+c),j2[A>>2]=z2(1)-z2(b+c);},Transform_getOrigin:H,Transform_getRotation:function(A,f){return C4(A|=0,f|=0),0|f;},Vec3_array_at:function(A,f){return T2[(A|=0)+12>>2]+((f|=0)<<4)|0;},int_array_size:function(A){return T2[(A|=0)+4>>2];},int_array_at:function(A,f){return T2[T2[(A|=0)+12>>2]+((f|=0)<<2)>>2];},ccMaterial_new:function(){var A=c(16);return T2[A+8>>2]=1036831949,T2[A+12>>2]=1036831949,T2[A>>2]=1036831949,T2[A+4>>2]=1058642330,0|A;},ccMaterial_set:r1,MotionState_del:q,MotionState_getWorldTransform:r2,MotionState_setWorldTransform:function(A,f){n1[T2[T2[(A|=0)>>2]+12>>2]](A,f|=0);},ccMotionState_new:function(A,f){A|=0,f|=0;var r,e,i=c(72);return T2[i+4>>2]=A,T2[i>>2]=20996,e=T2[4+(r=f+8|0)>>2],T2[(A=i+16|0)>>2]=T2[r>>2],T2[A+4>>2]=e,A=T2[f+4>>2],T2[i+8>>2]=T2[f>>2],T2[i+12>>2]=A,e=T2[4+(r=f+24|0)>>2],T2[(A=i+32|0)>>2]=T2[r>>2],T2[A+4>>2]=e,A=T2[f+20>>2],T2[i+24>>2]=T2[f+16>>2],T2[i+28>>2]=A,A=T2[f+36>>2],T2[i+40>>2]=T2[f+32>>2],T2[i+44>>2]=A,e=T2[4+(r=f+40|0)>>2],T2[(A=i+48|0)>>2]=T2[r>>2],T2[A+4>>2]=e,A=T2[f+52>>2],T2[i+56>>2]=T2[f+48>>2],T2[i+60>>2]=A,r=T2[(f=f+56|0)+4>>2],T2[(A=i- -64|0)>>2]=T2[f>>2],T2[A+4>>2]=r,0|i;},RigidBody_new:function(A,f){A=z2(A),f|=0;var r,e,i=0,a=0;return L2=a=L2-144|0,S2[22372]||(T2[5597]=0,T2[5598]=0,T2[5595]=27,T2[5596]=0,T2[5594]=11488,p2[22372]=1,T2[5599]=0),T2[(r=88+a|0)>>2]=0,T2[4+r>>2]=0,e=A==z2(0)?z2(0):z2(1.6666666269302368),j2[84+a>>2]=e,j2[80+a>>2]=e,T2[(r=12+a|0)>>2]=0,T2[4+r>>2]=0,T2[(r=20+a|0)>>2]=0,T2[4+r>>2]=0,T2[136+a>>2]=1008981770,T2[140+a>>2]=1008981770,T2[128+a>>2]=1000593162,T2[132+a>>2]=1008981770,p2[124+a|0]=0,T2[120+a>>2]=1065353216,T2[112+a>>2]=0,T2[116+a>>2]=1061997773,T2[104+a>>2]=0,T2[108+a>>2]=0,T2[96+a>>2]=0,T2[100+a>>2]=1056964608,j2[76+a>>2]=e,T2[72+a>>2]=22376,T2[4+a>>2]=f,j2[a>>2]=A,T2[8+a>>2]=1065353216,T2[(f=32+a|0)>>2]=0,T2[f+4>>2]=0,T2[28+a>>2]=1065353216,T2[(f=40+a|0)>>2]=0,T2[f+4>>2]=0,T2[48+a>>2]=1065353216,T2[(f=52+a|0)>>2]=0,T2[f+4>>2]=0,T2[(f=60+a|0)>>2]=0,T2[f+4>>2]=0,T2[68+a>>2]=0,T2[5498]=T2[5498]+1,(f=K2(695))&&(T2[(i=f+19&-16)-4>>2]=f),T2[i+132>>2]=0,T2[i+136>>2]=0,T2[i+188>>2]=0,T2[i+192>>2]=0,T2[i+180>>2]=0,T2[i+184>>2]=1566444395,T2[i+172>>2]=1065353216,T2[i+176>>2]=0,T2[i+164>>2]=1065353216,T2[i+168>>2]=1065353216,p2[i+300|0]=1,T2[i+276>>2]=0,T2[i+280>>2]=0,T2[i+268>>2]=1065353216,T2[i+272>>2]=0,T2[i+260>>2]=-1,T2[i+264>>2]=-1,T2[i+252>>2]=1,T2[i+256>>2]=0,T2[i+244>>2]=1036831949,T2[i+248>>2]=1176256512,T2[i+236>>2]=0,T2[i+240>>2]=0,T2[i+228>>2]=1056964608,T2[i+232>>2]=0,T2[i+220>>2]=1,T2[i+224>>2]=0,T2[i+212>>2]=-1,T2[i+216>>2]=-1,T2[i+204>>2]=1,T2[i+208>>2]=-1,T2[(f=i+156|0)>>2]=0,T2[f+4>>2]=0,T2[(f=i+148|0)>>2]=0,T2[f+4>>2]=0,T2[(f=i+140|0)>>2]=0,T2[f+4>>2]=0,T2[(f=i+196|0)>>2]=0,T2[f+4>>2]=0,T2[i+304>>2]=0,T2[i+296>>2]=0,T2[i+288>>2]=0,T2[i+292>>2]=0,T2[i+4>>2]=1065353216,T2[i+8>>2]=0,T2[i+12>>2]=0,T2[(f=i+16|0)>>2]=0,T2[f+4>>2]=0,T2[i+24>>2]=1065353216,T2[i+28>>2]=0,T2[i+32>>2]=0,T2[(f=i+36|0)>>2]=0,T2[f+4>>2]=0,T2[i+44>>2]=1065353216,T2[i+48>>2]=0,T2[i+52>>2]=0,T2[(f=i+56|0)>>2]=0,T2[f+4>>2]=0,T2[(f=i- -64|0)>>2]=0,T2[f+4>>2]=1065353216,T2[i+72>>2]=0,T2[i+76>>2]=0,T2[(f=i+80|0)>>2]=0,T2[f+4>>2]=0,T2[i+88>>2]=1065353216,T2[i+92>>2]=0,T2[i+96>>2]=0,T2[(f=i+100|0)>>2]=0,T2[f+4>>2]=0,T2[i+112>>2]=0,T2[i+116>>2]=0,T2[i+108>>2]=1065353216,T2[(f=i+120|0)>>2]=0,T2[f+4>>2]=0,T2[i+128>>2]=0,p2[i+560|0]=1,T2[i>>2]=17124,T2[i+556>>2]=0,T2[i+548>>2]=0,T2[i+552>>2]=0,w4(i,a),L2=144+a|0,0|i;},RigidBody_setCenterOfMassTransform:function(A,f){E4(A|=0,f|=0);},RigidBody_setSleepingThresholds:function(A,f,r){A|=0,f=z2(f),r=z2(r),j2[A+536>>2]=r,j2[A+532>>2]=f;},RigidBody_getLinearSleepingThreshold:function(A){return z2(j2[(A|=0)+532>>2]);},RigidBody_getAngularSleepingThreshold:function(A){return z2(j2[(A|=0)+536>>2]);},RigidBody_setDamping:function(A,f,r){A|=0,f=z2(f),r=z2(r);var e=0;j2[8+(e=L2-16|0)>>2]=r,j2[12+e>>2]=f,T2[4+e>>2]=0,T2[e>>2]=1065353216,j2[A+504>>2]=j2[(f<z2(0)?4+e|0:f>z2(1)?e:12+e|0)>>2],T2[4+e>>2]=0,T2[e>>2]=1065353216,j2[A+508>>2]=j2[(r<z2(0)?4+e|0:r>z2(1)?e:8+e|0)>>2];},RigidBody_setMass:function(A,f){A|=0,f=z2(f);var r=0,e=z2(0),i=0,a=z2(0);T2[8+(L2=r=L2-16|0)>>2]=1070945621,T2[12+r>>2]=0,T2[r>>2]=1070945621,T2[4+r>>2]=1070945621,i=T2[A+192>>2],31==T2[i+4>>2]&&T2[i+24>>2]<1||n1[T2[T2[i>>2]+32>>2]](i,f,r),i=T2[A+204>>2],f!=z2(0)?(T2[A+204>>2]=-2&i,a=z2(z2(1)/f)):T2[A+204>>2]=1|i,j2[A+404>>2]=a,T2[A+436>>2]=0,T2[A+468>>2]=0,j2[A+424>>2]=j2[A+440>>2]*f,e=j2[8+r>>2],j2[A+464>>2]=e!=z2(0)?z2(z2(1)/e):z2(0),e=j2[4+r>>2],j2[A+460>>2]=e!=z2(0)?z2(z2(1)/e):z2(0),e=j2[r>>2],j2[A+456>>2]=e!=z2(0)?z2(z2(1)/e):z2(0),j2[A+432>>2]=j2[A+448>>2]*f,j2[A+428>>2]=j2[A+444>>2]*f,f=j2[A+412>>2],e=j2[A+416>>2],i=j2[A+408>>2],T2[A+632>>2]=0,j2[A+628>>2]=a*e,j2[A+624>>2]=a*f,j2[A+620>>2]=i*a,L2=16+r|0;},RigidBody_setMassProps:function(A,f,r){A|=0,f=z2(f),r|=0;var e=z2(0),i=(T2[A+204>>2]);f!=z2(0)?(T2[A+204>>2]=-2&i,e=z2(z2(1)/f)):T2[A+204>>2]=1|i,j2[A+404>>2]=e,T2[A+436>>2]=0,j2[A+424>>2]=j2[A+440>>2]*f,j2[A+432>>2]=j2[A+448>>2]*f,j2[A+428>>2]=j2[A+444>>2]*f,f=j2[r+8>>2],i=j2[r+4>>2],r=j2[r>>2],j2[A+620>>2]=j2[A+408>>2]*e,j2[A+624>>2]=e*j2[A+412>>2],j2[A+628>>2]=e*j2[A+416>>2],T2[A+632>>2]=0,T2[A+468>>2]=0,j2[A+456>>2]=r!=z2(0)?z2(z2(1)/r):z2(0),j2[A+460>>2]=i!=z2(0)?z2(z2(1)/i):z2(0),j2[A+464>>2]=f!=z2(0)?z2(z2(1)/f):z2(0);},RigidBody_setLinearFactor:function(A,f){A|=0,f|=0,z2(0);var r,e=T2[f+4>>2];T2[A+408>>2]=T2[f>>2],T2[A+412>>2]=e,r=T2[(f=f+8|0)+4>>2],T2[(e=A+416|0)>>2]=T2[f>>2],T2[4+e>>2]=r,T2[A+632>>2]=0,r=j2[A+404>>2],j2[A+624>>2]=r*j2[A+412>>2],j2[A+620>>2]=r*j2[A+408>>2],j2[A+628>>2]=r*j2[e>>2];},RigidBody_setAngularFactor:function(A,f){var r;f|=0,T2[(A|=0)+304>>2]=T2[A+304>>2]+1,r=T2[f+4>>2],T2[A+604>>2]=T2[f>>2],T2[A+608>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+612|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},RigidBody_getLinearVelocity:function(A){return (A|=0)+372|0;},RigidBody_getAngularVelocity:function(A){return (A|=0)+388|0;},RigidBody_setLinearVelocity:function(A,f){var r;f|=0,T2[(A|=0)+304>>2]=T2[A+304>>2]+1,r=T2[f+4>>2],T2[A+372>>2]=T2[f>>2],T2[A+376>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+380|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},RigidBody_setAngularVelocity:function(A,f){var r;f|=0,T2[(A|=0)+304>>2]=T2[A+304>>2]+1,r=T2[f+4>>2],T2[A+388>>2]=T2[f>>2],T2[A+392>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+396|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},RigidBody_getGravity:function(A){return (A|=0)+440|0;},RigidBody_setGravity:function(A,f){A|=0,f|=0;var r,e,i,a=z2(0);(a=j2[A+404>>2])!=z2(0)&&(r=j2[f>>2],e=j2[f+4>>2],i=j2[f+8>>2],T2[A+436>>2]=0,a=z2(z2(1)/a),j2[A+432>>2]=i*a,j2[A+428>>2]=a*e,j2[A+424>>2]=a*r),r=T2[f+4>>2],T2[A+440>>2]=T2[f>>2],T2[A+444>>2]=r,r=T2[(f=f+8|0)+4>>2],T2[(A=A+448|0)>>2]=T2[f>>2],T2[A+4>>2]=r;},RigidBody_applyTorque:function(A,f){A|=0,f|=0,z2(0);var r=j2[f+8>>2],e=j2[f+4>>2];j2[A+488>>2]=z2(j2[f>>2]*j2[A+604>>2])+j2[A+488>>2],j2[(f=A+492|0)>>2]=z2(e*j2[A+608>>2])+j2[f>>2],j2[(f=A+496|0)>>2]=z2(r*j2[A+612>>2])+j2[f>>2];},RigidBody_applyForce:function(A,f,r){A|=0,f|=0,r|=0,z2(0);var e,i,a,n,o=j2[f+8>>2],b=j2[f+4>>2],t=j2[A+408>>2];j2[A+472>>2]=z2(j2[f>>2]*t)+j2[A+472>>2],i=b,b=j2[A+412>>2],j2[(a=A+476|0)>>2]=z2(i*b)+j2[a>>2],e=j2[A+416>>2],j2[(a=A+480|0)>>2]=z2(o*e)+j2[a>>2],n=j2[f>>2],o=j2[r>>2],a=j2[r+4>>2],e=z2(e*j2[f+8>>2]),b=z2(b*j2[f+4>>2]),r=j2[r+8>>2],j2[A+488>>2]=z2(z2(z2(a*e)-z2(b*r))*j2[A+604>>2])+j2[A+488>>2],i=j2[A+612>>2],f=A+492|0,t=z2(t*n),j2[f>>2]=z2(z2(z2(r*t)-z2(e*o))*j2[A+608>>2])+j2[f>>2],j2[(A=A+496|0)>>2]=z2(i*z2(z2(b*o)-z2(t*a)))+j2[A>>2];},RigidBody_applyCentralForce:function(A,f){A|=0,f|=0,z2(0);var r=j2[f+8>>2],e=j2[f+4>>2];j2[A+472>>2]=z2(j2[f>>2]*j2[A+408>>2])+j2[A+472>>2],j2[(f=A+476|0)>>2]=z2(e*j2[A+412>>2])+j2[f>>2],j2[(f=A+480|0)>>2]=z2(r*j2[A+416>>2])+j2[f>>2];},RigidBody_applyTorqueImpulse:function(A,f){A|=0,f|=0,z2(0);var r=j2[f>>2],e=j2[f+4>>2],i=j2[f+8>>2];j2[A+388>>2]=z2(z2(z2(z2(j2[A+324>>2]*r)+z2(j2[A+328>>2]*e))+z2(j2[A+332>>2]*i))*j2[A+604>>2])+j2[A+388>>2],j2[(f=A+392|0)>>2]=z2(z2(z2(z2(r*j2[A+340>>2])+z2(e*j2[A+344>>2]))+z2(i*j2[A+348>>2]))*j2[A+608>>2])+j2[f>>2],j2[(f=A+396|0)>>2]=z2(z2(z2(z2(r*j2[A+356>>2])+z2(e*j2[A+360>>2]))+z2(i*j2[A+364>>2]))*j2[A+612>>2])+j2[f>>2];},RigidBody_applyImpulse:function(A,f,r){_4(A|=0,f|=0,r|=0);},RigidBody_applyCentralImpulse:function(A,f){A|=0,f|=0,z2(0);var r=j2[f+8>>2],e=j2[f+4>>2],i=j2[A+404>>2];j2[A+372>>2]=z2(z2(j2[f>>2]*j2[A+408>>2])*i)+j2[A+372>>2],j2[(f=A+376|0)>>2]=z2(i*z2(e*j2[A+412>>2]))+j2[f>>2],j2[(f=A+380|0)>>2]=z2(i*z2(r*j2[A+416>>2]))+j2[f>>2];},RigidBody_updateInertiaTensor:function(A){var f,r,e,i,a,n,o,b,t,c,u,k,l,s,v;A|=0,T2[A+368>>2]=0,T2[A+352>>2]=0,T2[A+336>>2]=0,r=j2[A+36>>2],b=j2[A+456>>2],e=z2(r*b),i=j2[A+40>>2],t=j2[A+460>>2],a=z2(i*t),n=j2[A+44>>2],s=j2[A+464>>2],f=z2(n*s),j2[A+364>>2]=z2(z2(r*e)+z2(i*a))+z2(n*f),c=j2[A+20>>2],u=j2[A+24>>2],k=j2[A+28>>2],j2[A+360>>2]=z2(z2(c*e)+z2(u*a))+z2(k*f),l=j2[A+4>>2],o=z2(l*e),e=j2[A+8>>2],o=z2(o+z2(e*a)),a=j2[A+12>>2],j2[A+356>>2]=o+z2(a*f),f=z2(b*c),o=z2(t*u),v=z2(s*k),j2[A+348>>2]=z2(z2(r*f)+z2(i*o))+z2(n*v),j2[A+344>>2]=z2(z2(c*f)+z2(u*o))+z2(k*v),j2[A+340>>2]=z2(z2(l*f)+z2(e*o))+z2(a*v),f=r,r=z2(l*b),b=i,i=z2(e*t),t=n,n=z2(a*s),j2[A+332>>2]=z2(z2(f*r)+z2(b*i))+z2(t*n),j2[A+328>>2]=z2(z2(r*c)+z2(i*u))+z2(n*k),j2[A+324>>2]=z2(z2(l*r)+z2(e*i))+z2(a*n);},RigidBody_getTotalForce:function(A){return (A|=0)+472|0;},RigidBody_getTotalTorque:function(A){return (A|=0)+488|0;},RigidBody_getFlags:function(A){return T2[(A|=0)+564>>2];},RigidBody_setFlags:function(A,f){T2[(A|=0)+564>>2]=f|=0;},RigidBody_clearForces:function(A){var f;T2[(A|=0)+472>>2]=0,T2[A+476>>2]=0,T2[(f=A+496|0)>>2]=0,T2[4+f>>2]=0,T2[(f=A+488|0)>>2]=0,T2[4+f>>2]=0,T2[(A=A+480|0)>>2]=0,T2[A+4>>2]=0;},RigidBody_wantsSleeping:function(A){var f=0,r=0;return 4!=(0|(f=T2[(A|=0)+220>>2]))&&(S2[23468]||(r=1,2!=(-2&f)&&(j2[A+224>>2]>z2(2)||(r=0)))),0|r;},RigidBody_clearState:function(A){var f;T2[(A|=0)+372>>2]=0,T2[A+376>>2]=0,T2[A+472>>2]=0,T2[A+476>>2]=0,T2[(f=A+396|0)>>2]=0,T2[4+f>>2]=0,T2[(f=A+388|0)>>2]=0,T2[4+f>>2]=0,T2[(f=A+380|0)>>2]=0,T2[4+f>>2]=0,T2[(f=A+480|0)>>2]=0,T2[4+f>>2]=0,T2[(f=A+488|0)>>2]=0,T2[4+f>>2]=0,T2[(A=A+496|0)>>2]=0,T2[A+4>>2]=0;},RigidBody_getMotionState:function(A){return T2[(A|=0)+540>>2];}};}(A);}const bullet=instantiate;var _default=bullet;_exports.default=_default;});});var Bullet = unwrapExports(bullet_cocos);

            var _dec$S, _class$T, _class2$L, _descriptor$G, _descriptor2$w, _descriptor3$m, _descriptor4$g, _class3$f, _temp$M;
            let PhysicsMaterial = exports('gR', (_dec$S = ccclass('cc.PhysicsMaterial'), _dec$S(_class$T = (_class2$L = (_temp$M = _class3$f = class PhysicsMaterial extends Asset {
              get friction() {
                return this._friction;
              }

              set friction(value) {
                if (!equals(this._friction, value)) {
                  this._friction = value;
                  this.emit(PhysicsMaterial.EVENT_UPDATE);
                }
              }

              get rollingFriction() {
                return this._rollingFriction;
              }

              set rollingFriction(value) {
                if (!equals(this._rollingFriction, value)) {
                  this._rollingFriction = value;
                  this.emit(PhysicsMaterial.EVENT_UPDATE);
                }
              }

              get spinningFriction() {
                return this._spinningFriction;
              }

              set spinningFriction(value) {
                if (!equals(this._spinningFriction, value)) {
                  this._spinningFriction = value;
                  this.emit(PhysicsMaterial.EVENT_UPDATE);
                }
              }

              get restitution() {
                return this._restitution;
              }

              set restitution(value) {
                if (!equals(this._restitution, value)) {
                  this._restitution = value;
                  this.emit(PhysicsMaterial.EVENT_UPDATE);
                }
              }

              constructor() {
                super();
                this.id = void 0;

                _initializerDefineProperty(this, "_friction", _descriptor$G, this);

                _initializerDefineProperty(this, "_rollingFriction", _descriptor2$w, this);

                _initializerDefineProperty(this, "_spinningFriction", _descriptor3$m, this);

                _initializerDefineProperty(this, "_restitution", _descriptor4$g, this);

                PhysicsMaterial.allMaterials.push(this);
                this.id = PhysicsMaterial._idCounter++;
                if (!this._uuid) this._uuid = `pm_${this.id}`;
              }

              clone() {
                const c = new PhysicsMaterial();
                c._friction = this._friction;
                c._restitution = this._restitution;
                c._rollingFriction = this._rollingFriction;
                c._spinningFriction = this._spinningFriction;
                return c;
              }

              destroy() {
                if (super.destroy()) {
                  const idx = PhysicsMaterial.allMaterials.indexOf(this);

                  if (idx >= 0) {
                    PhysicsMaterial.allMaterials.splice(idx, 1);
                  }

                  return true;
                }

                return false;
              }

              setValues(friction, rollingFriction, spinningFriction, restitution) {
                const emitUpdate = this._friction !== friction || this._rollingFriction !== rollingFriction || this._spinningFriction !== spinningFriction || this._restitution !== restitution;
                this._friction = friction;
                this._rollingFriction = rollingFriction;
                this._spinningFriction = spinningFriction;
                this._restitution = restitution;
                if (emitUpdate) this.emit(PhysicsMaterial.EVENT_UPDATE);
              }

            }, _class3$f.allMaterials = [], _class3$f.EVENT_UPDATE = 'event_update', _class3$f._idCounter = 0, _temp$M), (_applyDecoratedDescriptor(_class2$L.prototype, "friction", [editable], Object.getOwnPropertyDescriptor(_class2$L.prototype, "friction"), _class2$L.prototype), _applyDecoratedDescriptor(_class2$L.prototype, "rollingFriction", [editable], Object.getOwnPropertyDescriptor(_class2$L.prototype, "rollingFriction"), _class2$L.prototype), _applyDecoratedDescriptor(_class2$L.prototype, "spinningFriction", [editable], Object.getOwnPropertyDescriptor(_class2$L.prototype, "spinningFriction"), _class2$L.prototype), _applyDecoratedDescriptor(_class2$L.prototype, "restitution", [editable], Object.getOwnPropertyDescriptor(_class2$L.prototype, "restitution"), _class2$L.prototype), _descriptor$G = _applyDecoratedDescriptor(_class2$L.prototype, "_friction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.6;
              }
            }), _descriptor2$w = _applyDecoratedDescriptor(_class2$L.prototype, "_rollingFriction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor3$m = _applyDecoratedDescriptor(_class2$L.prototype, "_spinningFriction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            }), _descriptor4$g = _applyDecoratedDescriptor(_class2$L.prototype, "_restitution", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.0;
              }
            })), _class2$L)) || _class$T));

            class PhysicsRayResult {
              constructor() {
                this._hitPoint = new Vec3();
                this._hitNormal = new Vec3();
                this._distance = 0;
                this._collider = null;
              }

              get hitPoint() {
                return this._hitPoint;
              }

              get distance() {
                return this._distance;
              }

              get collider() {
                return this._collider;
              }

              get hitNormal() {
                return this._hitNormal;
              }

              _assign(hitPoint, distance, collider, hitNormal) {
                Vec3.copy(this._hitPoint, hitPoint);
                Vec3.copy(this._hitNormal, hitNormal);
                this._distance = distance;
                this._collider = collider;
              }

              clone() {
                const c = new PhysicsRayResult();
                Vec3.copy(c._hitPoint, this._hitPoint);
                Vec3.copy(c._hitNormal, this._hitNormal);
                c._distance = this._distance;
                c._collider = this._collider;
                return c;
              }

            } exports('gS', PhysicsRayResult);

            class CollisionMatrix {
              constructor(strategy) {
                if (strategy === 1) {
                  const self = this;

                  for (let i = 0; i < 32; i++) {
                    const key = `_${1 << i}`;
                    self[key] = 0;
                    self.updateArray = [];
                    Object.defineProperty(self, 1 << i, {
                      get() {
                        return this[key];
                      },

                      set(v) {
                        if (this[key] !== v) {
                          this[key] = v;

                          if (this.updateArray.indexOf(i) < 0) {
                            this.updateArray.push(i);
                          }
                        }
                      }

                    });
                  }

                  this['_1'] = PhysicsGroup.DEFAULT;
                } else {
                  for (let i = 0; i < 32; i++) {
                    const key = 1 << i;
                    this[`${key}`] = 0;
                  }

                  this['1'] = PhysicsGroup.DEFAULT;
                }
              }

            } exports('eM', CollisionMatrix);

            legacyCC.internal.PhysicsGroup = PhysicsGroup;
            class PhysicsSystem extends System {
              static get PHYSICS_NONE() {
                return !selector.id;
              }

              static get PHYSICS_BUILTIN() {
                return selector.id === 'builtin';
              }

              static get PHYSICS_CANNON() {
                return selector.id === 'cannon.js';
              }

              static get PHYSICS_BULLET() {
                return selector.id === 'bullet';
              }

              static get PHYSICS_PHYSX() {
                return selector.id === 'physx';
              }

              static get PhysicsGroup() {
                return PhysicsGroup;
              }

              static get instance() {
                return PhysicsSystem._instance;
              }

              get enable() {
                return this._enable;
              }

              set enable(value) {
                this._enable = value;
              }

              get allowSleep() {
                return this._allowSleep;
              }

              set allowSleep(v) {
                this._allowSleep = v;

                if (this.physicsWorld) {
                  this.physicsWorld.setAllowSleep(v);
                }
              }

              get maxSubSteps() {
                return this._maxSubSteps;
              }

              set maxSubSteps(value) {
                this._maxSubSteps = value;
              }

              get fixedTimeStep() {
                return this._fixedTimeStep;
              }

              set fixedTimeStep(value) {
                this._fixedTimeStep = value;
              }

              get gravity() {
                return this._gravity;
              }

              set gravity(gravity) {
                this._gravity.set(gravity);

                if (this.physicsWorld) {
                  this.physicsWorld.setGravity(gravity);
                }
              }

              get sleepThreshold() {
                return this._sleepThreshold;
              }

              set sleepThreshold(v) {
                this._sleepThreshold = v;
              }

              get autoSimulation() {
                return this._autoSimulation;
              }

              set autoSimulation(value) {
                this._autoSimulation = value;
              }

              get defaultMaterial() {
                return this._material;
              }

              get physicsWorld() {
                return selector.physicsWorld;
              }

              constructor() {
                super();
                this.raycastClosestResult = new PhysicsRayResult();
                this.raycastResults = [];
                this.collisionMatrix = new CollisionMatrix(1);
                this.minVolumeSize = 1e-5;
                this.useNodeChains = false;
                this._enable = true;
                this._allowSleep = true;
                this._maxSubSteps = 1;
                this._subStepCount = 0;
                this._fixedTimeStep = 1.0 / 60.0;
                this._autoSimulation = true;
                this._accumulator = 0;
                this._sleepThreshold = 0.1;
                this._gravity = new Vec3(0, -10, 0);
                this._material = new PhysicsMaterial();
                this.raycastOptions = {
                  group: -1,
                  mask: -1,
                  queryTrigger: true,
                  maxDistance: 10000000
                };
                this.raycastResultPool = new RecyclePool(() => new PhysicsRayResult(), 1);

                this._material.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
              }

              postUpdate(deltaTime) {
                if (!this.physicsWorld) return;

                if (!this._enable) {
                  this.physicsWorld.syncSceneToPhysics();
                  return;
                }

                if (this._autoSimulation) {
                  this._subStepCount = 0;
                  this._accumulator += deltaTime;
                  director.emit(Director.EVENT_BEFORE_PHYSICS);

                  while (this._subStepCount < this._maxSubSteps) {
                    if (this._accumulator >= this._fixedTimeStep) {
                      this.physicsWorld.syncSceneToPhysics();
                      this.physicsWorld.step(this._fixedTimeStep);
                      this.physicsWorld.emitEvents();
                      this.physicsWorld.syncAfterEvents();
                      this._accumulator -= this._fixedTimeStep;
                      this._subStepCount++;
                    } else {
                      this.physicsWorld.syncSceneToPhysics();
                      break;
                    }
                  }

                  director.emit(Director.EVENT_AFTER_PHYSICS);
                }
              }

              resetConfiguration(config) {
                const con = config || (game.config ? game.config.physics : null);

                if (con) {
                  if (typeof con.allowSleep === 'boolean') this._allowSleep = con.allowSleep;
                  if (typeof con.fixedTimeStep === 'number') this._fixedTimeStep = con.fixedTimeStep;
                  if (typeof con.maxSubSteps === 'number') this._maxSubSteps = con.maxSubSteps;
                  if (typeof con.sleepThreshold === 'number') this._sleepThreshold = con.sleepThreshold;
                  if (typeof con.autoSimulation === 'boolean') this.autoSimulation = con.autoSimulation;
                  if (con.gravity) Vec3.copy(this._gravity, con.gravity);

                  if (con.defaultMaterial) {
                    this._material.setValues(con.defaultMaterial.friction, con.defaultMaterial.rollingFriction, con.defaultMaterial.spinningFriction, con.defaultMaterial.restitution);
                  }

                  if (con.collisionMatrix) {
                    for (const i in con.collisionMatrix) {
                      this.collisionMatrix[`${1 << parseInt(i)}`] = con.collisionMatrix[i];
                    }
                  }

                  if (con.collisionGroups) {
                    const cg = con.collisionGroups;

                    if (cg instanceof Array) {
                      cg.forEach(v => {
                        PhysicsGroup[v.name] = 1 << v.index;
                      });
                      Enum.update(PhysicsGroup);
                    }
                  }
                }

                if (this.physicsWorld) {
                  this.physicsWorld.setGravity(this._gravity);
                  this.physicsWorld.setAllowSleep(this._allowSleep);
                  this.physicsWorld.setDefaultMaterial(this._material);
                }
              }

              resetAccumulator(time = 0) {
                this._accumulator = time;
              }

              step(fixedTimeStep, deltaTime, maxSubSteps) {
                if (this.physicsWorld) this.physicsWorld.step(fixedTimeStep, deltaTime, maxSubSteps);
              }

              syncSceneToPhysics() {
                if (this.physicsWorld) this.physicsWorld.syncSceneToPhysics();
              }

              emitEvents() {
                if (this.physicsWorld) this.physicsWorld.emitEvents();
              }

              raycast(worldRay, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
                if (!this.physicsWorld) return false;
                this.raycastResultPool.reset();
                this.raycastResults.length = 0;
                this.raycastOptions.mask = mask >>> 0;
                this.raycastOptions.maxDistance = maxDistance;
                this.raycastOptions.queryTrigger = queryTrigger;
                return this.physicsWorld.raycast(worldRay, this.raycastOptions, this.raycastResultPool, this.raycastResults);
              }

              raycastClosest(worldRay, mask = 0xffffffff, maxDistance = 10000000, queryTrigger = true) {
                if (!this.physicsWorld) return false;
                this.raycastOptions.mask = mask >>> 0;
                this.raycastOptions.maxDistance = maxDistance;
                this.raycastOptions.queryTrigger = queryTrigger;
                return this.physicsWorld.raycastClosest(worldRay, this.raycastOptions, this.raycastClosestResult);
              }

              _updateMaterial() {
                if (this.physicsWorld) this.physicsWorld.setDefaultMaterial(this._material);
              }

              static constructAndRegister() {
                if (!PhysicsSystem._instance) {
                  const sys = new PhysicsSystem();
                  sys.resetConfiguration();
                  constructDefaultWorld(sys);
                  PhysicsSystem._instance = sys;
                  director.registerSystem(PhysicsSystem.ID, sys, sys.priority);
                }
              }

            } exports('du', PhysicsSystem);
            PhysicsSystem.ID = 'PHYSICS';
            PhysicsSystem._instance = null;
            director.once(Director.EVENT_INIT, () => {
              PhysicsSystem.constructAndRegister();
            });

            var _dec$T, _dec2$p, _dec3$h, _dec4$d, _dec5$9, _dec6$7, _dec7$5, _dec8$4, _dec9$4, _dec10$4, _dec11$3, _dec12$3, _dec13$3, _dec14$3, _dec15$3, _dec16$3, _dec17$3, _dec18$3, _dec19$3, _dec20$3, _dec21$3, _dec22$3, _dec23$3, _dec24$3, _dec25$3, _dec26$2, _dec27$2, _dec28$2, _dec29$2, _dec30$2, _dec31$2, _class$U, _class2$M, _descriptor$H, _descriptor2$x, _descriptor3$n, _descriptor4$h, _descriptor5$d, _descriptor6$8, _descriptor7$6, _descriptor8$6, _descriptor9$5, _class3$g, _temp$N;
            let RigidBody = exports('gP', (_dec$T = ccclass('cc.RigidBody'), _dec2$p = help(), _dec3$h = menu(), _dec4$d = executionOrder(-1), _dec5$9 = type(PhysicsSystem.PhysicsGroup), _dec6$7 = displayOrder(), _dec7$5 = tooltip(), _dec8$4 = type(ERigidBodyType), _dec9$4 = displayOrder(), _dec10$4 = tooltip(), _dec11$3 = visible(), _dec12$3 = displayOrder(), _dec13$3 = tooltip(), _dec14$3 = visible(), _dec15$3 = displayOrder(), _dec16$3 = tooltip(), _dec17$3 = visible(), _dec18$3 = displayOrder(), _dec19$3 = tooltip(), _dec20$3 = visible(), _dec21$3 = displayOrder(), _dec22$3 = tooltip(), _dec23$3 = visible(), _dec24$3 = displayOrder(), _dec25$3 = tooltip(), _dec26$2 = visible(), _dec27$2 = displayOrder(), _dec28$2 = tooltip(), _dec29$2 = visible(), _dec30$2 = displayOrder(), _dec31$2 = tooltip(), _dec$T(_class$U = _dec2$p(_class$U = _dec3$h(_class$U = executeInEditMode(_class$U = disallowMultiple(_class$U = _dec4$d(_class$U = (_class2$M = (_temp$N = _class3$g = class RigidBody extends Component {
              constructor(...args) {
                super(...args);
                this._body = null;

                _initializerDefineProperty(this, "_group", _descriptor$H, this);

                _initializerDefineProperty(this, "_type", _descriptor2$x, this);

                _initializerDefineProperty(this, "_mass", _descriptor3$n, this);

                _initializerDefineProperty(this, "_allowSleep", _descriptor4$h, this);

                _initializerDefineProperty(this, "_linearDamping", _descriptor5$d, this);

                _initializerDefineProperty(this, "_angularDamping", _descriptor6$8, this);

                _initializerDefineProperty(this, "_useGravity", _descriptor7$6, this);

                _initializerDefineProperty(this, "_linearFactor", _descriptor8$6, this);

                _initializerDefineProperty(this, "_angularFactor", _descriptor9$5, this);
              }

              get group() {
                return this._group;
              }

              set group(v) {
                if ( !Number.isInteger(Math.log2(v >>> 0))) warn('[Physics]: The group should only have one bit.');
                this._group = v;

                if (this._body) {
                  if (this._body.getGroup() !== v) this._body.setGroup(v);
                }
              }

              get type() {
                return this._type;
              }

              set type(v) {
                if (this._type === v) return;
                this._type = v;
                if (this._body) this._body.setType(v);
              }

              get mass() {
                return this._mass;
              }

              set mass(value) {
                if ( value <= 0) warn('[Physics]: The mass should be greater than zero.');
                if (this._mass === value) return;
                value = value <= 0 ? 0.0001 : value;
                this._mass = value;
                if (this._body) this._body.setMass(value);
              }

              get allowSleep() {
                return this._allowSleep;
              }

              set allowSleep(v) {
                this._allowSleep = v;
                if (this._body) this._body.setAllowSleep(v);
              }

              get linearDamping() {
                return this._linearDamping;
              }

              set linearDamping(value) {
                if ( (value < 0 || value > 1)) warn('[Physics]: The damping should be between zero to one.');
                this._linearDamping = value;
                if (this._body) this._body.setLinearDamping(value);
              }

              get angularDamping() {
                return this._angularDamping;
              }

              set angularDamping(value) {
                if ( (value < 0 || value > 1)) warn('[Physics]: The damping should be between zero to one.');
                this._angularDamping = value;
                if (this._body) this._body.setAngularDamping(value);
              }

              get useGravity() {
                return this._useGravity;
              }

              set useGravity(value) {
                this._useGravity = value;
                if (this._body) this._body.useGravity(value);
              }

              get linearFactor() {
                return this._linearFactor;
              }

              set linearFactor(value) {
                Vec3.copy(this._linearFactor, value);

                if (this._body) {
                  this._body.setLinearFactor(this._linearFactor);
                }
              }

              get angularFactor() {
                return this._angularFactor;
              }

              set angularFactor(value) {
                Vec3.copy(this._angularFactor, value);

                if (this._body) {
                  this._body.setAngularFactor(this._angularFactor);
                }
              }

              get sleepThreshold() {
                if (this._isInitialized) {
                  return this._body.getSleepThreshold();
                }

                return 0.1;
              }

              set sleepThreshold(v) {
                if (this._isInitialized) {
                  this._body.setSleepThreshold(v);
                }
              }

              get useCCD() {
                if (this._isInitialized) {
                  return this._body.isUsingCCD();
                }

                return false;
              }

              set useCCD(v) {
                if (this._isInitialized) {
                  this._body.useCCD(v);
                }
              }

              get isAwake() {
                if (this._isInitialized) return this._body.isAwake;
                return false;
              }

              get isSleepy() {
                if (this._isInitialized) return this._body.isSleepy;
                return false;
              }

              get isSleeping() {
                if (this._isInitialized) return this._body.isSleeping;
                return false;
              }

              get isStatic() {
                return this._type === ERigidBodyType.STATIC;
              }

              set isStatic(v) {
                if (v && this.isStatic || !v && !this.isStatic) return;
                this.type = v ? ERigidBodyType.STATIC : ERigidBodyType.DYNAMIC;
              }

              get isDynamic() {
                return this._type === ERigidBodyType.DYNAMIC;
              }

              set isDynamic(v) {
                if (v && this.isDynamic || !v && !this.isDynamic) return;
                this.type = v ? ERigidBodyType.DYNAMIC : ERigidBodyType.KINEMATIC;
              }

              get isKinematic() {
                return this._type === ERigidBodyType.KINEMATIC;
              }

              set isKinematic(v) {
                if (v && this.isKinematic || !v && !this.isKinematic) return;
                this.type = v ? ERigidBodyType.KINEMATIC : ERigidBodyType.DYNAMIC;
              }

              get body() {
                return this._body;
              }

              get _isInitialized() {
                const r = this._body === null;

                if (r) {
                  error('[Physics]: This component has not been call onLoad yet, please make sure the node has been added to the scene.');
                }

                return !r;
              }

              onLoad() {
                if (!selector.runInEditor) return;
                this._body = createRigidBody();

                this._body.initialize(this);
              }

              onEnable() {
                if (this._body) this._body.onEnable();
              }

              onDisable() {
                if (this._body) this._body.onDisable();
              }

              onDestroy() {
                if (this._body) this._body.onDestroy();
              }

              applyForce(force, relativePoint) {
                if (this._isInitialized) this._body.applyForce(force, relativePoint);
              }

              applyLocalForce(force, localPoint) {
                if (this._isInitialized) this._body.applyLocalForce(force, localPoint);
              }

              applyImpulse(impulse, relativePoint) {
                if (this._isInitialized) this._body.applyImpulse(impulse, relativePoint);
              }

              applyLocalImpulse(impulse, localPoint) {
                if (this._isInitialized) this._body.applyLocalImpulse(impulse, localPoint);
              }

              applyTorque(torque) {
                if (this._isInitialized) this._body.applyTorque(torque);
              }

              applyLocalTorque(torque) {
                if (this._isInitialized) this._body.applyLocalTorque(torque);
              }

              wakeUp() {
                if (this._isInitialized) this._body.wakeUp();
              }

              sleep() {
                if (this._isInitialized) this._body.sleep();
              }

              clearState() {
                if (this._isInitialized) this._body.clearState();
              }

              clearForces() {
                if (this._isInitialized) this._body.clearForces();
              }

              clearVelocity() {
                if (this._isInitialized) this._body.clearVelocity();
              }

              getLinearVelocity(out) {
                if (this._isInitialized) this._body.getLinearVelocity(out);
              }

              setLinearVelocity(value) {
                if (this._isInitialized) this._body.setLinearVelocity(value);
              }

              getAngularVelocity(out) {
                if (this._isInitialized) this._body.getAngularVelocity(out);
              }

              setAngularVelocity(value) {
                if (this._isInitialized) this._body.setAngularVelocity(value);
              }

              getGroup() {
                if (this._isInitialized) return this._body.getGroup();
                return 0;
              }

              setGroup(v) {
                if (this._isInitialized) this._body.setGroup(v);
              }

              addGroup(v) {
                if (this._isInitialized) this._body.addGroup(v);
              }

              removeGroup(v) {
                if (this._isInitialized) this._body.removeGroup(v);
              }

              getMask() {
                if (this._isInitialized) return this._body.getMask();
                return 0;
              }

              setMask(v) {
                if (this._isInitialized) this._body.setMask(v);
              }

              addMask(v) {
                if (this._isInitialized) this._body.addMask(v);
              }

              removeMask(v) {
                if (this._isInitialized) this._body.removeMask(v);
              }

            }, _class3$g.Type = ERigidBodyType, _temp$N), (_applyDecoratedDescriptor(_class2$M.prototype, "group", [_dec5$9, _dec6$7, _dec7$5], Object.getOwnPropertyDescriptor(_class2$M.prototype, "group"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "type", [_dec8$4, _dec9$4, _dec10$4], Object.getOwnPropertyDescriptor(_class2$M.prototype, "type"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "mass", [_dec11$3, _dec12$3, _dec13$3], Object.getOwnPropertyDescriptor(_class2$M.prototype, "mass"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "allowSleep", [_dec14$3, _dec15$3, _dec16$3], Object.getOwnPropertyDescriptor(_class2$M.prototype, "allowSleep"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "linearDamping", [_dec17$3, _dec18$3, _dec19$3], Object.getOwnPropertyDescriptor(_class2$M.prototype, "linearDamping"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "angularDamping", [_dec20$3, _dec21$3, _dec22$3], Object.getOwnPropertyDescriptor(_class2$M.prototype, "angularDamping"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "useGravity", [_dec23$3, _dec24$3, _dec25$3], Object.getOwnPropertyDescriptor(_class2$M.prototype, "useGravity"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "linearFactor", [_dec26$2, _dec27$2, _dec28$2], Object.getOwnPropertyDescriptor(_class2$M.prototype, "linearFactor"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "angularFactor", [_dec29$2, _dec30$2, _dec31$2], Object.getOwnPropertyDescriptor(_class2$M.prototype, "angularFactor"), _class2$M.prototype), _descriptor$H = _applyDecoratedDescriptor(_class2$M.prototype, "_group", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PhysicsSystem.PhysicsGroup.DEFAULT;
              }
            }), _descriptor2$x = _applyDecoratedDescriptor(_class2$M.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ERigidBodyType.DYNAMIC;
              }
            }), _descriptor3$n = _applyDecoratedDescriptor(_class2$M.prototype, "_mass", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor4$h = _applyDecoratedDescriptor(_class2$M.prototype, "_allowSleep", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor5$d = _applyDecoratedDescriptor(_class2$M.prototype, "_linearDamping", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            }), _descriptor6$8 = _applyDecoratedDescriptor(_class2$M.prototype, "_angularDamping", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$M.prototype, "_useGravity", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$M.prototype, "_linearFactor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(1, 1, 1);
              }
            }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$M.prototype, "_angularFactor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(1, 1, 1);
              }
            })), _class2$M)) || _class$U) || _class$U) || _class$U) || _class$U) || _class$U) || _class$U));

            (function (_RigidBody) {})(RigidBody || (RigidBody = exports('gP', {})));

            var _dec$U, _dec2$q, _dec3$i, _dec4$e, _dec5$a, _dec6$8, _dec7$6, _dec8$5, _dec9$5, _dec10$5, _dec11$4, _dec12$4, _dec13$4, _dec14$4, _dec15$4, _class$V, _class2$N, _descriptor$I, _descriptor2$y, _descriptor3$o, _class3$h, _temp$O;
            let Collider = exports('gT', (_dec$U = ccclass('cc.Collider'), _dec2$q = type(RigidBody), _dec3$i = displayName(), _dec4$e = displayOrder(), _dec5$a = tooltip(), _dec6$8 = type(PhysicsMaterial), _dec7$6 = displayName(), _dec8$5 = displayOrder(), _dec9$5 = tooltip(), _dec10$5 = displayOrder(), _dec11$4 = tooltip(), _dec12$4 = type(Vec3), _dec13$4 = displayOrder(), _dec14$4 = tooltip(), _dec15$4 = type(PhysicsMaterial), _dec$U(_class$V = (_class2$N = (_temp$O = _class3$h = class Collider extends Eventify(Component) {
              get attachedRigidBody() {
                return findAttachedBody(this.node);
              }

              get sharedMaterial() {
                return this._material;
              }

              set sharedMaterial(value) {
                {
                  this.material = value;
                }
              }

              get material() {
                if (this._isSharedMaterial && this._material) {
                  this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                  this._material = this._material.clone();

                  this._material.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                  this._isSharedMaterial = false;
                }

                return this._material;
              }

              set material(value) {
                if (this._shape) {
                  if (value && this._material) {
                    if (this._material.id !== value.id) {
                      this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                      value.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
                      this._isSharedMaterial = false;
                      this._material = value;
                    }
                  } else if (value && !this._material) {
                    value.on(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);
                    this._material = value;
                  } else if (!value && this._material) {
                    this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                    this._material = value;
                  }

                  this._updateMaterial();
                } else {
                  this._material = value;
                }
              }

              get isTrigger() {
                return this._isTrigger;
              }

              set isTrigger(value) {
                this._isTrigger = value;

                if (this._shape) {
                  this._shape.setAsTrigger(this._isTrigger);
                }
              }

              get center() {
                return this._center;
              }

              set center(value) {
                Vec3.copy(this._center, value);

                if (this._shape) {
                  this._shape.setCenter(this._center);
                }
              }

              get shape() {
                return this._shape;
              }

              get worldBounds() {
                if (this._aabb == null) this._aabb = new AABB();
                if (this._shape) this._shape.getAABB(this._aabb);
                return this._aabb;
              }

              get boundingSphere() {
                if (this._boundingSphere == null) this._boundingSphere = new Sphere();
                if (this._shape) this._shape.getBoundingSphere(this._boundingSphere);
                return this._boundingSphere;
              }

              get needTriggerEvent() {
                return this._needTriggerEvent;
              }

              get needCollisionEvent() {
                return this._needCollisionEvent;
              }

              get _isInitialized() {
                const r = this._shape === null;

                if (r) {
                  error('[Physics]: This component has not been call onLoad yet, please make sure the node has been added to the scene.');
                }

                return !r;
              }

              constructor(type) {
                super();
                this.type = void 0;
                this._shape = null;
                this._aabb = null;
                this._boundingSphere = null;
                this._isSharedMaterial = true;
                this._needTriggerEvent = false;
                this._needCollisionEvent = false;

                _initializerDefineProperty(this, "_material", _descriptor$I, this);

                _initializerDefineProperty(this, "_isTrigger", _descriptor2$y, this);

                _initializerDefineProperty(this, "_center", _descriptor3$o, this);

                this.type = type;
              }

              on(type, callback, target, once) {
                const ret = super.on(type, callback, target, once);

                this._updateNeedEvent(type);

                return ret;
              }

              off(type, callback, target) {
                super.off(type, callback, target);

                this._updateNeedEvent();
              }

              once(type, callback, target) {
                const ret = super.once(type, callback, target);

                this._updateNeedEvent(type);

                return ret;
              }

              removeAll(typeOrTarget) {
                super.removeAll(typeOrTarget);

                this._updateNeedEvent();
              }

              getGroup() {
                if (this._isInitialized) {
                  return this._shape.getGroup();
                }

                return 0;
              }

              setGroup(v) {
                if (this._isInitialized) {
                  this._shape.setGroup(v);
                }
              }

              addGroup(v) {
                if (this._isInitialized) {
                  this._shape.addGroup(v);
                }
              }

              removeGroup(v) {
                if (this._isInitialized) {
                  this._shape.removeGroup(v);
                }
              }

              getMask() {
                if (this._isInitialized) {
                  return this._shape.getMask();
                }

                return 0;
              }

              setMask(v) {
                if (this._isInitialized) {
                  this._shape.setMask(v);
                }
              }

              addMask(v) {
                if (this._isInitialized) {
                  this._shape.addMask(v);
                }
              }

              removeMask(v) {
                if (this._isInitialized) {
                  this._shape.removeMask(v);
                }
              }

              onLoad() {
                if (!selector.runInEditor) return;
                this.sharedMaterial = this._material == null ? PhysicsSystem.instance.defaultMaterial : this._material;
                this._shape = createShape(this.type);

                this._shape.initialize(this);

                this._shape.onLoad();
              }

              onEnable() {
                if (this._shape) {
                  this._shape.onEnable();
                }
              }

              onDisable() {
                if (this._shape) {
                  this._shape.onDisable();
                }
              }

              onDestroy() {
                if (this._shape) {
                  this._needTriggerEvent = false;
                  this._needCollisionEvent = false;

                  this._shape.updateEventListener();

                  if (this._material) this._material.off(PhysicsMaterial.EVENT_UPDATE, this._updateMaterial, this);

                  this._shape.onDestroy();
                }

                if (this._boundingSphere) this._boundingSphere.destroy();
              }

              _updateMaterial() {
                if (this._shape) this._shape.setMaterial(this._material);
              }

              _updateNeedEvent(type) {
                if (this.isValid) {
                  if (type !== undefined) {
                    if (type === 'onCollisionEnter' || type === 'onCollisionStay' || type === 'onCollisionExit') {
                      this._needCollisionEvent = true;
                    }

                    if (type === 'onTriggerEnter' || type === 'onTriggerStay' || type === 'onTriggerExit') {
                      this._needTriggerEvent = true;
                    }
                  } else {
                    if (!(this.hasEventListener('onTriggerEnter') || this.hasEventListener('onTriggerStay') || this.hasEventListener('onTriggerExit'))) {
                      this._needTriggerEvent = false;
                    }

                    if (!(this.hasEventListener('onCollisionEnter') || this.hasEventListener('onCollisionStay') || this.hasEventListener('onCollisionExit'))) {
                      this._needCollisionEvent = false;
                    }
                  }

                  if (this._shape) this._shape.updateEventListener();
                }
              }

            }, _class3$h.Type = EColliderType, _class3$h.Axis = EAxisDirection, _temp$O), (_applyDecoratedDescriptor(_class2$N.prototype, "attachedRigidBody", [_dec2$q, readOnly, _dec3$i, _dec4$e, _dec5$a], Object.getOwnPropertyDescriptor(_class2$N.prototype, "attachedRigidBody"), _class2$N.prototype), _applyDecoratedDescriptor(_class2$N.prototype, "sharedMaterial", [_dec6$8, _dec7$6, _dec8$5, _dec9$5], Object.getOwnPropertyDescriptor(_class2$N.prototype, "sharedMaterial"), _class2$N.prototype), _applyDecoratedDescriptor(_class2$N.prototype, "isTrigger", [_dec10$5, _dec11$4], Object.getOwnPropertyDescriptor(_class2$N.prototype, "isTrigger"), _class2$N.prototype), _applyDecoratedDescriptor(_class2$N.prototype, "center", [_dec12$4, _dec13$4, _dec14$4], Object.getOwnPropertyDescriptor(_class2$N.prototype, "center"), _class2$N.prototype), _descriptor$I = _applyDecoratedDescriptor(_class2$N.prototype, "_material", [_dec15$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$y = _applyDecoratedDescriptor(_class2$N.prototype, "_isTrigger", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor3$o = _applyDecoratedDescriptor(_class2$N.prototype, "_center", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            })), _class2$N)) || _class$V));

            (function (_Collider) {})(Collider || (Collider = exports('gT', {})));

            function findAttachedBody(node) {
              const rb = node.getComponent(RigidBody);

              if (rb && rb.isValid) {
                return rb;
              }

              return null;
            }

            function applyDefaultGeometryOptions(options) {
              options = options || {};

              if (options.includeNormal === undefined) {
                options.includeNormal = true;
              }

              if (options.includeUV === undefined) {
                options.includeUV = true;
              }

              return options;
            }

            function box(options) {
              options = options || {};
              const ws = options.widthSegments || 1;
              const hs = options.heightSegments || 1;
              const ls = options.lengthSegments || 1;
              const hw = (options.width || 1) / 2;
              const hh = (options.height || 1) / 2;
              const hl = (options.length || 1) / 2;
              const corners = [Vec3.set(c0, -hw, -hh, hl), Vec3.set(c1, hw, -hh, hl), Vec3.set(c2, hw, hh, hl), Vec3.set(c3, -hw, hh, hl), Vec3.set(c4, hw, -hh, -hl), Vec3.set(c5, -hw, -hh, -hl), Vec3.set(c6, -hw, hh, -hl), Vec3.set(c7, hw, hh, -hl)];
              const faceAxes = [[2, 3, 1], [4, 5, 7], [7, 6, 2], [1, 0, 4], [1, 4, 2], [5, 0, 6]];
              const faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];
              const faceTangents = [[-1, 0, 0, 1], [-1, 0, 0, 1], [-1, 0, 0, 1], [-1, 0, 0, 1], [0, 0, -1, 1], [0, 0, 1, 1]];
              const positions = [];
              const normals = [];
              const uvs = [];
              const tangents = [];
              const indices = [];
              const minPos = new Vec3(-hw, -hh, -hl);
              const maxPos = new Vec3(hw, hh, hl);
              const boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);

              function _buildPlane(side, uSegments, vSegments) {
                let u;
                let v;
                let ix;
                let iy;
                const offset = positions.length / 3;
                const faceAxe = faceAxes[side];
                const faceNormal = faceNormals[side];
                const faceTangent = faceTangents[side];

                for (iy = 0; iy <= vSegments; iy++) {
                  for (ix = 0; ix <= uSegments; ix++) {
                    u = ix / uSegments;
                    v = iy / vSegments;
                    Vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u);
                    Vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v);
                    Vec3.subtract(temp3, temp2, corners[faceAxe[0]]);
                    Vec3.add(r, temp1, temp3);
                    positions.push(r.x, r.y, r.z);
                    normals.push(faceNormal[0], faceNormal[1], faceNormal[2]);
                    uvs.push(u, v);
                    tangents.push(faceTangent[0], faceTangent[1], faceTangent[2], faceTangent[3]);

                    if (ix < uSegments && iy < vSegments) {
                      const useg1 = uSegments + 1;
                      const a = ix + iy * useg1;
                      const b = ix + (iy + 1) * useg1;
                      const c = ix + 1 + (iy + 1) * useg1;
                      const d = ix + 1 + iy * useg1;
                      indices.push(offset + a, offset + d, offset + b);
                      indices.push(offset + b, offset + d, offset + c);
                    }
                  }
                }
              }

              _buildPlane(0, ws, hs);

              _buildPlane(4, ls, hs);

              _buildPlane(1, ws, hs);

              _buildPlane(5, ls, hs);

              _buildPlane(3, ws, ls);

              _buildPlane(2, ws, ls);

              return {
                positions,
                normals,
                uvs,
                tangents,
                indices,
                minPos,
                maxPos,
                boundingRadius
              };
            }
            const temp1 = new Vec3();
            const temp2 = new Vec3();
            const temp3 = new Vec3();
            const r = new Vec3();
            const c0 = new Vec3();
            const c1 = new Vec3();
            const c2 = new Vec3();
            const c3 = new Vec3();
            const c4 = new Vec3();
            const c5 = new Vec3();
            const c6 = new Vec3();
            const c7 = new Vec3();

            const temp1$1 = new Vec3(0, 0, 0);
            const temp2$1 = new Vec3(0, 0, 0);
            function cylinder(radiusTop = 0.5, radiusBottom = 0.5, height = 2, opts = {}) {
              const halfHeight = height * 0.5;
              const radialSegments = opts.radialSegments || 32;
              const heightSegments = opts.heightSegments || 1;
              const capped = opts.capped !== undefined ? opts.capped : true;
              const arc = opts.arc || 2.0 * Math.PI;
              let cntCap = 0;

              if (!capped) {
                if (radiusTop > 0) {
                  cntCap++;
                }

                if (radiusBottom > 0) {
                  cntCap++;
                }
              }

              let vertCount = (radialSegments + 1) * (heightSegments + 1);

              if (capped) {
                vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap;
              }

              let indexCount = radialSegments * heightSegments * 2 * 3;

              if (capped) {
                indexCount += radialSegments * cntCap * 3;
              }

              const indices = new Array(indexCount);
              const positions = new Array(vertCount * 3);
              const normals = new Array(vertCount * 3);
              const uvs = new Array(vertCount * 2);
              const maxRadius = Math.max(radiusTop, radiusBottom);
              const minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius);
              const maxPos = new Vec3(maxRadius, halfHeight, maxRadius);
              const boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
              let index = 0;
              let indexOffset = 0;
              generateTorso();

              if (capped) {
                if (radiusBottom > 0) {
                  generateCap(false);
                }

                if (radiusTop > 0) {
                  generateCap(true);
                }
              }

              return {
                positions,
                normals,
                uvs,
                indices,
                minPos,
                maxPos,
                boundingRadius
              };

              function generateTorso() {
                const indexArray = [];
                const r = radiusTop - radiusBottom;
                const slope = r * r / height * Math.sign(r);

                for (let y = 0; y <= heightSegments; y++) {
                  const indexRow = [];
                  const v = y / heightSegments;
                  const radius = v * r + radiusBottom;

                  for (let x = 0; x <= radialSegments; ++x) {
                    const u = x / radialSegments;
                    const theta = u * arc;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    positions[3 * index] = radius * sinTheta;
                    positions[3 * index + 1] = v * height - halfHeight;
                    positions[3 * index + 2] = radius * cosTheta;
                    Vec3.normalize(temp1$1, Vec3.set(temp2$1, sinTheta, -slope, cosTheta));
                    normals[3 * index] = temp1$1.x;
                    normals[3 * index + 1] = temp1$1.y;
                    normals[3 * index + 2] = temp1$1.z;
                    uvs[2 * index] = (1 - u) * 2 % 1;
                    uvs[2 * index + 1] = v;
                    indexRow.push(index);
                    ++index;
                  }

                  indexArray.push(indexRow);
                }

                for (let y = 0; y < heightSegments; ++y) {
                  for (let x = 0; x < radialSegments; ++x) {
                    const i1 = indexArray[y][x];
                    const i2 = indexArray[y + 1][x];
                    const i3 = indexArray[y + 1][x + 1];
                    const i4 = indexArray[y][x + 1];
                    indices[indexOffset] = i1;
                    ++indexOffset;
                    indices[indexOffset] = i4;
                    ++indexOffset;
                    indices[indexOffset] = i2;
                    ++indexOffset;
                    indices[indexOffset] = i4;
                    ++indexOffset;
                    indices[indexOffset] = i3;
                    ++indexOffset;
                    indices[indexOffset] = i2;
                    ++indexOffset;
                  }
                }
              }

              function generateCap(top) {
                const radius = top ? radiusTop : radiusBottom;
                const sign = top ? 1 : -1;
                const centerIndexStart = index;

                for (let x = 1; x <= radialSegments; ++x) {
                  positions[3 * index] = 0;
                  positions[3 * index + 1] = halfHeight * sign;
                  positions[3 * index + 2] = 0;
                  normals[3 * index] = 0;
                  normals[3 * index + 1] = sign;
                  normals[3 * index + 2] = 0;
                  uvs[2 * index] = 0.5;
                  uvs[2 * index + 1] = 0.5;
                  ++index;
                }

                const centerIndexEnd = index;

                for (let x = 0; x <= radialSegments; ++x) {
                  const u = x / radialSegments;
                  const theta = u * arc;
                  const cosTheta = Math.cos(theta);
                  const sinTheta = Math.sin(theta);
                  positions[3 * index] = radius * sinTheta;
                  positions[3 * index + 1] = halfHeight * sign;
                  positions[3 * index + 2] = radius * cosTheta;
                  normals[3 * index] = 0;
                  normals[3 * index + 1] = sign;
                  normals[3 * index + 2] = 0;
                  uvs[2 * index] = 0.5 - sinTheta * 0.5 * sign;
                  uvs[2 * index + 1] = 0.5 + cosTheta * 0.5;
                  ++index;
                }

                for (let x = 0; x < radialSegments; ++x) {
                  const c = centerIndexStart + x;
                  const i = centerIndexEnd + x;

                  if (top) {
                    indices[indexOffset] = i + 1;
                    ++indexOffset;
                    indices[indexOffset] = c;
                    ++indexOffset;
                    indices[indexOffset] = i;
                    ++indexOffset;
                  } else {
                    indices[indexOffset] = c;
                    ++indexOffset;
                    indices[indexOffset] = i + 1;
                    ++indexOffset;
                    indices[indexOffset] = i;
                    ++indexOffset;
                  }
                }
              }
            }

            function applyDefaultPlaneOptions(options) {
              options = applyDefaultGeometryOptions(options);
              options.width = options.width || 10;
              options.length = options.length || 10;
              options.widthSegments = options.widthSegments || 10;
              options.lengthSegments = options.lengthSegments || 10;
              return options;
            }

            const temp1$2 = new Vec3(0, 0, 0);
            const temp2$2 = new Vec3(0, 0, 0);
            const temp3$1 = new Vec3(0, 0, 0);
            const r$1 = new Vec3(0, 0, 0);
            const c00 = new Vec3(0, 0, 0);
            const c10 = new Vec3(0, 0, 0);
            const c01 = new Vec3(0, 0, 0);
            function plane$1(options) {
              const normalizedOptions = applyDefaultPlaneOptions(options);
              const {
                width,
                length,
                widthSegments: uSegments,
                lengthSegments: vSegments
              } = normalizedOptions;
              const hw = width * 0.5;
              const hl = length * 0.5;
              const positions = [];
              const uvs = [];
              const indices = [];
              const minPos = new Vec3(-hw, 0, -hl);
              const maxPos = new Vec3(hw, 0, hl);
              const boundingRadius = Math.sqrt(width * width + length * length);
              Vec3.set(c00, -hw, 0, hl);
              Vec3.set(c10, hw, 0, hl);
              Vec3.set(c01, -hw, 0, -hl);

              for (let y = 0; y <= vSegments; y++) {
                for (let x = 0; x <= uSegments; x++) {
                  const u = x / uSegments;
                  const v = y / vSegments;
                  Vec3.lerp(temp1$2, c00, c10, u);
                  Vec3.lerp(temp2$2, c00, c01, v);
                  Vec3.subtract(temp3$1, temp2$2, c00);
                  Vec3.add(r$1, temp1$2, temp3$1);
                  positions.push(r$1.x, r$1.y, r$1.z);

                  if (normalizedOptions.includeUV) {
                    uvs.push(u, v);
                  }

                  if (x < uSegments && y < vSegments) {
                    const useg1 = uSegments + 1;
                    const a = x + y * useg1;
                    const b = x + (y + 1) * useg1;
                    const c = x + 1 + (y + 1) * useg1;
                    const d = x + 1 + y * useg1;
                    indices.push(a, d, b);
                    indices.push(d, c, b);
                  }
                }
              }

              const result = {
                positions,
                indices,
                minPos,
                maxPos,
                boundingRadius
              };

              if (normalizedOptions.includeNormal) {
                const nVertex = (vSegments + 1) * (uSegments + 1);
                const normals = new Array(3 * nVertex);
                result.normals = normals;

                for (let i = 0; i < nVertex; ++i) {
                  normals[i * 3 + 0] = 0;
                  normals[i * 3 + 1] = 1;
                  normals[i * 3 + 2] = 0;
                }
              }

              if (normalizedOptions.includeUV) {
                result.uvs = uvs;
              }

              return result;
            }

            const temp1$3 = new Vec3(0, 0, 0);
            const temp2$3 = new Vec3(0, 0, 0);
            function capsule$1(radiusTop = 0.5, radiusBottom = 0.5, height = 2, opts = {}) {
              const torsoHeight = height - radiusTop - radiusBottom;
              const sides = opts.sides || 32;
              const heightSegments = opts.heightSegments || 32;
              const bottomProp = radiusBottom / height;
              const torProp = torsoHeight / height;
              const topProp = radiusTop / height;
              const bottomSegments = Math.floor(heightSegments * bottomProp);
              const topSegments = Math.floor(heightSegments * topProp);
              const torSegments = Math.floor(heightSegments * torProp);
              const topOffset = torsoHeight + radiusBottom - height / 2;
              const torOffset = radiusBottom - height / 2;
              const bottomOffset = radiusBottom - height / 2;
              const arc = opts.arc || 2.0 * Math.PI;
              const positions = [];
              const normals = [];
              const uvs = [];
              const indices = [];
              const maxRadius = Math.max(radiusTop, radiusBottom);
              const minPos = new Vec3(-maxRadius, -height / 2, -maxRadius);
              const maxPos = new Vec3(maxRadius, height / 2, maxRadius);
              const boundingRadius = height / 2;
              let index = 0;
              const indexArray = [];
              generateBottom();
              generateTorso();
              generateTop();
              return {
                positions,
                normals,
                uvs,
                indices,
                minPos,
                maxPos,
                boundingRadius
              };

              function generateTorso() {
                const slope = (radiusTop - radiusBottom) / torsoHeight;

                for (let y = 0; y <= torSegments; y++) {
                  const indexRow = [];
                  const lat = y / torSegments;
                  const radius = lat * (radiusTop - radiusBottom) + radiusBottom;

                  for (let x = 0; x <= sides; ++x) {
                    const u = x / sides;
                    const v = lat * torProp + bottomProp;
                    const theta = u * arc - arc / 4;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    positions.push(radius * sinTheta);
                    positions.push(lat * torsoHeight + torOffset);
                    positions.push(radius * cosTheta);
                    Vec3.normalize(temp1$3, Vec3.set(temp2$3, sinTheta, -slope, cosTheta));
                    normals.push(temp1$3.x);
                    normals.push(temp1$3.y);
                    normals.push(temp1$3.z);
                    uvs.push(u, v);
                    indexRow.push(index);
                    ++index;
                  }

                  indexArray.push(indexRow);
                }

                for (let y = 0; y < torSegments; ++y) {
                  for (let x = 0; x < sides; ++x) {
                    const i1 = indexArray[y][x];
                    const i2 = indexArray[y + 1][x];
                    const i3 = indexArray[y + 1][x + 1];
                    const i4 = indexArray[y][x + 1];
                    indices.push(i1);
                    indices.push(i4);
                    indices.push(i2);
                    indices.push(i4);
                    indices.push(i3);
                    indices.push(i2);
                  }
                }
              }

              function generateBottom() {
                for (let lat = 0; lat <= bottomSegments; ++lat) {
                  const theta = lat * Math.PI / bottomSegments / 2;
                  const sinTheta = Math.sin(theta);
                  const cosTheta = -Math.cos(theta);

                  for (let lon = 0; lon <= sides; ++lon) {
                    const phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    const x = sinPhi * sinTheta;
                    const y = cosTheta;
                    const z = cosPhi * sinTheta;
                    const u = lon / sides;
                    const v = lat / heightSegments;
                    positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom);
                    normals.push(x, y, z);
                    uvs.push(u, v);

                    if (lat < bottomSegments && lon < sides) {
                      const seg1 = sides + 1;
                      const a = seg1 * lat + lon;
                      const b = seg1 * (lat + 1) + lon;
                      const c = seg1 * (lat + 1) + lon + 1;
                      const d = seg1 * lat + lon + 1;
                      indices.push(a, d, b);
                      indices.push(d, c, b);
                    }

                    ++index;
                  }
                }
              }

              function generateTop() {
                for (let lat = 0; lat <= topSegments; ++lat) {
                  const theta = lat * Math.PI / topSegments / 2 + Math.PI / 2;
                  const sinTheta = Math.sin(theta);
                  const cosTheta = -Math.cos(theta);

                  for (let lon = 0; lon <= sides; ++lon) {
                    const phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    const x = sinPhi * sinTheta;
                    const y = cosTheta;
                    const z = cosPhi * sinTheta;
                    const u = lon / sides;
                    const v = lat / heightSegments + (1 - topProp);
                    positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop);
                    normals.push(x, y, z);
                    uvs.push(u, v);

                    if (lat < topSegments && lon < sides) {
                      const seg1 = sides + 1;
                      const a = seg1 * lat + lon + indexArray[torSegments][sides] + 1;
                      const b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1;
                      const c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1;
                      const d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                      indices.push(a, d, b);
                      indices.push(d, c, b);
                    }
                  }
                }
              }
            }

            function setWrap(object, wrapper) {
              object.__cc_wrapper__ = wrapper;
            }
            function getWrap(object) {
              return object.__cc_wrapper__;
            }
            function maxComponent$1(v) {
              return Math.max(v.x, Math.max(v.y, v.z));
            }
            const VEC3_0 = exports('dy', new Vec3());
            const TriggerEventObject = {
              type: 'onTriggerEnter',
              selfCollider: null,
              otherCollider: null,
              impl: null
            };
            const CollisionEventObject = {
              type: 'onCollisionEnter',
              selfCollider: null,
              otherCollider: null,
              contacts: [],
              impl: null
            };
            function shrinkPositions(buffer) {
              const pos = [];

              if (buffer.length >= 3) {
                pos[0] = buffer[0], pos[1] = buffer[1], pos[2] = buffer[2];
                const len = buffer.length;

                for (let i = 3; i < len; i += 3) {
                  const p0 = buffer[i];
                  const p1 = buffer[i + 1];
                  const p2 = buffer[i + 2];
                  const len2 = pos.length;
                  let isNew = true;

                  for (let j = 0; j < len2; j += 3) {
                    if (equals(p0, pos[j]) && equals(p1, pos[j + 1]) && equals(p2, pos[j + 2])) {
                      isNew = false;
                      break;
                    }
                  }

                  if (isNew) {
                    pos.push(p0);
                    pos.push(p1);
                    pos.push(p2);
                  }
                }
              }

              return pos;
            }
            function absolute(v) {
              v.x = Math.abs(v.x);
              v.y = Math.abs(v.y);
              v.z = Math.abs(v.z);
              return v;
            }

            var util = /*#__PURE__*/Object.freeze({
                __proto__: null,
                setWrap: setWrap,
                getWrap: getWrap,
                maxComponent: maxComponent$1,
                VEC3_0: VEC3_0,
                TriggerEventObject: TriggerEventObject,
                CollisionEventObject: CollisionEventObject,
                shrinkPositions: shrinkPositions,
                absolute: absolute,
                cylinder: cylinder
            });

            var _dec$V, _dec2$r, _dec3$j, _dec4$f, _dec5$b, _class$W, _class2$O, _descriptor$J, _temp$P;
            let BoxCollider = exports('gU', (_dec$V = ccclass('cc.BoxCollider'), _dec2$r = help(), _dec3$j = menu(), _dec4$f = type(Vec3), _dec5$b = tooltip(), _dec$V(_class$W = _dec2$r(_class$W = _dec3$j(_class$W = executeInEditMode(_class$W = (_class2$O = (_temp$P = class BoxCollider extends Collider {
              get size() {
                return this._size;
              }

              set size(value) {
                if (Vec3.strictEquals(this._size, value)) return;
                Vec3.copy(this._size, value);
                absolute(this._size);

                if (this._shape) {
                  this.shape.updateSize();
                }
              }

              get shape() {
                return this._shape;
              }

              constructor() {
                super(EColliderType.BOX);

                _initializerDefineProperty(this, "_size", _descriptor$J, this);
              }

            }, _temp$P), (_applyDecoratedDescriptor(_class2$O.prototype, "size", [_dec4$f, _dec5$b], Object.getOwnPropertyDescriptor(_class2$O.prototype, "size"), _class2$O.prototype), _descriptor$J = _applyDecoratedDescriptor(_class2$O.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(1, 1, 1);
              }
            })), _class2$O)) || _class$W) || _class$W) || _class$W) || _class$W));

            var _dec$W, _dec2$s, _dec3$k, _dec4$g, _class$X, _class2$P, _descriptor$K, _temp$Q;
            let SphereCollider = exports('gV', (_dec$W = ccclass('cc.SphereCollider'), _dec2$s = help(), _dec3$k = menu(), _dec4$g = tooltip(), _dec$W(_class$X = _dec2$s(_class$X = _dec3$k(_class$X = executeInEditMode(_class$X = (_class2$P = (_temp$Q = class SphereCollider extends Collider {
              get radius() {
                return this._radius;
              }

              set radius(value) {
                if (this._radius === value) return;
                this._radius = Math.abs(value);

                if (this._shape) {
                  this.shape.updateRadius();
                }
              }

              get shape() {
                return this._shape;
              }

              constructor() {
                super(EColliderType.SPHERE);

                _initializerDefineProperty(this, "_radius", _descriptor$K, this);
              }

            }, _temp$Q), (_applyDecoratedDescriptor(_class2$P.prototype, "radius", [_dec4$g], Object.getOwnPropertyDescriptor(_class2$P.prototype, "radius"), _class2$P.prototype), _descriptor$K = _applyDecoratedDescriptor(_class2$P.prototype, "_radius", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            })), _class2$P)) || _class$X) || _class$X) || _class$X) || _class$X));

            var _dec$X, _dec2$t, _dec3$l, _dec4$h, _dec5$c, _dec6$9, _dec7$7, _class$Y, _class2$Q, _descriptor$L, _descriptor2$z, _descriptor3$p, _temp$R;
            let CapsuleCollider = exports('gW', (_dec$X = ccclass('cc.CapsuleCollider'), _dec2$t = help(), _dec3$l = menu(), _dec4$h = tooltip(), _dec5$c = tooltip(), _dec6$9 = type(EAxisDirection), _dec7$7 = tooltip(), _dec$X(_class$Y = _dec2$t(_class$Y = _dec3$l(_class$Y = executeInEditMode(_class$Y = (_class2$Q = (_temp$R = class CapsuleCollider extends Collider {
              get radius() {
                return this._radius;
              }

              set radius(value) {
                if (this._radius === value) return;
                this._radius = Math.abs(value);

                if (this._shape) {
                  this.shape.setRadius(value);
                }
              }

              get cylinderHeight() {
                return this._cylinderHeight;
              }

              set cylinderHeight(value) {
                if (this._cylinderHeight === value) return;
                this._cylinderHeight = Math.abs(value);

                if (this._shape) {
                  this.shape.setCylinderHeight(value);
                }
              }

              get direction() {
                return this._direction;
              }

              set direction(value) {
                value = Math.floor(value);
                if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                if (this._direction === value) return;
                this._direction = value;

                if (this._shape) {
                  this.shape.setDirection(value);
                }
              }

              get height() {
                return this._radius * 2 + this._cylinderHeight;
              }

              set height(value) {
                let ch = value - this._radius * 2;
                if (ch < 0) ch = 0;
                this.cylinderHeight = ch;
              }

              get worldHeight() {
                return this._radius * 2 * this._getRadiusScale() + this._cylinderHeight * this._getHeightScale();
              }

              get shape() {
                return this._shape;
              }

              constructor() {
                super(EColliderType.CAPSULE);

                _initializerDefineProperty(this, "_radius", _descriptor$L, this);

                _initializerDefineProperty(this, "_cylinderHeight", _descriptor2$z, this);

                _initializerDefineProperty(this, "_direction", _descriptor3$p, this);
              }

              _getRadiusScale() {
                if (this.node == null) return 1;
                const ws = this.node.worldScale;
                if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(absMax(ws.x, ws.z));
                if (this._direction === EAxisDirection.X_AXIS) return Math.abs(absMax(ws.y, ws.z));
                return Math.abs(absMax(ws.x, ws.y));
              }

              _getHeightScale() {
                if (this.node == null) return 1;
                const ws = this.node.worldScale;
                if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(ws.y);
                if (this._direction === EAxisDirection.X_AXIS) return Math.abs(ws.x);
                return Math.abs(ws.z);
              }

            }, _temp$R), (_applyDecoratedDescriptor(_class2$Q.prototype, "radius", [_dec4$h], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "radius"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "cylinderHeight", [_dec5$c], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "cylinderHeight"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "direction", [_dec6$9, _dec7$7], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "direction"), _class2$Q.prototype), _descriptor$L = _applyDecoratedDescriptor(_class2$Q.prototype, "_radius", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            }), _descriptor2$z = _applyDecoratedDescriptor(_class2$Q.prototype, "_cylinderHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor3$p = _applyDecoratedDescriptor(_class2$Q.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return EAxisDirection.Y_AXIS;
              }
            })), _class2$Q)) || _class$Y) || _class$Y) || _class$Y) || _class$Y));

            var _dec$Y, _dec2$u, _dec3$m, _dec4$i, _dec5$d, _dec6$a, _dec7$8, _class$Z, _class2$R, _descriptor$M, _descriptor2$A, _descriptor3$q, _temp$S;
            let CylinderCollider = exports('gY', (_dec$Y = ccclass('cc.CylinderCollider'), _dec2$u = help(), _dec3$m = menu(), _dec4$i = tooltip(), _dec5$d = tooltip(), _dec6$a = type(EAxisDirection), _dec7$8 = tooltip(), _dec$Y(_class$Z = _dec2$u(_class$Z = _dec3$m(_class$Z = executeInEditMode(_class$Z = (_class2$R = (_temp$S = class CylinderCollider extends Collider {
              get radius() {
                return this._radius;
              }

              set radius(value) {
                if (this._radius === value) return;
                this._radius = Math.abs(value);

                if (this._shape) {
                  this.shape.setRadius(value);
                }
              }

              get height() {
                return this._height;
              }

              set height(value) {
                if (this._height === value) return;
                this._height = Math.abs(value);

                if (this._shape) {
                  this.shape.setHeight(value);
                }
              }

              get direction() {
                return this._direction;
              }

              set direction(value) {
                if (this._direction === value) return;
                if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                this._direction = value;

                if (this._shape) {
                  this.shape.setDirection(value);
                }
              }

              get shape() {
                return this._shape;
              }

              constructor() {
                super(EColliderType.CYLINDER);

                _initializerDefineProperty(this, "_radius", _descriptor$M, this);

                _initializerDefineProperty(this, "_height", _descriptor2$A, this);

                _initializerDefineProperty(this, "_direction", _descriptor3$q, this);
              }

            }, _temp$S), (_applyDecoratedDescriptor(_class2$R.prototype, "radius", [_dec4$i], Object.getOwnPropertyDescriptor(_class2$R.prototype, "radius"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "height", [_dec5$d], Object.getOwnPropertyDescriptor(_class2$R.prototype, "height"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "direction", [_dec6$a, _dec7$8], Object.getOwnPropertyDescriptor(_class2$R.prototype, "direction"), _class2$R.prototype), _descriptor$M = _applyDecoratedDescriptor(_class2$R.prototype, "_radius", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            }), _descriptor2$A = _applyDecoratedDescriptor(_class2$R.prototype, "_height", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 2;
              }
            }), _descriptor3$q = _applyDecoratedDescriptor(_class2$R.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return EAxisDirection.Y_AXIS;
              }
            })), _class2$R)) || _class$Z) || _class$Z) || _class$Z) || _class$Z));

            var _dec$Z, _dec2$v, _dec3$n, _dec4$j, _dec5$e, _dec6$b, _dec7$9, _class$_, _class2$S, _descriptor$N, _descriptor2$B, _descriptor3$r, _temp$T;
            let ConeCollider = exports('gZ', (_dec$Z = ccclass('cc.ConeCollider'), _dec2$v = help(), _dec3$n = menu(), _dec4$j = tooltip(), _dec5$e = tooltip(), _dec6$b = type(EAxisDirection), _dec7$9 = tooltip(), _dec$Z(_class$_ = _dec2$v(_class$_ = _dec3$n(_class$_ = executeInEditMode(_class$_ = (_class2$S = (_temp$T = class ConeCollider extends Collider {
              get radius() {
                return this._radius;
              }

              set radius(value) {
                if (this._radius === value) return;
                this._radius = Math.abs(value);

                if (this._shape) {
                  this.shape.setRadius(value);
                }
              }

              get height() {
                return this._height;
              }

              set height(value) {
                if (this._height === value) return;
                if (value < 0) value = 0;
                this._height = value;

                if (this._shape) {
                  this.shape.setHeight(value);
                }
              }

              get direction() {
                return this._direction;
              }

              set direction(value) {
                if (this._direction === value) return;
                if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                this._direction = value;

                if (this._shape) {
                  this.shape.setDirection(value);
                }
              }

              get shape() {
                return this._shape;
              }

              constructor() {
                super(EColliderType.CONE);

                _initializerDefineProperty(this, "_radius", _descriptor$N, this);

                _initializerDefineProperty(this, "_height", _descriptor2$B, this);

                _initializerDefineProperty(this, "_direction", _descriptor3$r, this);
              }

            }, _temp$T), (_applyDecoratedDescriptor(_class2$S.prototype, "radius", [_dec4$j], Object.getOwnPropertyDescriptor(_class2$S.prototype, "radius"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "height", [_dec5$e], Object.getOwnPropertyDescriptor(_class2$S.prototype, "height"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "direction", [_dec6$b, _dec7$9], Object.getOwnPropertyDescriptor(_class2$S.prototype, "direction"), _class2$S.prototype), _descriptor$N = _applyDecoratedDescriptor(_class2$S.prototype, "_radius", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            }), _descriptor2$B = _applyDecoratedDescriptor(_class2$S.prototype, "_height", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor3$r = _applyDecoratedDescriptor(_class2$S.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return EAxisDirection.Y_AXIS;
              }
            })), _class2$S)) || _class$_) || _class$_) || _class$_) || _class$_));

            var _dec$_, _dec2$w, _dec3$o, _dec4$k, _dec5$f, _dec6$c, _class$$, _class2$T, _descriptor$O, _descriptor2$C, _temp$U;
            let MeshCollider = exports('gX', (_dec$_ = ccclass('cc.MeshCollider'), _dec2$w = help(), _dec3$o = menu(), _dec4$k = type(Mesh), _dec5$f = tooltip(), _dec6$c = tooltip(), _dec$_(_class$$ = _dec2$w(_class$$ = _dec3$o(_class$$ = executeInEditMode(_class$$ = (_class2$T = (_temp$U = class MeshCollider extends Collider {
              get mesh() {
                return this._mesh;
              }

              set mesh(value) {
                if (this._mesh === value) return;
                this._mesh = value;
                if (this._shape) this.shape.setMesh(this._mesh);
              }

              get convex() {
                return this._convex;
              }

              set convex(value) {
                if (this._convex === value) return;
                this._convex = value;
              }

              get shape() {
                return this._shape;
              }

              constructor() {
                super(EColliderType.MESH);

                _initializerDefineProperty(this, "_mesh", _descriptor$O, this);

                _initializerDefineProperty(this, "_convex", _descriptor2$C, this);
              }

            }, _temp$U), (_applyDecoratedDescriptor(_class2$T.prototype, "mesh", [_dec4$k, _dec5$f], Object.getOwnPropertyDescriptor(_class2$T.prototype, "mesh"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "convex", [editable, _dec6$c], Object.getOwnPropertyDescriptor(_class2$T.prototype, "convex"), _class2$T.prototype), _descriptor$O = _applyDecoratedDescriptor(_class2$T.prototype, "_mesh", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$C = _applyDecoratedDescriptor(_class2$T.prototype, "_convex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class2$T)) || _class$$) || _class$$) || _class$$) || _class$$));

            var _dec$$, _dec2$x, _dec3$p, _dec4$l, _dec5$g, _dec6$d, _dec7$a, _dec8$6, _dec9$6, _dec10$6, _dec11$5, _dec12$5, _class$10, _class2$U, _descriptor$P, _descriptor2$D, _descriptor3$s, _descriptor4$i, _temp$V;
            let ConstantForce = exports('gQ', (_dec$$ = ccclass('cc.ConstantForce'), _dec2$x = help(), _dec3$p = requireComponent(RigidBody), _dec4$l = menu(), _dec5$g = displayOrder(), _dec6$d = tooltip(), _dec7$a = displayOrder(), _dec8$6 = tooltip(), _dec9$6 = displayOrder(), _dec10$6 = tooltip(), _dec11$5 = displayOrder(), _dec12$5 = tooltip(), _dec$$(_class$10 = _dec2$x(_class$10 = _dec3$p(_class$10 = _dec4$l(_class$10 = disallowMultiple(_class$10 = executeInEditMode(_class$10 = (_class2$U = (_temp$V = class ConstantForce extends Component {
              constructor(...args) {
                super(...args);
                this._rigidBody = null;

                _initializerDefineProperty(this, "_force", _descriptor$P, this);

                _initializerDefineProperty(this, "_localForce", _descriptor2$D, this);

                _initializerDefineProperty(this, "_torque", _descriptor3$s, this);

                _initializerDefineProperty(this, "_localTorque", _descriptor4$i, this);

                this._mask = 0;
              }

              get force() {
                return this._force;
              }

              set force(value) {
                Vec3.copy(this._force, value);

                this._maskUpdate(this._force, 1);
              }

              get localForce() {
                return this._localForce;
              }

              set localForce(value) {
                Vec3.copy(this._localForce, value);

                this._maskUpdate(this.localForce, 2);
              }

              get torque() {
                return this._torque;
              }

              set torque(value) {
                Vec3.copy(this._torque, value);

                this._maskUpdate(this._torque, 4);
              }

              get localTorque() {
                return this._localTorque;
              }

              set localTorque(value) {
                Vec3.copy(this._localTorque, value);

                this._maskUpdate(this._localTorque, 8);
              }

              onLoad() {
                this._rigidBody = this.node.getComponent(RigidBody);

                this._maskUpdate(this._force, 1);

                this._maskUpdate(this._localForce, 2);

                this._maskUpdate(this._torque, 4);

                this._maskUpdate(this._localTorque, 8);
              }

              lateUpdate(dt) {
                {
                  if (this._rigidBody != null && this._mask !== 0) {
                    if (this._mask & 1) this._rigidBody.applyForce(this._force);
                    if (this._mask & 2) this._rigidBody.applyLocalForce(this.localForce);
                    if (this._mask & 4) this._rigidBody.applyTorque(this._torque);
                    if (this._mask & 8) this._rigidBody.applyLocalTorque(this._localTorque);
                  }
                }
              }

              _maskUpdate(t, m) {
                if (t.strictEquals(Vec3.ZERO)) {
                  this._mask &= ~m;
                } else {
                  this._mask |= m;
                }
              }

            }, _temp$V), (_descriptor$P = _applyDecoratedDescriptor(_class2$U.prototype, "_force", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _descriptor2$D = _applyDecoratedDescriptor(_class2$U.prototype, "_localForce", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _descriptor3$s = _applyDecoratedDescriptor(_class2$U.prototype, "_torque", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _descriptor4$i = _applyDecoratedDescriptor(_class2$U.prototype, "_localTorque", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _applyDecoratedDescriptor(_class2$U.prototype, "force", [_dec5$g, _dec6$d], Object.getOwnPropertyDescriptor(_class2$U.prototype, "force"), _class2$U.prototype), _applyDecoratedDescriptor(_class2$U.prototype, "localForce", [_dec7$a, _dec8$6], Object.getOwnPropertyDescriptor(_class2$U.prototype, "localForce"), _class2$U.prototype), _applyDecoratedDescriptor(_class2$U.prototype, "torque", [_dec9$6, _dec10$6], Object.getOwnPropertyDescriptor(_class2$U.prototype, "torque"), _class2$U.prototype), _applyDecoratedDescriptor(_class2$U.prototype, "localTorque", [_dec11$5, _dec12$5], Object.getOwnPropertyDescriptor(_class2$U.prototype, "localTorque"), _class2$U.prototype)), _class2$U)) || _class$10) || _class$10) || _class$10) || _class$10) || _class$10) || _class$10));

            var _dec$10, _class$11, _class2$V, _descriptor$Q, _descriptor2$E, _descriptor3$t, _descriptor4$j, _descriptor5$e, _descriptor6$9, _temp$W, _dec2$y, _class4$a, _temp2$9, _dec3$q, _class6, _class7$5, _descriptor7$7, _temp3$4;
            const TERRAIN_MAX_LEVELS = exports('h5', 4);
            const TERRAIN_MAX_BLEND_LAYERS = exports('dY', 4);
            const TERRAIN_MAX_LAYER_COUNT = exports('dQ', 256);
            const TERRAIN_BLOCK_TILE_COMPLEXITY = exports('dJ', 32);
            const TERRAIN_BLOCK_VERTEX_COMPLEXITY = exports('dH', 33);
            const TERRAIN_BLOCK_VERTEX_SIZE = exports('dG', 8);
            const TERRAIN_HEIGHT_BASE = exports('dW', 32768);
            const TERRAIN_HEIGHT_FACTORY = exports('dX', 1.0 / 512.0);
            const TERRAIN_HEIGHT_FMIN = exports('dV', -TERRAIN_HEIGHT_BASE * TERRAIN_HEIGHT_FACTORY);
            const TERRAIN_HEIGHT_FMAX = exports('dU', (65535 - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY);
            const TERRAIN_NORTH_INDEX = exports('h6', 0);
            const TERRAIN_SOUTH_INDEX = exports('h7', 1);
            const TERRAIN_WEST_INDEX = exports('h8', 2);
            const TERRAIN_EAST_INDEX = exports('h9', 3);
            const TERRAIN_DATA_VERSION = exports('ha', 0x01010001);
            const TERRAIN_DATA_VERSION2 = exports('hb', 0x01010002);
            const TERRAIN_DATA_VERSION3 = exports('hc', 0x01010003);
            const TERRAIN_DATA_VERSION4 = exports('hd', 0x01010004);
            const TERRAIN_DATA_VERSION5 = exports('dZ', 0x01010005);
            const TERRAIN_DATA_VERSION_DEFAULT = exports('he', 0x01010111);

            class TerrainBuffer {
              constructor() {
                this.length = 0;
                this.buffer = new Uint8Array(2048);
                this._buffView = new DataView(this.buffer.buffer);
                this._seekPos = 0;
              }

              reserve(size) {
                if (this.buffer.byteLength > size) {
                  return;
                }

                let capacity = this.buffer.byteLength;

                while (capacity < size) {
                  capacity += capacity;
                }

                const temp = new Uint8Array(capacity);

                for (let i = 0; i < this.length; ++i) {
                  temp[i] = this.buffer[i];
                }

                this.buffer = temp;
                this._buffView = new DataView(this.buffer.buffer);
              }

              assign(buff) {
                this.buffer = buff;
                this.length = buff.length;
                this._seekPos = buff.byteOffset;
                this._buffView = new DataView(buff.buffer);
              }

              writeInt8(value) {
                this.reserve(this.length + 1);

                this._buffView.setInt8(this.length, value);

                this.length += 1;
              }

              writeInt16(value) {
                this.reserve(this.length + 2);

                this._buffView.setInt16(this.length, value, true);

                this.length += 2;
              }

              writeInt32(value) {
                this.reserve(this.length + 4);

                this._buffView.setInt32(this.length, value, true);

                this.length += 4;
              }

              writeIntArray(value) {
                this.reserve(this.length + 4 * value.length);

                for (let i = 0; i < value.length; ++i) {
                  this._buffView.setInt32(this.length + i * 4, value[i], true);
                }

                this.length += 4 * value.length;
              }

              writeFloat(value) {
                this.reserve(this.length + 4);

                this._buffView.setFloat32(this.length, value, true);

                this.length += 4;
              }

              writeFloatArray(value) {
                this.reserve(this.length + 4 * value.length);

                for (let i = 0; i < value.length; ++i) {
                  this._buffView.setFloat32(this.length + i * 4, value[i], true);
                }

                this.length += 4 * value.length;
              }

              writeString(value) {
                this.reserve(this.length + value.length + 4);

                this._buffView.setInt32(this.length, value.length, true);

                for (let i = 0; i < value.length; ++i) {
                  this._buffView.setInt8(this.length + 4 + i, value.charCodeAt(i));
                }

                this.length += value.length + 4;
              }

              readInt8() {
                const value = this._buffView.getInt8(this._seekPos);

                this._seekPos += 1;
                return value;
              }

              readInt16() {
                const value = this._buffView.getInt16(this._seekPos, true);

                this._seekPos += 2;
                return value;
              }

              readInt() {
                const value = this._buffView.getInt32(this._seekPos, true);

                this._seekPos += 4;
                return value;
              }

              readIntArray(value) {
                for (let i = 0; i < value.length; ++i) {
                  value[i] = this._buffView.getInt32(this._seekPos + i * 4, true);
                }

                this._seekPos += 4 * value.length;
                return value;
              }

              readFloat() {
                const value = this._buffView.getFloat32(this._seekPos, true);

                this._seekPos += 4;
                return value;
              }

              readFloatArray(value) {
                for (let i = 0; i < value.length; ++i) {
                  value[i] = this._buffView.getFloat32(this._seekPos + i * 4, true);
                }

                this._seekPos += 4 * value.length;
                return value;
              }

              readString() {
                const length = this.readInt();
                let value = '';

                for (let i = 0; i < length; ++i) {
                  value += String.fromCharCode(this.readInt8());
                }

                return value;
              }

            }

            let TerrainLayerInfo = exports('dS', (_dec$10 = ccclass('cc.TerrainLayerInfo'), _dec$10(_class$11 = (_class2$V = (_temp$W = class TerrainLayerInfo {
              constructor() {
                _initializerDefineProperty(this, "slot", _descriptor$Q, this);

                _initializerDefineProperty(this, "tileSize", _descriptor2$E, this);

                _initializerDefineProperty(this, "detailMap", _descriptor3$t, this);

                _initializerDefineProperty(this, "normalMap", _descriptor4$j, this);

                _initializerDefineProperty(this, "roughness", _descriptor5$e, this);

                _initializerDefineProperty(this, "metallic", _descriptor6$9, this);
              }

            }, _temp$W), (_descriptor$Q = _applyDecoratedDescriptor(_class2$V.prototype, "slot", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$E = _applyDecoratedDescriptor(_class2$V.prototype, "tileSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor3$t = _applyDecoratedDescriptor(_class2$V.prototype, "detailMap", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor4$j = _applyDecoratedDescriptor(_class2$V.prototype, "normalMap", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor5$e = _applyDecoratedDescriptor(_class2$V.prototype, "roughness", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$V.prototype, "metallic", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$V)) || _class$11));
            let TerrainLayerBinaryInfo = exports('hf', (_dec2$y = ccclass('cc.TerrainLayerBinaryInfo'), _dec2$y(_class4$a = (_temp2$9 = class TerrainLayerBinaryInfo {
              constructor() {
                this.slot = 0;
                this.tileSize = 1;
                this.roughness = 1;
                this.metallic = 0;
                this.detailMapId = '';
                this.normalMapId = '';
              }

            }, _temp2$9)) || _class4$a));
            let TerrainAsset = exports('dK', (_dec3$q = ccclass('cc.TerrainAsset'), _dec3$q(_class6 = (_class7$5 = (_temp3$4 = class TerrainAsset extends Asset {
              constructor() {
                super();
                this._version = 0;
                this._data = null;
                this._tileSize = 1;
                this._blockCount = [1, 1];
                this._weightMapSize = 128;
                this._lightMapSize = 128;
                this._heights = new Uint16Array();
                this._weights = new Uint8Array();
                this._layerBuffer = [-1, -1, -1, -1];
                this._layerBinaryInfos = [];

                _initializerDefineProperty(this, "_layerInfos", _descriptor7$7, this);
              }

              get _nativeAsset() {
                return this._data.buffer;
              }

              set _nativeAsset(value) {
                if (this._data && this._data.byteLength === value.byteLength) {
                  this._data.set(new Uint8Array(value));
                } else {
                  this._data = new Uint8Array(value);
                }

                this._loadNativeData(this._data);
              }

              get version() {
                return this._version;
              }

              set tileSize(value) {
                this._tileSize = value;
              }

              get tileSize() {
                return this._tileSize;
              }

              set blockCount(value) {
                this._blockCount = value;
              }

              get blockCount() {
                return this._blockCount;
              }

              set lightMapSize(value) {
                this._lightMapSize = value;
              }

              get lightMapSize() {
                return this._lightMapSize;
              }

              set weightMapSize(value) {
                this._weightMapSize = value;
              }

              get weightMapSize() {
                return this._weightMapSize;
              }

              set heights(value) {
                this._heights = value;
              }

              get heights() {
                return this._heights;
              }

              set weights(value) {
                this._weights = value;
              }

              get weights() {
                return this._weights;
              }

              set layerBuffer(value) {
                this._layerBuffer = value;
              }

              get layerBuffer() {
                return this._layerBuffer;
              }

              set layerInfos(value) {
                this._layerInfos = value;
              }

              get layerInfos() {
                return this._layerInfos;
              }

              get layerBinaryInfos() {
                return this._layerBinaryInfos;
              }

              getLayer(xBlock, yBlock, layerId) {
                const blockId = yBlock * this.blockCount[0] + xBlock;
                const index = blockId * 4 + layerId;

                if (xBlock < this.blockCount[0] && yBlock < this.blockCount[1] && index < this._layerBuffer.length) {
                  return this._layerBuffer[index];
                }

                return -1;
              }

              getHeight(i, j) {
                const vertexCountX = this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
                return (this._heights[j * vertexCountX + i] - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY;
              }

              getVertexCountI() {
                if (this._blockCount.length < 1) return 0;
                return this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
              }

              getVertexCountJ() {
                if (this._blockCount.length < 2) return 0;
                return this._blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
              }

              _setNativeData(_nativeData) {
                this._data = _nativeData;
              }

              _loadNativeData(_nativeData) {
                if (!_nativeData || _nativeData.length === 0) {
                  return false;
                }

                const stream = new TerrainBuffer();
                stream.assign(_nativeData);
                this._version = stream.readInt();

                if (this._version === TERRAIN_DATA_VERSION_DEFAULT) {
                  return true;
                }

                if (this._version !== TERRAIN_DATA_VERSION && this._version !== TERRAIN_DATA_VERSION2 && this._version !== TERRAIN_DATA_VERSION3 && this._version !== TERRAIN_DATA_VERSION4 && this._version !== TERRAIN_DATA_VERSION5) {
                  return false;
                }

                this.tileSize = stream.readFloat();
                stream.readIntArray(this._blockCount);
                this.weightMapSize = stream.readInt16();
                this.lightMapSize = stream.readInt16();
                const heightBufferSize = stream.readInt();
                this.heights = new Uint16Array(heightBufferSize);

                for (let i = 0; i < this.heights.length; ++i) {
                  this.heights[i] = stream.readInt16();
                }

                const WeightBufferSize = stream.readInt();
                this.weights = new Uint8Array(WeightBufferSize);

                for (let i = 0; i < this.weights.length; ++i) {
                  this.weights[i] = stream.readInt8();
                }

                if (this._version >= TERRAIN_DATA_VERSION2) {
                  const layerBufferSize = stream.readInt();
                  this.layerBuffer = new Array(layerBufferSize);

                  for (let i = 0; i < this.layerBuffer.length; ++i) {
                    this.layerBuffer[i] = stream.readInt16();
                  }
                }

                if (this._version >= TERRAIN_DATA_VERSION3) {
                  const layerInfoSize = stream.readInt();
                  this._layerBinaryInfos = new Array(layerInfoSize);

                  for (let i = 0; i < this._layerBinaryInfos.length; ++i) {
                    this._layerBinaryInfos[i] = new TerrainLayerBinaryInfo();
                    this._layerBinaryInfos[i].slot = stream.readInt();
                    this._layerBinaryInfos[i].tileSize = stream.readFloat();
                    this._layerBinaryInfos[i].detailMapId = stream.readString();

                    if (this._version >= TERRAIN_DATA_VERSION4) {
                      this._layerBinaryInfos[i].normalMapId = stream.readString();
                      this._layerBinaryInfos[i].roughness = stream.readFloat();
                      this._layerBinaryInfos[i].metallic = stream.readFloat();
                    }
                  }
                }

                return true;
              }

              _exportNativeData() {
                const stream = new TerrainBuffer();
                stream.writeInt32(TERRAIN_DATA_VERSION5);
                stream.writeFloat(this.tileSize);
                stream.writeIntArray(this._blockCount);
                stream.writeInt16(this.weightMapSize);
                stream.writeInt16(this.lightMapSize);
                stream.writeInt32(this.heights.length);

                for (let i = 0; i < this.heights.length; ++i) {
                  stream.writeInt16(this.heights[i]);
                }

                stream.writeInt32(this.weights.length);

                for (let i = 0; i < this.weights.length; ++i) {
                  stream.writeInt8(this.weights[i]);
                }

                stream.writeInt32(this.layerBuffer.length);

                for (let i = 0; i < this.layerBuffer.length; ++i) {
                  stream.writeInt16(this.layerBuffer[i]);
                }

                const layerBinaryInfos = [];
                layerBinaryInfos.length = this.layerInfos.length;

                for (let i = 0; i < layerBinaryInfos.length; ++i) {
                  const layer = this.layerInfos[i];
                  const binaryLayer = new TerrainLayerBinaryInfo();
                  binaryLayer.slot = i;
                  binaryLayer.tileSize = layer.tileSize;
                  binaryLayer.detailMapId = layer.detailMap ? layer.detailMap._uuid : '';
                  binaryLayer.normalMapId = layer.normalMap ? layer.normalMap._uuid : '';
                  binaryLayer.metallic = layer.metallic;
                  binaryLayer.roughness = layer.roughness;
                  layerBinaryInfos[i] = binaryLayer;
                }

                stream.writeInt32(layerBinaryInfos.length);

                for (let i = 0; i < layerBinaryInfos.length; ++i) {
                  stream.writeInt32(layerBinaryInfos[i].slot);
                  stream.writeFloat(layerBinaryInfos[i].tileSize);
                  stream.writeString(layerBinaryInfos[i].detailMapId);
                  stream.writeString(layerBinaryInfos[i].normalMapId);
                  stream.writeFloat(layerBinaryInfos[i].roughness);
                  stream.writeFloat(layerBinaryInfos[i].metallic);
                }

                return stream.buffer;
              }

              _exportDefaultNativeData() {
                const stream = new TerrainBuffer();
                stream.writeInt32(TERRAIN_DATA_VERSION_DEFAULT);
                return stream.buffer;
              }

            }, _temp3$4), (_descriptor7$7 = _applyDecoratedDescriptor(_class7$5.prototype, "_layerInfos", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class7$5)) || _class6));

            var _dec$11, _dec2$z, _dec3$r, _dec4$m, _dec5$h, _class$12, _class2$W, _descriptor$R, _temp$X;
            let TerrainCollider = exports('g_', (_dec$11 = ccclass('cc.TerrainCollider'), _dec2$z = help(), _dec3$r = menu(), _dec4$m = type(TerrainAsset), _dec5$h = tooltip(), _dec$11(_class$12 = _dec2$z(_class$12 = _dec3$r(_class$12 = executeInEditMode(_class$12 = (_class2$W = (_temp$X = class TerrainCollider extends Collider {
              get terrain() {
                return this._terrain;
              }

              set terrain(value) {
                this._terrain = value;
                if (this._shape) this.shape.setTerrain(this._terrain);
              }

              get shape() {
                return this._shape;
              }

              constructor() {
                super(EColliderType.TERRAIN);

                _initializerDefineProperty(this, "_terrain", _descriptor$R, this);
              }

            }, _temp$X), (_applyDecoratedDescriptor(_class2$W.prototype, "terrain", [_dec4$m, _dec5$h], Object.getOwnPropertyDescriptor(_class2$W.prototype, "terrain"), _class2$W.prototype), _descriptor$R = _applyDecoratedDescriptor(_class2$W.prototype, "_terrain", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$W)) || _class$12) || _class$12) || _class$12) || _class$12));

            var _dec$12, _dec2$A, _dec3$s, _dec4$n, _dec5$i, _dec6$e, _dec7$b, _dec8$7, _dec9$7, _dec10$7, _dec11$6, _dec12$6, _class$13, _class2$X, _descriptor$S, _descriptor2$F, _class3$i, _temp$Y;
            let SimplexCollider = exports('g$', (_dec$12 = ccclass('cc.SimplexCollider'), _dec2$A = help(), _dec3$s = menu(), _dec4$n = type(ESimplexType), _dec5$i = tooltip(), _dec6$e = tooltip(), _dec7$b = visible(), _dec8$7 = tooltip(), _dec9$7 = visible(), _dec10$7 = tooltip(), _dec11$6 = visible(), _dec12$6 = tooltip(), _dec$12(_class$13 = _dec2$A(_class$13 = _dec3$s(_class$13 = executeInEditMode(_class$13 = (_class2$X = (_temp$Y = _class3$i = class SimplexCollider extends Collider {
              get shapeType() {
                return this._shapeType;
              }

              set shapeType(v) {
                this._shapeType = v;

                if (this._shape) {
                  this.shape.setShapeType(v);
                }
              }

              get vertex0() {
                return this._vertices[0];
              }

              set vertex0(v) {
                Vec3.copy(this._vertices[0], v);
                this.updateVertices();
              }

              get vertex1() {
                return this._vertices[1];
              }

              set vertex1(v) {
                Vec3.copy(this._vertices[1], v);
                this.updateVertices();
              }

              get vertex2() {
                return this._vertices[2];
              }

              set vertex2(v) {
                Vec3.copy(this._vertices[2], v);
                this.updateVertices();
              }

              get vertex3() {
                return this._vertices[3];
              }

              set vertex3(v) {
                Vec3.copy(this._vertices[3], v);
                this.updateVertices();
              }

              get shape() {
                return this._shape;
              }

              get vertices() {
                return this._vertices;
              }

              constructor() {
                super(EColliderType.SIMPLEX);

                _initializerDefineProperty(this, "_shapeType", _descriptor$S, this);

                _initializerDefineProperty(this, "_vertices", _descriptor2$F, this);
              }

              updateVertices() {
                if (this._shape) {
                  this.shape.setVertices(this._vertices);
                }
              }

            }, _class3$i.ESimplexType = ESimplexType, _temp$Y), (_applyDecoratedDescriptor(_class2$X.prototype, "shapeType", [_dec4$n, _dec5$i], Object.getOwnPropertyDescriptor(_class2$X.prototype, "shapeType"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "vertex0", [editable, _dec6$e], Object.getOwnPropertyDescriptor(_class2$X.prototype, "vertex0"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "vertex1", [_dec7$b, _dec8$7], Object.getOwnPropertyDescriptor(_class2$X.prototype, "vertex1"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "vertex2", [_dec9$7, _dec10$7], Object.getOwnPropertyDescriptor(_class2$X.prototype, "vertex2"), _class2$X.prototype), _applyDecoratedDescriptor(_class2$X.prototype, "vertex3", [_dec11$6, _dec12$6], Object.getOwnPropertyDescriptor(_class2$X.prototype, "vertex3"), _class2$X.prototype), _descriptor$S = _applyDecoratedDescriptor(_class2$X.prototype, "_shapeType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ESimplexType.TETRAHEDRON;
              }
            }), _descriptor2$F = _applyDecoratedDescriptor(_class2$X.prototype, "_vertices", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [new Vec3(0, 0, 0), new Vec3(0, 0, 1), new Vec3(1, 0, 0), new Vec3(0, 1, 0)];
              }
            })), _class2$X)) || _class$13) || _class$13) || _class$13) || _class$13));

            (function (_SimplexCollider) {})(SimplexCollider || (SimplexCollider = exports('g$', {})));

            var _dec$13, _dec2$B, _dec3$t, _dec4$o, _dec5$j, _dec6$f, _class$14, _class2$Y, _descriptor$T, _descriptor2$G, _temp$Z;
            let PlaneCollider = exports('h0', (_dec$13 = ccclass('cc.PlaneCollider'), _dec2$B = help(), _dec3$t = menu(), _dec4$o = type(Vec3), _dec5$j = tooltip(), _dec6$f = tooltip(), _dec$13(_class$14 = _dec2$B(_class$14 = _dec3$t(_class$14 = executeInEditMode(_class$14 = (_class2$Y = (_temp$Z = class PlaneCollider extends Collider {
              get normal() {
                return this._normal;
              }

              set normal(value) {
                if (Vec3.strictEquals(this._normal, value)) return;
                Vec3.copy(this._normal, value);

                if (this._shape) {
                  this.shape.setNormal(this._normal);
                }
              }

              get constant() {
                return this._constant;
              }

              set constant(v) {
                if (this._constant === v) return;
                this._constant = v;

                if (this._shape) {
                  this.shape.setConstant(this._constant);
                }
              }

              get shape() {
                return this._shape;
              }

              constructor() {
                super(EColliderType.PLANE);

                _initializerDefineProperty(this, "_normal", _descriptor$T, this);

                _initializerDefineProperty(this, "_constant", _descriptor2$G, this);
              }

            }, _temp$Z), (_applyDecoratedDescriptor(_class2$Y.prototype, "normal", [_dec4$o, _dec5$j], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "normal"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "constant", [editable, _dec6$f], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "constant"), _class2$Y.prototype), _descriptor$T = _applyDecoratedDescriptor(_class2$Y.prototype, "_normal", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(0, 1, 0);
              }
            }), _descriptor2$G = _applyDecoratedDescriptor(_class2$Y.prototype, "_constant", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$Y)) || _class$14) || _class$14) || _class$14) || _class$14));

            var _dec$14, _dec2$C, _dec3$u, _dec4$p, _dec5$k, _dec6$g, _dec7$c, _dec8$8, _class$15, _class2$Z, _descriptor$U, _descriptor2$H, _class3$j, _temp$_;
            let Constraint = exports('h1', (_dec$14 = ccclass('cc.Constraint'), _dec2$C = requireComponent(RigidBody), _dec3$u = type(RigidBody), _dec4$p = displayOrder(), _dec5$k = type(RigidBody), _dec6$g = displayOrder(), _dec7$c = displayOrder(), _dec8$8 = type(RigidBody), _dec$14(_class$15 = _dec2$C(_class$15 = (_class2$Z = (_temp$_ = _class3$j = class Constraint extends Eventify(Component) {
              get attachedBody() {
                return this.getComponent(RigidBody);
              }

              get connectedBody() {
                return this._connectedBody;
              }

              set connectedBody(v) {
                this._connectedBody = v;

                {
                  if (this._constraint) this._constraint.setConnectedBody(v);
                }
              }

              get enableCollision() {
                return this._enableCollision;
              }

              set enableCollision(v) {
                this._enableCollision = v;

                {
                  if (this._constraint) this._constraint.setEnableCollision(v);
                }
              }

              constructor(type) {
                super();
                this.TYPE = void 0;

                _initializerDefineProperty(this, "_enableCollision", _descriptor$U, this);

                _initializerDefineProperty(this, "_connectedBody", _descriptor2$H, this);

                this._constraint = null;
                this.TYPE = type;
              }

              onLoad() {
                if (!selector.runInEditor) return;
                this._constraint = createConstraint(this.TYPE);

                this._constraint.initialize(this);
              }

              onEnable() {
                if (this._constraint) {
                  this._constraint.onEnable();
                }
              }

              onDisable() {
                if (this._constraint) {
                  this._constraint.onDisable();
                }
              }

              onDestroy() {
                if (this._constraint) {
                  this._constraint.onDestroy();
                }
              }

            }, _class3$j.Type = EConstraintType, _temp$_), (_applyDecoratedDescriptor(_class2$Z.prototype, "attachedBody", [_dec3$u, readOnly, _dec4$p], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "attachedBody"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "connectedBody", [_dec5$k, _dec6$g], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "connectedBody"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "enableCollision", [_dec7$c], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "enableCollision"), _class2$Z.prototype), _descriptor$U = _applyDecoratedDescriptor(_class2$Z.prototype, "_enableCollision", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor2$H = _applyDecoratedDescriptor(_class2$Z.prototype, "_connectedBody", [_dec8$8], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$Z)) || _class$15) || _class$15));

            (function (_Constraint) {})(Constraint || (Constraint = exports('h1', {})));

            var _dec$15, _dec2$D, _dec3$v, _dec4$q, _dec5$l, _dec6$h, _dec7$d, _dec8$9, _dec9$8, _class$16, _class2$_, _descriptor$V, _descriptor2$I, _descriptor3$u, _temp$$;
            let HingeConstraint = exports('h2', (_dec$15 = ccclass('cc.HingeConstraint'), _dec2$D = help(), _dec3$v = menu(), _dec4$q = type(Vec3), _dec5$l = type(Vec3), _dec6$h = type(Vec3), _dec7$d = formerlySerializedAs('axisA'), _dec8$9 = formerlySerializedAs('pivotA'), _dec9$8 = formerlySerializedAs('pivotB'), _dec$15(_class$16 = _dec2$D(_class$16 = _dec3$v(_class$16 = (_class2$_ = (_temp$$ = class HingeConstraint extends Constraint {
              get pivotA() {
                return this._pivotA;
              }

              set pivotA(v) {
                Vec3.copy(this._pivotA, v);

                {
                  this.constraint.setPivotA(this._pivotA);
                }
              }

              get pivotB() {
                return this._pivotB;
              }

              set pivotB(v) {
                Vec3.copy(this._pivotB, v);

                {
                  this.constraint.setPivotB(this._pivotB);
                }
              }

              get axis() {
                return this._axis;
              }

              set axis(v) {
                Vec3.copy(this._axis, v);

                {
                  this.constraint.setAxis(this._axis);
                }
              }

              get constraint() {
                return this._constraint;
              }

              constructor() {
                super(EConstraintType.HINGE);

                _initializerDefineProperty(this, "_axis", _descriptor$V, this);

                _initializerDefineProperty(this, "_pivotA", _descriptor2$I, this);

                _initializerDefineProperty(this, "_pivotB", _descriptor3$u, this);
              }

            }, _temp$$), (_applyDecoratedDescriptor(_class2$_.prototype, "pivotA", [_dec4$q], Object.getOwnPropertyDescriptor(_class2$_.prototype, "pivotA"), _class2$_.prototype), _applyDecoratedDescriptor(_class2$_.prototype, "pivotB", [_dec5$l], Object.getOwnPropertyDescriptor(_class2$_.prototype, "pivotB"), _class2$_.prototype), _applyDecoratedDescriptor(_class2$_.prototype, "axis", [_dec6$h], Object.getOwnPropertyDescriptor(_class2$_.prototype, "axis"), _class2$_.prototype), _descriptor$V = _applyDecoratedDescriptor(_class2$_.prototype, "_axis", [serializable, _dec7$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _descriptor2$I = _applyDecoratedDescriptor(_class2$_.prototype, "_pivotA", [serializable, _dec8$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _descriptor3$u = _applyDecoratedDescriptor(_class2$_.prototype, "_pivotB", [serializable, _dec9$8], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            })), _class2$_)) || _class$16) || _class$16) || _class$16));

            var _dec$16, _dec2$E, _dec3$w, _dec4$r, _dec5$m, _class$17, _class2$$, _descriptor$W, _descriptor2$J, _temp$10;
            let PointToPointConstraint = exports('h3', (_dec$16 = ccclass('cc.PointToPointConstraint'), _dec2$E = help(), _dec3$w = menu(), _dec4$r = type(Vec3), _dec5$m = type(Vec3), _dec$16(_class$17 = _dec2$E(_class$17 = _dec3$w(_class$17 = (_class2$$ = (_temp$10 = class PointToPointConstraint extends Constraint {
              get pivotA() {
                return this._pivotA;
              }

              set pivotA(v) {
                Vec3.copy(this._pivotA, v);

                {
                  this.constraint.setPivotA(this._pivotA);
                }
              }

              get pivotB() {
                return this._pivotB;
              }

              set pivotB(v) {
                Vec3.copy(this._pivotB, v);

                {
                  this.constraint.setPivotB(this._pivotB);
                }
              }

              get constraint() {
                return this._constraint;
              }

              constructor() {
                super(EConstraintType.POINT_TO_POINT);

                _initializerDefineProperty(this, "_pivotA", _descriptor$W, this);

                _initializerDefineProperty(this, "_pivotB", _descriptor2$J, this);
              }

            }, _temp$10), (_applyDecoratedDescriptor(_class2$$.prototype, "pivotA", [_dec4$r], Object.getOwnPropertyDescriptor(_class2$$.prototype, "pivotA"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "pivotB", [_dec5$m], Object.getOwnPropertyDescriptor(_class2$$.prototype, "pivotB"), _class2$$.prototype), _descriptor$W = _applyDecoratedDescriptor(_class2$$.prototype, "_pivotA", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            }), _descriptor2$J = _applyDecoratedDescriptor(_class2$$.prototype, "_pivotB", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3();
              }
            })), _class2$$)) || _class$17) || _class$17) || _class$17));

            legacyCC.PhysicsSystem = PhysicsSystem;
            legacyCC.PhysicsMaterial = PhysicsMaterial;
            legacyCC.PhysicsRayResult = PhysicsRayResult;
            legacyCC.ConstantForce = ConstantForce;

            var physics = /*#__PURE__*/Object.freeze({
                __proto__: null,
                PhysicsSystem: PhysicsSystem,
                PhysicsRayResult: PhysicsRayResult,
                get Collider () { return Collider; },
                BoxCollider: BoxCollider,
                SphereCollider: SphereCollider,
                CapsuleCollider: CapsuleCollider,
                MeshCollider: MeshCollider,
                CylinderCollider: CylinderCollider,
                ConeCollider: ConeCollider,
                TerrainCollider: TerrainCollider,
                get SimplexCollider () { return SimplexCollider; },
                PlaneCollider: PlaneCollider,
                get Constraint () { return Constraint; },
                HingeConstraint: HingeConstraint,
                PointToPointConstraint: PointToPointConstraint,
                get RigidBody () { return RigidBody; },
                PhysicsMaterial: PhysicsMaterial,
                ConstantForce: ConstantForce,
                selector: selector,
                utils: util,
                get ERigidBodyType () { return ERigidBodyType; },
                get EAxisDirection () { return EAxisDirection; },
                get ESimplexType () { return ESimplexType; },
                get EColliderType () { return EColliderType; },
                get EConstraintType () { return EConstraintType; },
                get PhysicsGroup () { return PhysicsGroup; }
            });
            exports('gO', physics);

            replaceProperty(PhysicsSystem, 'PhysicsSystem', [{
              name: 'ins',
              newName: 'instance'
            }, {
              name: 'PHYSICS_AMMO',
              newName: 'PHYSICS_BULLET'
            }]);
            replaceProperty(PhysicsSystem.prototype, 'PhysicsSystem.prototype', [{
              name: 'deltaTime',
              newName: 'fixedTimeStep'
            }, {
              name: 'maxSubStep',
              newName: 'maxSubSteps'
            }]);
            removeProperty(PhysicsSystem.prototype, 'PhysicsSystem.prototype', [{
              name: 'useFixedTime'
            }, {
              name: 'useCollisionMatrix'
            }, {
              name: 'updateCollisionMatrix'
            }, {
              name: 'resetCollisionMatrix'
            }, {
              name: 'isCollisionGroup'
            }, {
              name: 'setCollisionGroup'
            }]);
            replaceProperty(Collider.prototype, 'Collider.prototype', [{
              name: 'attachedRigidbody',
              newName: 'attachedRigidBody'
            }, {
              name: 'TYPE',
              newName: 'type'
            }]);
            replaceProperty(Collider, 'Collider', [{
              name: 'EColliderType',
              newName: 'Type'
            }, {
              name: 'EAxisDirection',
              newName: 'Axis'
            }]);
            replaceProperty(Constraint, 'Constraint', [{
              name: 'EConstraintType',
              newName: 'Type'
            }]);
            replaceProperty(BoxCollider.prototype, 'BoxCollider.prototype', [{
              name: 'boxShape',
              newName: 'shape'
            }]);
            replaceProperty(SphereCollider.prototype, 'SphereCollider.prototype', [{
              name: 'sphereShape',
              newName: 'shape'
            }]);
            replaceProperty(CapsuleCollider.prototype, 'CapsuleCollider.prototype', [{
              name: 'capsuleShape',
              newName: 'shape'
            }]);
            replaceProperty(RigidBody.prototype, 'RigidBody.prototype', [{
              name: 'rigidBody',
              newName: 'body'
            }]);
            replaceProperty(RigidBody, 'RigidBody', [{
              name: 'ERigidBodyType',
              newName: 'Type'
            }]);
            removeProperty(RigidBody.prototype, 'RigidBody.prototype', [{
              name: 'fixedRotation'
            }]);
            legacyCC.RigidBodyComponent = RigidBody;
            js.setClassAlias(RigidBody, 'cc.RigidBodyComponent');
            legacyCC.ColliderComponent = Collider;
            js.setClassAlias(Collider, 'cc.ColliderComponent');
            legacyCC.BoxColliderComponent = BoxCollider;
            js.setClassAlias(BoxCollider, 'cc.BoxColliderComponent');
            legacyCC.SphereColliderComponent = SphereCollider;
            js.setClassAlias(SphereCollider, 'cc.SphereColliderComponent');
            js.setClassAlias(CapsuleCollider, 'cc.CapsuleColliderComponent');
            js.setClassAlias(MeshCollider, 'cc.MeshColliderComponent');
            js.setClassAlias(CylinderCollider, 'cc.CylinderColliderComponent');
            legacyCC.PhysicMaterial = PhysicsMaterial;
            js.setClassAlias(PhysicsMaterial, 'cc.PhysicMaterial');

            legacyCC.physics = physics;

            const pageSize = 65536;
            const pageCount = 250;
            const importFunc = {
              syncPhysicsToGraphics(id) {
                const bt = globalThis.Bullet;
                const body = bt.CACHE.getWrapper(id, bt.BODY_CACHE_NAME);
                body.syncPhysicsToGraphics();
              }

            };

            let bulletLibs = Bullet;

            if (globalThis.BULLET) {
              console.log('[Physics][Bullet]: Using the external Bullet libs.');
              bulletLibs = globalThis.BULLET;
            }

            if (!selector.runInEditor) bulletLibs = () => ({});
            const bt = exports('dt', {});
            globalThis.Bullet = bt;
            bt.BODY_CACHE_NAME = 'body';
            function waitForAmmoInstantiation(dirRoot) {
              const supported = (() => {
                try {
                  if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
                    const module = new WebAssembly.Module(new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]));

                    if (module instanceof WebAssembly.Module) {
                      return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
                    }
                  }
                } catch (e) {
                  return false;
                }

                return false;
              })();

              return Promise.resolve().then(() => {

                return bulletLibs;
              }).then(module => {
                if (typeof module === 'string') {
                  console.info('[Physics][Bullet]: Using wasm Bullet libs.');

                  const infoReport = msg => {
                    console.info(msg);
                  };

                  const errorReport = msg => {
                    console.error(msg);
                  };

                  const memory = new WebAssembly.Memory({
                    initial: pageCount
                  });
                  const importObject = {
                    cc: importFunc,
                    wasi_snapshot_preview1: {
                      fd_close: infoReport,
                      fd_seek: infoReport,
                      fd_write: infoReport
                    },
                    env: {
                      memory
                    }
                  };
                  return new Promise((resolve, reject) => {
                    function instantiateWasm(buff) {
                      WebAssembly.instantiate(buff, importObject).then(results => {
                        const btInstance = results.instance.exports;
                        Object.assign(bt, btInstance);
                        resolve();
                      }, errorReport);
                    }

                    {
                      fetch(module).then(response => {
                        response.arrayBuffer().then(buff => {
                          instantiateWasm(buff);
                        }, errorReport);
                      }, errorReport);
                    }
                  });
                } else {
                  console.info('[Physics][Bullet]: Using asmjs Bullet libs.');
                  const env = importFunc;
                  const wasmMemory = {};
                  wasmMemory.buffer = new ArrayBuffer(pageSize * pageCount);
                  env.memory = wasmMemory;
                  const btInstance = module(env, wasmMemory);
                  Object.assign(bt, btInstance);
                  return new Promise((resolve, reject) => {
                    resolve();
                  });
                }
              });
            }

        }
    };
});
